<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c88112a3343021a4aad0bad923e47c3c5b760806" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75026629" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="f6353-101">Реализует интерфейс сокетов Беркли.</span><span class="sxs-lookup"><span data-stu-id="f6353-101">Implements the Berkeley sockets interface.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-102">Класс <xref:System.Net.Sockets.Socket> предоставляет широкий набор методов и свойств для сетевого взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="f6353-102">The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications.</span></span> <span data-ttu-id="f6353-103">Класс <xref:System.Net.Sockets.Socket> позволяет выполнять синхронную и асинхронную передачу данных с помощью любого из протоколов связи, перечисленных в перечислении <xref:System.Net.Sockets.ProtocolType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-103">The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.</span></span>  
  
 <span data-ttu-id="f6353-104">Класс <xref:System.Net.Sockets.Socket> соответствует шаблону именования .NET Framework для асинхронных методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-104">The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods.</span></span> <span data-ttu-id="f6353-105">Например, синхронный метод <xref:System.Net.Sockets.Socket.Receive%2A> соответствует асинхронным методам <xref:System.Net.Sockets.Socket.BeginReceive%2A> и <xref:System.Net.Sockets.Socket.EndReceive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-105">For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.</span></span>  
  
 <span data-ttu-id="f6353-106">Если приложению требуется только один поток во время выполнения, используйте следующие методы, предназначенные для работы в синхронном режиме.</span><span class="sxs-lookup"><span data-stu-id="f6353-106">If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</span></span>  
  
-   <span data-ttu-id="f6353-107">Если используется протокол, ориентированный на подключение, например TCP, сервер может прослушивать подключения с помощью метода <xref:System.Net.Sockets.Socket.Listen%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-107">If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="f6353-108">Метод <xref:System.Net.Sockets.Socket.Accept%2A> обрабатывает все входящие запросы на подключение и возвращает <xref:System.Net.Sockets.Socket>, который можно использовать для передачи данных с удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-108">The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host.</span></span> <span data-ttu-id="f6353-109">Используйте возвращенный <xref:System.Net.Sockets.Socket>, чтобы вызвать метод <xref:System.Net.Sockets.Socket.Send%2A> или <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-109">Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span> <span data-ttu-id="f6353-110">Вызовите метод <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом метода <xref:System.Net.Sockets.Socket.Listen%2A>, если требуется указать локальный IP-адрес и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-110">Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number.</span></span> <span data-ttu-id="f6353-111">Если вы хотите, чтобы базовый поставщик услуг назначит свободный порт, используйте нулевой номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-111">Use a port number of zero if you want the underlying service provider to assign a free port for you.</span></span> <span data-ttu-id="f6353-112">Если вы хотите подключиться к узлу прослушивания, вызовите метод <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-112">If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="f6353-113">Чтобы передать данные, вызовите метод <xref:System.Net.Sockets.Socket.Send%2A> или <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-113">To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
-   <span data-ttu-id="f6353-114">Если используется протокол без установления соединения, например UDP, нет необходимости прослушивать подключения вообще.</span><span class="sxs-lookup"><span data-stu-id="f6353-114">If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</span></span> <span data-ttu-id="f6353-115">Вызовите метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, чтобы принимать все входящие датаграммы.</span><span class="sxs-lookup"><span data-stu-id="f6353-115">Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams.</span></span> <span data-ttu-id="f6353-116">Используйте метод <xref:System.Net.Sockets.Socket.SendTo%2A> для отправки датаграмм на удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-116">Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.</span></span>  
  
 <span data-ttu-id="f6353-117">Для обработки обмена данными с помощью отдельных потоков во время выполнения используйте следующие методы, предназначенные для асинхронного режима работы.</span><span class="sxs-lookup"><span data-stu-id="f6353-117">To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</span></span>  
  
-   <span data-ttu-id="f6353-118">Если используется протокол, ориентированный на подключение, например TCP, используйте методы <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>и <xref:System.Net.Sockets.Socket.EndConnect%2A> для подключения к узлу прослушивания.</span><span class="sxs-lookup"><span data-stu-id="f6353-118">If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host.</span></span> <span data-ttu-id="f6353-119">Используйте методы <xref:System.Net.Sockets.Socket.BeginSend%2A> и <xref:System.Net.Sockets.Socket.EndSend%2A> или <xref:System.Net.Sockets.Socket.BeginReceive%2A> и <xref:System.Net.Sockets.Socket.EndReceive%2A> для асинхронной передачи данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-119">Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously.</span></span> <span data-ttu-id="f6353-120">Входящие запросы на подключение могут обрабатываться с помощью <xref:System.Net.Sockets.Socket.BeginAccept%2A> и <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-120">Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span></span>  
  
-   <span data-ttu-id="f6353-121">Если используется протокол без установления соединения, например UDP, можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> и <xref:System.Net.Sockets.Socket.EndSendTo%2A> для отправки датаграмм, а <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> и <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> для получения датаграмм.</span><span class="sxs-lookup"><span data-stu-id="f6353-121">If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> and <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.</span></span>  
  
 <span data-ttu-id="f6353-122">При выполнении нескольких асинхронных операций на сокете они не обязательно завершаются в том порядке, в котором они были запущены.</span><span class="sxs-lookup"><span data-stu-id="f6353-122">If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</span></span>  
  
 <span data-ttu-id="f6353-123">После завершения отправки и получения данных используйте метод <xref:System.Net.Sockets.Socket.Shutdown%2A>, чтобы отключить <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-123">When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-124">После вызова <xref:System.Net.Sockets.Socket.Shutdown%2A>вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>, чтобы освободить все ресурсы, связанные с <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-124">After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 <span data-ttu-id="f6353-125">Класс <xref:System.Net.Sockets.Socket> позволяет настроить <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.SetSocketOption%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-125">The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span> <span data-ttu-id="f6353-126">Извлеките эти параметры с помощью метода <xref:System.Net.Sockets.Socket.GetSocketOption%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-126">Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-127">Если вы создаете относительно простое приложение и не требует максимальной производительности, рассмотрите возможность использования <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>и <xref:System.Net.Sockets.UdpClient>.</span><span class="sxs-lookup"><span data-stu-id="f6353-127">If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>.</span></span> <span data-ttu-id="f6353-128">Эти классы предоставляют более простой и удобный интерфейс для <xref:System.Net.Sockets.Socket> взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="f6353-128">These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-129">В следующем примере кода показано, как можно использовать класс <xref:System.Net.Sockets.Socket> для отправки данных на HTTP-сервер и получения ответа.</span><span class="sxs-lookup"><span data-stu-id="f6353-129">The following code example shows how the <xref:System.Net.Sockets.Socket> class can be used to send data to an HTTP server and receive the response.</span></span> <span data-ttu-id="f6353-130">Этот пример блокируется до получения всей страницы.</span><span class="sxs-lookup"><span data-stu-id="f6353-130">This example blocks until the entire page is received.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-131">Чтобы установить исходящее подключение или принять входящий запрос.</span><span class="sxs-lookup"><span data-stu-id="f6353-131">To establish an outgoing connection or accept an incoming request.</span></span></permission>
    <threadsafe><span data-ttu-id="f6353-132">Экземпляры этого класса являются потокобезопасными.</span><span class="sxs-lookup"><span data-stu-id="f6353-132">Instances of this class are thread safe.</span></span></threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md"><span data-ttu-id="f6353-133">Сетевое программирование в .NET Framework</span><span class="sxs-lookup"><span data-stu-id="f6353-133">Network Programming in the .NET Framework</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md"><span data-ttu-id="f6353-134">Рекомендации по использованию классов System.Net</span><span class="sxs-lookup"><span data-stu-id="f6353-134">Best Practices for System.Net Classes</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md"><span data-ttu-id="f6353-135">Управление кэшем для сетевых приложений</span><span class="sxs-lookup"><span data-stu-id="f6353-135">Cache Management for Network Applications</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md"><span data-ttu-id="f6353-136">протокол IP версии 6</span><span class="sxs-lookup"><span data-stu-id="f6353-136">Internet Protocol Version 6</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md"><span data-ttu-id="f6353-137">Примеры сетевого программирования</span><span class="sxs-lookup"><span data-stu-id="f6353-137">Network Programming Samples</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md"><span data-ttu-id="f6353-138">Трассировка сети в .NET Framework</span><span class="sxs-lookup"><span data-stu-id="f6353-138">Network Tracing in the .NET Framework</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md"><span data-ttu-id="f6353-139">Безопасность в сетевом программировании</span><span class="sxs-lookup"><span data-stu-id="f6353-139">Security in Network Programming</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md"><span data-ttu-id="f6353-140">Улучшения производительности сокетов в версии 3.5</span><span class="sxs-lookup"><span data-stu-id="f6353-140">Socket Performance Enhancements in Version 3.5</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-141">Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-141">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><span data-ttu-id="f6353-142">Информация сокета, возвращенная объектом <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-142">The socket information returned by <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></param>
        <summary><span data-ttu-id="f6353-143">Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.Socket" /> с помощью указанного значения, возвращенного из объекта <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-143">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified value returned from <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-144">Если вы вызываете конструктор <xref:System.Net.Sockets.Socket.%23ctor%2A> несколько раз с тем же массивом байтов, что и аргумент для каждого вызова, вы создадите несколько управляемых <xref:System.Net.Sockets.Socket>s с одним и тем же базовым сокетом.</span><span class="sxs-lookup"><span data-stu-id="f6353-144">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket.</span></span> <span data-ttu-id="f6353-145">Этот подход настоятельно не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="f6353-145">This practice is strongly discouraged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="f6353-146">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketType" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-146">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="f6353-147">Одно из значений перечисления <see cref="T:System.Net.Sockets.ProtocolType" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-147">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="f6353-148">Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.Socket" />, используя указанный тип сокетов и протокол.</span><span class="sxs-lookup"><span data-stu-id="f6353-148">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-149">Параметр `socketType` задает тип <xref:System.Net.Sockets.Socket> класса, а параметр `protocolType` указывает протокол, используемый <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-149">The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-150">Два параметра не являются независимыми.</span><span class="sxs-lookup"><span data-stu-id="f6353-150">The two parameters are not independent.</span></span> <span data-ttu-id="f6353-151">Часто тип <xref:System.Net.Sockets.Socket> является неявным в протоколе.</span><span class="sxs-lookup"><span data-stu-id="f6353-151">Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="f6353-152">Если сочетание типа <xref:System.Net.Sockets.Socket> и типа протокола приводит к недопустимому <xref:System.Net.Sockets.Socket>, этот конструктор создает исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-152">If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-153">Если этот конструктор создает исключение <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-153">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-154">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-154">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-155">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-155">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-156">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-156">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-157">Сочетание параметров <paramref name="socketType" /> и <paramref name="protocolType" /> приводит к недопустимому сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-157">The combination of  <paramref name="socketType" /> and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><span data-ttu-id="f6353-158">Одно из значений перечисления <see cref="T:System.Net.Sockets.AddressFamily" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-158">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></param>
        <param name="socketType"><span data-ttu-id="f6353-159">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketType" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-159">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="f6353-160">Одно из значений перечисления <see cref="T:System.Net.Sockets.ProtocolType" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-160">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="f6353-161">Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.Socket" />, используя заданные семейство адресов, тип сокета и протокол.</span><span class="sxs-lookup"><span data-stu-id="f6353-161">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified address family, socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-162">Параметр `addressFamily` указывает схему адресации, используемую классом <xref:System.Net.Sockets.Socket>, параметр `socketType` указывает тип класса <xref:System.Net.Sockets.Socket>, а параметр `protocolType` указывает протокол, используемый <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-162">The `addressFamily` parameter specifies the addressing scheme that the <xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-163">Три параметра не являются независимыми.</span><span class="sxs-lookup"><span data-stu-id="f6353-163">The three parameters are not independent.</span></span> <span data-ttu-id="f6353-164">Некоторые семейства адресов ограничивают, какие протоколы можно использовать с ними, и часто тип <xref:System.Net.Sockets.Socket> неявным в протоколе.</span><span class="sxs-lookup"><span data-stu-id="f6353-164">Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="f6353-165">Если сочетание семейства адресов, типа <xref:System.Net.Sockets.Socket> и типа протокола приводит к недопустимому <xref:System.Net.Sockets.Socket>, этот конструктор создает исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-165">If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-166">Если этот конструктор создает исключение <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-166">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-167">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-167">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-168">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-168">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-169">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-169">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-170">В следующем примере кода показано, как создать экземпляр класса <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-170">The following code example demonstrates how to create an instance of the <xref:System.Net.Sockets.Socket> class.</span></span>  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-171">Сочетание параметров <paramref name="addressFamily" />, <paramref name="socketType" /> и <paramref name="protocolType" /> приводит к неработоспособному сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-171">The combination of <paramref name="addressFamily" />, <paramref name="socketType" />, and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6353-172">Создает новый объект <see cref="T:System.Net.Sockets.Socket" /> для заново созданного подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-172">Creates a new <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></summary>
        <returns><span data-ttu-id="f6353-173">Объект <see cref="T:System.Net.Sockets.Socket" /> для заново созданного подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-173">A <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-174"><xref:System.Net.Sockets.Socket.Accept%2A> синхронно извлекает из очереди запросов на подключение прослушивающего сокета первый ожидающий запрос на подключение, а затем создает и возвращает новый <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-174"><xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-175">Этот возвращенный <xref:System.Net.Sockets.Socket> нельзя использовать для принятия дополнительных соединений из очереди подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-175">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="f6353-176">Однако можно вызвать метод <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> возвращенной <xref:System.Net.Sockets.Socket>, чтобы узнать сетевой адрес и номер порта удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-176">However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
 <span data-ttu-id="f6353-177">В режиме блокировки <xref:System.Net.Sockets.Socket.Accept%2A> блокируется до тех пор, пока не помещается в очередь входящих подключений.</span><span class="sxs-lookup"><span data-stu-id="f6353-177">In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued.</span></span> <span data-ttu-id="f6353-178">Когда подключение будет принято, исходное <xref:System.Net.Sockets.Socket> продолжит постановку в очередь входящих запросов на подключение, пока вы не закроете его.</span><span class="sxs-lookup"><span data-stu-id="f6353-178">Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.</span></span>  
  
 <span data-ttu-id="f6353-179">При вызове этого метода с помощью неблокирующего <xref:System.Net.Sockets.Socket>и отсутствии запросов на подключение <xref:System.Net.Sockets.Socket.Accept%2A> выдает <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-179">If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-180">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-180">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-181">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-181">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-182">Перед вызовом метода <xref:System.Net.Sockets.Socket.Accept%2A> необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.Listen%2A> для прослушивания и постановки в очередь входящих запросов на подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-182">Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-183">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-183">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-184">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-184">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-185">В следующем примере кода принимается простое <xref:System.Net.Sockets.Socket> соединение.</span><span class="sxs-lookup"><span data-stu-id="f6353-185">The following code example accepts a simple <xref:System.Net.Sockets.Socket> connection.</span></span>  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-186">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-186">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-187"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-187">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-188">Принимающий сокет не производит прослушивание подключений.</span><span class="sxs-lookup"><span data-stu-id="f6353-188">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="f6353-189">Необходимо вызвать <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> до вызова объекта <see cref="M:System.Net.Sockets.Socket.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-189">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.Accept" />.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f6353-190">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-190">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="f6353-191">Начинает асинхронную операцию, чтобы принять попытку входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-191">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="f6353-192"><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-192"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="f6353-193">По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-193">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="f6353-194"><see langword="false" />, если операция ввода-вывода завершена синхронно.</span><span class="sxs-lookup"><span data-stu-id="f6353-194"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="f6353-195">Событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не произойдет и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-195">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-196">Протоколы, ориентированные на подключение, могут использовать метод <xref:System.Net.Sockets.Socket.AcceptAsync%2A> для асинхронной обработки входящих попыток подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-196">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="f6353-197">Асинхронное принятие подключений дает возможность отправлять и получать данные в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-197">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="f6353-198">Перед вызовом метода <xref:System.Net.Sockets.Socket.AcceptAsync%2A> необходимо вызвать метод <xref:System.Net.Sockets.Socket.Listen%2A> для прослушивания и постановки в очередь входящих запросов на подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-198">Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="f6353-199">Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик события EventHandler\<SocketAsyncEventArgs > делегата и привязать его к событию <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-199">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="f6353-200">Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> являются обязательными:</span><span class="sxs-lookup"><span data-stu-id="f6353-200">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="f6353-201">Вызывающий объект может дополнительно указать существующий <xref:System.Net.Sockets.Socket>, который будет использоваться для входящего подключения, указав <xref:System.Net.Sockets.Socket> для использования со свойством <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-201">The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="f6353-202">Если свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> имеет значение null, создается новая <xref:System.Net.Sockets.Socket> с тем же <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>и <xref:System.Net.Sockets.Socket.ProtocolType%2A> в качестве текущего <xref:System.Net.Sockets.Socket> и устанавливается как свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-202">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="f6353-203">Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, чтобы информация была извлечена в методе обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-203">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="f6353-204">Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.</span><span class="sxs-lookup"><span data-stu-id="f6353-204">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="f6353-205">При необходимости можно указать буфер, в котором будет получен начальный блок данных на сокете после того, как метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> будет выполнен.</span><span class="sxs-lookup"><span data-stu-id="f6353-205">Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="f6353-206">В этом случае для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> необходимо задать буфер, содержащий получаемые данные, а для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> необходимо задать максимальное число байтов данных для получения в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-206">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the maximum number of bytes of data to receive in the buffer.</span></span> <span data-ttu-id="f6353-207">Эти свойства можно задать с помощью метода <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-207">These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f6353-208">Часть переданного буфера будет использоваться внутренне для использования базовым вызовом Winsock Акцептекс.</span><span class="sxs-lookup"><span data-stu-id="f6353-208">Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</span></span> <span data-ttu-id="f6353-209">Это означает, что объем возвращаемых данных всегда будет меньше значения свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> в предоставленном экземпляре <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-209">This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instance provided.</span></span> <span data-ttu-id="f6353-210">Объем буфера, используемый внутри, зависит от семейства адресов сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-210">The amount of the buffer used internally varies based on the address family of the socket.</span></span> <span data-ttu-id="f6353-211">Минимальный требуемый размер буфера составляет 288 байт.</span><span class="sxs-lookup"><span data-stu-id="f6353-211">The minimum buffer size required is 288 bytes.</span></span> <span data-ttu-id="f6353-212">Если указан больший размер буфера, <xref:System.Net.Sockets.Socket> ожидает некоторые дополнительные данные, кроме данных адреса, полученных вызовом Winsock Акцептекс, и ждет, пока эти дополнительные данные не будут получены.</span><span class="sxs-lookup"><span data-stu-id="f6353-212">If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</span></span> <span data-ttu-id="f6353-213">В случае истечения времени ожидания соединение сбрасывается.</span><span class="sxs-lookup"><span data-stu-id="f6353-213">If a timeout occurs, the connection is reset.</span></span> <span data-ttu-id="f6353-214">Поэтому, если требуются дополнительные данные определенного объема, то размер буфера должен быть минимальным размером буфера и этим значением.</span><span class="sxs-lookup"><span data-stu-id="f6353-214">So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</span></span>  
  
 <span data-ttu-id="f6353-215">Метод обратного вызова завершения должен проверять свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>, чтобы определить, была ли операция <xref:System.Net.Sockets.Socket.AcceptAsync%2A> выполнена успешно.</span><span class="sxs-lookup"><span data-stu-id="f6353-215">The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.</span></span>  
  
 <span data-ttu-id="f6353-216">Событие <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> может возникать в некоторых случаях, если соединение не было принято, и для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> задано значение <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span><span class="sxs-lookup"><span data-stu-id="f6353-216">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span></span> <span data-ttu-id="f6353-217">Это может произойти в результате сканирования портов с использованием половины открытой проверки типа SYN (с последовательностью SYN-> SYN-ACK-> RST).</span><span class="sxs-lookup"><span data-stu-id="f6353-217">This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence).</span></span> <span data-ttu-id="f6353-218">Приложения, использующие метод <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, должны быть готовы к обработке этого условия.</span><span class="sxs-lookup"><span data-stu-id="f6353-218">Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-219">Аргумент является недопустимым.</span><span class="sxs-lookup"><span data-stu-id="f6353-219">An argument is not valid.</span></span> <span data-ttu-id="f6353-220">Это исключение возникает, если обеспечиваемый буфер имеет недостаточный размер.</span><span class="sxs-lookup"><span data-stu-id="f6353-220">This exception occurs if the buffer provided is not large enough.</span></span> <span data-ttu-id="f6353-221">Буфер должен иметь размер, равный, по крайней мере, 2 \* (размер(SOCKADDR_STORAGE + 16) байт.</span><span class="sxs-lookup"><span data-stu-id="f6353-221">The buffer must be at least 2 \* (sizeof(SOCKADDR_STORAGE + 16) bytes.</span></span>  
  
<span data-ttu-id="f6353-222">Это исключение также возникает, если задано несколько буферов, свойство <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> не имеет значение "null".</span><span class="sxs-lookup"><span data-stu-id="f6353-222">This exception also occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-223">Аргумент вне диапазона.</span><span class="sxs-lookup"><span data-stu-id="f6353-223">An argument is out of range.</span></span> <span data-ttu-id="f6353-224">Исключение возникает, если объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> имеет значение меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-224">The exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-225">Предпринят запрос выполнения недопустимой операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-225">An invalid operation was requested.</span></span> <span data-ttu-id="f6353-226">Это исключение возникает, если принимающий объект <see cref="T:System.Net.Sockets.Socket" /> не производит прослушивание подключений или принимающий сокет является связанным.</span><span class="sxs-lookup"><span data-stu-id="f6353-226">This exception occurs if the accepting <see cref="T:System.Net.Sockets.Socket" /> is not listening for connections or the accepted socket is bound.</span></span>  
  
<span data-ttu-id="f6353-227">Требуется вызвать объект <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и метод <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> перед вызовом метода <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-227">You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span></span>  
  
<span data-ttu-id="f6353-228">Это исключение также происходит, если сокет уже подключен или работа с сокетом уже выполнялась с использованием указанного параметра <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-228">This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-229">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-229">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-230">Этот метод доступен только в Windows XP и более поздних версиях.</span><span class="sxs-lookup"><span data-stu-id="f6353-230">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-231"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-231">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-232">Получает семейство адресов объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-232">Gets the address family of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="f6353-233">Одно из значений перечисления <see cref="T:System.Net.Sockets.AddressFamily" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-233">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-234"><xref:System.Net.Sockets.AddressFamily> указывает схему адресации, которую может использовать экземпляр класса <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-234">The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use.</span></span> <span data-ttu-id="f6353-235">Это свойство доступно только для чтения и задается при создании <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-235">This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-236">В следующем примере кода выводятся <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>и <xref:System.Net.Sockets.ProtocolType> на консоль.</span><span class="sxs-lookup"><span data-stu-id="f6353-236">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-237">Возвращает значение, указывающее количество полученных из сети и доступных для чтения данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-237">Gets the amount of data that has been received from the network and is available to be read.</span></span></summary>
        <value><span data-ttu-id="f6353-238">Количество байтов данных, полученных из сети и доступных для чтения.</span><span class="sxs-lookup"><span data-stu-id="f6353-238">The number of bytes of data received from the network and available to be read.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-239">Если вы используете неблокирующий <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> является хорошим способом определить, помещаются ли данные в очередь для чтения, перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-239">If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="f6353-240">Доступные данные — это общий объем данных, помещенных в очередь сетевого буфера для чтения.</span><span class="sxs-lookup"><span data-stu-id="f6353-240">The available data is the total amount of data queued in the network buffer for reading.</span></span> <span data-ttu-id="f6353-241">Если в сетевом буфере нет данных, <xref:System.Net.Sockets.Socket.Available%2A> возвращает 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-241">If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.</span></span>  
  
 <span data-ttu-id="f6353-242">Если удаленный узел завершает работу или закрывает соединение, <xref:System.Net.Sockets.Socket.Available%2A> может вызвать <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-242">If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-243">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-243">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-244">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-244">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-245">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-245">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-246">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-246">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-247">В следующем примере кода сравниваются результаты вызова Иоконтрол с ФИОНРЕАД и доступным свойством.</span><span class="sxs-lookup"><span data-stu-id="f6353-247">The following code example compares the results of calling IOControl with FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-248">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-248">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-249"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-249">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-250">Начинает асинхронную операцию, чтобы принять попытку входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-250">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callback"><span data-ttu-id="f6353-251">Делегат <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-251">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-252">Объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-252">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="f6353-253">Начинает асинхронную операцию, чтобы принять попытку входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-253">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="f6353-254">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное создание объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-254">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-255">Протоколы, ориентированные на подключение, могут использовать метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> для асинхронной обработки входящих попыток подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-255">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="f6353-256">Асинхронное принятие подключений дает возможность отправлять и получать данные в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-256">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="f6353-257">Перед вызовом метода <xref:System.Net.Sockets.Socket.BeginAccept%2A> необходимо вызвать метод <xref:System.Net.Sockets.Socket.Listen%2A> для прослушивания и постановки в очередь входящих запросов на подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-257">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="f6353-258">Необходимо создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-258">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="f6353-259">Для этого, как минимум, необходимо передать объект <xref:System.Net.Sockets.Socket> прослушивания для <xref:System.Net.Sockets.Socket.BeginAccept%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-259">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="f6353-260">Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений.</span><span class="sxs-lookup"><span data-stu-id="f6353-260">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="f6353-261">Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-261">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="f6353-262">Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-262">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="f6353-263">Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginAccept%2A>, система обычно использует отдельный поток для выполнения указанного метода обратного вызова и блокируется на <xref:System.Net.Sockets.Socket.EndAccept%2A> до тех пор, пока не будет получено ожидающее подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-263">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span> <span data-ttu-id="f6353-264"><xref:System.Net.Sockets.Socket.EndAccept%2A> вернет новый объект <xref:System.Net.Sockets.Socket>, который можно использовать для отправки и получения данных с удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-264"><xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="f6353-265">Этот возвращенный <xref:System.Net.Sockets.Socket> нельзя использовать для принятия дополнительных соединений из очереди подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-265">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="f6353-266">Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginAccept%2A>, используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-266">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-267">Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение.</span><span class="sxs-lookup"><span data-stu-id="f6353-267">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="f6353-268">Система также может использовать вызывающий поток для вызова метода обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-268">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="f6353-269">В этом случае свойство <xref:System.IAsyncResult.CompletedSynchronously%2A> в возвращаемом <xref:System.IAsyncResult> будет установлено, чтобы указать, что метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> завершился синхронно.</span><span class="sxs-lookup"><span data-stu-id="f6353-269">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="f6353-270">Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-270">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="f6353-271">Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginAccept%2A>, закройте <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-271">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-272">При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-272">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="f6353-273">При последующем вызове метода <xref:System.Net.Sockets.Socket.EndAccept%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.</span><span class="sxs-lookup"><span data-stu-id="f6353-273">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-274">Чтобы указать сетевой адрес и номер порта удаленного узла, можно использовать свойство <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> возвращенной <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-274">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-275">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-275">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-276">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-276">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-277">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-277">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-278">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-278">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-279">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-279">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-280">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-280">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-281">В следующем примере кода выполняется попытка асинхронного получения входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-281">The following code example attempts to receive an incoming connection asynchronously.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-282">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-282">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-283">Этот метод доступен только в Windows NT.</span><span class="sxs-lookup"><span data-stu-id="f6353-283">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-284">Принимающий сокет не производит прослушивание подключений.</span><span class="sxs-lookup"><span data-stu-id="f6353-284">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="f6353-285">Необходимо вызвать <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> до вызова объекта <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-285">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="f6353-286">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-286">-or-</span></span> 
<span data-ttu-id="f6353-287">Производится связывание принимающего сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-287">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-288">Значение параметра <paramref name="receiveSize" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-288"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-289">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-289">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-290">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-290">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-291">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-291">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="receiveSize"><span data-ttu-id="f6353-292">Число байтов, которые необходимо принять от отправителя.</span><span class="sxs-lookup"><span data-stu-id="f6353-292">The number of bytes to accept from the sender.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-293">Делегат <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-293">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-294">Объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-294">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="f6353-295">Начинает асинхронную операцию, чтобы принять попытку входящего подключения и получить первый блок данных, посланных клиентским приложением.</span><span class="sxs-lookup"><span data-stu-id="f6353-295">Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="f6353-296">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное создание объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-296">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-297">Протоколы, ориентированные на подключение, могут использовать метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> для асинхронной обработки входящих попыток подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-297">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="f6353-298">Асинхронное принятие подключений позволяет отправлять и получать данные в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-298">Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="f6353-299">Эта перегрузка позволяет указать число байтов, которое будет принято в начальной пересылку в параметре `receiveSize`.</span><span class="sxs-lookup"><span data-stu-id="f6353-299">This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="f6353-300">Перед вызовом метода <xref:System.Net.Sockets.Socket.BeginAccept%2A> необходимо вызвать метод <xref:System.Net.Sockets.Socket.Listen%2A> для прослушивания и постановки в очередь входящих запросов на подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-300">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="f6353-301">Необходимо создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-301">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="f6353-302">Для этого, как минимум, необходимо передать объект <xref:System.Net.Sockets.Socket> прослушивания для <xref:System.Net.Sockets.Socket.BeginAccept%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-302">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="f6353-303">Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений.</span><span class="sxs-lookup"><span data-stu-id="f6353-303">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="f6353-304">Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-304">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="f6353-305">Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-305">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="f6353-306">Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginAccept%2A>, система обычно использует отдельный поток для выполнения указанного метода обратного вызова и блокируется на <xref:System.Net.Sockets.Socket.EndAccept%2A> до тех пор, пока не будет получено ожидающее подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-306">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="f6353-307"><xref:System.Net.Sockets.Socket.EndAccept%2A> возвращает новую <xref:System.Net.Sockets.Socket>, которую можно использовать для отправки и получения данных с удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-307"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="f6353-308">Этот возвращенный <xref:System.Net.Sockets.Socket> нельзя использовать для принятия дополнительных соединений из очереди подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-308">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="f6353-309">Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginAccept%2A>, используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-309">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-310">Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение.</span><span class="sxs-lookup"><span data-stu-id="f6353-310">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="f6353-311">Система также может использовать вызывающий поток для вызова метода обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-311">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="f6353-312">В этом случае свойство <xref:System.IAsyncResult.CompletedSynchronously%2A> в возвращаемом <xref:System.IAsyncResult> будет установлено, чтобы указать, что метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> завершился синхронно.</span><span class="sxs-lookup"><span data-stu-id="f6353-312">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="f6353-313">Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-313">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="f6353-314">Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginAccept%2A>, закройте <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-314">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span>  <span data-ttu-id="f6353-315">При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-315">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="f6353-316">При последующем вызове метода <xref:System.Net.Sockets.Socket.EndAccept%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.</span><span class="sxs-lookup"><span data-stu-id="f6353-316">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-317">Чтобы указать сетевой адрес и номер порта удаленного узла, можно вызвать метод, используя свойство <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> возвращенного объекта <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-317">You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-318">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-318">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-319">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-319">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-320">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-320">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-321">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-321">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-322">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-322">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-323">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-323">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-324">В следующем примере кода открывается сокет и принимается асинхронное соединение.</span><span class="sxs-lookup"><span data-stu-id="f6353-324">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="f6353-325">В этом примере сокет принимает начальные 10 байт данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-325">In this example, the socket accepts the initial 10 bytes of data.</span></span> <span data-ttu-id="f6353-326">Число полученных байтов и данные отображаются в консоли делегатом обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-326">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="f6353-327">Описание того, как получены оставшиеся данные, см. в разделе <xref:System.Net.Sockets.Socket.BeginReceive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-327">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-328">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-328">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-329">Этот метод доступен только в Windows NT.</span><span class="sxs-lookup"><span data-stu-id="f6353-329">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-330">Принимающий сокет не производит прослушивание подключений.</span><span class="sxs-lookup"><span data-stu-id="f6353-330">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="f6353-331">Необходимо вызвать <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> до вызова объекта <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-331">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="f6353-332">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-332">-or-</span></span> 
<span data-ttu-id="f6353-333">Производится связывание принимающего сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-333">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-334">Значение параметра <paramref name="receiveSize" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-334"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-335">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-335">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-336">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-336">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-337">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-337">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="acceptSocket"><span data-ttu-id="f6353-338">Принятый объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-338">The accepted <see cref="T:System.Net.Sockets.Socket" /> object.</span></span> <span data-ttu-id="f6353-339">Это значение может быть равно <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-339">This value may be <see langword="null" />.</span></span></param>
        <param name="receiveSize"><span data-ttu-id="f6353-340">Максимальное число принимаемых байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-340">The maximum number of bytes to receive.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-341">Делегат <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-341">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-342">Объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-342">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="f6353-343">Начинает асинхронную операцию, чтобы принять попытку входящего подключения с указанного сокета и получить первый блок данных, посланных клиентским приложением.</span><span class="sxs-lookup"><span data-stu-id="f6353-343">Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="f6353-344">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное создание объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-344">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> object creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-345">Протоколы, ориентированные на подключение, могут использовать метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> для асинхронной обработки входящих попыток подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-345">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="f6353-346">Асинхронное принятие подключений дает возможность отправлять и получать данные в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-346">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="f6353-347">Эта перегрузка позволяет указать обслуживаемый сокет в параметре `acceptSocket`.</span><span class="sxs-lookup"><span data-stu-id="f6353-347">This overload allows you to specify the accepted socket in the `acceptSocket` parameter.</span></span> <span data-ttu-id="f6353-348">Если этот параметр имеет значение `null`, то принятый сокет создается методом <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-348">If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="f6353-349">В параметре `receiveSize` можно указать число байтов, которое будет принято в ходе начальной пересылки.</span><span class="sxs-lookup"><span data-stu-id="f6353-349">You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="f6353-350">Перед вызовом метода <xref:System.Net.Sockets.Socket.BeginAccept%2A> необходимо вызвать метод <xref:System.Net.Sockets.Socket.Listen%2A> для прослушивания и постановки в очередь входящих запросов на подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-350">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="f6353-351">Необходимо создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-351">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="f6353-352">Для этого, как минимум, необходимо передать объект <xref:System.Net.Sockets.Socket> прослушивания для <xref:System.Net.Sockets.Socket.BeginAccept%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-352">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="f6353-353">Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений.</span><span class="sxs-lookup"><span data-stu-id="f6353-353">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="f6353-354">Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-354">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="f6353-355">Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-355">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="f6353-356">Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginAccept%2A>, система обычно использует отдельный поток для выполнения указанного метода обратного вызова и блокируется на <xref:System.Net.Sockets.Socket.EndAccept%2A> до тех пор, пока не будет получено ожидающее подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-356">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="f6353-357"><xref:System.Net.Sockets.Socket.EndAccept%2A> возвращает новый объект <xref:System.Net.Sockets.Socket>, который можно использовать для отправки и получения данных с удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-357"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="f6353-358">Этот возвращенный <xref:System.Net.Sockets.Socket> нельзя использовать для принятия дополнительных соединений из очереди подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-358">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="f6353-359">Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginAccept%2A>, используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-359">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-360">Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение.</span><span class="sxs-lookup"><span data-stu-id="f6353-360">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="f6353-361">Система также может использовать вызывающий поток для вызова метода обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-361">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="f6353-362">В этом случае свойство <xref:System.IAsyncResult.CompletedSynchronously%2A> в возвращаемом <xref:System.IAsyncResult> будет установлено, чтобы указать, что метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> завершился синхронно.</span><span class="sxs-lookup"><span data-stu-id="f6353-362">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="f6353-363">Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-363">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="f6353-364">Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginAccept%2A>, закройте <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-364">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-365">При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-365">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="f6353-366">При последующем вызове метода <xref:System.Net.Sockets.Socket.EndAccept%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.</span><span class="sxs-lookup"><span data-stu-id="f6353-366">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-367">Можно использовать свойство <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> возвращаемого объекта <xref:System.Net.Sockets.Socket>, чтобы указать сетевой адрес и номер порта удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-367">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-368">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-368">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-369">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-369">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-370">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-370">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-371">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-371">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-372">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-372">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-373">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-373">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-374">В следующем примере кода открывается сокет и принимается асинхронное соединение.</span><span class="sxs-lookup"><span data-stu-id="f6353-374">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="f6353-375">В этом примере сокет принимает начальные 10 байт данных, а параметр `acceptSocket` — `null`, что заставляет метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> создать обслуживаемый сокет.</span><span class="sxs-lookup"><span data-stu-id="f6353-375">In this example, the socket accepts the initial 10 bytes of data and the `acceptSocket` parameter is `null`, which forces the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to create the accepted socket.</span></span> <span data-ttu-id="f6353-376">Число полученных байтов и данные отображаются в консоли делегатом обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-376">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="f6353-377">Описание того, как получены оставшиеся данные, см. в разделе <xref:System.Net.Sockets.Socket.BeginReceive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-377">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-378">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-378">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-379">Этот метод доступен только в Windows NT.</span><span class="sxs-lookup"><span data-stu-id="f6353-379">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-380">Принимающий сокет не производит прослушивание подключений.</span><span class="sxs-lookup"><span data-stu-id="f6353-380">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="f6353-381">Необходимо вызвать <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> до вызова объекта <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-381">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="f6353-382">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-382">-or-</span></span> 
<span data-ttu-id="f6353-383">Производится связывание принимающего сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-383">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-384">Значение параметра <paramref name="receiveSize" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-384"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-385">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-385">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-386">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-386">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-387">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-387">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-388">Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-388">Begins an asynchronous request for a remote host connection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><span data-ttu-id="f6353-389">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-389">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span></span></param>
        <param name="end_point"><span data-ttu-id="f6353-390">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-390">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-391">Делегат <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-391">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-392">Объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-392">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="f6353-393">Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-393">Begins an asynchronous request for a remote host connection.</span></span></summary>
        <returns><span data-ttu-id="f6353-394">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-394">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-395">При использовании протокола, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.BeginConnect%2A> запускает асинхронный запрос соединения с параметром `remoteEP`.</span><span class="sxs-lookup"><span data-stu-id="f6353-395">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter.</span></span> <span data-ttu-id="f6353-396">Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.BeginConnect%2A> устанавливает удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-396">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host.</span></span> <span data-ttu-id="f6353-397">Подключение или установка удаленного узла по умолчанию асинхронно дает возможность отправлять и получать данные в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-397">Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="f6353-398">Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-398">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span> <span data-ttu-id="f6353-399">Как минимум, необходимо передать <xref:System.Net.Sockets.Socket> в <xref:System.Net.Sockets.Socket.BeginConnect%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-399">At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter.</span></span> <span data-ttu-id="f6353-400">Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket>и другие необходимые сведения.</span><span class="sxs-lookup"><span data-stu-id="f6353-400">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="f6353-401">Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginConnect%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-401">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="f6353-402">Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-402">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="f6353-403">Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginConnect%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет блокироваться на <xref:System.Net.Sockets.Socket.EndConnect%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не подключится к серверу или не выдаст исключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-403">When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception.</span></span> <span data-ttu-id="f6353-404">Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginConnect%2A>, используйте <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-404">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="f6353-405">Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение.</span><span class="sxs-lookup"><span data-stu-id="f6353-405">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="f6353-406">Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-406">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="f6353-407">Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.BeginConnect%2A> перед отправкой и получением данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-407">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data.</span></span> <span data-ttu-id="f6353-408">Для взаимодействия с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> и <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-408">You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host.</span></span> <span data-ttu-id="f6353-409">При вызове <xref:System.Net.Sockets.Socket.BeginConnect%2A>все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут удалены.</span><span class="sxs-lookup"><span data-stu-id="f6353-409">If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="f6353-410">Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, сначала необходимо вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и настроить вещание на `true`.</span><span class="sxs-lookup"><span data-stu-id="f6353-410">If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="f6353-411">Если это невозможно, <xref:System.Net.Sockets.Socket.BeginConnect%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-411">If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-412">Если вы используете протокол, ориентированный на подключение, и не вызываете <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.BeginConnect%2A>, базовый поставщик услуг присвоит наиболее подходящий локальный сетевой адрес и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-412">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="f6353-413">Если используется протокол без установления соединения, поставщик услуг не присвоит адрес локальной сети и номер порта, пока не будет вызван метод <xref:System.Net.Sockets.Socket.BeginSend%2A> или <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-413">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-414">Если вы хотите изменить удаленный узел по умолчанию, вызовите метод <xref:System.Net.Sockets.Socket.BeginConnect%2A> еще раз, указав нужную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-414">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="f6353-415">Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginConnect%2A>, закройте <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-415">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-416">При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-416">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="f6353-417">При последующем вызове метода <xref:System.Net.Sockets.Socket.EndConnect%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.</span><span class="sxs-lookup"><span data-stu-id="f6353-417">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-418">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-418">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-419">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-419">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-420">Если этот сокет ранее был отключен, то <xref:System.Net.Sockets.Socket.BeginConnect%2A> должен быть вызван в потоке, который не будет выходить до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-420">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="f6353-421">Это ограничение базового поставщика.</span><span class="sxs-lookup"><span data-stu-id="f6353-421">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-422">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-422">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-423">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-423">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-424">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-424">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-425">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-425">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-426">В следующем примере кода инициируется асинхронная попытка соединения.</span><span class="sxs-lookup"><span data-stu-id="f6353-426">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-427">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-427"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-428">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-428">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-429"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-429">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-430">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</span><span class="sxs-lookup"><span data-stu-id="f6353-430">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-431">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, либо асинхронная операция уже выполняется.</span><span class="sxs-lookup"><span data-stu-id="f6353-431">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-432">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-432">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-433">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-433">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-434">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-434">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="f6353-435">Адрес <see cref="T:System.Net.IPAddress" /> удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-435">The <see cref="T:System.Net.IPAddress" /> of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="f6353-436">Номер порта удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-436">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="f6353-437">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-437">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-438">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении операции подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-438">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-439">Пользовательский объект, содержащий информацию об операции подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-439">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="f6353-440">Этот объект передается делегату <paramref name="requestCallback" /> по завершении операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-440">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="f6353-441">Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-441">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="f6353-442">узел задается объектом <see cref="T:System.Net.IPAddress" /> и номером порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-442">The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</span></span></summary>
        <returns><span data-ttu-id="f6353-443">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-443">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-444">Асинхронная <xref:System.Net.Sockets.Socket.BeginConnect%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-444">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="f6353-445">Как правило, метод вызывается делегатом `requestCallback`.</span><span class="sxs-lookup"><span data-stu-id="f6353-445">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="f6353-446">Этот метод не блокируется до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-446">This method does not block until the operation is complete.</span></span> <span data-ttu-id="f6353-447">Чтобы заблокировать блокировку до завершения операции, используйте одну из <xref:System.Net.Sockets.Socket.Connect%2A> перегрузок метода или <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-447">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span></span>  
  
 <span data-ttu-id="f6353-448">Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginConnect%2A>, закройте <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-448">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-449">При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-449">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="f6353-450">При последующем вызове метода <xref:System.Net.Sockets.Socket.EndConnect%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.</span><span class="sxs-lookup"><span data-stu-id="f6353-450">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="f6353-451">Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="f6353-451">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-452">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-452">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-453">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-453">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-454">Если этот сокет ранее был отключен, то <xref:System.Net.Sockets.Socket.BeginConnect%2A> должен быть вызван в потоке, который не будет выходить до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-454">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="f6353-455">Это ограничение базового поставщика.</span><span class="sxs-lookup"><span data-stu-id="f6353-455">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="f6353-456">Кроме того, используемое <xref:System.Net.EndPoint> должно отличаться.</span><span class="sxs-lookup"><span data-stu-id="f6353-456">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-457">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-457">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-458">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-458">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-459">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-459">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-460">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-460">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-461">В следующем примере кода инициируется асинхронная попытка соединения.</span><span class="sxs-lookup"><span data-stu-id="f6353-461">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-462">Свойство <paramref name="address" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-462"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-463">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-463">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-464"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-464">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-465">Объект <see cref="T:System.Net.Sockets.Socket" /> не входит в состав семейства сокетов.</span><span class="sxs-lookup"><span data-stu-id="f6353-465">The <see cref="T:System.Net.Sockets.Socket" /> is not in the socket family.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-466">Номер порта недействителен.</span><span class="sxs-lookup"><span data-stu-id="f6353-466">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-467">Длина параметра <paramref name="address" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="f6353-467">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-468">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, либо асинхронная операция уже выполняется.</span><span class="sxs-lookup"><span data-stu-id="f6353-468">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-469">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-469">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-470">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-470">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-471">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-471">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="f6353-472">По крайней мере, один объект <see cref="T:System.Net.IPAddress" />, определяющий удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-472">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="f6353-473">Номер порта удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-473">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="f6353-474">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-474">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-475">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении операции подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-475">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-476">Пользовательский объект, содержащий информацию об операции подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-476">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="f6353-477">Этот объект передается делегату <paramref name="requestCallback" /> по завершении операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-477">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="f6353-478">Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-478">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="f6353-479">узел задается массивом <see cref="T:System.Net.IPAddress" /> и номером порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-479">The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</span></span></summary>
        <returns><span data-ttu-id="f6353-480"><see cref="T:System.IAsyncResult" />, который ссылается на асинхронное подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-480">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-481">Асинхронная <xref:System.Net.Sockets.Socket.BeginConnect%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-481">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="f6353-482">Как правило, метод вызывается делегатом `requestCallback`.</span><span class="sxs-lookup"><span data-stu-id="f6353-482">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="f6353-483">Этот метод не блокируется до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-483">This method does not block until the operation is complete.</span></span> <span data-ttu-id="f6353-484">Чтобы заблокировать блокировку до завершения операции, используйте одну из перегрузок метода <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-484">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="f6353-485">Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginConnect%2A>, закройте <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-485">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-486">При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-486">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="f6353-487">При последующем вызове метода <xref:System.Net.Sockets.Socket.EndConnect%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.</span><span class="sxs-lookup"><span data-stu-id="f6353-487">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="f6353-488">Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-488">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-489">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-489">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-490">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-490">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-491">Если этот сокет ранее был отключен, то <xref:System.Net.Sockets.Socket.BeginConnect%2A> должен быть вызван в потоке, который не будет выходить до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-491">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="f6353-492">Это ограничение базового поставщика.</span><span class="sxs-lookup"><span data-stu-id="f6353-492">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="f6353-493">Кроме того, используемое <xref:System.Net.EndPoint> должно отличаться.</span><span class="sxs-lookup"><span data-stu-id="f6353-493">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-494">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-494">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-495">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-495">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-496">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-496">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-497">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-497">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-498">В следующем примере кода инициируется асинхронная попытка соединения.</span><span class="sxs-lookup"><span data-stu-id="f6353-498">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-499">Свойство <paramref name="addresses" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-499"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-500">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-500">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-501"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-501">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-502">Этот метод применим для сокетов, которые используют объект <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-502">This method is valid for sockets that use <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-503">Недействительный номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-503">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-504">Длина параметра <paramref name="address" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="f6353-504">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-505">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, либо асинхронная операция уже выполняется.</span><span class="sxs-lookup"><span data-stu-id="f6353-505">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-506">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-506">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-507">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-507">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-508">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-508">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="f6353-509">Имя удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-509">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="f6353-510">Номер порта удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-510">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="f6353-511">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-511">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-512">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении операции подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-512">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-513">Пользовательский объект, содержащий информацию об операции подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-513">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="f6353-514">Этот объект передается делегату <paramref name="requestCallback" /> по завершении операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-514">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="f6353-515">Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-515">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="f6353-516">Узел задается именем узла и номером порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-516">The host is specified by a host name and a port number.</span></span></summary>
        <returns><span data-ttu-id="f6353-517">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-517">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-518">Асинхронная <xref:System.Net.Sockets.Socket.BeginConnect%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-518">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="f6353-519">Как правило, метод вызывается делегатом `requestCallback`.</span><span class="sxs-lookup"><span data-stu-id="f6353-519">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="f6353-520">Этот метод не блокируется до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-520">This method does not block until the operation is complete.</span></span> <span data-ttu-id="f6353-521">Чтобы заблокировать блокировку до завершения операции, используйте одну из перегрузок метода <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-521">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="f6353-522">Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginConnect%2A>, закройте <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-522">To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-523">При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-523">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="f6353-524">При последующем вызове метода <xref:System.Net.Sockets.Socket.EndConnect%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.</span><span class="sxs-lookup"><span data-stu-id="f6353-524">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="f6353-525">Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="f6353-525">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-526">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-526">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-527">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-527">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-528">Если этот сокет ранее был отключен, то <xref:System.Net.Sockets.Socket.BeginConnect%2A> должен быть вызван в потоке, который не будет выходить до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-528">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="f6353-529">Это ограничение базового поставщика.</span><span class="sxs-lookup"><span data-stu-id="f6353-529">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="f6353-530">Кроме того, используемое <xref:System.Net.EndPoint> должно отличаться.</span><span class="sxs-lookup"><span data-stu-id="f6353-530">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-531">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-531">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-532">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-532">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-533">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-533">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-534">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-534">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-535">В следующем примере кода инициируется асинхронная попытка соединения.</span><span class="sxs-lookup"><span data-stu-id="f6353-535">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-536">Свойство <paramref name="host" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-536"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-537"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-537">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-538">Этот метод допустим для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> .</span><span class="sxs-lookup"><span data-stu-id="f6353-538">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-539">Недействительный номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-539">The port number is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-540">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, либо асинхронная операция уже выполняется.</span><span class="sxs-lookup"><span data-stu-id="f6353-540">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-541">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-541">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-542">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-542">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-543">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-543">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><span data-ttu-id="f6353-544">Значение <see langword="true" />, если этот сокет может быть повторно использован после закрытия подключения; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-544"><see langword="true" /> if this socket can be reused after the connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-545">Делегат <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-545">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-546">Объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-546">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="f6353-547">Начинает выполнение асинхронного запроса для отключения от удаленной конечной точки.</span><span class="sxs-lookup"><span data-stu-id="f6353-547">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="f6353-548">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию.</span><span class="sxs-lookup"><span data-stu-id="f6353-548">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-549">При использовании протокола, ориентированного на соединение, можно вызвать метод <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>, чтобы запросить отключение от удаленной конечной точки.</span><span class="sxs-lookup"><span data-stu-id="f6353-549">If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint.</span></span> <span data-ttu-id="f6353-550">Если `reuseSocket` `true`, можно повторно использовать сокет.</span><span class="sxs-lookup"><span data-stu-id="f6353-550">If `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="f6353-551">Метод <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> использует отдельный поток для вызова указанного метода обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-551">The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method.</span></span> <span data-ttu-id="f6353-552">Метод <xref:System.Net.Sockets.Socket.EndDisconnect%2A> блокируется до завершения ожидающего отключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-552">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete.</span></span> <span data-ttu-id="f6353-553">Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-553">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-554">При получении исключения <xref:System.Net.Sockets.SocketException> используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-554">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-555">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-555">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-556">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-556">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-557">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-557">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-558">В следующем примере кода создается сокет для асинхронного взаимодействия и данные отправляются на удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-558">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="f6353-559">После отправки данных вызывается <xref:System.Net.Sockets.Socket.Shutdown%2A> для отмены действия Send и Receive.</span><span class="sxs-lookup"><span data-stu-id="f6353-559">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="f6353-560">Затем вызывается <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> для начала запроса на отключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-560">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="f6353-561">По завершении запроса свойство <xref:System.Net.Sockets.Socket.Connected%2A> запрашивается, чтобы проверить, отключен ли сокет.</span><span class="sxs-lookup"><span data-stu-id="f6353-561">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-562">Используется операционная система Windows 2000 или более ранняя версия, а для этого метода необходима операционная система Windows XP.</span><span class="sxs-lookup"><span data-stu-id="f6353-562">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-563">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-563">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-564">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-564">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-565">Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-565">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="f6353-566">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-566">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-567">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-567">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-568">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-568">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-569">Пользовательский объект, содержащий информацию об операции приема.</span><span class="sxs-lookup"><span data-stu-id="f6353-569">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="f6353-570">Этот объект передается делегату <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> по завершении операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-570">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="f6353-571">Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-571">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-572">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</span><span class="sxs-lookup"><span data-stu-id="f6353-572">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-573">Асинхронная <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndReceive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-573">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="f6353-574">Как правило, метод вызывается делегатом `callback`.</span><span class="sxs-lookup"><span data-stu-id="f6353-574">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="f6353-575">Этот метод не блокируется до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-575">This method does not block until the operation is complete.</span></span> <span data-ttu-id="f6353-576">Чтобы заблокировать блокировку до завершения операции, используйте одну из перегрузок метода <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-576">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="f6353-577">Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-577">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-578">Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-578">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-579">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-579">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-580">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-580">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-581">Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока.</span><span class="sxs-lookup"><span data-stu-id="f6353-581">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="f6353-582">Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-582">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-583">`state` является экземпляром определяемого пользователем класса.</span><span class="sxs-lookup"><span data-stu-id="f6353-583">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-584">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-584">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-585">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-585">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-586">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-586">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-587">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-587">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-588">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-588"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-589">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-589">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-590">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-590"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-591">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-591">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-592">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-592">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-593">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-593">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="f6353-594">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-594">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-595">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-595">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="f6353-596">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-596">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-597">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-597">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-598">Пользовательский объект, содержащий информацию об операции приема.</span><span class="sxs-lookup"><span data-stu-id="f6353-598">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="f6353-599">Этот объект передается делегату <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> по завершении операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-599">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="f6353-600">Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-600">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-601">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</span><span class="sxs-lookup"><span data-stu-id="f6353-601">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-602">Асинхронная <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndReceive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-602">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="f6353-603">Как правило, метод вызывается делегатом `callback`.</span><span class="sxs-lookup"><span data-stu-id="f6353-603">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="f6353-604">Этот метод не блокируется до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-604">This method does not block until the operation is complete.</span></span> <span data-ttu-id="f6353-605">Чтобы заблокировать блокировку до завершения операции, используйте одну из перегрузок метода <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-605">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="f6353-606">Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-606">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-607">Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-607">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-608">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-608">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-609">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-609">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-610">Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока.</span><span class="sxs-lookup"><span data-stu-id="f6353-610">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="f6353-611">Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-611">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-612">`state` является экземпляром определяемого пользователем класса.</span><span class="sxs-lookup"><span data-stu-id="f6353-612">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-613">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-613">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-614">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-614">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-615">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-615">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-616">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-616">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-617">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-617"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-618">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-618">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-619">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-619"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-620">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-620">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-621">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-621">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-622">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-622">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-623">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-623">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-624">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, начиная с которой хранятся принятые данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-624">The zero-based position in the <paramref name="buffer" /> parameter at which to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-625">Количество байтов, которые необходимо получить.</span><span class="sxs-lookup"><span data-stu-id="f6353-625">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-626">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-626">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="f6353-627">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-627">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-628">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-628">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-629">Пользовательский объект, содержащий информацию об операции приема.</span><span class="sxs-lookup"><span data-stu-id="f6353-629">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="f6353-630">Этот объект передается делегату <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> по завершении операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-630">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="f6353-631">Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-631">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-632">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</span><span class="sxs-lookup"><span data-stu-id="f6353-632">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-633">Асинхронная <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndReceive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-633">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="f6353-634">Как правило, метод вызывается делегатом `callback`.</span><span class="sxs-lookup"><span data-stu-id="f6353-634">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="f6353-635">Этот метод не блокируется до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-635">This method does not block until the operation is complete.</span></span> <span data-ttu-id="f6353-636">Чтобы заблокировать блокировку до завершения операции, используйте одну из перегрузок метода <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-636">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="f6353-637">Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-637">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-638">Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-638">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-639">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-639">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-640">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-640">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-641">Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока.</span><span class="sxs-lookup"><span data-stu-id="f6353-641">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="f6353-642">Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-642">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-643">`state` является экземпляром определяемого пользователем класса.</span><span class="sxs-lookup"><span data-stu-id="f6353-643">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-644">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-644">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-645">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-645">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-646">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-646">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-647">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-647">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-648">В следующем примере кода начинается асинхронный прием данных из подключенной <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-648">The following code example begins to asynchronously receive data from a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-649">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-649"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-650">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-650">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-651">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-651"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-652">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-652"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-653">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-653">-or-</span></span> 
 <span data-ttu-id="f6353-654">Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-654"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-655">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-655">-or-</span></span> 
 <span data-ttu-id="f6353-656">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-656"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-657">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-657">-or-</span></span> 
 <span data-ttu-id="f6353-658">Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-658"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-659">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-659">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-660">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-660">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-661">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-661">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, errorCode, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-662">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-662">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-663">Место в объекте <paramref name="buffer" />, выделенное для хранения принимаемых данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-663">The location in <paramref name="buffer" /> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-664">Количество байтов, которые необходимо получить.</span><span class="sxs-lookup"><span data-stu-id="f6353-664">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-665">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-665">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="flags"><span data-ttu-id="f6353-666">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-666">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="f6353-667">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-667">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="error"><span data-ttu-id="f6353-668">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-668">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-669">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-669">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-670">Пользовательский объект, содержащий информацию об операции приема.</span><span class="sxs-lookup"><span data-stu-id="f6353-670">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="f6353-671">Этот объект передается делегату <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> по завершении операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-671">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="f6353-672">Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-672">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-673">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</span><span class="sxs-lookup"><span data-stu-id="f6353-673">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-674">Асинхронная <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndReceive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-674">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="f6353-675">Как правило, метод вызывается делегатом `callback`.</span><span class="sxs-lookup"><span data-stu-id="f6353-675">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="f6353-676">Этот метод не блокируется до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-676">This method does not block until the operation is complete.</span></span> <span data-ttu-id="f6353-677">Чтобы заблокировать блокировку до завершения операции, используйте одну из перегрузок метода <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-677">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="f6353-678">Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-678">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-679">Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-679">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-680">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-680">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-681">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-681">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-682">Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока.</span><span class="sxs-lookup"><span data-stu-id="f6353-682">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="f6353-683">Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-683">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-684">`state` является экземпляром определяемого пользователем класса.</span><span class="sxs-lookup"><span data-stu-id="f6353-684">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-685">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-685">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-686">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-686">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-687">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-687">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-688">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-688">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-689">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-689"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-690">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-690">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-691">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-691"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-692">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-692"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-693">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-693">-or-</span></span> 
 <span data-ttu-id="f6353-694">Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-694"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-695">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-695">-or-</span></span> 
 <span data-ttu-id="f6353-696">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-696"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-697">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-697">-or-</span></span> 
 <span data-ttu-id="f6353-698">Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-698"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-699">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-699">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-700">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-700">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-701">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-701">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-702">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-702">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-703">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, начиная с которой хранятся данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-703">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-704">Количество байтов, которые необходимо получить.</span><span class="sxs-lookup"><span data-stu-id="f6353-704">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-705">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-705">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="f6353-706">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-706">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="f6353-707">Объект <see cref="T:System.Net.EndPoint" />, представляющий источник данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-707">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="remote_end"><span data-ttu-id="f6353-708">Объект <see cref="T:System.Net.EndPoint" />, представляющий источник данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-708">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-709">Делегат <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-709">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-710">Объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-710">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="f6353-711">Начинает выполнение асинхронного приема данных с указанного сетевого устройства.</span><span class="sxs-lookup"><span data-stu-id="f6353-711">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="f6353-712">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</span><span class="sxs-lookup"><span data-stu-id="f6353-712">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-713">Метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> запускает асинхронное чтение датаграмм без подключения с удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-713">The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host.</span></span> <span data-ttu-id="f6353-714">Вызов метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> дает возможность получения данных в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-714">Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="f6353-715">Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-715">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-716">Для этого, как минимум, параметр `state` должен содержать подключенный или <xref:System.Net.Sockets.Socket> по умолчанию, используемый для связи.</span><span class="sxs-lookup"><span data-stu-id="f6353-716">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="f6353-717">Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений.</span><span class="sxs-lookup"><span data-stu-id="f6353-717">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="f6353-718">Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-718">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="f6353-719">Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-719">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-720">Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова, и он будет заблокирован на <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не прочитает данные или не выдаст исключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-720">When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception.</span></span> <span data-ttu-id="f6353-721">Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-721">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-722">Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение.</span><span class="sxs-lookup"><span data-stu-id="f6353-722">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="f6353-723">Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-723">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-724">Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>необходимо явно привязать <xref:System.Net.Sockets.Socket> к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.Bind%2A>, иначе <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> выдаст исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-724">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-725">Этот метод считывает данные в параметр `buffer` и фиксирует конечную точку удаленного узла, из которой отправляются данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-725">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent.</span></span> <span data-ttu-id="f6353-726">Сведения о том, как получить эту конечную точку, см. в разделе <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-726">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="f6353-727">Этот метод наиболее удобен, если предполагается асинхронное получение датаграмм без подключения из неизвестного узла или с нескольких узлов.</span><span class="sxs-lookup"><span data-stu-id="f6353-727">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span> <span data-ttu-id="f6353-728">В таких случаях <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> будет считывать из буфера локальной сети полученную датаграмму из очереди.</span><span class="sxs-lookup"><span data-stu-id="f6353-728">In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="f6353-729">Если полученная датаграмма превышает размер `buffer`, метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> будет заполняться `buffer` с максимально возможной частью сообщения и вызывать <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-729">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-730">При использовании ненадежного протокола избыточные данные будут потеряны.</span><span class="sxs-lookup"><span data-stu-id="f6353-730">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="f6353-731">Если используется надежный протокол, избыточные данные будут сохранены поставщиком услуг, и его можно будет извлечь, вызвав метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> с достаточно большим буфером.</span><span class="sxs-lookup"><span data-stu-id="f6353-731">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="f6353-732">Чтобы гарантировать, что конечная точка удаленного узла всегда возвращается, приложение должно явно привязать <xref:System.Net.Sockets.Socket> к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.Bind%2A>, а затем вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> с параметром `optionLevel`, для которого задано значение <xref:System.Net.Sockets.SocketOptionLevel.IP> или <xref:System.Net.Sockets.SocketOptionLevel.IPv6> соответственно, параметр `optionName` имеет значение <xref:System.Net.Sockets.SocketOptionName.PacketInformation>и параметр `optionValue`, чтобы включить этот параметр перед вызовом метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-732">To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-733">В противном случае конечная точка удаленного узла может быть не возвращена, когда отправитель отправил число датаграмм, прежде чем получатель вызвал метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-733">Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-734">Хотя <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение.</span><span class="sxs-lookup"><span data-stu-id="f6353-734">Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="f6353-735">Если вы решили сделать это, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> или приняв входящий запрос на подключение, вызвав метод <xref:System.Net.Sockets.Socket.Accept%2A> или <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-735">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="f6353-736">При вызове метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> перед установкой или приемом соединения вы получите <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-736">If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-737">Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-737">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-738">В любом из этих случаев метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> будет игнорировать параметр `remoteEP` и получить данные только с подключенного или удаленного узла по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-738">In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="f6353-739">При использовании сокетов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> будет считывать столько данных, сколько доступно до числа байтов, указанного параметром `size`.</span><span class="sxs-lookup"><span data-stu-id="f6353-739">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span>  
  
 <span data-ttu-id="f6353-740">Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-740">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-741">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-741">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-742">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-742">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-743">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-743">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-744">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-744">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-745">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-745">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-746">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-746">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-747">В следующем примере кода асинхронно принимаются датаграммы без установления соединения с удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-747">The following code example asynchronously receives connectionless datagrams from a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-748">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-748"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-749">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-749">-or-</span></span> 
 <span data-ttu-id="f6353-750">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-750"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-751">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-751">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-752">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-752"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-753">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-753">-or-</span></span> 
 <span data-ttu-id="f6353-754">Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-754"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-755">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-755">-or-</span></span> 
 <span data-ttu-id="f6353-756">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-756"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-757">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-757">-or-</span></span> 
 <span data-ttu-id="f6353-758">Значение<paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" /> .</span><span class="sxs-lookup"><span data-stu-id="f6353-758"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-759"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-759">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-760">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</span><span class="sxs-lookup"><span data-stu-id="f6353-760">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-761">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-761">Marshaling a Delegate as a Callback Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-762">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-762">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-763">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, начиная с которой хранятся данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-763">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-764">Количество байтов, которые необходимо получить.</span><span class="sxs-lookup"><span data-stu-id="f6353-764">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-765">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-765">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="f6353-766">Объект <see cref="T:System.Net.EndPoint" />, представляющий источник данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-766">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-767">Делегат <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-767">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-768">Объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-768">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="f6353-769">Начинает асинхронный прием заданного числа байтов данных в указанное место буфера данных, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />, а также сохраняет конечную точку и информацию пакета.</span><span class="sxs-lookup"><span data-stu-id="f6353-769">Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="f6353-770">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</span><span class="sxs-lookup"><span data-stu-id="f6353-770">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-771">Асинхронная операция получения должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-771">The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method.</span></span> <span data-ttu-id="f6353-772">Как правило, метод вызывается делегатом `asyncCallback`.</span><span class="sxs-lookup"><span data-stu-id="f6353-772">Typically, the method is invoked by the `asyncCallback` delegate.</span></span>  
  
 <span data-ttu-id="f6353-773">Этот метод не блокируется до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-773">This method does not block until the operation completes.</span></span> <span data-ttu-id="f6353-774">Для блокировки до завершения операции используйте метод <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-774">To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-775">Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-775">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-776">Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span><span class="sxs-lookup"><span data-stu-id="f6353-776">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</span></span>  
  
 <span data-ttu-id="f6353-777">Этот метод считывает данные в параметр `buffer` и захватывает конечную точку удаленного узла, из которой отправляются данные, а также сведения о полученных пакетах.</span><span class="sxs-lookup"><span data-stu-id="f6353-777">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</span></span> <span data-ttu-id="f6353-778">Сведения о том, как получить эту конечную точку, см. в разделе <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-778">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="f6353-779">Этот метод наиболее удобен, если предполагается асинхронное получение датаграмм без подключения из неизвестного узла или с нескольких узлов.</span><span class="sxs-lookup"><span data-stu-id="f6353-779">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-780">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-780">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-781">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-781">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-782">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-782">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-783">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-783">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-784">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-784">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-785">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-785">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-786">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-786"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-787">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-787">-or-</span></span> 
 <span data-ttu-id="f6353-788">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-788"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-789">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-789">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-790">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-790"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-791">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-791">-or-</span></span> 
 <span data-ttu-id="f6353-792">Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-792"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-793">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-793">-or-</span></span> 
 <span data-ttu-id="f6353-794">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-794"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-795">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-795">-or-</span></span> 
 <span data-ttu-id="f6353-796">Значение<paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" /> .</span><span class="sxs-lookup"><span data-stu-id="f6353-796"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-797"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-797">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-798">Используется операционная система Windows 2000 или более ранняя версия, а для этого метода необходима операционная система Windows XP.</span><span class="sxs-lookup"><span data-stu-id="f6353-798">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-799">Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-799">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="f6353-800">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-800">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-801">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-801">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-802">Делегат <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-802">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-803">Объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-803">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="f6353-804">Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-804">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-805">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</span><span class="sxs-lookup"><span data-stu-id="f6353-805">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-806">Метод <xref:System.Net.Sockets.Socket.BeginSend%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в методе <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-806">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="f6353-807"><xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-807"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="f6353-808">Вызов метода <xref:System.Net.Sockets.Socket.BeginSend%2A> дает возможность отправки данных в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-808">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="f6353-809">Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-809">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="f6353-810">Для этого, как минимум, параметр `state` должен содержать подключенный или <xref:System.Net.Sockets.Socket> по умолчанию, используемый для связи.</span><span class="sxs-lookup"><span data-stu-id="f6353-810">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="f6353-811">Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений.</span><span class="sxs-lookup"><span data-stu-id="f6353-811">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="f6353-812">Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginSend%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-812">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="f6353-813">Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-813">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="f6353-814">Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет блокироваться на <xref:System.Net.Sockets.Socket.EndSend%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-814">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="f6353-815">Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginSend%2A>, используйте метод <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-815">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f6353-816">Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение.</span><span class="sxs-lookup"><span data-stu-id="f6353-816">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="f6353-817">Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-817">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="f6353-818">Хотя для протоколов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginSend%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>, чтобы установить удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-818">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="f6353-819">Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-819">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="f6353-820">Можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-820">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-821">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-821">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="f6353-822">При использовании протоколов без подключения необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-822">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-823">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-823">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-824">Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-824">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-825">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-825">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-826">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-826">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-827">Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока.</span><span class="sxs-lookup"><span data-stu-id="f6353-827">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="f6353-828">Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-828">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-829">`state` является экземпляром определяемого пользователем класса.</span><span class="sxs-lookup"><span data-stu-id="f6353-829">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-830">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-830">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-831">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-831">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-832">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-832">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-833">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-833">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-834">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-834">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-835">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-835">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-836">Свойство <paramref name="buffers" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-836"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-837">Параметр <paramref name="buffers" /> пуст.</span><span class="sxs-lookup"><span data-stu-id="f6353-837"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-838">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-838">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="f6353-839">См. ниже примeчания к данному разделу.</span><span class="sxs-lookup"><span data-stu-id="f6353-839">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-840"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-840">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-841">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-841">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-842">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-842">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-843">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-843">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="f6353-844">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-844">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-845">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-845">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="f6353-846">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-846">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-847">Делегат <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-847">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-848">Объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-848">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="f6353-849">Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-849">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-850">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</span><span class="sxs-lookup"><span data-stu-id="f6353-850">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-851">Метод <xref:System.Net.Sockets.Socket.BeginSend%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в методе <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-851">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="f6353-852"><xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-852"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="f6353-853">Вызов метода <xref:System.Net.Sockets.Socket.BeginSend%2A> дает возможность отправки данных в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-853">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="f6353-854">Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-854">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="f6353-855">Для этого, как минимум, параметр `state` должен содержать подключенный или <xref:System.Net.Sockets.Socket> по умолчанию, используемый для связи.</span><span class="sxs-lookup"><span data-stu-id="f6353-855">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="f6353-856">Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений.</span><span class="sxs-lookup"><span data-stu-id="f6353-856">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="f6353-857">Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginSend%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-857">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="f6353-858">Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-858">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="f6353-859">Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет блокироваться на <xref:System.Net.Sockets.Socket.EndSend%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-859">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="f6353-860">Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginSend%2A>, используйте метод <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-860">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f6353-861">Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение.</span><span class="sxs-lookup"><span data-stu-id="f6353-861">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="f6353-862">Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-862">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="f6353-863">Хотя для протоколов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginSend%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>, чтобы установить удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-863">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="f6353-864">Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-864">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="f6353-865">Можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-865">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-866">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-866">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="f6353-867">При использовании протоколов без подключения необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-867">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-868">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-868">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-869">Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-869">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-870">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-870">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-871">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-871">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-872">Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока.</span><span class="sxs-lookup"><span data-stu-id="f6353-872">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="f6353-873">Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-873">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-874">`state` является экземпляром определяемого пользователем класса.</span><span class="sxs-lookup"><span data-stu-id="f6353-874">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-875">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-875">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-876">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-876">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-877">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-877">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-878">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-878">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-879">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-879">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-880">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-880">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-881">Свойство <paramref name="buffers" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-881"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-882">Параметр <paramref name="buffers" /> пуст.</span><span class="sxs-lookup"><span data-stu-id="f6353-882"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-883">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-883">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="f6353-884">См. ниже примeчания к данному разделу.</span><span class="sxs-lookup"><span data-stu-id="f6353-884">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-885"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-885">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-886">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-886">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-887">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-887">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-888">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-888">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-889">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-889">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-890">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, с которой начинается отправка данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-890">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-891">Количество байтов для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-891">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-892">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-892">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="f6353-893">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-893">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-894">Делегат <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-894">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-895">Объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-895">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="f6353-896">Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-896">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-897">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</span><span class="sxs-lookup"><span data-stu-id="f6353-897">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-898">Метод <xref:System.Net.Sockets.Socket.BeginSend%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в методе <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-898">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="f6353-899"><xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-899"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="f6353-900">Вызов метода <xref:System.Net.Sockets.Socket.BeginSend%2A> дает возможность отправки данных в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-900">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="f6353-901">Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-901">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="f6353-902">Для этого, как минимум, параметр `state` должен содержать подключенный или <xref:System.Net.Sockets.Socket> по умолчанию, используемый для связи.</span><span class="sxs-lookup"><span data-stu-id="f6353-902">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="f6353-903">Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений.</span><span class="sxs-lookup"><span data-stu-id="f6353-903">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="f6353-904">Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginSend%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-904">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="f6353-905">Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-905">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="f6353-906">Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет блокироваться на <xref:System.Net.Sockets.Socket.EndSend%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-906">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="f6353-907">Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginSend%2A>, используйте метод <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-907">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f6353-908">Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение.</span><span class="sxs-lookup"><span data-stu-id="f6353-908">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="f6353-909">Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-909">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="f6353-910">Хотя для протоколов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginSend%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>, чтобы установить удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-910">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="f6353-911">Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-911">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="f6353-912">Можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-912">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-913">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-913">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="f6353-914">При использовании протоколов без подключения необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-914">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-915">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-915">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-916">Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-916">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-917">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-917">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-918">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-918">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-919">Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока.</span><span class="sxs-lookup"><span data-stu-id="f6353-919">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="f6353-920">Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-920">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-921">`state` является экземпляром определяемого пользователем класса.</span><span class="sxs-lookup"><span data-stu-id="f6353-921">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-922">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-922">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-923">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-923">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-924">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-924">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-925">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-925">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-926">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-926">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-927">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-927">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-928">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-928"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-929">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-929">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="f6353-930">См. ниже примeчания к данному разделу.</span><span class="sxs-lookup"><span data-stu-id="f6353-930">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-931">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-931"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-932">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-932">-or-</span></span> 
 <span data-ttu-id="f6353-933">Значение параметра <paramref name="offset" /> меньше значения длины, указанного в параметре <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-933"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-934">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-934">-or-</span></span> 
 <span data-ttu-id="f6353-935">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-935"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-936">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-936">-or-</span></span> 
 <span data-ttu-id="f6353-937">Значение<paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" /> .</span><span class="sxs-lookup"><span data-stu-id="f6353-937"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-938"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-938">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-939">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-939">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-940">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-940">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-941">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-941">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-942">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-942">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-943">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, с которой начинается отправка данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-943">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-944">Количество байтов для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-944">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-945">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-945">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="f6353-946">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-946">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-947">Делегат <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-947">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-948">Объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-948">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="f6353-949">Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-949">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-950">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</span><span class="sxs-lookup"><span data-stu-id="f6353-950">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-951">Метод <xref:System.Net.Sockets.Socket.BeginSend%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в методе <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-951">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="f6353-952"><xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-952"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="f6353-953">Вызов метода <xref:System.Net.Sockets.Socket.BeginSend%2A> дает возможность отправки данных в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-953">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="f6353-954">Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-954">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="f6353-955">Для этого, как минимум, параметр `state` должен содержать подключенный или <xref:System.Net.Sockets.Socket> по умолчанию, используемый для связи.</span><span class="sxs-lookup"><span data-stu-id="f6353-955">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="f6353-956">Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений.</span><span class="sxs-lookup"><span data-stu-id="f6353-956">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="f6353-957">Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginSend%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-957">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="f6353-958">Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-958">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="f6353-959">Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет блокироваться на <xref:System.Net.Sockets.Socket.EndSend%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-959">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="f6353-960">Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginSend%2A>, используйте метод <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-960">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f6353-961">Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение.</span><span class="sxs-lookup"><span data-stu-id="f6353-961">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="f6353-962">Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-962">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="f6353-963">Хотя для протоколов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginSend%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>, чтобы установить удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-963">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="f6353-964">Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-964">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="f6353-965">Можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-965">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-966">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-966">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="f6353-967">При использовании протоколов без подключения необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-967">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-968">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-968">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-969">Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-969">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-970">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-970">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-971">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-971">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-972">Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока.</span><span class="sxs-lookup"><span data-stu-id="f6353-972">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="f6353-973">Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-973">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-974">`state` является экземпляром определяемого пользователем класса.</span><span class="sxs-lookup"><span data-stu-id="f6353-974">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-975">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-975">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-976">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-976">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-977">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-977">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-978">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-978">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-979">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-979">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-980">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-980">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-981">В следующем примере кода начинается асинхронная отправка данных на удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-981">The following code example begins asynchronously sending data to a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-982">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-982"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-983">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-983">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="f6353-984">См. ниже примeчания к данному разделу.</span><span class="sxs-lookup"><span data-stu-id="f6353-984">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-985">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-985"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-986">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-986">-or-</span></span> 
 <span data-ttu-id="f6353-987">Значение параметра <paramref name="offset" /> меньше значения длины, указанного в параметре <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-987"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-988">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-988">-or-</span></span> 
 <span data-ttu-id="f6353-989">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-989"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-990">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-990">-or-</span></span> 
 <span data-ttu-id="f6353-991">Значение<paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" /> .</span><span class="sxs-lookup"><span data-stu-id="f6353-991"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-992"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-992">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-993">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-993">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md"><span data-ttu-id="f6353-994">Примеры асинхронных сокетов клиента</span><span class="sxs-lookup"><span data-stu-id="f6353-994">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md"><span data-ttu-id="f6353-995">Пример асинхронного сокета сервера</span><span class="sxs-lookup"><span data-stu-id="f6353-995">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-996">Выполняет асинхронную передачу файла на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-996">Sends a file asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="f6353-997">Строка, содержащая путь и имя отправляемого файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-997">A string that contains the path and name of the file to send.</span></span> <span data-ttu-id="f6353-998">Этот параметр может иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-998">This parameter can be <see langword="null" />.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-999">Делегат <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-999">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-1000">Объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-1000">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="f6353-1001">Отправляет файл <paramref name="fileName" /> на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя флаг <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1001">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.</span></span></summary>
        <returns><span data-ttu-id="f6353-1002">Объект <see cref="T:System.IAsyncResult" />, который представляет асинхронную передачу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1002">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1003">Эта перегрузка отправляет файл `fileName` подключенному сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1003">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="f6353-1004">Если `fileName` находится в локальном каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1004">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="f6353-1005">Подстановочные знаки ("..\\\мифиле.ткст ") и имена общих UNC-папок ("\\\\\\Directory\\\мифиле.ткст ") поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="f6353-1005">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="f6353-1006">Если файл не найден, вызывается исключение <xref:System.IO.FileNotFoundException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1006">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="f6353-1007">Этот метод использует функцию `TransmitFile`, которая находится в API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="f6353-1007">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="f6353-1008">Дополнительные сведения о функции `TransmitFile` и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="f6353-1008">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="f6353-1009">Метод <xref:System.Net.Sockets.Socket.BeginSendFile%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в методах <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1009">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="f6353-1010"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> создает исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1010"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="f6353-1011">Вызов метода <xref:System.Net.Sockets.Socket.BeginSendFile%2A> позволяет отправить файл в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1011">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="f6353-1012">Чтобы завершить операцию, можно создать метод обратного вызова, вызываемый параметром делегата <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1012">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="f6353-1013">Для этого, как минимум, параметр `state` должен содержать объект <xref:System.Net.Sockets.Socket>, используемый для связи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1013">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="f6353-1014">Если для обратного вызова требуются дополнительные сведения, можно создать класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений.</span><span class="sxs-lookup"><span data-stu-id="f6353-1014">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="f6353-1015">Передайте экземпляр этого пользовательского объекта методу <xref:System.Net.Sockets.Socket.BeginSendFile%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1015">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="f6353-1016">Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSendFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1016">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="f6353-1017">Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, система использует отдельный поток для выполнения указанного метода обратного вызова и блокируется на <xref:System.Net.Sockets.Socket.EndSendFile%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит весь файл или не выдаст исключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1017">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="f6353-1018">Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1018">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="f6353-1019">Хотя для протоколов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>, чтобы установить удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1019">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="f6353-1020">При использовании протоколов без подключения необходимо убедиться, что размер файла не превышает максимальный размер пакета поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-1020">With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-1021">Если это так, датаграмма не отправляется, а <xref:System.Net.Sockets.Socket.BeginSendFile%2A> вызывает исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1021">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1022">При получении исключения <xref:System.Net.Sockets.SocketException> используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1022">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1023">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1023">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1024">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1024">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1025">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1025">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1026">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1026">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-1027">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-1027">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1028">В следующем примере кода создается и подключается сокет для асинхронного взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="f6353-1028">The following code example creates and connects a socket for asynchronous communication.</span></span> <span data-ttu-id="f6353-1029">Сначала файл "Text. txt" отправляется асинхронно на удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-1029">First, the file "text.txt" is sent asynchronously to the remote host.</span></span> <span data-ttu-id="f6353-1030">Делегат обратного вызова вызывает <xref:System.Net.Sockets.Socket.EndSendFile%2A> для завершения передачи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1030">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1031">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1031">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1032">Сокет не подключен к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1032">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f6353-1033">Файл <paramref name="fileName" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="f6353-1033">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1034">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1034">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="f6353-1035">См. ниже примeчания к данному разделу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1035">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="f6353-1036">Строка, содержащая путь и имя отправляемого файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1036">A string that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="f6353-1037">Этот параметр может иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1037">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="f6353-1038">Массив <see cref="T:System.Byte" />, содержащий данные, отправляемые перед передачей файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1038">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="f6353-1039">Этот параметр может иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1039">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="f6353-1040">Массив <see cref="T:System.Byte" />, содержащий данные, отправляемые после передачи файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1040">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="f6353-1041">Этот параметр может иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1041">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="f6353-1042">Побитовое сочетание значений <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1042">A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-1043">Делегат <see cref="T:System.AsyncCallback" />, который должен быть вызван, когда эта операция завершается.</span><span class="sxs-lookup"><span data-stu-id="f6353-1043">An <see cref="T:System.AsyncCallback" /> delegate to be invoked when this operation completes.</span></span> <span data-ttu-id="f6353-1044">Этот параметр может иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1044">This parameter can be <see langword="null" />.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-1045">Определенный пользователем объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-1045">A user-defined object that contains state information for this request.</span></span> <span data-ttu-id="f6353-1046">Этот параметр может иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1046">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="f6353-1047">Выполняет асинхронную передачу файла и буферов данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1047">Sends a file and buffers of data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="f6353-1048">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1048">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1049">Для этой перегрузки требуется имя файла, который требуется отправить, и побитовое сочетание значений <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1049">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="f6353-1050">Параметр `preBuffer` содержит все данные, которые необходимо указать перед файлом.</span><span class="sxs-lookup"><span data-stu-id="f6353-1050">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="f6353-1051">`postBuffer` содержит данные, которые необходимо отслеживать в файле.</span><span class="sxs-lookup"><span data-stu-id="f6353-1051">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="f6353-1052">Если `fileName` находится в локальном каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1052">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="f6353-1053">Подстановочные знаки ("..\\\мифиле.ткст ") и имена общих UNC-папок ("\\\\\\Directory\\\мифиле.ткст ") поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="f6353-1053">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="f6353-1054">Если файл не найден, вызывается исключение <xref:System.IO.FileNotFoundException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1054">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="f6353-1055">Параметр `flags` предоставляет поставщику службы оконных сокетов дополнительные сведения о переносе файлов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1055">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="f6353-1056">Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1056">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="f6353-1057">Этот метод использует функцию `TransmitFile`, которая находится в API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="f6353-1057">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="f6353-1058">Дополнительные сведения о функции `TransmitFile` и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="f6353-1058">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="f6353-1059">Метод <xref:System.Net.Sockets.Socket.BeginSendFile%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в методах <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1059">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="f6353-1060"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> создает исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1060"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="f6353-1061">Вызов метода <xref:System.Net.Sockets.Socket.BeginSendFile%2A> дает возможность отправить файл в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1061">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="f6353-1062">Чтобы завершить операцию, можно создать метод обратного вызова, вызываемый параметром делегата <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1062">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="f6353-1063">Для этого, как минимум, параметр `state` должен содержать объект <xref:System.Net.Sockets.Socket>, используемый для связи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1063">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="f6353-1064">Если для обратного вызова требуются дополнительные сведения, можно создать класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений.</span><span class="sxs-lookup"><span data-stu-id="f6353-1064">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="f6353-1065">Передайте экземпляр этого пользовательского объекта методу <xref:System.Net.Sockets.Socket.BeginSendFile%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1065">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="f6353-1066">Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSendFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1066">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="f6353-1067">Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, система использует отдельный поток для выполнения указанного метода обратного вызова и блокируется на <xref:System.Net.Sockets.Socket.EndSendFile%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит весь файл или не выдаст исключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1067">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="f6353-1068">Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1068">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="f6353-1069">Хотя для протоколов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>, чтобы установить удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1069">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="f6353-1070">При использовании протоколов без подключения необходимо также убедиться в том, что размер файла не превышает максимальный размер пакета для базового поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-1070">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-1071">Если это так, датаграмма не отправляется, а <xref:System.Net.Sockets.Socket.BeginSendFile%2A> вызывает исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1071">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1072">При получении исключения <xref:System.Net.Sockets.SocketException> используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1072">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1073">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1073">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1074">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1074">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1075">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1075">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1076">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1076">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-1077">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-1077">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1078">Следующий пример кода создает и подключает сокет для асинхронного взаимодействия и начинает асинхронно отправлять файл "Text. txt" на удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-1078">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="f6353-1079">В этом примере создается `preBuffer` и `postBuffer` данных для отправки с файлом и используется значение по умолчанию <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1079">In this example, a `preBuffer` and a `postBuffer` of data is created to send with the file and the default <xref:System.Net.Sockets.TransmitFileOptions> value is used.</span></span> <span data-ttu-id="f6353-1080">Делегат обратного вызова вызывает <xref:System.Net.Sockets.Socket.EndSendFile%2A> для завершения передачи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1080">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1081">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1081">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1082">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1082">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="f6353-1083">См. ниже примeчания к данному разделу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1083">See remarks section below.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1084">Операционной системой не является Windows NT или более поздняя версия.</span><span class="sxs-lookup"><span data-stu-id="f6353-1084">The operating system is not Windows NT or later.</span></span>  
  
<span data-ttu-id="f6353-1085">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-1085">-or-</span></span>
  
 <span data-ttu-id="f6353-1086">Сокет не подключен к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1086">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f6353-1087">Файл <paramref name="fileName" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="f6353-1087">The file <paramref name="fileName" /> was not found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-1088">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-1088">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-1089">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, с которой начинается отправка данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-1089">The zero-based position in <paramref name="buffer" /> at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-1090">Количество байтов для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1090">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-1091">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1091">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="f6353-1092">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1092">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="f6353-1093">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленное устройство.</span><span class="sxs-lookup"><span data-stu-id="f6353-1093">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <param name="remote_end"><span data-ttu-id="f6353-1094">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленное устройство.</span><span class="sxs-lookup"><span data-stu-id="f6353-1094">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <param name="callback"><span data-ttu-id="f6353-1095">Делегат <see cref="T:System.AsyncCallback" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1095">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="f6353-1096">Объект, содержащий сведения о состоянии для этого запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-1096">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="f6353-1097">Асинхронно передает данные на конкретный удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-1097">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="f6353-1098">Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1098">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1099">Метод <xref:System.Net.Sockets.Socket.BeginSendTo%2A> запускает асинхронную операцию отправки на удаленный узел, указанный в параметре `remoteEP`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1099">The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter.</span></span> <span data-ttu-id="f6353-1100">Вызов метода <xref:System.Net.Sockets.Socket.BeginSendTo%2A> дает возможность отправки данных в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1100">Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="f6353-1101">Несмотря на то, что предназначен для протоколов без подключения, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> работает с протоколами, ориентированными на подключения и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1101">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="f6353-1102">Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1102">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method.</span></span> <span data-ttu-id="f6353-1103">Для этого, как минимум, параметр `state` должен содержать подключенный или <xref:System.Net.Sockets.Socket> по умолчанию, используемый для связи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1103">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="f6353-1104">Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket>и другие необходимые сведения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1104">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="f6353-1105">Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginSendTo%2A> с помощью параметра `state`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1105">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="f6353-1106">Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1106">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method.</span></span> <span data-ttu-id="f6353-1107">Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет блокироваться на <xref:System.Net.Sockets.Socket.EndSendTo%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1107">When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="f6353-1108">Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, используйте метод <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1108">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="f6353-1109">Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1109">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="f6353-1110">Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1110">For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).</span></span>  
  
 <span data-ttu-id="f6353-1111">При использовании протокола, ориентированного на соединение, необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A> или <xref:System.Net.Sockets.Socket.BeginSendTo%2A> выдаст исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1111">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-1112"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> будет игнорировать параметр `remoteEP` и отправить данные в <xref:System.Net.EndPoint>, установленные в <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или методе <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1112"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-1113">Если используется протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод перед вызовом <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1113">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="f6353-1114">Это необходимо сделать только в том случае, если предполагается вызывать метод <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1114">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="f6353-1115">При вызове метода <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A> до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>параметр `remoteEP` переопределит указанный удаленный узел по умолчанию только для этой операции отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1115">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="f6353-1116">Также не требуется вызывать метод <xref:System.Net.Sockets.Socket.Bind%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1116">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="f6353-1117">В этом случае базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1117">In this case, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="f6353-1118">Если необходимо, чтобы базовый поставщик услуг выберет свободный порт, используйте нуль-порт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1118">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="f6353-1119">Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> после успешного завершения метода <xref:System.Net.Sockets.Socket.EndSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1119">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="f6353-1120">Если вы хотите отправить данные на широковещательный адрес, сначала необходимо вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1120">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-1121">— Необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-1121">-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-1122">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.EndSendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1122">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-1123">Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-1123">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1124">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1124">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1125">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1125">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1126">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1126">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1127">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1127">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1128">Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1128">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="f6353-1129">После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-1129">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1130">В следующем примере кода асинхронно отправляются данные на указанный удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-1130">The following code example asynchronously sends data to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1131">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1131"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-1132">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-1132">-or-</span></span> 
 <span data-ttu-id="f6353-1133">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1133"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1134">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1134">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-1135">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-1135"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-1136">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-1136">-or-</span></span> 
 <span data-ttu-id="f6353-1137">Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1137"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-1138">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-1138">-or-</span></span> 
 <span data-ttu-id="f6353-1139">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-1139"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-1140">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-1140">-or-</span></span> 
 <span data-ttu-id="f6353-1141">Значение<paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" /> .</span><span class="sxs-lookup"><span data-stu-id="f6353-1141"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1142"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1142">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-1143">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1143">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md"><span data-ttu-id="f6353-1144">Маршалинг делегата как метода обратного вызова</span><span class="sxs-lookup"><span data-stu-id="f6353-1144">Marshaling a Delegate as a Callback Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><span data-ttu-id="f6353-1145">Локальный объект <see cref="T:System.Net.EndPoint" />, который необходимо связать с объектом <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1145">The local <see cref="T:System.Net.EndPoint" /> to associate with the <see cref="T:System.Net.Sockets.Socket" />.</span></span></param>
        <summary><span data-ttu-id="f6353-1146">Связывает объект <see cref="T:System.Net.Sockets.Socket" /> с локальной конечной точкой.</span><span class="sxs-lookup"><span data-stu-id="f6353-1146">Associates a <see cref="T:System.Net.Sockets.Socket" /> with a local endpoint.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1147">Если необходимо использовать определенную локальную конечную точку, используйте метод <xref:System.Net.Sockets.Socket.Bind%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1147">Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint.</span></span> <span data-ttu-id="f6353-1148">Необходимо вызвать <xref:System.Net.Sockets.Socket.Bind%2A>, прежде чем можно будет вызвать метод <xref:System.Net.Sockets.Socket.Listen%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1148">You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="f6353-1149">Не нужно вызывать <xref:System.Net.Sockets.Socket.Bind%2A> перед использованием метода <xref:System.Net.Sockets.Socket.Connect%2A>, если не требуется использовать определенную локальную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-1149">You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint.</span></span> <span data-ttu-id="f6353-1150">Вы можете использовать метод <xref:System.Net.Sockets.Socket.Bind%2A> для протоколов, ориентированных на подключения и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1150">You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="f6353-1151">Перед вызовом <xref:System.Net.Sockets.Socket.Bind%2A>необходимо сначала создать локальный <xref:System.Net.IPEndPoint>, из которого предполагается передавать данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-1151">Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data.</span></span> <span data-ttu-id="f6353-1152">Если вы не хотите, чтобы локальный адрес был назначен, можно создать <xref:System.Net.IPEndPoint> с помощью <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> в качестве параметра адреса, и базовый поставщик услуг присвоит наиболее подходящий сетевой адрес.</span><span class="sxs-lookup"><span data-stu-id="f6353-1152">If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> as the address parameter, and the underlying service provider will assign the most appropriate network address.</span></span> <span data-ttu-id="f6353-1153">Это может помочь упростить приложение при наличии нескольких сетевых интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1153">This might help simplify your application if you have multiple network interfaces.</span></span> <span data-ttu-id="f6353-1154">Если вы не хотите узнать, какой локальный порт используется, можно создать <xref:System.Net.IPEndPoint>, используя значение 0 для номера порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1154">If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number.</span></span> <span data-ttu-id="f6353-1155">В этом случае поставщик услуг присвоит доступному номеру порта от 1024 до 5000.</span><span class="sxs-lookup"><span data-stu-id="f6353-1155">In this case, the service provider will assign an available port number between 1024 and 5000.</span></span>  
  
 <span data-ttu-id="f6353-1156">При использовании описанного выше подхода можно определить, какой локальный сетевой адрес и номер порта были назначены путем вызова <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1156">If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span></span> <span data-ttu-id="f6353-1157">При использовании протокола, ориентированного на соединение, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> не возвращает локально назначенный сетевой адрес до тех пор, пока не будет выполнен вызов метода <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1157">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="f6353-1158">Если используется протокол без подключения, вы не сможете получить доступ к этим данным, пока не завершите отправку или получение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1158">If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</span></span>  
  
 <span data-ttu-id="f6353-1159">Если сокету UDP требуется получать сведения о интерфейсе для полученных пакетов, то метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> должен быть явно вызван с параметром Socket, установленным в <xref:System.Net.Sockets.SocketOptionName.PacketInformation> сразу после вызова метода <xref:System.Net.Sockets.Socket.Bind%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1159">If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1160">Если предполагается получение датаграмм многоадресной рассылки, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Bind%2A> с номером многоадресного порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1160">If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1161">Необходимо вызвать метод <xref:System.Net.Sockets.Socket.Bind%2A>, если предполагается получение датаграмм без подключения с помощью метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1161">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1162">При получении <xref:System.Net.Sockets.SocketException> при вызове метода <xref:System.Net.Sockets.Socket.Bind%2A> используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1162">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1163">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1163">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1164">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1164">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1165">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1165">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1166">В следующем примере кода выполняется привязка <xref:System.Net.Sockets.Socket> с помощью указанной локальной конечной точки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1166">The following code example binds a <xref:System.Net.Sockets.Socket> using the specified local endpoint.</span></span>  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1167">Свойство <paramref name="localEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1167"><paramref name="localEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1168">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1168">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1169"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1169">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-1170">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1170">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-1171">для приема соединений с узла, определенного <paramref name="localEP" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1171">for accepting connections from the host defined by <paramref name="localEP" />.</span></span> <span data-ttu-id="f6353-1172">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" /></span><span class="sxs-lookup"><span data-stu-id="f6353-1172">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></span></span></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-1173">Возвращает или задает значение, определяющее, находится ли объект <see cref="T:System.Net.Sockets.Socket" /> в заблокированном режиме.</span><span class="sxs-lookup"><span data-stu-id="f6353-1173">Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</span></span></summary>
        <value><span data-ttu-id="f6353-1174">Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> будет заблокирован; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1174"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> will block; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f6353-1175">Значение по умолчанию — <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1175">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1176">Свойство <xref:System.Net.Sockets.Socket.Blocking%2A> указывает, находится ли <xref:System.Net.Sockets.Socket> в блокирующем режиме.</span><span class="sxs-lookup"><span data-stu-id="f6353-1176">The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.</span></span>  
  
 <span data-ttu-id="f6353-1177">Если вы используете режим блокировки и вы выполняете вызов метода, который не завершается немедленно, приложение будет блокировать выполнение до тех пор, пока не завершится запрошенная операция.</span><span class="sxs-lookup"><span data-stu-id="f6353-1177">If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</span></span> <span data-ttu-id="f6353-1178">Если требуется продолжить выполнение, даже если запрошенная операция не завершена, измените свойство <xref:System.Net.Sockets.Socket.Blocking%2A> на `false`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1178">If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`.</span></span> <span data-ttu-id="f6353-1179">Свойство <xref:System.Net.Sockets.Socket.Blocking%2A> не влияет на асинхронные методы.</span><span class="sxs-lookup"><span data-stu-id="f6353-1179">The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods.</span></span> <span data-ttu-id="f6353-1180">Если вы отправляете и получаете данные асинхронно и хотите блокировать выполнение, используйте класс <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1180">If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1181">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1181">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1182">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1182">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1183">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1183">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1184">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1184">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1185">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1185">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1186"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1186">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f6353-1187">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, используемый для запроса соединения с удаленным узлом путем вызова одного из методов <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1187">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object used to request the connection to the remote host by calling one of the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> methods.</span></span></param>
        <summary><span data-ttu-id="f6353-1188">Отменяет выполнение асинхронного запроса для подключения к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1188">Cancels an asynchronous request for a remote host connection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1189">Метод <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> отменяет асинхронный запрос для подключения к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1189">The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1190">Параметр <paramref name="e" /> и <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не могут иметь значение NULL.</span><span class="sxs-lookup"><span data-stu-id="f6353-1190">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1191">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1191">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1192"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1192">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-1193">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1193">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-1194">Закрывает подключение <see cref="T:System.Net.Sockets.Socket" /> и освобождает все связанные ресурсы.</span><span class="sxs-lookup"><span data-stu-id="f6353-1194">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6353-1195">Закрывает подключение <see cref="T:System.Net.Sockets.Socket" /> и освобождает все связанные ресурсы.</span><span class="sxs-lookup"><span data-stu-id="f6353-1195">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1196">Метод <xref:System.Net.Sockets.Socket.Close%2A> закрывает подключение к удаленному узлу и освобождает все управляемые и неуправляемые ресурсы, связанные с <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1196">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-1197">После закрытия свойству <xref:System.Net.Sockets.Socket.Connected%2A> присваивается значение `false`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1197">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="f6353-1198">Для протоколов, ориентированных на соединение, рекомендуется вызвать <xref:System.Net.Sockets.Socket.Shutdown%2A> перед вызовом метода <xref:System.Net.Sockets.Socket.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1198">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span> <span data-ttu-id="f6353-1199">Это гарантирует, что все данные отправляются и получаются на подключенном сокете до его закрытия.</span><span class="sxs-lookup"><span data-stu-id="f6353-1199">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="f6353-1200">Если необходимо вызвать <xref:System.Net.Sockets.Socket.Close%2A> без первого вызова <xref:System.Net.Sockets.Socket.Shutdown%2A>, можно убедиться, что данные, поставленные в очередь для исходящей передачи, будут отправлены, задав для параметра <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> значение `false` и указав интервал времени ожидания, отличный от нуля.</span><span class="sxs-lookup"><span data-stu-id="f6353-1200">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="f6353-1201"><xref:System.Net.Sockets.Socket.Close%2A> будет блокироваться до тех пор, пока эти данные не будут отправлены или пока не истечет указанное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-1201"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="f6353-1202">Если для <xref:System.Net.Sockets.SocketOptionName.DontLinger> задано значение `false` и задан интервал нулевого времени ожидания, то <xref:System.Net.Sockets.Socket.Close%2A> освобождает соединение и автоматически удаляет исходящие данные из очереди.</span><span class="sxs-lookup"><span data-stu-id="f6353-1202">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1203">Чтобы задать для параметра <xref:System.Net.Sockets.SocketOptionName.DontLinger> сокета значение `false`, создайте <xref:System.Net.Sockets.LingerOption>, задайте для свойства Enabled значение `true`и задайте для свойства <xref:System.Net.Sockets.LingerOption.LingerTime%2A> значение нужного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-1203">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period.</span></span> <span data-ttu-id="f6353-1204">Используйте этот <xref:System.Net.Sockets.LingerOption> вместе с параметром сокета <xref:System.Net.Sockets.SocketOptionName.DontLinger>, чтобы вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1204">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1205">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1205">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1206">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1206">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1207">В следующем примере кода закрывается <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1207">The following code example closes a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="f6353-1208">Процесс ожидает указанное число секунд <paramref name="timeout" />, прежде чем отправить оставшиеся данные, а затем закрывает сокет.</span><span class="sxs-lookup"><span data-stu-id="f6353-1208">Wait up to <paramref name="timeout" /> seconds to send any remaining data, then close the socket.</span></span></param>
        <summary><span data-ttu-id="f6353-1209">Закрывает подключение <see cref="T:System.Net.Sockets.Socket" /> и освобождает все связанные ресурсы с заданным временем ожидания, чтобы разрешить отправку данных в очереди.</span><span class="sxs-lookup"><span data-stu-id="f6353-1209">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1210">Метод <xref:System.Net.Sockets.Socket.Close%2A> закрывает подключение к удаленному узлу и освобождает все управляемые и неуправляемые ресурсы, связанные с <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1210">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-1211">После закрытия свойству <xref:System.Net.Sockets.Socket.Connected%2A> присваивается значение `false`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1211">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="f6353-1212">Для протоколов, ориентированных на соединение, рекомендуется вызывать <xref:System.Net.Sockets.Socket.Shutdown%2A> перед вызовом <xref:System.Net.Sockets.Socket.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1212">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>.</span></span> <span data-ttu-id="f6353-1213">Это гарантирует, что все данные отправляются и получаются на подключенном сокете до его закрытия.</span><span class="sxs-lookup"><span data-stu-id="f6353-1213">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="f6353-1214">Если необходимо вызвать <xref:System.Net.Sockets.Socket.Close%2A> без первого вызова <xref:System.Net.Sockets.Socket.Shutdown%2A>, можно убедиться, что данные, поставленные в очередь для исходящей передачи, будут отправлены, установив для параметра <xref:System.Net.Sockets.SocketOptionName.DontLinger> значение `false` и указав интервал времени ожидания, отличный от нуля.</span><span class="sxs-lookup"><span data-stu-id="f6353-1214">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="f6353-1215"><xref:System.Net.Sockets.Socket.Close%2A> будет блокироваться до тех пор, пока эти данные не будут отправлены или пока не истечет указанное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-1215"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="f6353-1216">Если для <xref:System.Net.Sockets.SocketOptionName.DontLinger> задано значение `false` и задан интервал нулевого времени ожидания, то <xref:System.Net.Sockets.Socket.Close%2A> освобождает соединение и автоматически удаляет исходящие данные из очереди.</span><span class="sxs-lookup"><span data-stu-id="f6353-1216">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1217">Чтобы задать для параметра <xref:System.Net.Sockets.SocketOptionName.DontLinger> сокета значение `false`, создайте <xref:System.Net.Sockets.LingerOption>, задайте для свойства Enabled значение `true`, а для свойства <xref:System.Net.Sockets.LingerOption.LingerTime%2A> задайте требуемый период времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-1217">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period.</span></span> <span data-ttu-id="f6353-1218">Используйте этот <xref:System.Net.Sockets.LingerOption> вместе с параметром сокета <xref:System.Net.Sockets.SocketOptionName.DontLinger>, чтобы вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1218">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1219">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1219">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1220">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1220">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1221">В следующем примере кода показано, как закрыть <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1221">The following code example demonstrates how to close a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-1222">Устанавливает подключение к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1222">Establishes a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><span data-ttu-id="f6353-1223">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленное устройство.</span><span class="sxs-lookup"><span data-stu-id="f6353-1223">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <summary><span data-ttu-id="f6353-1224">Устанавливает подключение к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1224">Establishes a connection to a remote host.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1225">Если используется протокол, ориентированный на подключение, например TCP, метод <xref:System.Net.Sockets.Socket.Connect%2A> синхронно устанавливает сетевое подключение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанной удаленной конечной точкой.</span><span class="sxs-lookup"><span data-stu-id="f6353-1225">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="f6353-1226">Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1226">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="f6353-1227">После вызова <xref:System.Net.Sockets.Socket.Connect%2A>можно отправить данные на удаленное устройство с помощью метода <xref:System.Net.Sockets.Socket.Send%2A> или получить данные с удаленного устройства с помощью метода <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1227">After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-1228">Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.Connect%2A> перед отправкой и получением данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-1228">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="f6353-1229">Для синхронной связи с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> и <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1229">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="f6353-1230">При вызове <xref:System.Net.Sockets.Socket.Connect%2A>все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут удалены.</span><span class="sxs-lookup"><span data-stu-id="f6353-1230">If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="f6353-1231">Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>или <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1231">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-1232">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1232">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1233">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1233">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="f6353-1234">Метод <xref:System.Net.Sockets.Socket.Connect%2A> будет блокироваться, если только вы не установили для свойства <xref:System.Net.Sockets.Socket.Blocking%2A> значение `false` до вызова <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1234">The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-1235">Если вы используете протокол, ориентированный на подключение, например TCP, и отключите блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>, так как требуется время для подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1235">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="f6353-1236">Протоколы без подключения не вызовут исключение, так как они просто устанавливают удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1236">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="f6353-1237">Для получения конкретного кода ошибки можно использовать <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1237">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1238">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1238">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="f6353-1239">Если ошибка вернула ВСАЕВАУЛДБЛОКК, подключение к удаленному узлу было инициировано <xref:System.Net.Sockets.Socket>, ориентированного на подключение, но еще не завершено успешно.</span><span class="sxs-lookup"><span data-stu-id="f6353-1239">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="f6353-1240">Чтобы определить время завершения подключения <xref:System.Net.Sockets.Socket>, используйте метод <xref:System.Net.Sockets.Socket.Poll%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1240">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1241">Если вы используете протокол, ориентированный на подключение, и не вызывали <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.Connect%2A>, базовый поставщик услуг присвоит локальный сетевой адрес и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1241">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="f6353-1242">Если используется протокол без подключения, поставщик услуг не будет назначать локальный сетевой адрес и номер порта, пока не завершится операция отправки или получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1242">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="f6353-1243">Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> еще раз, указав нужную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-1243">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1244">Если сокет был ранее отключен, использовать этот метод для восстановления соединения нельзя.</span><span class="sxs-lookup"><span data-stu-id="f6353-1244">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="f6353-1245">Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методов для повторного подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1245">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="f6353-1246">Это ограничение базового поставщика.</span><span class="sxs-lookup"><span data-stu-id="f6353-1246">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1247">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1247">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1248">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1248">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1249">Следующий пример кода подключается к удаленной конечной точке, а затем проверяет подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1249">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1250">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1250"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1251">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1251">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1252"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1252">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-1253">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1253">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1254">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1254">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-1255">для подключения к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1255">for connecting to the remote host.</span></span> <span data-ttu-id="f6353-1256">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Connect" /></span><span class="sxs-lookup"><span data-stu-id="f6353-1256">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="f6353-1257">IP-адрес удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1257">The IP address of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="f6353-1258">Номер порта удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1258">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="f6353-1259">Создает подключение к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1259">Establishes a connection to a remote host.</span></span> <span data-ttu-id="f6353-1260">Узел задается IP-адресом и номером порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1260">The host is specified by an IP address and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1261">Если используется протокол, ориентированный на подключение, например TCP, метод <xref:System.Net.Sockets.Socket.Connect%2A> синхронно устанавливает сетевое подключение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанной удаленной конечной точкой.</span><span class="sxs-lookup"><span data-stu-id="f6353-1261">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="f6353-1262">Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1262">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="f6353-1263">После вызова <xref:System.Net.Sockets.Socket.Connect%2A> можно отправить данные на удаленное устройство с помощью метода <xref:System.Net.Sockets.Socket.Send%2A> или получить данные с удаленного устройства с помощью метода <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1263">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-1264">Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.Connect%2A> перед отправкой и получением данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-1264">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="f6353-1265">Для синхронной связи с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> и <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1265">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="f6353-1266">При вызове <xref:System.Net.Sockets.Socket.Connect%2A> все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут отклонены.</span><span class="sxs-lookup"><span data-stu-id="f6353-1266">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="f6353-1267">Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>или <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1267">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-1268">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1268">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1269">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1269">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="f6353-1270"><xref:System.Net.Sockets.Socket.Connect%2A> метод будет блокироваться, если только вы не установили для свойства <xref:System.Net.Sockets.Socket.Blocking%2A> значение `false` до вызова <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1270"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-1271">Если вы используете протокол, ориентированный на подключение, например TCP, и отключите блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>, так как требуется время для подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1271">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="f6353-1272">Протоколы без подключения не вызовут исключение, так как они просто устанавливают удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1272">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="f6353-1273">Для получения конкретного кода ошибки можно использовать <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1273">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1274">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1274">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="f6353-1275">Если ошибка вернула ВСАЕВАУЛДБЛОКК, подключение к удаленному узлу было инициировано <xref:System.Net.Sockets.Socket>, ориентированного на подключение, но еще не завершено успешно.</span><span class="sxs-lookup"><span data-stu-id="f6353-1275">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="f6353-1276">Чтобы определить время завершения подключения <xref:System.Net.Sockets.Socket>, используйте метод <xref:System.Net.Sockets.Socket.Poll%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1276">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1277">Если вы используете протокол, ориентированный на подключение, и не вызывали <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.Connect%2A>, базовый поставщик услуг присвоит локальный сетевой адрес и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1277">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="f6353-1278">Если используется протокол без подключения, поставщик услуг не будет назначать локальный сетевой адрес и номер порта, пока не завершится операция отправки или получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1278">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="f6353-1279">Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> еще раз, указав нужную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-1279">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1280">Если сокет был ранее отключен, использовать этот метод для восстановления соединения нельзя.</span><span class="sxs-lookup"><span data-stu-id="f6353-1280">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="f6353-1281">Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методов для повторного подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1281">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="f6353-1282">Это ограничение базового поставщика.</span><span class="sxs-lookup"><span data-stu-id="f6353-1282">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1283">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1283">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1284">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1284">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1285">Следующий пример кода подключается к удаленной конечной точке, а затем проверяет подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1285">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1286">Свойство <paramref name="address" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1286"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-1287">Недействительный номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1287">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1288">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1288">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1289"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1289">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1290">Этот метод допустим для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1290">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1291">Длина параметра <paramref name="address" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="f6353-1291">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1292">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1292">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="f6353-1293">IP-адрес удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1293">The IP addresses of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="f6353-1294">Номер порта удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1294">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="f6353-1295">Устанавливает подключение к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1295">Establishes a connection to a remote host.</span></span> <span data-ttu-id="f6353-1296">Узел задается массивом IP-адресов и номером порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1296">The host is specified by an array of IP addresses and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1297">Этот метод обычно используется сразу после вызова <xref:System.Net.Dns.GetHostAddresses%2A>, который может возвращать несколько IP-адресов для одного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1297">This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host.</span></span> <span data-ttu-id="f6353-1298">Если используется протокол, ориентированный на подключение, например TCP, метод <xref:System.Net.Sockets.Socket.Connect%2A> синхронно устанавливает сетевое подключение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанной удаленной конечной точкой.</span><span class="sxs-lookup"><span data-stu-id="f6353-1298">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="f6353-1299">Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1299">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="f6353-1300">После вызова <xref:System.Net.Sockets.Socket.Connect%2A> можно отправить данные на удаленное устройство с помощью метода <xref:System.Net.Sockets.Socket.Send%2A> или получить данные с удаленного устройства с помощью метода <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1300">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-1301">Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.Connect%2A> перед отправкой и получением данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-1301">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="f6353-1302">Для синхронной связи с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> и <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1302">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="f6353-1303">При вызове <xref:System.Net.Sockets.Socket.Connect%2A> все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут отклонены.</span><span class="sxs-lookup"><span data-stu-id="f6353-1303">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="f6353-1304">Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>или <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1304">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-1305">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1305">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1306">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1306">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="f6353-1307"><xref:System.Net.Sockets.Socket.Connect%2A> метод будет блокироваться, если только вы не установили для свойства <xref:System.Net.Sockets.Socket.Blocking%2A> значение `false` до вызова <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1307"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-1308">Если вы используете протокол, ориентированный на подключение, например TCP, и отключите блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>, так как требуется время для подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1308">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="f6353-1309">Протоколы без подключения не вызовут исключение, так как они просто устанавливают удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1309">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="f6353-1310">Для получения конкретного кода ошибки можно использовать <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1310">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1311">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1311">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="f6353-1312">Если ошибка вернула ВСАЕВАУЛДБЛОКК, подключение к удаленному узлу было инициировано <xref:System.Net.Sockets.Socket>, ориентированного на подключение, но еще не завершено успешно.</span><span class="sxs-lookup"><span data-stu-id="f6353-1312">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="f6353-1313">Чтобы определить время завершения подключения <xref:System.Net.Sockets.Socket>, используйте метод <xref:System.Net.Sockets.Socket.Poll%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1313">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1314">Если вы используете протокол, ориентированный на подключение, и не вызывали <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.Connect%2A>, базовый поставщик услуг присвоит локальный сетевой адрес и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1314">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="f6353-1315">Если используется протокол без подключения, поставщик услуг не будет назначать локальный сетевой адрес и номер порта, пока не завершится операция отправки или получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1315">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="f6353-1316">Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> еще раз, указав нужную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-1316">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1317">Если сокет был ранее отключен, использовать этот метод для восстановления соединения нельзя.</span><span class="sxs-lookup"><span data-stu-id="f6353-1317">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="f6353-1318">Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методов для повторного подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1318">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="f6353-1319">Это ограничение базового поставщика.</span><span class="sxs-lookup"><span data-stu-id="f6353-1319">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1320">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1320">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1321">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1321">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1322">Следующий пример кода подключается к удаленной конечной точке, а затем проверяет подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1322">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1323">Свойство <paramref name="addresses" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1323"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-1324">Недействительный номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1324">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1325">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1325">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1326"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1326">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1327">Этот метод допустим для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1327">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1328">Длина параметра <paramref name="address" /> равна нулю.</span><span class="sxs-lookup"><span data-stu-id="f6353-1328">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1329">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1329">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="f6353-1330">Имя удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1330">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="f6353-1331">Номер порта удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1331">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="f6353-1332">Устанавливает подключение к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1332">Establishes a connection to a remote host.</span></span> <span data-ttu-id="f6353-1333">Узел задается именем узла и номером порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1333">The host is specified by a host name and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1334">Если используется протокол, ориентированный на подключение, например TCP, метод <xref:System.Net.Sockets.Socket.Connect%2A> синхронно устанавливает сетевое подключение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанным удаленным узлом.</span><span class="sxs-lookup"><span data-stu-id="f6353-1334">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host.</span></span> <span data-ttu-id="f6353-1335">Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1335">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="f6353-1336">После вызова <xref:System.Net.Sockets.Socket.Connect%2A> можно отправить данные на удаленное устройство с помощью метода <xref:System.Net.Sockets.Socket.Send%2A> или получить данные с удаленного устройства с помощью метода <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1336">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-1337">Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.Connect%2A> перед отправкой и получением данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-1337">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="f6353-1338">Для синхронной связи с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> и <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1338">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="f6353-1339">При вызове <xref:System.Net.Sockets.Socket.Connect%2A> все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут отклонены.</span><span class="sxs-lookup"><span data-stu-id="f6353-1339">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="f6353-1340">Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>или <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1340">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-1341">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1341">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1342">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1342">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="f6353-1343"><xref:System.Net.Sockets.Socket.Connect%2A> метод будет блокироваться, если только вы не установили для свойства <xref:System.Net.Sockets.Socket.Blocking%2A> значение `false` до вызова <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1343"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-1344">Если вы используете протокол, ориентированный на подключение, например TCP, и отключите блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>, так как требуется время для подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1344">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="f6353-1345">Протоколы без подключения не вызовут исключение, так как они просто устанавливают удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1345">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="f6353-1346">Для получения конкретного кода ошибки можно использовать <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1346">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1347">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1347">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="f6353-1348">Если ошибка вернула ВСАЕВАУЛДБЛОКК, подключение к удаленному узлу было инициировано <xref:System.Net.Sockets.Socket>, ориентированного на подключение, но еще не завершено успешно.</span><span class="sxs-lookup"><span data-stu-id="f6353-1348">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="f6353-1349">Чтобы определить время завершения подключения <xref:System.Net.Sockets.Socket>, используйте метод <xref:System.Net.Sockets.Socket.Poll%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1349">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
 <span data-ttu-id="f6353-1350">Если включена поддержка протокола IPv6 и вызывается метод <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> для подключения к узлу, который разрешается как в IPv6, так и в IPv4-адресах, сначала будет предпринята попытка подключения к IPv6-адресу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1350">If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</span></span> <span data-ttu-id="f6353-1351">Это может привести к задержке времени для установления соединения, если узел не прослушивает IPv6-адрес.</span><span class="sxs-lookup"><span data-stu-id="f6353-1351">This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1352">Если вы используете протокол, ориентированный на подключение, и не вызывали <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.Connect%2A>, базовый поставщик услуг присвоит локальный сетевой адрес и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1352">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="f6353-1353">Если используется протокол без подключения, поставщик услуг не будет назначать локальный сетевой адрес и номер порта, пока не завершится операция отправки или получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1353">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="f6353-1354">Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> еще раз, указав нужную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-1354">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1355">Если сокет был ранее отключен, использовать этот метод для восстановления соединения нельзя.</span><span class="sxs-lookup"><span data-stu-id="f6353-1355">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="f6353-1356">Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методов для повторного подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1356">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="f6353-1357">Это ограничение базового поставщика.</span><span class="sxs-lookup"><span data-stu-id="f6353-1357">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1358">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1358">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1359">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1359">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1360">Следующий пример кода подключается к удаленной конечной точке, а затем проверяет подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1360">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1361">Свойство <paramref name="host" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1361"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-1362">Недействительный номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1362">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1363">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1363">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1364"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1364">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1365">Этот метод применим для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1365">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1366">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1366">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-1367">Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1367">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f6353-1368">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-1368">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="f6353-1369">Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1369">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="f6353-1370"><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-1370"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="f6353-1371">По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1371">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="f6353-1372"><see langword="false" />, если операция ввода-вывода завершена синхронно.</span><span class="sxs-lookup"><span data-stu-id="f6353-1372"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="f6353-1373">В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1373">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1374">При использовании протокола, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> запускает асинхронный запрос подключения к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1374">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="f6353-1375">Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> устанавливает удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1375">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.</span></span>  
  
 <span data-ttu-id="f6353-1376">Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик события EventHandler\<SocketAsyncEventArgs > делегат и присоединить обратный вызов к событию <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1376">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="f6353-1377">Вызывающий объект должен задать свойству <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> <xref:System.Net.IPEndPoint> удаленного узла для подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1377">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="f6353-1378">Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, чтобы информация была извлечена в методе обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-1378">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="f6353-1379">Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1379">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="f6353-1380">Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.ConnectAsync%2A> перед отправкой и получением данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-1380">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="f6353-1381">Для взаимодействия с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.SendToAsync%2A> и <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1381">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="f6353-1382">При вызове <xref:System.Net.Sockets.Socket.ConnectAsync%2A>все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут удалены.</span><span class="sxs-lookup"><span data-stu-id="f6353-1382">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="f6353-1383">Если вы хотите изменить удаленный узел по умолчанию, вызовите метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> еще раз, указав нужную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-1383">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="f6353-1384">Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, сначала необходимо вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и настроить вещание на `true`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1384">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="f6353-1385">Если это не сделано, метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1385">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-1386">Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> являются обязательными:</span><span class="sxs-lookup"><span data-stu-id="f6353-1386">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="f6353-1387">При необходимости можно указать буфер, который будет атомарно отправлен на сокет после того, как метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> завершится с ошибкой.</span><span class="sxs-lookup"><span data-stu-id="f6353-1387">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="f6353-1388">В этом случае свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> должно быть установлено в буфер, содержащий данные для отправки, а свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> должно иметь значение, равное числу байтов данных, отправляемых из буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-1388">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="f6353-1389">После установления соединения отправляется этот буфер данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-1389">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="f6353-1390">Если вы используете протокол, ориентированный на подключение, и не вызываете <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, базовый поставщик услуг присвоит наиболее подходящий локальный сетевой адрес и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1390">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="f6353-1391">Если используется протокол без подключения, поставщик услуг не будет назначать IP-адрес и номер порта локальной сети, пока не будут вызваны методы <xref:System.Net.Sockets.Socket.SendAsync%2A> или <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1391">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="f6353-1392">Метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> вызывает исключение <xref:System.NotSupportedException>, если семейство адресов <xref:System.Net.Sockets.Socket> и <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> не совпадают с семейством адресов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1392">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1393">При получении <xref:System.Net.Sockets.SocketException> при вызове этого метода используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1393">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1394">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1394">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1395">Аргумент является недопустимым.</span><span class="sxs-lookup"><span data-stu-id="f6353-1395">An argument is not valid.</span></span> <span data-ttu-id="f6353-1396">Это исключение возникает, если задано несколько буферов, свойство <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> не имеет значение "null".</span><span class="sxs-lookup"><span data-stu-id="f6353-1396">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1397">Параметр <paramref name="e" /> и <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не могут иметь значение NULL.</span><span class="sxs-lookup"><span data-stu-id="f6353-1397">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1398"><see cref="T:System.Net.Sockets.Socket" /> ведет прослушивание или работа с сокетом уже выполняется с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного параметром <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1398">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1399">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1399">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1400">Этот метод доступен только в Windows XP и более поздних версиях.</span><span class="sxs-lookup"><span data-stu-id="f6353-1400">Windows XP or later is required for this method.</span></span> <span data-ttu-id="f6353-1401">Это исключение возникает также в том случае, если локальная конечная точка и объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не принадлежат к одному семейству адресов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1401">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1402"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1402">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-1403">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1403">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="f6353-1404">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketType" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1404">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="f6353-1405">Одно из значений перечисления <see cref="T:System.Net.Sockets.ProtocolType" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1405">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <param name="e"><span data-ttu-id="f6353-1406">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-1406">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="f6353-1407">Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1407">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="f6353-1408"><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-1408"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="f6353-1409">По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1409">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="f6353-1410"><see langword="false" />, если операция ввода-вывода завершена синхронно.</span><span class="sxs-lookup"><span data-stu-id="f6353-1410"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="f6353-1411">В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1411">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1412">Если используется протокол, ориентированный на соединение, метод М:систем.нет.соккетс.соккет.коннектасинк (System .NET. Sockets. Соккеттипе, System .NET. Sockets. ProtocolType, System .NET. Sockets. SocketAsyncEventArgs) запускает асинхронный запрос для подключение к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1412">If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="f6353-1413">Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> устанавливает удаленный узел по умолчанию, заданный параметрами `socketType` и `protocolType`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1413">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.</span></span>  
  
 <span data-ttu-id="f6353-1414">Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик события EventHandler\<SocketAsyncEventArgs > делегат и присоединить обратный вызов к событию <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1414">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="f6353-1415">Вызывающий объект должен задать свойству <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> <xref:System.Net.IPEndPoint> удаленного узла для подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1415">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="f6353-1416">Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, чтобы информация была извлечена в методе обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-1416">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="f6353-1417">Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1417">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="f6353-1418">Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.ConnectAsync%2A> перед отправкой и получением данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-1418">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="f6353-1419">Для взаимодействия с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.SendToAsync%2A> и <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1419">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="f6353-1420">При вызове <xref:System.Net.Sockets.Socket.ConnectAsync%2A>все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут удалены.</span><span class="sxs-lookup"><span data-stu-id="f6353-1420">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="f6353-1421">Если вы хотите изменить удаленный узел по умолчанию, вызовите метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> еще раз, указав нужную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-1421">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="f6353-1422">Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, сначала необходимо вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и настроить вещание на `true`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1422">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="f6353-1423">Если это не сделано, метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1423">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-1424">Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> являются обязательными:</span><span class="sxs-lookup"><span data-stu-id="f6353-1424">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="f6353-1425">При необходимости можно указать буфер, который будет атомарно отправлен на сокет после того, как метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> завершится с ошибкой.</span><span class="sxs-lookup"><span data-stu-id="f6353-1425">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="f6353-1426">В этом случае свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> должно быть установлено в буфер, содержащий данные для отправки, а свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> должно иметь значение, равное числу байтов данных, отправляемых из буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-1426">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="f6353-1427">После установления соединения отправляется этот буфер данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-1427">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="f6353-1428">Если вы используете протокол, ориентированный на подключение, и не вызываете <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, базовый поставщик услуг присвоит наиболее подходящий локальный сетевой адрес и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1428">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="f6353-1429">Если используется протокол без подключения, поставщик услуг не будет назначать IP-адрес и номер порта локальной сети, пока не будут вызваны методы <xref:System.Net.Sockets.Socket.SendAsync%2A> или <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1429">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="f6353-1430">Метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> вызывает исключение <xref:System.NotSupportedException>, если семейство адресов <xref:System.Net.Sockets.Socket> и <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> не совпадают с семейством адресов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1430">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1431">При получении <xref:System.Net.Sockets.SocketException> при вызове этого метода используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1431">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1432">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1432">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1433">Аргумент является недопустимым.</span><span class="sxs-lookup"><span data-stu-id="f6353-1433">An argument is not valid.</span></span> <span data-ttu-id="f6353-1434">Это исключение возникает, если задано несколько буферов, свойство <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> не имеет значение "null".</span><span class="sxs-lookup"><span data-stu-id="f6353-1434">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1435">Параметр <paramref name="e" /> и <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не могут иметь значение NULL.</span><span class="sxs-lookup"><span data-stu-id="f6353-1435">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1436"><see cref="T:System.Net.Sockets.Socket" /> ведет прослушивание или работа с сокетом уже выполняется с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного параметром <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1436">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1437">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1437">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1438">Этот метод доступен только в Windows XP и более поздних версиях.</span><span class="sxs-lookup"><span data-stu-id="f6353-1438">Windows XP or later is required for this method.</span></span> <span data-ttu-id="f6353-1439">Это исключение возникает также в том случае, если локальная конечная точка и объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не принадлежат к одному семейству адресов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1439">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1440"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1440">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-1441">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</span><span class="sxs-lookup"><span data-stu-id="f6353-1441">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-1442">Получает значение, указывающее, подключается ли объект <see cref="T:System.Net.Sockets.Socket" /> к удаленному узлу в результате последней операции <see cref="Overload:System.Net.Sockets.Socket.Send" /> или <see cref="Overload:System.Net.Sockets.Socket.Receive" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1442">Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="Overload:System.Net.Sockets.Socket.Send" /> or <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operation.</span></span></summary>
        <value><span data-ttu-id="f6353-1443">Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> в результате последней операции был подключен к удаленному ресурсу; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1443"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> was connected to a remote resource as of the most recent operation; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1444">Свойство `Connected` возвращает состояние соединения <xref:System.Net.Sockets.Socket> на последней операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="f6353-1444">The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation.</span></span> <span data-ttu-id="f6353-1445">Когда он возвращает `false`, <xref:System.Net.Sockets.Socket> не был подключен или больше не подключен.</span><span class="sxs-lookup"><span data-stu-id="f6353-1445">When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.</span></span>  
  
 <span data-ttu-id="f6353-1446">Значение свойства <xref:System.Net.Sockets.Socket.Connected%2A> отражает состояние соединения в последней операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1446">The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation.</span></span> <span data-ttu-id="f6353-1447">Если необходимо определить текущее состояние соединения, сделайте неблокирующий вызов send с нулевым байтом.</span><span class="sxs-lookup"><span data-stu-id="f6353-1447">If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</span></span> <span data-ttu-id="f6353-1448">Если вызов завершается успешно или вызывается код ошибки ВАЕВАУЛДБЛОКК (10035), сокет все еще подключен; в противном случае сокет больше не будет подключен.</span><span class="sxs-lookup"><span data-stu-id="f6353-1448">If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</span></span>  
  
 <span data-ttu-id="f6353-1449">При вызове <xref:System.Net.Sockets.Socket.Connect%2A> для сокета UDP, свойство <xref:System.Net.Sockets.Socket.Connected%2A> всегда возвращает `true`; Однако это действие не изменяет характер протокола UDP без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1449">If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1450">Следующий пример кода подключается к удаленной конечной точке, проверяет свойство <xref:System.Net.Sockets.Socket.Connected%2A> и проверяет текущее состояние соединения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1450">The following code example connects to a remote endpoint, checks the <xref:System.Net.Sockets.Socket.Connected%2A> property, and checks the current state of the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><span data-ttu-id="f6353-1451">Значение <see langword="true" />, если этот сокет может быть повторно использован после закрытия текущего подключения; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1451"><see langword="true" /> if this socket can be reused after the current connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="f6353-1452">Закрывает подключение к сокету и позволяет повторно его использовать.</span><span class="sxs-lookup"><span data-stu-id="f6353-1452">Closes the socket connection and allows reuse of the socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1453">При использовании протокола, ориентированного на подключение, этот метод можно использовать для закрытия сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-1453">If you are using a connection-oriented protocol, you can use this method to close the socket.</span></span> <span data-ttu-id="f6353-1454">Этот метод завершает соединение и задает для свойства <xref:System.Net.Sockets.Socket.Connected%2A> значение `false`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1454">This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`.</span></span> <span data-ttu-id="f6353-1455">Однако если `reuseSocket` `true`, можно повторно использовать сокет.</span><span class="sxs-lookup"><span data-stu-id="f6353-1455">However, if `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="f6353-1456">Чтобы обеспечить отправку и получение всех данных перед закрытием сокета, следует вызвать метод <xref:System.Net.Sockets.Socket.Shutdown%2A> перед вызовом метода <xref:System.Net.Sockets.Socket.Disconnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1456">To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-1457">Если необходимо вызвать <xref:System.Net.Sockets.Socket.Disconnect%2A> без первого вызова <xref:System.Net.Sockets.Socket.Shutdown%2A>, можно установить параметр <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket>, чтобы `false`, и указать ненулевой интервал времени ожидания, чтобы гарантировать отправку данных, поставленных в очередь для исходящей передачи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1457">If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</span></span> <span data-ttu-id="f6353-1458"><xref:System.Net.Sockets.Socket.Disconnect%2A> затем блокируется до тех пор, пока данные не будут отправлены или пока не истечет указанное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-1458"><xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="f6353-1459">Если для <xref:System.Net.Sockets.SocketOptionName.DontLinger> задано значение `false` и задан интервал нулевого времени ожидания, то <xref:System.Net.Sockets.Socket.Close%2A> освобождает соединение и автоматически удаляет исходящие данные из очереди.</span><span class="sxs-lookup"><span data-stu-id="f6353-1459">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1460">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1460">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1461">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1461">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1462">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1462">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1463">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1463">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1464">В следующем примере кода создается сокет для синхронного взаимодействия и отправляются некоторые данные на удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-1464">The following code example creates a socket for synchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="f6353-1465">Затем он вызывает <xref:System.Net.Sockets.Socket.Shutdown%2A>, чтобы завершить действие Send и Receive, и <xref:System.Net.Sockets.Socket.Disconnect%2A>, чтобы закрыть подключение к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1465">It then calls <xref:System.Net.Sockets.Socket.Shutdown%2A>, to stop the send and receive activity, and <xref:System.Net.Sockets.Socket.Disconnect%2A>, to close the socket connection.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="f6353-1466">Для этого метода необходима операционная система Windows 2000 или более ранняя версия или будет создано исключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1466">This method requires Windows 2000 or earlier, or the exception will be thrown.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1467">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1467">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1468">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1468">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f6353-1469">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-1469">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="f6353-1470">Начинает выполнение асинхронного запроса для отключения от удаленной конечной точки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1470">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="f6353-1471"><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-1471"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="f6353-1472">По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1472">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="f6353-1473"><see langword="false" />, если операция ввода-вывода завершена синхронно.</span><span class="sxs-lookup"><span data-stu-id="f6353-1473"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="f6353-1474">В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1474">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1475">При использовании протокола, ориентированного на соединение, вызов метода <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> запрашивает отключение от удаленной конечной точки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1475">When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint.</span></span> <span data-ttu-id="f6353-1476">Если для параметра <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> задано значение `true` в параметре `e`, сокет можно использовать повторно.</span><span class="sxs-lookup"><span data-stu-id="f6353-1476">If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> to `true` in the `e` parameter, the socket can be reused.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1477">Параметр <paramref name="e" /> не может иметь значение null.</span><span class="sxs-lookup"><span data-stu-id="f6353-1477">The <paramref name="e" /> parameter cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1478">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1478">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1479">Этот метод доступен только в Windows XP и более поздних версиях.</span><span class="sxs-lookup"><span data-stu-id="f6353-1479">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1480"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1480">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1481">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1481">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-1482">Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1482">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6353-1483">Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1483">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1484">Вызовите метод `Dispose` по окончании использования класса <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1484">Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-1485">Метод `Dispose` оставляет класс <xref:System.Net.Sockets.Socket> в непригодном для использования состоянии.</span><span class="sxs-lookup"><span data-stu-id="f6353-1485">The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="f6353-1486">После вызова метода `Dispose` необходимо освободить все ссылки на объект <xref:System.Net.Sockets.Socket>, чтобы сборщик мусора мог освободить память, занимаемую объектом <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1486">After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span>  
  
 <span data-ttu-id="f6353-1487">Дополнительные сведения см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1487">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1488">Всегда вызывайте метод `Dispose` перед освобождением последней ссылки на класс <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1488">Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-1489">В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Net.Sockets.Socket> метод `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1489">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="f6353-1490">Значение <see langword="true" /> для освобождения управляемых и неуправляемых ресурсов; значение <see langword="false" /> для освобождения только неуправляемых ресурсов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1490"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="f6353-1491">Освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.Net.Sockets.Socket" />, и при необходимости освобождает также управляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="f6353-1491">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.Socket" />, and optionally disposes of the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1492">Этот метод вызывается методом Public `Dispose()` и методом <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1492">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="f6353-1493">`Dispose()` вызывает защищенный метод `Dispose(Boolean)` с параметром `disposing`, для которого задано значение `true`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1493">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="f6353-1494"><xref:System.Object.Finalize%2A> вызывает `Dispose`, для `disposing` задано значение `false`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1494"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="f6353-1495">Если параметр `disposing` имеет значение `true`, то данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, на которые ссылается этот объект <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1495">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references.</span></span> <span data-ttu-id="f6353-1496">Этот метод вызывает метод `Dispose()` каждого объекта, на который есть ссылка.</span><span class="sxs-lookup"><span data-stu-id="f6353-1496">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1497">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1497">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1498">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1498">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="f6353-1499">Метод 
            <see langword="Dispose" /> может вызываться несколько раз другими объектами.</span><span class="sxs-lookup"><span data-stu-id="f6353-1499">
            <see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="f6353-1500">При переопределении метода <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами метода <see langword="Dispose" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1500">When overriding <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="f6353-1501">Дополнительные сведения о реализации <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />см. в разделе [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1501">For more information about how to implement <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="f6353-1502">Дополнительные сведения о <see langword="Dispose" /> и <see cref="M:System.Object.Finalize" />см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Переопределение метода Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="f6353-1502">For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-1503">Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, разрешает ли объект <see cref="T:System.Net.Sockets.Socket" /> выполнение фрагментации датаграмм протокола IP.</span><span class="sxs-lookup"><span data-stu-id="f6353-1503">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows Internet Protocol (IP) datagrams to be fragmented.</span></span></summary>
        <value><span data-ttu-id="f6353-1504">Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> разрешает фрагментацию датаграмм; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1504"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows datagram fragmentation; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f6353-1505">Значение по умолчанию — <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1505">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1506">Для датаграмм требуется фрагментация, если их размер превышает максимальную единицу передачи (MTU) носителя передачи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1506">Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</span></span> <span data-ttu-id="f6353-1507">Датаграммы могут быть фрагментированы отправляющим узлом (все версии протокола IP) или промежуточным маршрутизатором (только для протокола IP версии 4).</span><span class="sxs-lookup"><span data-stu-id="f6353-1507">Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</span></span> <span data-ttu-id="f6353-1508">Если датаграмма должна быть фрагментирована, а параметр <xref:System.Net.Sockets.Socket.DontFragment%2A> установлен, датаграмма отбрасывается, а сообщение об ошибке протокола ICMP отправляется обратно отправителю датаграммы.</span><span class="sxs-lookup"><span data-stu-id="f6353-1508">If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</span></span>  
  
 <span data-ttu-id="f6353-1509">Установка этого свойства для сокета протокола TCP не будет действовать.</span><span class="sxs-lookup"><span data-stu-id="f6353-1509">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1510">В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.DontFragment%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="f6353-1510">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.DontFragment%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1511">Это свойство может быть установлено только для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1511">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1512">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1512">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1513"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1513">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-1514">Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, является ли <see cref="T:System.Net.Sockets.Socket" /> сокетом с двойным режимом, используемым для IPv4 и IPv6.</span><span class="sxs-lookup"><span data-stu-id="f6353-1514">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> is a dual-mode socket used for both IPv4 and IPv6.</span></span></summary>
        <value><span data-ttu-id="f6353-1515">Значение <see langword="true" />, если <see cref="T:System.Net.Sockets.Socket" /> — сокет с двойным режимом. В противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1515"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is a  dual-mode socket; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f6353-1516">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1516">The default is <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetProcessId"><span data-ttu-id="f6353-1517">Идентификатор конечного процесса, в котором создается дубликат ссылки сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-1517">The ID of the target process where a duplicate of the socket reference is created.</span></span></param>
        <summary><span data-ttu-id="f6353-1518">Дублирует ссылку сокета для конечного процесса и закрывает сокет для этого процесса.</span><span class="sxs-lookup"><span data-stu-id="f6353-1518">Duplicates the socket reference for the target process, and closes the socket for this process.</span></span></summary>
        <returns><span data-ttu-id="f6353-1519">Ссылка сокета, передаваемая в конечный процесс.</span><span class="sxs-lookup"><span data-stu-id="f6353-1519">The socket reference to be passed to the target process.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1520">Для создания повторяющегося экземпляра сокета целевой процесс должен использовать <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1520">The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.</span></span>  
  
 <span data-ttu-id="f6353-1521">Если вы вызываете конструктор <xref:System.Net.Sockets.Socket.%23ctor%2A> несколько раз с тем же массивом байтов, что и аргумент для каждого вызова, вы создадите несколько управляемых экземпляров <xref:System.Net.Sockets.Socket> с одним и тем же базовым сокетом.</span><span class="sxs-lookup"><span data-stu-id="f6353-1521">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket.</span></span> <span data-ttu-id="f6353-1522">Этот подход настоятельно не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="f6353-1522">This practice is strongly discouraged.</span></span>  
  
 <span data-ttu-id="f6353-1523">Если процесс создания сокета использует асинхронные методы (<xref:System.Net.Sockets.Socket.BeginReceive%2A> или <xref:System.Net.Sockets.Socket.BeginSend%2A>), процесс должен сначала установить свойство <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> в значение true. в противном случае сокет привязывается к порту завершения процесса создания, что может привести к возникновению <xref:System.ArgumentNullException> в целевом процессе.</span><span class="sxs-lookup"><span data-stu-id="f6353-1523">If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1524">Параметр <paramref name="targetProcessID" /> не является допустимым идентификатором процесса.</span><span class="sxs-lookup"><span data-stu-id="f6353-1524"><paramref name="targetProcessID" /> is not a valid process id.</span></span> 
<span data-ttu-id="f6353-1525">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-1525">-or-</span></span> 
<span data-ttu-id="f6353-1526">Дубликат ссылки сокета не создан.</span><span class="sxs-lookup"><span data-stu-id="f6353-1526">Duplication of the socket reference failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-1527">Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, может ли объект <see cref="T:System.Net.Sockets.Socket" /> производить отправку или прием широковещательных пакетов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1527">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> can send or receive broadcast packets.</span></span></summary>
        <value><span data-ttu-id="f6353-1528">Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> разрешает использование широковещательных пакетов; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1528"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows broadcast packets; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f6353-1529">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1529">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1530">Широковещательная рассылка ограничена определенной подсетью и должна использовать протокол UDP. Для протокола IP версии 4 можно выполнить широковещательную рассылку в локальную подсеть, отправив пакет в 255.255.255.255; также можно использовать направленный широковещательный адрес, который представляет собой сетевую часть IP-адреса со всеми битами, заданными в части узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1530">Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</span></span> <span data-ttu-id="f6353-1531">Например, если IP-адрес — 192.168.1.40 (адрес класса C, маска 255.255.255.0--, часть сети — первые три октета, а часть узла — последний октет), направленный широковещательный адрес 192.168.1.255.</span><span class="sxs-lookup"><span data-stu-id="f6353-1531">For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</span></span>  
  
 <span data-ttu-id="f6353-1532">Установка этого свойства для сокета протокола TCP не будет действовать.</span><span class="sxs-lookup"><span data-stu-id="f6353-1532">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1533">В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="f6353-1533">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1534">Эта функция применима только для сокета датаграмм.</span><span class="sxs-lookup"><span data-stu-id="f6353-1534">This option is valid for a datagram socket only.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1535"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1535">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-1536">Асинхронно принимает попытку входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1536">Asynchronously accepts an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-1537">Массив типа <see cref="T:System.Byte" />, который содержит переданные байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-1537">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="f6353-1538">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии для этой асинхронной операции, а также любые данные, определенные пользователем.</span><span class="sxs-lookup"><span data-stu-id="f6353-1538">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="f6353-1539">Асинхронно принимает входящие попытки подключения и создает новый объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</span><span class="sxs-lookup"><span data-stu-id="f6353-1539">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="f6353-1540">Этот метод возвращает буфер, который содержит начальные данные для передачи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1540">This method returns a buffer that contains the initial data transferred.</span></span></summary>
        <returns><span data-ttu-id="f6353-1541">Объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</span><span class="sxs-lookup"><span data-stu-id="f6353-1541">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1542"><xref:System.Net.Sockets.Socket.EndAccept%2A> завершает вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1542"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="f6353-1543">Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A>необходимо создать метод обратного вызова, который вызывается делегатом <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1543">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="f6353-1544">Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> возвращает.</span><span class="sxs-lookup"><span data-stu-id="f6353-1544">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span>  
  
 <span data-ttu-id="f6353-1545">В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра `asyncResult`, чтобы получить <xref:System.Net.Sockets.Socket>, на который устанавливается попытка подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1545">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="f6353-1546">После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndAccept%2A> для успешного завершения попытки подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1546">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="f6353-1547">Параметр `buffer` этой перегрузки содержит данные, полученные при вызове функции <xref:System.Net.Sockets.Socket.BeginAccept%2A>, а параметр `bytesTransferred` содержит число байтов, переданных в вызове.</span><span class="sxs-lookup"><span data-stu-id="f6353-1547">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="f6353-1548">Метод <xref:System.Net.Sockets.Socket.EndAccept%2A> блокируется до тех пор, пока не будет ожидание подключения в очереди входящих подключений.</span><span class="sxs-lookup"><span data-stu-id="f6353-1548">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="f6353-1549">Метод <xref:System.Net.Sockets.Socket.EndAccept%2A> принимает входящее подключение и возвращает новый <xref:System.Net.Sockets.Socket>, который можно использовать для отправки и получения данных с удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1549">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1550">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1550">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1551">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1551">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1552">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1552">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1553">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1553">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1554">В следующем примере кода используется <xref:System.Net.Sockets.Socket.BeginAccept%2A>, чтобы создать и подключить сокет и принять начальные 10 байт данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-1554">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="f6353-1555">Делегат обратного вызова вызывает <xref:System.Net.Sockets.Socket.EndAccept%2A> для завершения асинхронного запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-1555">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="f6353-1556">Число переданных байтов и данные возвращаются в `buffer` и `bytesTransferred` параметров этого метода и отображаются в консоли.</span><span class="sxs-lookup"><span data-stu-id="f6353-1556">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1557">Этот метод доступен только в Windows NT.</span><span class="sxs-lookup"><span data-stu-id="f6353-1557">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1558">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1558">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1559">Параметр <paramref name="asyncResult" /> пуст.</span><span class="sxs-lookup"><span data-stu-id="f6353-1559"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1560">Параметр <paramref name="asyncResult" /> не был создан вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1560"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1561">Ранее был вызван метод <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1561"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1562">Произошла ошибка при попытке доступа к объекту <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1562">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="f6353-1563">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии для этой асинхронной операции, а также любые данные, определенные пользователем.</span><span class="sxs-lookup"><span data-stu-id="f6353-1563">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <param name="result"><span data-ttu-id="f6353-1564">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии для этой асинхронной операции, а также любые данные, определенные пользователем.</span><span class="sxs-lookup"><span data-stu-id="f6353-1564">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="f6353-1565">Асинхронно принимает входящие попытки подключения и создает новый объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</span><span class="sxs-lookup"><span data-stu-id="f6353-1565">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</span></span></summary>
        <returns><span data-ttu-id="f6353-1566">Объект<see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</span><span class="sxs-lookup"><span data-stu-id="f6353-1566">A <see cref="T:System.Net.Sockets.Socket" /> to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1567"><xref:System.Net.Sockets.Socket.EndAccept%2A> завершает вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1567"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="f6353-1568">Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1568">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="f6353-1569">Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> возвращает.</span><span class="sxs-lookup"><span data-stu-id="f6353-1569">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="f6353-1570">Он должен принять параметр `asyncResult`, возвращенный методом <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1570">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-1571">В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра `asyncResult`, чтобы получить <xref:System.Net.Sockets.Socket>, на который устанавливается попытка подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1571">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="f6353-1572">После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndAccept%2A> для успешного завершения попытки подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1572">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span>  
  
 <span data-ttu-id="f6353-1573">Метод <xref:System.Net.Sockets.Socket.EndAccept%2A> блокируется до тех пор, пока не будет ожидание подключения в очереди входящих подключений.</span><span class="sxs-lookup"><span data-stu-id="f6353-1573">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="f6353-1574">Метод <xref:System.Net.Sockets.Socket.EndAccept%2A> принимает входящее подключение и возвращает новый <xref:System.Net.Sockets.Socket>, который можно использовать для отправки и получения данных с удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1574">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1575">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1575">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1576">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1576">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1577">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1577">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1578">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1578">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1579">В следующем примере кода завершается асинхронный запрос и создается новый <xref:System.Net.Sockets.Socket> для принятия входящего запроса на подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1579">The following code example ends an asynchronous request and creates a new <xref:System.Net.Sockets.Socket> to accept an incoming connection request.</span></span> <span data-ttu-id="f6353-1580">Полный пример, демонстрирующий асинхронную связь с сокетами, см. в статье [примеры кода для сокетов](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1580">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1581">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1581"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1582">Параметр <paramref name="asyncResult" /> не был создан вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1582"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1583">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1583">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="f6353-1584">Дополнительные сведения см. в разделе "Примечания".</span><span class="sxs-lookup"><span data-stu-id="f6353-1584">See the Remarks section for more information.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1585"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1585">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1586">Ранее был вызван метод <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1586"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1587">Этот метод доступен только в Windows NT.</span><span class="sxs-lookup"><span data-stu-id="f6353-1587">Windows NT is required for this method.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * int * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-1588">Массив типа <see cref="T:System.Byte" />, который содержит переданные байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-1588">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="bytesTransferred"><span data-ttu-id="f6353-1589">Количество переданных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1589">The number of bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="f6353-1590">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии для этой асинхронной операции, а также любые данные, определенные пользователем.</span><span class="sxs-lookup"><span data-stu-id="f6353-1590">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="f6353-1591">Асинхронно принимает входящие попытки подключения и создает новый объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</span><span class="sxs-lookup"><span data-stu-id="f6353-1591">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="f6353-1592">Этот метод возвращает буфер, который содержит начальные данные и число переданных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1592">This method returns a buffer that contains the initial data and the number of bytes transferred.</span></span></summary>
        <returns><span data-ttu-id="f6353-1593">Объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</span><span class="sxs-lookup"><span data-stu-id="f6353-1593">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1594"><xref:System.Net.Sockets.Socket.EndAccept%2A> завершает вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1594"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="f6353-1595">Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A>необходимо создать метод обратного вызова, который вызывается делегатом <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1595">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="f6353-1596">Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> возвращает.</span><span class="sxs-lookup"><span data-stu-id="f6353-1596">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="f6353-1597">Он должен принять параметр `asyncResult`, возвращенный методом <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1597">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-1598">В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра `asyncResult`, чтобы получить <xref:System.Net.Sockets.Socket>, на который устанавливается попытка подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1598">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="f6353-1599">После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndAccept%2A> для успешного завершения попытки подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1599">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="f6353-1600">Параметр `buffer` этой перегрузки содержит данные, полученные при вызове функции <xref:System.Net.Sockets.Socket.BeginAccept%2A>, а параметр `bytesTransferred` содержит число байтов, переданных в вызове.</span><span class="sxs-lookup"><span data-stu-id="f6353-1600">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="f6353-1601">Метод <xref:System.Net.Sockets.Socket.EndAccept%2A> блокируется до тех пор, пока не будет ожидание подключения в очереди входящих подключений.</span><span class="sxs-lookup"><span data-stu-id="f6353-1601">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="f6353-1602">Метод <xref:System.Net.Sockets.Socket.EndAccept%2A> принимает входящее подключение и возвращает новый <xref:System.Net.Sockets.Socket>, который можно использовать для отправки и получения данных с удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1602">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1603">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1603">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1604">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1604">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1605">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1605">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1606">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1606">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1607">В следующем примере кода используется <xref:System.Net.Sockets.Socket.BeginAccept%2A>, чтобы создать и подключить сокет и принять начальные 10 байт данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-1607">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="f6353-1608">Делегат обратного вызова вызывает <xref:System.Net.Sockets.Socket.EndAccept%2A> для завершения асинхронного запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-1608">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="f6353-1609">Число переданных байтов и данные возвращаются в `buffer` и `bytesTransferred` параметров этого метода и отображаются в консоли.</span><span class="sxs-lookup"><span data-stu-id="f6353-1609">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1610">Этот метод доступен только в Windows NT.</span><span class="sxs-lookup"><span data-stu-id="f6353-1610">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1611">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1611">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1612">Параметр <paramref name="asyncResult" /> пуст.</span><span class="sxs-lookup"><span data-stu-id="f6353-1612"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1613">Параметр <paramref name="asyncResult" /> не был создан вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1613"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1614">Ранее был вызван метод <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1614"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1615">Произошла ошибка при попытке доступа к объекту <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1615">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="f6353-1616">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1616">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="f6353-1617">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1617">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="f6353-1618">Завершает ожидающий асинхронный запрос на подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1618">Ends a pending asynchronous connection request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1619"><xref:System.Net.Sockets.Socket.EndConnect%2A> — это блокирующий метод, который завершает асинхронный запрос на подключение к удаленному узлу, запущенный в методе <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1619"><xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-1620">Перед вызовом <xref:System.Net.Sockets.Socket.BeginConnect%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1620">Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="f6353-1621">Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginConnect%2A> возвращает.</span><span class="sxs-lookup"><span data-stu-id="f6353-1621">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns.</span></span> <span data-ttu-id="f6353-1622">Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginConnect%2A> в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-1622">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="f6353-1623">В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра <xref:System.IAsyncResult>, чтобы получить <xref:System.Net.Sockets.Socket>, на который устанавливается попытка подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1623">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="f6353-1624">После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndConnect%2A> для успешного завершения попытки подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1624">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1625">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1625">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1626">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1626">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1627">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1627">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1628">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1628">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1629">В следующем примере кода завершается асинхронная попытки подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1629">The following code example ends the asynchronous connection attempt.</span></span> <span data-ttu-id="f6353-1630">Полный пример, демонстрирующий асинхронную связь с сокетами, см. в статье [примеры кода для сокетов](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1630">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1631">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1631"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1632">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1632"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1633">Метод <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> был ранее вызван для асинхронного подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1633"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1634">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1634">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1635"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1635">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="f6353-1636">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1636">An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="f6353-1637">Завершает ожидающий асинхронный запрос на разъединение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1637">Ends a pending asynchronous disconnect request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1638"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> завершает вызов <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1638"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span></span> <span data-ttu-id="f6353-1639">Метод <xref:System.Net.Sockets.Socket.EndDisconnect%2A> блокируется до завершения отключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1639">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes.</span></span> <span data-ttu-id="f6353-1640">Дополнительные сведения об асинхронных операциях см. в разделе Общие сведения о асинхронном программировании в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="f6353-1640">For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1641">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1641">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1642">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1642">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1643">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1643">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1644">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1644">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1645">В следующем примере кода создается сокет для асинхронного взаимодействия и данные отправляются на удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-1645">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="f6353-1646">После отправки данных вызывается <xref:System.Net.Sockets.Socket.Shutdown%2A> для отмены действия Send и Receive.</span><span class="sxs-lookup"><span data-stu-id="f6353-1646">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="f6353-1647">Затем вызывается <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> для начала запроса на отключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1647">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="f6353-1648">Делегат обратного вызова вызывает <xref:System.Net.Sockets.Socket.EndDisconnect%2A> для завершения асинхронного запроса.</span><span class="sxs-lookup"><span data-stu-id="f6353-1648">The callback delegate calls <xref:System.Net.Sockets.Socket.EndDisconnect%2A> to end the asynchronous request.</span></span> <span data-ttu-id="f6353-1649">По завершении запроса свойство <xref:System.Net.Sockets.Socket.Connected%2A> запрашивается, чтобы проверить, отключен ли сокет.</span><span class="sxs-lookup"><span data-stu-id="f6353-1649">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1650">Используется операционная система Windows 2000 или более ранняя версия, а для этого метода необходима операционная система Windows XP.</span><span class="sxs-lookup"><span data-stu-id="f6353-1650">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1651">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1651">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1652">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1652"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1653">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1653"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1654">Метод <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> был ранее вызван для асинхронного подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1654"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1655">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1655">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.Net.WebException"><span data-ttu-id="f6353-1656">Истекло время ожидания для запроса на разъединение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1656">The disconnect request has timed out.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-1657">Завершает отложенное асинхронное чтение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1657">Ends a pending asynchronous read.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="f6353-1658">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1658">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="f6353-1659">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1659">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="f6353-1660">Завершает отложенное асинхронное чтение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1660">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="f6353-1661">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1661">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1662">Метод <xref:System.Net.Sockets.Socket.EndReceive%2A> завершает операцию асинхронного чтения, запущенную в методе <xref:System.Net.Sockets.Socket.BeginReceive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1662">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-1663">Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceive%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1663">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="f6353-1664">Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginReceive%2A> возвращает.</span><span class="sxs-lookup"><span data-stu-id="f6353-1664">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="f6353-1665">Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginReceive%2A> в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-1665">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="f6353-1666">В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>, чтобы получить объект состояния, переданный методу <xref:System.Net.Sockets.Socket.BeginReceive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1666">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="f6353-1667">Извлеките <xref:System.Net.Sockets.Socket> получения из этого объекта состояния.</span><span class="sxs-lookup"><span data-stu-id="f6353-1667">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="f6353-1668">После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndReceive%2A> для успешного завершения операции чтения и возврата числа считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1668">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="f6353-1669">Метод <xref:System.Net.Sockets.Socket.EndReceive%2A> будет блокироваться до тех пор, пока данные недоступны.</span><span class="sxs-lookup"><span data-stu-id="f6353-1669">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="f6353-1670">Если используется протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndReceive%2A> прочитает первую поставленную в очередь датаграмму, доступную во входящем сетевом буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-1670">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="f6353-1671">При использовании протокола, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.EndReceive%2A> будет считывать столько данных, сколько доступно до числа байтов, указанных в параметре `size` метода <xref:System.Net.Sockets.Socket.BeginReceive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1671">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="f6353-1672">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.EndReceive%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-1672">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="f6353-1673">Чтобы получить полученные данные, вызовите метод <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>и извлеките буфер, содержащийся в результирующем объекте состояния.</span><span class="sxs-lookup"><span data-stu-id="f6353-1673">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
 <span data-ttu-id="f6353-1674">Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1674">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1675">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1675">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1676">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1676">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1677">Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока.</span><span class="sxs-lookup"><span data-stu-id="f6353-1677">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="f6353-1678">Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1678">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1679">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1679">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1680">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1680">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1681">В следующем примере кода завершается ожидание асинхронного чтения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1681">The following code example ends a pending asynchronous read.</span></span> <span data-ttu-id="f6353-1682">Полный пример, демонстрирующий асинхронную связь с сокетами, см. в статье [примеры кода для сокетов](~/docs/framework/network-programming/socket-code-examples.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1682">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1683">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1683"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1684">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1684"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1685">Метод <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> был ранее вызван для асинхронного чтения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1685"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1686">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1686">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1687"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1687">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult * SocketError -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="f6353-1688">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1688">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="f6353-1689">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-1689">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="f6353-1690">Завершает отложенное асинхронное чтение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1690">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="f6353-1691">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1691">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1692">Метод <xref:System.Net.Sockets.Socket.EndReceive%2A> завершает операцию асинхронного чтения, запущенную в методе <xref:System.Net.Sockets.Socket.BeginReceive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1692">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-1693">Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceive%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1693">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="f6353-1694">Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginReceive%2A> возвращает.</span><span class="sxs-lookup"><span data-stu-id="f6353-1694">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="f6353-1695">Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginReceive%2A> в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-1695">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="f6353-1696">В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>, чтобы получить объект состояния, переданный методу <xref:System.Net.Sockets.Socket.BeginReceive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1696">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="f6353-1697">Извлеките <xref:System.Net.Sockets.Socket> получения из этого объекта состояния.</span><span class="sxs-lookup"><span data-stu-id="f6353-1697">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="f6353-1698">После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndReceive%2A> для успешного завершения операции чтения и возврата числа считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1698">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="f6353-1699">Метод <xref:System.Net.Sockets.Socket.EndReceive%2A> будет блокироваться до тех пор, пока данные недоступны.</span><span class="sxs-lookup"><span data-stu-id="f6353-1699">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="f6353-1700">Если используется протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndReceive%2A> прочитает первую поставленную в очередь датаграмму, доступную во входящем сетевом буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-1700">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="f6353-1701">При использовании протокола, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.EndReceive%2A> будет считывать столько данных, сколько доступно до числа байтов, указанных в параметре `size` метода <xref:System.Net.Sockets.Socket.BeginReceive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1701">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="f6353-1702">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.EndReceive%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-1702">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="f6353-1703">Чтобы получить полученные данные, вызовите метод <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>и извлеките буфер, содержащийся в результирующем объекте состояния.</span><span class="sxs-lookup"><span data-stu-id="f6353-1703">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1704">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1704">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1705">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1705">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1706">Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока.</span><span class="sxs-lookup"><span data-stu-id="f6353-1706">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="f6353-1707">Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1707">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1708">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1708">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1709">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1709">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1710">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1710"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1711">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1711"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1712">Метод <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> был ранее вызван для асинхронного чтения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1712"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1713">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1713">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1714"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1714">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (asyncResult, endPoint)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="f6353-1715">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1715">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="f6353-1716">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1716">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="endPoint"><span data-ttu-id="f6353-1717">Источник <see cref="T:System.Net.EndPoint" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1717">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <param name="end_point"><span data-ttu-id="f6353-1718">Источник <see cref="T:System.Net.EndPoint" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1718">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <summary><span data-ttu-id="f6353-1719">Завершает отложенное асинхронное чтение с определенной конечной точки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1719">Ends a pending asynchronous read from a specific endpoint.</span></span></summary>
        <returns><span data-ttu-id="f6353-1720">Количество полученных байтов, если операция успешно выполнена.</span><span class="sxs-lookup"><span data-stu-id="f6353-1720">If successful, the number of bytes received.</span></span> <span data-ttu-id="f6353-1721">Возвращает значение 0, если операция завершилась неудачей.</span><span class="sxs-lookup"><span data-stu-id="f6353-1721">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1722">Метод <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> завершает операцию асинхронного чтения, запущенную в методе <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1722">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-1723">Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1723">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="f6353-1724">Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> возвращает.</span><span class="sxs-lookup"><span data-stu-id="f6353-1724">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns.</span></span> <span data-ttu-id="f6353-1725">Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-1725">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="f6353-1726">В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>, чтобы получить объект состояния, переданный методу <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1726">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-1727">Извлеките <xref:System.Net.Sockets.Socket> получения из этого объекта состояния.</span><span class="sxs-lookup"><span data-stu-id="f6353-1727">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="f6353-1728">После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> для успешного завершения операции чтения и возврата числа считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1728">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="f6353-1729">Метод <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> будет блокироваться до тех пор, пока данные недоступны.</span><span class="sxs-lookup"><span data-stu-id="f6353-1729">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="f6353-1730">Если используется протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> прочитает первую поставленную в очередь датаграмму, доступную во входящем сетевом буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-1730">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="f6353-1731">При использовании протокола, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> будет считывать столько данных, сколько доступно до числа байтов, указанных в параметре `size` метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1731">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-1732">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-1732">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span> <span data-ttu-id="f6353-1733">Чтобы получить полученные данные, вызовите метод <xref:System.IAsyncResult.AsyncState%2A> объекта <xref:System.IAsyncResult> и извлеките буфер, содержащийся в результирующем объекте состояния.</span><span class="sxs-lookup"><span data-stu-id="f6353-1733">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object.</span></span> <span data-ttu-id="f6353-1734">Чтобы найти исходный узел, извлеките <xref:System.Net.EndPoint> и приведите его к <xref:System.Net.IPEndPoint>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1734">To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>.</span></span> <span data-ttu-id="f6353-1735">Используйте метод <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>, чтобы получить IP-адрес и метод <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> для получения номера порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1735">Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to obtain the port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1736">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1736">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1737">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1737">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1738">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1738">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1739">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1739">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1740">В следующем примере кода завершается ожидание асинхронного чтения из определенного <xref:System.Net.EndPoint>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1740">The following code example ends a pending asynchronous read from a specific <xref:System.Net.EndPoint>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1741">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1741"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1742">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1742"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1743">Метод <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> был ранее вызван для асинхронного чтения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1743"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1744">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1744">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1745"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1745">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="f6353-1746">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1746">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-1747">Поразрядное сочетание значений перечисления <see cref="T:System.Net.Sockets.SocketFlags" /> для принятого пакета.</span><span class="sxs-lookup"><span data-stu-id="f6353-1747">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values for the received packet.</span></span></param>
        <param name="endPoint"><span data-ttu-id="f6353-1748">Источник <see cref="T:System.Net.EndPoint" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1748">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="f6353-1749">Объект <see cref="T:System.Net.IPAddress" /> и интерфейс полученного пакета.</span><span class="sxs-lookup"><span data-stu-id="f6353-1749">The <see cref="T:System.Net.IPAddress" /> and interface of the received packet.</span></span></param>
        <summary><span data-ttu-id="f6353-1750">Завершает отложенное асинхронное чтение с определенной конечной точки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1750">Ends a pending asynchronous read from a specific endpoint.</span></span> <span data-ttu-id="f6353-1751">Этот метод также показывает больше информации о пакете, чем метод <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1751">This method also reveals more information about the packet than <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-1752">Количество полученных байтов, если операция успешно выполнена.</span><span class="sxs-lookup"><span data-stu-id="f6353-1752">If successful, the number of bytes received.</span></span> <span data-ttu-id="f6353-1753">Возвращает значение 0, если операция завершилась неудачей.</span><span class="sxs-lookup"><span data-stu-id="f6353-1753">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1754">Если операция не завершена, этот метод блокируется до тех пор, пока он не завершится.</span><span class="sxs-lookup"><span data-stu-id="f6353-1754">If the operation has not completed, this method blocks until it does.</span></span>  
  
 <span data-ttu-id="f6353-1755">Чтобы выполнить эту операцию синхронно, используйте метод <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1755">To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-1756">Изучите `ipPacketInformation`, если необходимо узнать, была ли датаграмма отправлена с помощью одноадресной рассылки, многоадресной рассылки или широковещательной рассылки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1756">Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1757"><paramref name="asyncResult" /> равно <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="f6353-1757"><paramref name="asyncResult" /> is <see langword="null" /></span></span>  
  
<span data-ttu-id="f6353-1758">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-1758">-or-</span></span> 
 <span data-ttu-id="f6353-1759">Свойство <paramref name="endPoint" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1759"><paramref name="endPoint" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1760">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1760"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1761">Метод <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> был ранее вызван для асинхронного чтения.</span><span class="sxs-lookup"><span data-stu-id="f6353-1761"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1762">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1762">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1763"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1763">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-1764">Завершает отложенную операцию асинхронной передачи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1764">Ends a pending asynchronous send.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="f6353-1765">Объект <see cref="T:System.IAsyncResult" />, хранящий сведения о состоянии этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1765">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="f6353-1766">Объект <see cref="T:System.IAsyncResult" />, хранящий сведения о состоянии этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1766">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="f6353-1767">Завершает отложенную операцию асинхронной передачи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1767">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="f6353-1768">Если операция завершилась успешно — значение количества байтов, переданных в объект <see cref="T:System.Net.Sockets.Socket" />; в противном случае — ошибка, указывающая на недопустимость объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1768">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1769"><xref:System.Net.Sockets.Socket.EndSend%2A> завершает операцию асинхронной отправки, запущенную в <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1769"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="f6353-1770">Перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1770">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="f6353-1771">Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginSend%2A> возвращает.</span><span class="sxs-lookup"><span data-stu-id="f6353-1771">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="f6353-1772">Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginSend%2A> в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-1772">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="f6353-1773">В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра <xref:System.IAsyncResult>, чтобы получить <xref:System.Net.Sockets.Socket>отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1773">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-1774">После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndSend%2A> для успешного завершения операции отправки и возврата числа отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1774">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="f6353-1775">Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.EndSend%2A> будет блокироваться до отправки датаграммы.</span><span class="sxs-lookup"><span data-stu-id="f6353-1775">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="f6353-1776">Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.EndSend%2A> будет блокироваться до отправки некоторых буферов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1776">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="f6353-1777">Если возвращаемое значение из <xref:System.Net.Sockets.Socket.EndSend%2A> указывает, что буфер не был полностью отправлен, вызовите метод <xref:System.Net.Sockets.Socket.BeginSend%2A> еще раз, изменив буфер, чтобы вместить неотправленные данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-1777">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="f6353-1778">Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1778">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-1779">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-1779">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-1780">Успешное завершение метода <xref:System.Net.Sockets.Socket.BeginSend%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-1780">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1781">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1781">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1782">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1782">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1783">Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока.</span><span class="sxs-lookup"><span data-stu-id="f6353-1783">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="f6353-1784">Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1784">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1785">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-1785">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-1786">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-1786">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1787">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1787">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1788">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1788">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1789">В следующем примере кода завершается отложенная асинхронная отправка.</span><span class="sxs-lookup"><span data-stu-id="f6353-1789">The following code example ends a pending asynchronous send.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1790">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1790"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1791">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1791"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1792">Метод <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> был ранее вызван для асинхронной передачи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1792"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1793">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1793">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1794"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1794">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult * SocketError -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="f6353-1795">Объект <see cref="T:System.IAsyncResult" />, хранящий сведения о состоянии этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1795">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="f6353-1796">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-1796">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="f6353-1797">Завершает отложенную операцию асинхронной передачи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1797">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="f6353-1798">Если операция завершилась успешно — значение количества байтов, переданных в объект <see cref="T:System.Net.Sockets.Socket" />; в противном случае — ошибка, указывающая на недопустимость объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1798">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1799"><xref:System.Net.Sockets.Socket.EndSend%2A> завершает операцию асинхронной отправки, запущенную в <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1799"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="f6353-1800">Перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1800">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="f6353-1801">Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginSend%2A> возвращает.</span><span class="sxs-lookup"><span data-stu-id="f6353-1801">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="f6353-1802">Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginSend%2A> в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-1802">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="f6353-1803">В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра <xref:System.IAsyncResult>, чтобы получить <xref:System.Net.Sockets.Socket>отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1803">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-1804">После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndSend%2A> для успешного завершения операции отправки и возврата числа отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1804">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="f6353-1805">Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.EndSend%2A> будет блокироваться до отправки датаграммы.</span><span class="sxs-lookup"><span data-stu-id="f6353-1805">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="f6353-1806">Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.EndSend%2A> будет блокироваться до отправки некоторых буферов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1806">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="f6353-1807">Если возвращаемое значение из <xref:System.Net.Sockets.Socket.EndSend%2A> указывает, что буфер не был полностью отправлен, вызовите метод <xref:System.Net.Sockets.Socket.BeginSend%2A> еще раз, изменив буфер, чтобы вместить неотправленные данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-1807">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="f6353-1808">Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1808">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-1809">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-1809">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-1810">Успешное завершение метода <xref:System.Net.Sockets.Socket.BeginSend%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-1810">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1811">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1811">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1812">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1812">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1813">Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока.</span><span class="sxs-lookup"><span data-stu-id="f6353-1813">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="f6353-1814">Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1814">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1815">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-1815">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-1816">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-1816">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1817">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1817">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1818">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1818">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1819">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1819"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1820">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1820"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1821">Метод <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> был ранее вызван для асинхронной передачи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1821"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1822">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1822">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1823"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1823">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="f6353-1824">Объект <see cref="T:System.IAsyncResult" />, хранящий сведения о состоянии этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1824">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="f6353-1825">Завершает отложенную операцию асинхронной передачи файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-1825">Ends a pending asynchronous send of a file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1826"><xref:System.Net.Sockets.Socket.EndSendFile%2A> завершает операцию асинхронной отправки, запущенную в <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1826"><xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span></span>  
  
 <span data-ttu-id="f6353-1827">Перед вызовом <xref:System.Net.Sockets.Socket.BeginSendFile%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1827">Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="f6353-1828">Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginSendFile%2A> возвращает.</span><span class="sxs-lookup"><span data-stu-id="f6353-1828">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns.</span></span> <span data-ttu-id="f6353-1829">Метод обратного вызова должен принимать объект <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginSendFile%2A> в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-1829">The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="f6353-1830">В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра <xref:System.IAsyncResult>, чтобы получить <xref:System.Net.Sockets.Socket>отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1830">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-1831">После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndSendFile%2A> для успешного завершения операции Send.</span><span class="sxs-lookup"><span data-stu-id="f6353-1831">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.</span></span>  
  
 <span data-ttu-id="f6353-1832">Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.EndSendFile%2A> блокируется до отправки датаграммы.</span><span class="sxs-lookup"><span data-stu-id="f6353-1832">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent.</span></span> <span data-ttu-id="f6353-1833">Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.EndSendFile%2A> блокируется до тех пор, пока не будет отправлен весь файл.</span><span class="sxs-lookup"><span data-stu-id="f6353-1833">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="f6353-1834">Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1834">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-1835">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-1835">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-1836">Успешное завершение метода <xref:System.Net.Sockets.Socket.BeginSendFile%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-1836">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1837">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1837">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1838">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1838">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1839">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1839">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1840">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1840">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1841">Следующий пример кода создает и подключает сокет для асинхронного взаимодействия и начинает асинхронно отправлять файл "Text. txt" на удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-1841">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="f6353-1842">Делегат обратного вызова вызывает <xref:System.Net.Sockets.Socket.EndSendFile%2A> для завершения передачи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1842">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-1843">Этот метод доступен только в Windows NT.</span><span class="sxs-lookup"><span data-stu-id="f6353-1843">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1844">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1844">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1845">Параметр <paramref name="asyncResult" /> пуст.</span><span class="sxs-lookup"><span data-stu-id="f6353-1845"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1846">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1846"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1847">Метод <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> был ранее вызван для асинхронной передачи объекта <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1847"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> was previously called for the asynchronous <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1848">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1848">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="f6353-1849">См. ниже примeчания к данному разделу.</span><span class="sxs-lookup"><span data-stu-id="f6353-1849">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="f6353-1850">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1850">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="f6353-1851">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1851">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="f6353-1852">Завершает отложенную операцию асинхронной отправки в определенное местоположение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1852">Ends a pending asynchronous send to a specific location.</span></span></summary>
        <returns><span data-ttu-id="f6353-1853">Если операция завершилась успешно — значение количества отправленных байтов; в противном случае — ошибка, указывающая на недопустимость объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1853">If successful, the number of bytes sent; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1854"><xref:System.Net.Sockets.Socket.EndSendTo%2A> завершает операцию асинхронной отправки, запущенную в <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1854"><xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span>  
  
 <span data-ttu-id="f6353-1855">Перед вызовом <xref:System.Net.Sockets.Socket.BeginSendTo%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1855">Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="f6353-1856">Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginReceive%2A> возвращает.</span><span class="sxs-lookup"><span data-stu-id="f6353-1856">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="f6353-1857">Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginSendTo%2A> в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-1857">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="f6353-1858">В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра <xref:System.IAsyncResult>, чтобы получить <xref:System.Net.Sockets.Socket>отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1858">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-1859">После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndSendTo%2A> для успешного завершения операции отправки и возврата числа отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1859">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="f6353-1860">Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.EndSendTo%2A> будет блокироваться до отправки датаграммы.</span><span class="sxs-lookup"><span data-stu-id="f6353-1860">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="f6353-1861">Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.EndSendTo%2A> будет блокироваться до отправки запрошенного числа байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1861">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="f6353-1862">Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1862">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-1863">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-1863">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-1864">Успешное завершение метода <xref:System.Net.Sockets.Socket.BeginSendTo%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-1864">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1865">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1865">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1866">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1866">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1867">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1867">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1868">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1868">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1869">В следующем примере кода завершается асинхронная отправка в определенное расположение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1869">The following code example ends an asynchronous send to a specific location.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-1870">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1870"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-1871">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1871"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1872">Метод <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> был ранее вызван для асинхронной передачи.</span><span class="sxs-lookup"><span data-stu-id="f6353-1872"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1873">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1873">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1874"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1874">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-1875">Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, разрешает ли объект <see cref="T:System.Net.Sockets.Socket" /> привязку к порту только одного процесса.</span><span class="sxs-lookup"><span data-stu-id="f6353-1875">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows only one process to bind to a port.</span></span></summary>
        <value><span data-ttu-id="f6353-1876">Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> разрешает привязку только одного сокета к определенному порту; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1876"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows only one socket to bind to a specific port; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f6353-1877">Значение по умолчанию — <see langword="true" /> для Windows Server 2003 и Windows XP с пакетом обновления 2, а <see langword="false" /> для всех остальных версий.</span><span class="sxs-lookup"><span data-stu-id="f6353-1877">The default is <see langword="true" /> for Windows Server 2003 and Windows XP Service Pack 2, and <see langword="false" /> for all other versions.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1878">Если <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> `false`, то несколько сокетов могут использовать метод <xref:System.Net.Sockets.Socket.Bind%2A> для привязки к определенному порту; Однако только один из сокетов может выполнять операции с сетевым трафиком, отправляемым на порт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1878">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</span></span> <span data-ttu-id="f6353-1879">Если несколько сокетов пытаются использовать метод <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> для привязки к определенному порту, то один из них с более конкретным IP-адресом будет работать с сетевым трафиком, отправляемым на этот порт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1879">If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</span></span>  
  
 <span data-ttu-id="f6353-1880">Если <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> `true`, то при первом использовании метода <xref:System.Net.Sockets.Socket.Bind%2A> для попытки привязки к определенному порту, независимо от IP-адреса, будет выполнена успешная попытка. все последующие применения метода <xref:System.Net.Sockets.Socket.Bind%2A> для попыток привязки к этому порту завершатся ошибкой, пока не будет разрушен исходный связанный сокет.</span><span class="sxs-lookup"><span data-stu-id="f6353-1880">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed.</span></span>  
  
 <span data-ttu-id="f6353-1881">Это свойство должно быть установлено перед вызовом <xref:System.Net.Sockets.Socket.Bind%2A>; в противном случае будет выдано исключение <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1881">This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1882">В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="f6353-1882">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1883">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1883">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1884"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1884">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1885">Объект <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> вызван для этого объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1885"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> has been called for this <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6353-1886">Освобождает ресурсы, используемые классом <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1886">Frees resources used by the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1887">Финализатор класса <xref:System.Net.Sockets.Socket> вызывает метод <xref:System.Net.Sockets.Socket.Close%2A>, чтобы закрыть <xref:System.Net.Sockets.Socket> и свободные ресурсы, связанные с <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1887">The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6353-1888">Возвращает хэш-значение для экземпляра <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1888">Returns a hash value for a <see cref="T:System.Net.Sockets.Socket" /> instance.</span></span></summary>
        <returns><span data-ttu-id="f6353-1889">Целочисленное хэш-значение.</span><span class="sxs-lookup"><span data-stu-id="f6353-1889">An integer hash value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="f6353-1890">Метод GetHashCode возвращает хэш-код этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="f6353-1890">The GetHashCode method returns a hash code of this instance.</span></span> <span data-ttu-id="f6353-1891">Это значение можно использовать в качестве ключа в хэш-таблицах.</span><span class="sxs-lookup"><span data-stu-id="f6353-1891">This value can be used as a key in hash tables.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-1892">Возвращает значение параметра <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1892">Returns the value of a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="f6353-1893">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1893">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="f6353-1894">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1894">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <summary><span data-ttu-id="f6353-1895">Возвращает значение указанного параметра <see cref="T:System.Net.Sockets.Socket" />, представленного в виде объекта.</span><span class="sxs-lookup"><span data-stu-id="f6353-1895">Returns the value of a specified <see cref="T:System.Net.Sockets.Socket" /> option, represented as an object.</span></span></summary>
        <returns><span data-ttu-id="f6353-1896">Объект, который представляет значение параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-1896">An object that represents the value of the option.</span></span> <span data-ttu-id="f6353-1897">Когда для параметра <paramref name="optionName" /> установлено значение <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />, возвращаемое значение является экземпляром класса <see cref="T:System.Net.Sockets.LingerOption" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1897">When the <paramref name="optionName" /> parameter is set to <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> the return value is an instance of the <see cref="T:System.Net.Sockets.LingerOption" /> class.</span></span> <span data-ttu-id="f6353-1898">Когда для параметра <paramref name="optionName" /> задано значение <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> или <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, возвращаемое значение является экземпляром класса <see cref="T:System.Net.Sockets.MulticastOption" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1898">When <paramref name="optionName" /> is set to <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> or <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, the return value is an instance of the <see cref="T:System.Net.Sockets.MulticastOption" /> class.</span></span> <span data-ttu-id="f6353-1899">Когда для параметра <paramref name="optionName" /> задано любое другое значение, возвращаемое значение является целым числом.</span><span class="sxs-lookup"><span data-stu-id="f6353-1899">When <paramref name="optionName" /> is any other value, the return value is an integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1900">Параметры <xref:System.Net.Sockets.Socket> определяют поведение текущего <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1900"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-1901">Используйте эту перегрузку для получения параметров <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>и <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1901">Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="f6353-1902">Для параметра <xref:System.Net.Sockets.SocketOptionName.Linger> используйте <xref:System.Net.Sockets.Socket> для параметра `optionLevel`.</span><span class="sxs-lookup"><span data-stu-id="f6353-1902">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="f6353-1903">Для <xref:System.Net.Sockets.SocketOptionName.AddMembership> и <xref:System.Net.Sockets.SocketOptionName.DropMembership>используйте <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1903">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="f6353-1904">Если вы хотите задать значение любого из перечисленных выше параметров, используйте метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1904">If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1905">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1905">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1906">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1906">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1907">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1907">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1908">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1908">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1909">Следующий пример кода извлекает значения времени ожидания <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A> и отображает их в консоли.</span><span class="sxs-lookup"><span data-stu-id="f6353-1909">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1910">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1910">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="f6353-1911">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-1911">-or-</span></span> 
 <span data-ttu-id="f6353-1912">Для параметра <paramref name="optionName" /> было установлено неподдерживаемое значение <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1912"><paramref name="optionName" /> was set to the unsupported value <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1913"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1913">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="f6353-1914">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1914">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="f6353-1915">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1915">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="f6353-1916">Массив типа <see cref="T:System.Byte" />, который используется для отправки значения параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-1916">An array of type <see cref="T:System.Byte" /> that is to receive the option setting.</span></span></param>
        <summary><span data-ttu-id="f6353-1917">Возвращает указанное значение параметра <see cref="T:System.Net.Sockets.Socket" />, представленного в виде байтового массива.</span><span class="sxs-lookup"><span data-stu-id="f6353-1917">Returns the specified <see cref="T:System.Net.Sockets.Socket" /> option setting, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1918">Параметры <xref:System.Net.Sockets.Socket> определяют поведение текущего <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1918"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-1919">После успешного завершения этого метода массив, заданный параметром `optionValue`, содержит значение указанного параметра <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1919">Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.</span></span>  
  
 <span data-ttu-id="f6353-1920">Если длина массива `optionValue` меньше, чем число байтов, необходимое для хранения значения указанного параметра <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1920">When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-1921">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1921">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1922">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1922">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="f6353-1923">Используйте эту перегрузку для всех сокетов, представленных логическими значениями или целыми числами.</span><span class="sxs-lookup"><span data-stu-id="f6353-1923">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1924">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1924">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1925">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1925">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1926">Следующий пример кода извлекает значения времени ожидания <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A> и отображает их в консоли.</span><span class="sxs-lookup"><span data-stu-id="f6353-1926">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1927">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1927">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="f6353-1928">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-1928">-or-</span></span> 
<span data-ttu-id="f6353-1929">В приложениях .NET Compact Framework для размера буферного пространства Windows CE установлено по умолчанию значение 32768 байт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1929">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="f6353-1930">Можно изменить размер буферного пространства сокета, вызвав свойство <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1930">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1931"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1931">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="f6353-1932">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1932">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="f6353-1933">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1933">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionLength"><span data-ttu-id="f6353-1934">Длина ожидаемого возвращаемого значения, указанная в байтах.</span><span class="sxs-lookup"><span data-stu-id="f6353-1934">The length, in bytes, of the expected return value.</span></span></param>
        <summary><span data-ttu-id="f6353-1935">Возвращает значение указанного параметра <see cref="T:System.Net.Sockets.Socket" /> в массиве.</span><span class="sxs-lookup"><span data-stu-id="f6353-1935">Returns the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option in an array.</span></span></summary>
        <returns><span data-ttu-id="f6353-1936">Массив типа <see cref="T:System.Byte" />, который содержит значение параметра сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-1936">An array of type <see cref="T:System.Byte" /> that contains the value of the socket option.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1937">Параметр `optionLength` задает максимальный размер возвращаемого массива байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1937">The `optionLength` parameter sets the maximum size of the returned byte array.</span></span> <span data-ttu-id="f6353-1938">Если значение параметра требует меньше байт, массив будет содержать только столько байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-1938">If the option value requires fewer bytes, the array will contain only that many bytes.</span></span> <span data-ttu-id="f6353-1939">Если значение параметра требует больше байтов, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1939">If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-1940">Используйте эту перегрузку для всех сокетов, представленных логическими значениями или целыми числами.</span><span class="sxs-lookup"><span data-stu-id="f6353-1940">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1941">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1941">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1942">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1942">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1943">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1943">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1944">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1944">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1945">Следующий пример кода извлекает значения времени ожидания <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A> и отображает их в консоли.</span><span class="sxs-lookup"><span data-stu-id="f6353-1945">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1946">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1946">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="f6353-1947">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-1947">-or-</span></span> 
<span data-ttu-id="f6353-1948">В приложениях .NET Compact Framework для размера буферного пространства Windows CE установлено по умолчанию значение 32768 байт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1948">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="f6353-1949">Можно изменить размер буферного пространства сокета, вызвав свойство <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1949">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1950"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1950">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-1951">Возвращает дескриптор операционной системы для объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1951">Gets the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="f6353-1952">Объект <see cref="T:System.IntPtr" />, представляющий дескриптор операционной системы для <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1952">An <see cref="T:System.IntPtr" /> that represents the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-1953">Задает низкоуровневые операционные режимы для объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1953">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="f6353-1954">Значение <see cref="T:System.Int32" />, задающее код элемента управления для выполняемой операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1954">An <see cref="T:System.Int32" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="f6353-1955">Массив <see cref="T:System.Byte" />, который содержит входные данные, необходимые для операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1955">A <see cref="T:System.Byte" /> array that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="f6353-1956">Массив <see cref="T:System.Byte" />, который содержит выходные данные, необходимые для операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1956">A <see cref="T:System.Byte" /> array that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="f6353-1957">Задает низкоуровневые операционные режимы для объекта <see cref="T:System.Net.Sockets.Socket" />, используя цифровые коды элементов управления.</span><span class="sxs-lookup"><span data-stu-id="f6353-1957">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using numerical control codes.</span></span></summary>
        <returns><span data-ttu-id="f6353-1958">Число байтов в параметре <paramref name="optionOutValue" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1958">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1959">Метод <xref:System.Net.Sockets.Socket.IOControl%2A> предоставляет низкоуровневый доступ к операционной системе <xref:System.Net.Sockets.Socket> базовому экземпляру класса <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1959">The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="f6353-1960">Дополнительные сведения см. в документации по [всаиоктл](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) .</span><span class="sxs-lookup"><span data-stu-id="f6353-1960">For more information, see the [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) documentation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1961">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1961">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1962">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1962">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1963">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1963">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1964">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1964">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1965">В следующем примере кода сравниваются результаты ФИОНРЕАД и доступного свойства.</span><span class="sxs-lookup"><span data-stu-id="f6353-1965">The following code example compares the results of FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1966">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1966">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1967"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1967">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1968">Была сделана попытка изменения блокирующего режима без использования свойства <see cref="P:System.Net.Sockets.Socket.Blocking" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1968">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-1969">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</span><span class="sxs-lookup"><span data-stu-id="f6353-1969">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f6353-1970">для выполнения неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="f6353-1970">to execute unmanaged code.</span></span> <span data-ttu-id="f6353-1971">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1971">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="f6353-1972">Значение <see cref="T:System.Net.Sockets.IOControlCode" />, задающее код элемента управления для выполняемой операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1972">A <see cref="T:System.Net.Sockets.IOControlCode" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="f6353-1973">Массив типа <see cref="T:System.Byte" />, который содержит входные данные, необходимые для операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-1973">An array of type <see cref="T:System.Byte" /> that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="f6353-1974">Массив типа <see cref="T:System.Byte" />, который содержит выходные данные, возвращенные операцией.</span><span class="sxs-lookup"><span data-stu-id="f6353-1974">An array of type <see cref="T:System.Byte" /> that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="f6353-1975">Задает низкоуровневые операционные режимы для объекта <see cref="T:System.Net.Sockets.Socket" />, используя перечисление <see cref="T:System.Net.Sockets.IOControlCode" />, чтобы указать коды элементов управления.</span><span class="sxs-lookup"><span data-stu-id="f6353-1975">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="T:System.Net.Sockets.IOControlCode" /> enumeration to specify control codes.</span></span></summary>
        <returns><span data-ttu-id="f6353-1976">Число байтов в параметре <paramref name="optionOutValue" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1976">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1977">Этот метод обеспечивает низкоуровневый доступ к операционной системе <xref:System.Net.Sockets.Socket> базовом экземпляре класса <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1977">This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="f6353-1978">Дополнительные сведения см. в документации по [всаиоктл](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) .</span><span class="sxs-lookup"><span data-stu-id="f6353-1978">For more, see the [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) documentation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1979">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1979">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-1980">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1980">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-1981">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-1981">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-1982">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-1982">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1983">В следующем примере кода сравниваются результаты вызова <xref:System.Net.Sockets.Socket.IOControl%2A> с <xref:System.Net.Sockets.IOControlCode.DataToRead> и свойством <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-1983">The following code example compares the results of calling <xref:System.Net.Sockets.Socket.IOControl%2A> with <xref:System.Net.Sockets.IOControlCode.DataToRead> and the <xref:System.Net.Sockets.Socket.Available%2A> property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-1984">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-1984">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-1985"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-1985">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-1986">Была сделана попытка изменения блокирующего режима без использования свойства <see cref="P:System.Net.Sockets.Socket.Blocking" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1986">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f6353-1987">для выполнения неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="f6353-1987">to execute unmanaged code.</span></span> <span data-ttu-id="f6353-1988">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1988">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-1989">Получает значение, указывающее, привязан ли объект <see cref="T:System.Net.Sockets.Socket" /> к конкретному локальному порту.</span><span class="sxs-lookup"><span data-stu-id="f6353-1989">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is bound to a specific local port.</span></span></summary>
        <value><span data-ttu-id="f6353-1990">Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> привязан к локальному порту; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-1990"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is bound to a local port; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1991">Сокет считается привязанным к локальному порту, если он явно привязан путем вызова метода <xref:System.Net.Sockets.Socket.Bind%2A> или неявно привязан путем вызова членов, таких как <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>или <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, которые используют временный локальный порт (бесплатный порт, превышающий 1024, выбранный операционной системой). Серверы используют метод <xref:System.Net.Sockets.Socket.Bind%2A> для привязки к хорошо известному порту, чтобы клиенты могли подключаться к ним.</span><span class="sxs-lookup"><span data-stu-id="f6353-1991">A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-1992">В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.IsBound%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="f6353-1992">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.IsBound%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-1993">Возвращает или задает значение, указывающее, будет ли объект <see cref="T:System.Net.Sockets.Socket" /> задерживать закрытие сокета при попытке отправки всех отложенных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-1993">Gets or sets a value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> will delay closing a socket in an attempt to send all pending data.</span></span></summary>
        <value><span data-ttu-id="f6353-1994">Объект <see cref="T:System.Net.Sockets.LingerOption" />, указывающий задержку при закрытии сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-1994">A <see cref="T:System.Net.Sockets.LingerOption" /> that specifies how to linger while closing a socket.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-1995">Свойство <xref:System.Net.Sockets.Socket.LingerState%2A> изменяет способ, которым <xref:System.Net.Sockets.Socket.Close%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="f6353-1995">The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves.</span></span> <span data-ttu-id="f6353-1996">Это свойство задается при изменении условий, при которых подключение может быть сброшено с помощью Winsock.</span><span class="sxs-lookup"><span data-stu-id="f6353-1996">This property when set modifies the conditions under which the connection can be reset by Winsock.</span></span> <span data-ttu-id="f6353-1997">Сброс соединения по-прежнему может происходить в зависимости от поведения протокола IP.</span><span class="sxs-lookup"><span data-stu-id="f6353-1997">Connection resets can still occur based on the IP protocol behavior.</span></span>  
  
 <span data-ttu-id="f6353-1998">Это свойство управляет длительностью времени, в течение которого соединение, ориентированное на соединение, остается открытым после вызова <xref:System.Net.Sockets.Socket.Close%2A>, когда данные остаются для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-1998">This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.</span></span>  
  
 <span data-ttu-id="f6353-1999">При вызове методов для отправки данных одноранговой сети эти данные помещаются в исходящий сетевой буфер.</span><span class="sxs-lookup"><span data-stu-id="f6353-1999">When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</span></span> <span data-ttu-id="f6353-2000">Это свойство можно использовать, чтобы убедиться, что эти данные отправляются на удаленный узел перед тем, как метод <xref:System.Net.Sockets.TcpClient.Close%2A> удаляет подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-2000">This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.</span></span>  
  
 <span data-ttu-id="f6353-2001">Чтобы включить ожидание, создайте экземпляр <xref:System.Net.Sockets.LingerOption>, содержащий нужные значения, и задайте для свойства <xref:System.Net.Sockets.Socket.LingerState%2A> значение этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="f6353-2001">To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.</span></span>  
  
 <span data-ttu-id="f6353-2002">В следующей таблице описывается поведение метода <xref:System.Net.Sockets.Socket.Close%2A> для возможных значений свойства <xref:System.Net.Sockets.LingerOption.Enabled%2A> и свойства <xref:System.Net.Sockets.LingerOption.LingerTime%2A>, хранящегося в свойстве <xref:System.Net.Sockets.Socket.LingerState%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2002">The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
|<span data-ttu-id="f6353-2003">Линжерстате. Enabled</span><span class="sxs-lookup"><span data-stu-id="f6353-2003">LingerState.Enabled</span></span>|<span data-ttu-id="f6353-2004">Линжерстате. Линжертиме</span><span class="sxs-lookup"><span data-stu-id="f6353-2004">LingerState.LingerTime</span></span>|<span data-ttu-id="f6353-2005">Поведение</span><span class="sxs-lookup"><span data-stu-id="f6353-2005">Behavior</span></span>|  
|-------------------------|----------------------------|--------------|  
|<span data-ttu-id="f6353-2006">`false` (отключено), значение по умолчанию</span><span class="sxs-lookup"><span data-stu-id="f6353-2006">`false` (disabled), the default value</span></span>|<span data-ttu-id="f6353-2007">Время ожидания неприменимо (по умолчанию).</span><span class="sxs-lookup"><span data-stu-id="f6353-2007">The time-out is not applicable, (default).</span></span>|<span data-ttu-id="f6353-2008">Пытается отправить ожидающие данные до истечения времени ожидания протокола IP по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-2008">Attempts to send pending data until the default IP protocol time-out expires.</span></span>|  
|<span data-ttu-id="f6353-2009">`true` (включено)</span><span class="sxs-lookup"><span data-stu-id="f6353-2009">`true` (enabled)</span></span>|<span data-ttu-id="f6353-2010">Ненулевое время ожидания</span><span class="sxs-lookup"><span data-stu-id="f6353-2010">A nonzero time-out</span></span>|<span data-ttu-id="f6353-2011">Пытается отправить ожидающие данные до истечения заданного времени ожидания. Если попытка не удалась, Winsock сбрасывает подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-2011">Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</span></span>|  
|<span data-ttu-id="f6353-2012">`true` (включено)</span><span class="sxs-lookup"><span data-stu-id="f6353-2012">`true` (enabled)</span></span>|<span data-ttu-id="f6353-2013">Нулевое время ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-2013">A zero timeout.</span></span>|<span data-ttu-id="f6353-2014">Отменяет все ожидающие данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2014">Discards any pending data.</span></span> <span data-ttu-id="f6353-2015">Для сокета, ориентированного на подключение (например, TCP), Winsock сбрасывает подключение.</span><span class="sxs-lookup"><span data-stu-id="f6353-2015">For connection-oriented socket (TCP, for example), Winsock resets the connection.</span></span>|  
  
 <span data-ttu-id="f6353-2016">В стеке IP-адресов используется период ожидания протокола IP по умолчанию, используемый в зависимости от времени кругового пути соединения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2016">The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</span></span> <span data-ttu-id="f6353-2017">В большинстве случаев время ожидания, вычисленное стеком, больше релевантно, чем определено приложением.</span><span class="sxs-lookup"><span data-stu-id="f6353-2017">In most cases, the time-out computed by the stack is more relevant than one defined by an application.</span></span> <span data-ttu-id="f6353-2018">Это поведение по умолчанию для сокета, если не задано свойство <xref:System.Net.Sockets.Socket.LingerState%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2018">This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.</span></span>  
  
 <span data-ttu-id="f6353-2019">Если свойство <xref:System.Net.Sockets.LingerOption.LingerTime%2A>, хранящееся в свойстве <xref:System.Net.Sockets.Socket.LingerState%2A>, установлено больше, чем время ожидания протокола IP по умолчанию, по умолчанию время ожидания протокола IP по-прежнему будет применяться и переопределено.</span><span class="sxs-lookup"><span data-stu-id="f6353-2019">When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2020">В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.LingerState%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="f6353-2020">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2021">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2021">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2022"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2022">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog"><span data-ttu-id="f6353-2023">Максимальная длина очереди ожидающих подключений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2023">The maximum length of the pending connections queue.</span></span></param>
        <summary><span data-ttu-id="f6353-2024">Устанавливает объект <see cref="T:System.Net.Sockets.Socket" /> в состояние прослушивания.</span><span class="sxs-lookup"><span data-stu-id="f6353-2024">Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2025"><xref:System.Net.Sockets.Socket.Listen%2A> вызывает <xref:System.Net.Sockets.Socket>, ориентированный на подключение, для прослушивания входящих попыток подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2025"><xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts.</span></span> <span data-ttu-id="f6353-2026">Параметр `backlog` указывает количество входящих подключений, которые могут быть поставлены в очередь на принятие.</span><span class="sxs-lookup"><span data-stu-id="f6353-2026">The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance.</span></span> <span data-ttu-id="f6353-2027">Чтобы определить максимальное количество подключений, которое можно указать, извлеките значение <xref:System.Net.Sockets.SocketOptionName.MaxConnections>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2027">To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value.</span></span> <span data-ttu-id="f6353-2028"><xref:System.Net.Sockets.Socket.Listen%2A> не блокируется.</span><span class="sxs-lookup"><span data-stu-id="f6353-2028"><xref:System.Net.Sockets.Socket.Listen%2A> does not block.</span></span>  
  
 <span data-ttu-id="f6353-2029">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2029">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2030">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2030">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="f6353-2031">Используйте <xref:System.Net.Sockets.Socket.Accept%2A> или <xref:System.Net.Sockets.Socket.BeginAccept%2A>, чтобы принимать подключение из очереди.</span><span class="sxs-lookup"><span data-stu-id="f6353-2031">Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2032">Перед вызовом <xref:System.Net.Sockets.Socket.Listen%2A>необходимо вызвать метод <xref:System.Net.Sockets.Socket.Bind%2A> или <xref:System.Net.Sockets.Socket.Listen%2A> вызовет <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2032">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2033">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2033">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2034">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2034">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2035">Параметр невыполненной работы ограничен различными значениями в зависимости от операционной системы.</span><span class="sxs-lookup"><span data-stu-id="f6353-2035">The backlog parameter is limited to different values depending on the Operating System.</span></span> <span data-ttu-id="f6353-2036">Вы можете указать более высокое значение, но невыполненная работа будет ограничена в зависимости от операционной системы.</span><span class="sxs-lookup"><span data-stu-id="f6353-2036">You may specify a higher value, but the backlog will be limited based on the Operating System.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2037">В следующем примере кода <xref:System.Net.Sockets.Socket> используется для прослушивания входящих подключений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2037">The following code example uses <xref:System.Net.Sockets.Socket> to listen for incoming connections.</span></span>  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2038">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2038">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2039"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2039">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-2040">Возвращает локальную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-2040">Gets the local endpoint.</span></span></summary>
        <value><span data-ttu-id="f6353-2041">Объект <see cref="T:System.Net.EndPoint" />, который объект <see cref="T:System.Net.Sockets.Socket" /> использует для взаимодействий.</span><span class="sxs-lookup"><span data-stu-id="f6353-2041">The <see cref="T:System.Net.EndPoint" /> that the <see cref="T:System.Net.Sockets.Socket" /> is using for communications.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2042">Свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> возвращает <xref:System.Net.EndPoint>, который содержит локальный IP-адрес и номер порта, к которым привязан <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2042">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound.</span></span> <span data-ttu-id="f6353-2043">Перед получением каких-либо сведений необходимо привести этот <xref:System.Net.EndPoint> к <xref:System.Net.IPEndPoint>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2043">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="f6353-2044">Затем можно вызвать метод <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> для получения локального <xref:System.Net.IPAddress>и метод <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> для получения номера локального порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-2044">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the local port number.</span></span>  
  
 <span data-ttu-id="f6353-2045">Свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> обычно задается после вызова метода <xref:System.Net.Sockets.Socket.Bind%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2045">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="f6353-2046">Если разрешить системе назначать локальный IP-адрес сокета и номер порта, свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> будет установлено после первой операции ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="f6353-2046">If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation.</span></span> <span data-ttu-id="f6353-2047">Для протоколов, ориентированных на соединение, первая операция ввода-вывода будет вызывать метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2047">For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2048">Для протоколов без подключения первая операция ввода-вывода будет иметь любой из вызовов Send или Receive.</span><span class="sxs-lookup"><span data-stu-id="f6353-2048">For connectionless protocols, the first I/O operation would be any of the send or receive calls.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2049">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2049">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2050">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2050">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2051">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2051">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2052">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2052">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2053">В следующем примере кода извлекаются и отображаются локальные и удаленные конечные точки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2053">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2054">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2054">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2055"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2055">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-2056">Возвращает или задает значение, указывающее, могут ли доставляться исходящие пакеты многоадресной рассылки в передающем приложении.</span><span class="sxs-lookup"><span data-stu-id="f6353-2056">Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</span></span></summary>
        <value><span data-ttu-id="f6353-2057">Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> получает исходящие пакеты многоадресной рассылки; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2057"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> receives outgoing multicast packets; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2058">Многоадресная рассылка — это масштабируемый метод для связи "многие ко многим" в Интернете.</span><span class="sxs-lookup"><span data-stu-id="f6353-2058">Multicast is a scalable method for many-to-many communication on the Internet.</span></span> <span data-ttu-id="f6353-2059">Процесс подписывается на адрес многоадресной рассылки; Затем все пакеты, отправленные подписанным процессом, получаются любым другим процессом, подписанным на адрес многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2059">A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</span></span>  
  
 <span data-ttu-id="f6353-2060">Установка этого свойства для сокета протокола TCP не будет действовать.</span><span class="sxs-lookup"><span data-stu-id="f6353-2060">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2061">В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="f6353-2061">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2062">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2062">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2063"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2063">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-2064">Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, используется ли поток <see cref="T:System.Net.Sockets.Socket" /> в алгоритме Nagle.</span><span class="sxs-lookup"><span data-stu-id="f6353-2064">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the stream <see cref="T:System.Net.Sockets.Socket" /> is using the Nagle algorithm.</span></span></summary>
        <value><span data-ttu-id="f6353-2065">Значение <see langword="false" />, если объект <see cref="T:System.Net.Sockets.Socket" /> использует алгоритм Nagle; в противном случае — значение <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2065"><see langword="false" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses the Nagle algorithm; otherwise, <see langword="true" />.</span></span> <span data-ttu-id="f6353-2066">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2066">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2067">Алгоритм Nagle предназначен для уменьшения сетевого трафика, вызывая буферизацию небольших пакетов через сокет, а затем объединять и отсылать их в одном пакете при определенных обстоятельствах.</span><span class="sxs-lookup"><span data-stu-id="f6353-2067">The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</span></span> <span data-ttu-id="f6353-2068">Пакет TCP состоит из 40 байт заголовка и отправляемых данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2068">A TCP packet consists of 40 bytes of header plus the data being sent.</span></span> <span data-ttu-id="f6353-2069">Когда небольшие пакеты данных отправляются по протоколу TCP, накладные расходы, полученные из заголовка TCP, могут стать значительным частью сетевого трафика.</span><span class="sxs-lookup"><span data-stu-id="f6353-2069">When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.</span></span> <span data-ttu-id="f6353-2070">В сильно загруженных сетях перегрузка, полученная в результате этой дополнительной нагрузки, может привести к потере датаграмм и повторных передач, а также к чрезмерному времени распространения, вызванному перегрузкой.</span><span class="sxs-lookup"><span data-stu-id="f6353-2070">On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</span></span> <span data-ttu-id="f6353-2071">Алгоритм Nagle запрещает отправку новых TCP-сегментов при поступлении новых исходящих данных от пользователя, если все ранее переданные подключения не подтверждены.</span><span class="sxs-lookup"><span data-stu-id="f6353-2071">The Nagle algorithm inhibits the sending of new TCP segments when new outgoing data arrives from the user if any previously transmitted data on the connection remains unacknowledged.</span></span>  
  
 <span data-ttu-id="f6353-2072">Большинство сетевых приложений должны использовать алгоритм Nagle.</span><span class="sxs-lookup"><span data-stu-id="f6353-2072">The majority of network applications should use the Nagle algorithm.</span></span>  
  
 <span data-ttu-id="f6353-2073">Задание этого свойства для сокета UDP не будет действовать.</span><span class="sxs-lookup"><span data-stu-id="f6353-2073">Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2074">В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.NoDelay%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="f6353-2074">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.NoDelay%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2075">Произошла ошибка при попытке доступа к объекту <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2075">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2076"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2076">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-2077">Указывает, поддерживают ли основная операционная система и сетевые адаптеры протокол IPv4.</span><span class="sxs-lookup"><span data-stu-id="f6353-2077">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</span></span></summary>
        <value><span data-ttu-id="f6353-2078">Значение <see langword="true" />, если основная операционная система и сетевые адаптеры поддерживают протокол IPv4; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2078"><see langword="true" /> if the operating system and network adaptors support the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2079">Операционная система может поддерживать протоколы IPv4 и IPv6.</span><span class="sxs-lookup"><span data-stu-id="f6353-2079">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-2080">Указывает, поддерживают ли основная операционная система и сетевые адаптеры протокол IPv6.</span><span class="sxs-lookup"><span data-stu-id="f6353-2080">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</span></span></summary>
        <value><span data-ttu-id="f6353-2081">Значение <see langword="true" />, если основная операционная система и сетевые адаптеры поддерживают протокол IPv6; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2081"><see langword="true" /> if the operating system and network adaptors support the IPv6 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2082">Операционная система может поддерживать протоколы IPv4 и IPv6.</span><span class="sxs-lookup"><span data-stu-id="f6353-2082">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="microSeconds"><span data-ttu-id="f6353-2083">Время ожидания ответа, заданное в микросекундах.</span><span class="sxs-lookup"><span data-stu-id="f6353-2083">The time to wait for a response, in microseconds.</span></span></param>
        <param name="mode"><span data-ttu-id="f6353-2084">Одно из значений перечисления <see cref="T:System.Net.Sockets.SelectMode" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2084">One of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></param>
        <summary><span data-ttu-id="f6353-2085">Определяет состояние объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2085">Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2086">Состояние объекта <see cref="T:System.Net.Sockets.Socket" />, основанное на значении режима опроса, переданного в параметре <paramref name="mode" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2086">The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="f6353-2087">Режим</span><span class="sxs-lookup"><span data-stu-id="f6353-2087">Mode</span></span> 
 </term><description> <span data-ttu-id="f6353-2088">Возвращаемое значение</span><span class="sxs-lookup"><span data-stu-id="f6353-2088">Return Value</span></span> 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><span data-ttu-id="f6353-2089">Значение <see langword="true" />, если был вызван метод <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> и подключение отложено;</span><span class="sxs-lookup"><span data-stu-id="f6353-2089"><see langword="true" /> if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending;</span></span> 
<span data-ttu-id="f6353-2090">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2090">-or-</span></span> 
 <span data-ttu-id="f6353-2091">Значение <see langword="true" />, если данные доступны для чтения;</span><span class="sxs-lookup"><span data-stu-id="f6353-2091"><see langword="true" /> if data is available for reading;</span></span> 
<span data-ttu-id="f6353-2092">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2092">-or-</span></span> 
 <span data-ttu-id="f6353-2093">Значение <see langword="true" />, если подключение закрыто, сброшено или завершено.</span><span class="sxs-lookup"><span data-stu-id="f6353-2093"><see langword="true" /> if the connection has been closed, reset, or terminated;</span></span> 
<span data-ttu-id="f6353-2094">В противном случае, возвращает значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2094">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><span data-ttu-id="f6353-2095">Значение <see langword="true" />, если обработка метода <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> и подключения завершились успешно;</span><span class="sxs-lookup"><span data-stu-id="f6353-2095"><see langword="true" />, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded;</span></span> 
<span data-ttu-id="f6353-2096">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2096">-or-</span></span> 
 <span data-ttu-id="f6353-2097">Значение <see langword="true" />, если данные могут быть посланы;</span><span class="sxs-lookup"><span data-stu-id="f6353-2097"><see langword="true" /> if data can be sent;</span></span> 
<span data-ttu-id="f6353-2098">В противном случае, возвращает значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2098">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><span data-ttu-id="f6353-2099">Значение <see langword="true" />, если не блокируется обработка метода <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> и попытка подключения завершилась неудачей;</span><span class="sxs-lookup"><span data-stu-id="f6353-2099"><see langword="true" /> if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed;</span></span> 
<span data-ttu-id="f6353-2100">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2100">-or-</span></span> 
 <span data-ttu-id="f6353-2101">Значение <see langword="true" />, если не установлен объект <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> и доступны экстренные данные;</span><span class="sxs-lookup"><span data-stu-id="f6353-2101"><see langword="true" /> if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available;</span></span> 
<span data-ttu-id="f6353-2102">В противном случае, возвращает значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2102">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2103">Метод <xref:System.Net.Sockets.Socket.Poll%2A> проверит состояние <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2103">The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-2104">Укажите <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> для параметра `selectMode`, чтобы определить, доступен ли <xref:System.Net.Sockets.Socket> для чтения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2104">Specify <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable.</span></span> <span data-ttu-id="f6353-2105">Укажите <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType>, чтобы определить, доступна ли <xref:System.Net.Sockets.Socket> для записи.</span><span class="sxs-lookup"><span data-stu-id="f6353-2105">Specify <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> to determine if the <xref:System.Net.Sockets.Socket> is writable.</span></span> <span data-ttu-id="f6353-2106">Для обнаружения состояния ошибки используйте <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2106">Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> to detect an error condition.</span></span> <span data-ttu-id="f6353-2107"><xref:System.Net.Sockets.Socket.Poll%2A> будет блокировать выполнение до истечения указанного периода времени, измеряемого в `microseconds`.</span><span class="sxs-lookup"><span data-stu-id="f6353-2107"><xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses.</span></span> <span data-ttu-id="f6353-2108">Задайте для параметра `microSeconds` отрицательное целое число, если вы хотите подождать неопределенное время ответа.</span><span class="sxs-lookup"><span data-stu-id="f6353-2108">Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response.</span></span> <span data-ttu-id="f6353-2109">Если вы хотите проверить состояние нескольких сокетов, можно использовать метод <xref:System.Net.Sockets.Socket.Select%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2109">If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2110">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2110">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2111">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2111">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2112">Этот метод не может обнаружить некоторые виды проблем с подключением, например обрыв сетевого кабеля или некорректное завершение работы удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2112">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="f6353-2113">Необходимо попытаться отправить или получить данные для обнаружения ошибок этих типов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2113">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2114">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2114">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2115">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2115">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2116">В следующем примере кода создается сокет, подключается к серверу и используется <xref:System.Net.Sockets.Socket.Poll%2A> для проверки состояния сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-2116">The following code example creates a socket, connects to a server, and uses <xref:System.Net.Sockets.Socket.Poll%2A> to check the status of the socket.</span></span>  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-2117">Параметр <paramref name="mode" /> не является одним из значений <see cref="T:System.Net.Sockets.SelectMode" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2117">The <paramref name="mode" /> parameter is not one of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2118">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2118">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="f6353-2119">См. примечания ниже.</span><span class="sxs-lookup"><span data-stu-id="f6353-2119">See remarks below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2120"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2120">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-2121">Получает тип протокола объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2121">Gets the protocol type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="f6353-2122">Одно из значений перечисления <see cref="T:System.Net.Sockets.ProtocolType" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2122">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2123">Свойство <xref:System.Net.Sockets.Socket.ProtocolType%2A> задается при создании <xref:System.Net.Sockets.Socket> и указывает протокол, используемый <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2123">The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2124">В следующем примере кода выводятся <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>и <xref:System.Net.Sockets.ProtocolType> на консоль.</span><span class="sxs-lookup"><span data-stu-id="f6353-2124">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-2125">Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2125">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2126">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2126">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <summary><span data-ttu-id="f6353-2127">Возвращает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер.</span><span class="sxs-lookup"><span data-stu-id="f6353-2127">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span></span></summary>
        <returns><span data-ttu-id="f6353-2128">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2128">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2129">Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2129">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="f6353-2130">Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2130">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="f6353-2131">Эта перегрузка требует только предоставления буфера приема.</span><span class="sxs-lookup"><span data-stu-id="f6353-2131">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="f6353-2132">По умолчанию смещение буфера равно 0, размер по умолчанию равен длине параметра buffer, а <xref:System.Net.Sockets.SocketFlags> значение по умолчанию равно <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2132">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="f6353-2133">Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2133">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="f6353-2134">Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2134">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2135">Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2135">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2136"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2136"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="f6353-2137">Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2137">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2138">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Receive%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2138">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2139">Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2139">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2140">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2140">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2141">Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2141">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="f6353-2142">При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2142">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="f6353-2143">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2143">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="f6353-2144">Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2144">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="f6353-2145">Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2145">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2146">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2146">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2147">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2147">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2148">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2148">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2149">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2149">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2150">Следующий пример кода получает данные на подключенном <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2150">The following code example receives data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2151">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2151"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2152">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2152">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2153"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2153">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-2154">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2154">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2155">для приема подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2155">for accepting connections from the network.</span></span> <span data-ttu-id="f6353-2156">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2156">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="f6353-2157">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих полученные данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2157">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <summary><span data-ttu-id="f6353-2158">Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в список приемных буферов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2158">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers.</span></span></summary>
        <returns><span data-ttu-id="f6353-2159">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2159">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2160">Этот метод считывает данные в параметр Buffers и возвращает число успешно считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2160">This method reads data into the buffers parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="f6353-2161">Вы можете вызывать из сокетов, ориентированных на подключение, и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2161">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="f6353-2162">Эта перегрузка требует предоставления одного или нескольких буферов приема.</span><span class="sxs-lookup"><span data-stu-id="f6353-2162">This overload requires you to provide one or more receive buffers.</span></span>  
  
 <span data-ttu-id="f6353-2163">Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2163">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="f6353-2164">Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с подключения к удаленному узлу, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2164">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2165">Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2165">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2166"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2166"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="f6353-2167">Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2167">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2168">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Receive%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2168">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2169">Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2169">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2170">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2170">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2171">Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2171">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="f6353-2172">При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2172">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="f6353-2173">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2173">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="f6353-2174">Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую из указанных в очереди датаграмму из адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2174">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="f6353-2175">Если полученная датаграмма превышает размер параметра `buffers`, `buffers` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2175">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2176">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2176">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2177">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2177">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="f6353-2178">**Примечание** . Этот элемент выводит данные трассировки при включении трассировки сети в приложении.</span><span class="sxs-lookup"><span data-stu-id="f6353-2178">**Note** This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2179">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2179">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2180">Параметр <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2180">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2181">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2181">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2182"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2182">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2183">Диапазон байтов, который является местом хранения для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2183">A span of bytes that is the storage location for the received data.</span></span></param>
        <summary><span data-ttu-id="f6353-2184">Возвращает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер.</span><span class="sxs-lookup"><span data-stu-id="f6353-2184">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span></span></summary>
        <returns><span data-ttu-id="f6353-2185">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2185">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="f6353-2186">Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2186">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="f6353-2187">Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2187">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>

<span data-ttu-id="f6353-2188">Эта перегрузка требует только предоставления буфера приема.</span><span class="sxs-lookup"><span data-stu-id="f6353-2188">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="f6353-2189">По умолчанию смещение буфера равно 0, размер по умолчанию равен длине параметра buffer, а <xref:System.Net.Sockets.SocketFlags> значение по умолчанию равно <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2189">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>

<span data-ttu-id="f6353-2190">Если используется протокол, ориентированный на подключение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> для установления соединения с удаленным узлом, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2190">If you're using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="f6353-2191">Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2191">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2192">Если вы используете протокол без установления соединения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2192">If you're using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2193"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2193"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>

<span data-ttu-id="f6353-2194">Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2194">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2195">Когда значение времени ожидания превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов выдаст исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2195">When the time-out value is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2196">Если вы находитесь в режиме без блокировки и в буфере стека протоколов нет данных, то метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2196">If you're in non-blocking mode, and there's no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2197">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2197">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2198">Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2198">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>

<span data-ttu-id="f6353-2199">Если вы используете <xref:System.Net.Sockets.Socket>, ориентированную на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2199">If you're using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="f6353-2200">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2200">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>

<span data-ttu-id="f6353-2201">Если вы используете <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2201">If you're using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="f6353-2202">Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2202">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost, and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>

> [!NOTE]
> <span data-ttu-id="f6353-2203">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2203">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2204">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2204">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="f6353-2205">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2205">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2206">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2206">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2207">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2207">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2208"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2208">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-2209">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2209">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2210">Принятие подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2210">Accepting connections from the network.</span></span> <span data-ttu-id="f6353-2211">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2211">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2212">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2212">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2213">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2213">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="f6353-2214">Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2214">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2215">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2215">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2216">Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2216">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="f6353-2217">Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2217">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="f6353-2218">Эта перегрузка требует только предоставления буфера получения и необходимых <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2218">This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="f6353-2219">По умолчанию смещение буфера равно 0, а размер по умолчанию равен длине параметра Byte.</span><span class="sxs-lookup"><span data-stu-id="f6353-2219">The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</span></span>  
  
 <span data-ttu-id="f6353-2220">Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2220">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="f6353-2221">Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2221">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2222">Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2222">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2223"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2223"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="f6353-2224">Если данные для чтения недоступны, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные недоступны.</span><span class="sxs-lookup"><span data-stu-id="f6353-2224">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available.</span></span> <span data-ttu-id="f6353-2225">Если вы используете неблокирующий режим и в буфере стека протокола нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет выполнен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2225">If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2226">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2226">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2227">Если <xref:System.Net.Sockets.Socket.Available%2A> не равен нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2227">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="f6353-2228">При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно до размера буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2228">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer.</span></span> <span data-ttu-id="f6353-2229">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2229">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="f6353-2230">Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую из указанных в очереди датаграмму из адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2230">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="f6353-2231">Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2231">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2232">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2232">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2233">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2233">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2234">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2234">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2235">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2235">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2236">В следующем примере кода задается буфер данных и <xref:System.Net.Sockets.SocketFlags> для получения данных в подключенной <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2236">The following code example specifies a data buffer, and <xref:System.Net.Sockets.SocketFlags> for receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2237">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2237"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2238">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2238">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2239"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2239">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-2240">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2240">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2241">Принятие подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2241">Accepting connections from the network.</span></span> <span data-ttu-id="f6353-2242">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2242">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="f6353-2243">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих полученные данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2243">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2244">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2244">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="f6353-2245">Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в список приемных буферов, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2245">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2246">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2246">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2247">Этот метод считывает данные в параметр `buffers` и возвращает число успешно считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2247">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="f6353-2248">Вы можете вызывать из сокетов, ориентированных на подключение, и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2248">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="f6353-2249">Эта перегрузка требует предоставления одного или нескольких буферов приема.</span><span class="sxs-lookup"><span data-stu-id="f6353-2249">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="f6353-2250">Значение <xref:System.Net.Sockets.SocketFlags> по умолчанию равно <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2250">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="f6353-2251">Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2251">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="f6353-2252">Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с подключения к удаленному узлу, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2252">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2253">Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2253">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2254"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2254"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="f6353-2255">Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2255">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2256">Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов создает исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2256">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2257">Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2257">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2258">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2258">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2259">Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2259">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="f6353-2260">При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2260">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="f6353-2261">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2261">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="f6353-2262">Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую из указанных в очереди датаграмму из адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2262">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="f6353-2263">Если полученная датаграмма превышает размер параметра `buffers`, `buffers` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2263">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2264">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2264">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2265">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2265">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2266">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2266">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2267">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2267">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2268">В следующем примере кода показано, как получить данные на подключенном <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2268">The following code example demonstrates how to receive data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2269">Свойство <paramref name="buffers" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2269"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-2270">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2270">-or-</span></span> 
 <span data-ttu-id="f6353-2271">Значение <paramref name="buffers" />. Отсчет равен нулю.</span><span class="sxs-lookup"><span data-stu-id="f6353-2271"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2272">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2272">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2273"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2273">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2274">для приема подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2274">for accepting connections from the network.</span></span> <span data-ttu-id="f6353-2275">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2275">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2276">Диапазон байтов, который является местом хранения для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2276">A span of bytes that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2277">Побитовое сочетание значений перечисления, которое задает поведение получения и отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2277">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <summary><span data-ttu-id="f6353-2278">Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2278">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2279">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2279">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

<span data-ttu-id="f6353-2280">Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2280">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="f6353-2281">Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2281">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>

<span data-ttu-id="f6353-2282">Эта перегрузка требует только предоставления буфера приема.</span><span class="sxs-lookup"><span data-stu-id="f6353-2282">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="f6353-2283">По умолчанию смещение буфера равно 0, размер по умолчанию равен длине параметра buffer, а <xref:System.Net.Sockets.SocketFlags> значение по умолчанию равно <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2283">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>

<span data-ttu-id="f6353-2284">Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2284">If you're using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="f6353-2285">Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2285">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2286">Если вы используете протокол без установления соединения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2286">If you're using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2287"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2287"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>

<span data-ttu-id="f6353-2288">Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2288">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2289">Когда значение времени ожидания превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов выдаст исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2289">When the time-out value is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2290">Если вы находитесь в неблокирующем режиме и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет выполнен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2290">If you're in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2291">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2291">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2292">Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2292">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>

<span data-ttu-id="f6353-2293">Если вы используете <xref:System.Net.Sockets.Socket>, ориентированную на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2293">If you're using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="f6353-2294">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2294">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>

<span data-ttu-id="f6353-2295">Если вы используете <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2295">If you're using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="f6353-2296">Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2296">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost, and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>

> [!NOTE]
> <span data-ttu-id="f6353-2297">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2297">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2298">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2298">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="f6353-2299">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2299">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2300">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2300">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2301">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2301">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2302"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2302">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-2303">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2303">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2304">для приема подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2304">for accepting connections from the network.</span></span> <span data-ttu-id="f6353-2305">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2305">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2306">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2306">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-2307">Количество байтов, которые необходимо получить.</span><span class="sxs-lookup"><span data-stu-id="f6353-2307">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2308">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2308">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="f6353-2309">Получает указанное число байтов данных из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2309">Receives the specified number of bytes of data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2310">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2310">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2311">Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметр `buffer` и возвращает число успешно считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2311">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="f6353-2312">Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2312">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="f6353-2313">Эта перегрузка требует только предоставить буфер приема, число принимаемых байтов и необходимое <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2313">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 <span data-ttu-id="f6353-2314">Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2314">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="f6353-2315">Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2315">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2316">Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2316">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2317"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2317"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="f6353-2318">Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2318">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2319">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Receive%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2319">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2320">Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2320">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2321">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2321">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2322">Если <xref:System.Net.Sockets.Socket.Available%2A> не равен нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2322">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="f6353-2323">При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до числа байтов, заданного параметром `size`.</span><span class="sxs-lookup"><span data-stu-id="f6353-2323">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="f6353-2324">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2324">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="f6353-2325">Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2325">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="f6353-2326">Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2326">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2327">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2327">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2328">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2328">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2329">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2329">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2330">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2330">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2331">Следующий пример получает данные, найденные в `buffer`, и указывает <xref:System.Net.Sockets.SocketFlags.None> для <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2331">The following receives the data found into `buffer`, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2332">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2332"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-2333">Значение <paramref name="size" /> превышает размер параметра <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2333"><paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2334">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2334">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2335"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2335">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-2336">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2336">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2337">для приема подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2337">for accepting connections from the network.</span></span> <span data-ttu-id="f6353-2338">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2338">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="f6353-2339">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих полученные данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2339">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2340">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2340">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="f6353-2341">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-2341">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="f6353-2342">Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в список приемных буферов, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2342">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2343">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2343">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2344">Этот метод считывает данные в параметр `buffers` и возвращает число успешно считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2344">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="f6353-2345">Вы можете вызывать из сокетов, ориентированных на подключение, и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2345">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="f6353-2346">Эта перегрузка требует предоставления одного или нескольких буферов приема.</span><span class="sxs-lookup"><span data-stu-id="f6353-2346">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="f6353-2347">Значение <xref:System.Net.Sockets.SocketFlags> по умолчанию равно <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2347">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="f6353-2348">Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2348">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="f6353-2349">Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с подключения к удаленному узлу, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2349">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2350">Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2350">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2351"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2351"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="f6353-2352">Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2352">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2353">Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов создает исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2353">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2354">Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2354">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2355">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2355">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2356">Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2356">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="f6353-2357">При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2357">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="f6353-2358">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2358">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="f6353-2359">Если используется <xref:System.Net.Sockets.Socket>без подключения,<xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2359">If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="f6353-2360">Если полученная датаграмма превышает размер параметра `buffers`, `buffers` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2360">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2361">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2361">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2362">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2362">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2363">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2363">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2364">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2364">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2365">Свойство <paramref name="buffers" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2365"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-2366">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2366">-or-</span></span> 
 <span data-ttu-id="f6353-2367">Значение <paramref name="buffers" />. Отсчет равен нулю.</span><span class="sxs-lookup"><span data-stu-id="f6353-2367"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2368">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2368">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2369"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2369">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2370">для приема подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2370">for accepting connections from the network.</span></span> <span data-ttu-id="f6353-2371">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2371">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2372">Диапазон байтов, который является местом хранения для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2372">A span of bytes that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2373">Побитовое сочетание значений перечисления, которое задает поведение получения и отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2373">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <param name="errorCode"><span data-ttu-id="f6353-2374">При возврате из этого метода содержит одно из значений перечисления, которое определяет коды ошибок для сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-2374">When this method returns, contains one of the enumeration values that defines error codes for the socket.</span></span></param>
        <summary><span data-ttu-id="f6353-2375">Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2375">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2376">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2376">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="f6353-2377">Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2377">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="f6353-2378">Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2378">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  

<span data-ttu-id="f6353-2379">Эта перегрузка требует только предоставления буфера приема.</span><span class="sxs-lookup"><span data-stu-id="f6353-2379">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="f6353-2380">По умолчанию смещение буфера равно 0, размер по умолчанию равен длине параметра buffer, а <xref:System.Net.Sockets.SocketFlags> значение по умолчанию равно <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2380">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  

<span data-ttu-id="f6353-2381">Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2381">If you're using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="f6353-2382">Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2382">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2383">Если вы используете протокол без установления соединения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2383">If you're using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2384"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2384"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  

<span data-ttu-id="f6353-2385">Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2385">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2386">Когда значение времени ожидания превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов выдаст исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2386">When the time-out value is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2387">Если вы находитесь в режиме без блокировки и в буфере стека протоколов нет данных, то метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2387">If you're in non-blocking mode, and there's no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2388">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2388">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2389">Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2389">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  

<span data-ttu-id="f6353-2390">Если вы используете <xref:System.Net.Sockets.Socket>, ориентированную на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2390">If you're using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="f6353-2391">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2391">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  

<span data-ttu-id="f6353-2392">Если вы используете <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2392">If you're using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="f6353-2393">Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2393">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  

> [!NOTE]
>  <span data-ttu-id="f6353-2394">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2394">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2395">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2395">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  

> [!NOTE]
>  <span data-ttu-id="f6353-2396">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2396">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2397">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2397">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2398">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2398">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2399"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2399">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-2400">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2400">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2401">для приема подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2401">for accepting connections from the network.</span></span> <span data-ttu-id="f6353-2402">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2402">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2403">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2403">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-2404">Место в объекте <paramref name="buffer" />, выделенное для хранения принимаемых данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2404">The location in <paramref name="buffer" /> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-2405">Количество байтов, которые необходимо получить.</span><span class="sxs-lookup"><span data-stu-id="f6353-2405">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2406">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2406">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="f6353-2407">Получает указанное число байтов данных из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер с указанной позиции смещения, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2407">Receives the specified number of bytes from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified offset position of the receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2408">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2408">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2409">Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2409">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="f6353-2410">Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2410">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="f6353-2411">Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2411">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="f6353-2412">Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2412">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2413">Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2413">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2414"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2414"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="f6353-2415">Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2415">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2416">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Receive%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2416">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2417">Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2417">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2418">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2418">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="f6353-2419">См. примечания ниже.</span><span class="sxs-lookup"><span data-stu-id="f6353-2419">See Remarks below.</span></span> <span data-ttu-id="f6353-2420">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2420">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2421">Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2421">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="f6353-2422">При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до числа байтов, заданного параметром size.</span><span class="sxs-lookup"><span data-stu-id="f6353-2422">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="f6353-2423">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2423">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="f6353-2424">Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2424">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="f6353-2425">Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2425">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2426">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2426">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2427">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2427">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2428">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2428">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2429">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2429">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2430">В следующем примере кода задается буфер данных, смещение, размер и флаг сокета перед получением данных на подключенном <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2430">The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2431">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2431"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-2432">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-2432"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-2433">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2433">-or-</span></span> 
 <span data-ttu-id="f6353-2434">Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2434"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-2435">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2435">-or-</span></span> 
 <span data-ttu-id="f6353-2436">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-2436"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-2437">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2437">-or-</span></span> 
 <span data-ttu-id="f6353-2438">Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2438"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2439"><paramref name="socketFlags" /> — недопустимое сочетание значений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2439"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="f6353-2440">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2440">-or-</span></span> 
<span data-ttu-id="f6353-2441">Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.</span><span class="sxs-lookup"><span data-stu-id="f6353-2441">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="f6353-2442">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2442">-or-</span></span> 
<span data-ttu-id="f6353-2443">Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2443">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2444"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2444">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-2445">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2445">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2446">для приема подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2446">for accepting connections from the network.</span></span> <span data-ttu-id="f6353-2447">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2447">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2448">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2448">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-2449">Позиция в параметре <paramref name="buffer" /> для хранения полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2449">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-2450">Количество байтов, которые необходимо получить.</span><span class="sxs-lookup"><span data-stu-id="f6353-2450">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2451">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2451">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="f6353-2452">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-2452">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="f6353-2453">Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2453">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2454">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2454">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2455">Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2455">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="f6353-2456">Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2456">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="f6353-2457">Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2457">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="f6353-2458">Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2458">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2459">Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2459">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2460"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2460"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="f6353-2461">Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2461">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2462">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Receive%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2462">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2463">Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2463">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2464">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2464">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="f6353-2465">См. примечания ниже.</span><span class="sxs-lookup"><span data-stu-id="f6353-2465">See Remarks below.</span></span> <span data-ttu-id="f6353-2466">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2466">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2467">Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2467">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="f6353-2468">При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до числа байтов, заданного параметром size.</span><span class="sxs-lookup"><span data-stu-id="f6353-2468">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="f6353-2469">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2469">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="f6353-2470">Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2470">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="f6353-2471">Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2471">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2472">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2472">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2473">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2473">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2474">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2474">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2475">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2475">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2476">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2476"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-2477">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-2477"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-2478">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2478">-or-</span></span> 
 <span data-ttu-id="f6353-2479">Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2479"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-2480">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2480">-or-</span></span> 
 <span data-ttu-id="f6353-2481">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-2481"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-2482">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2482">-or-</span></span> 
 <span data-ttu-id="f6353-2483">Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2483"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2484"><paramref name="socketFlags" /> — недопустимое сочетание значений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2484"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="f6353-2485">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2485">-or-</span></span> 
<span data-ttu-id="f6353-2486">Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.</span><span class="sxs-lookup"><span data-stu-id="f6353-2486">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is not set.</span></span>  
  
<span data-ttu-id="f6353-2487">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2487">-or-</span></span> 
<span data-ttu-id="f6353-2488">Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2488">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2489"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2489">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-2490">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2490">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2491">для приема подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2491">for accepting connections from the network.</span></span> <span data-ttu-id="f6353-2492">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2492">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f6353-2493">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-2493">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="f6353-2494">Начинает выполнение асинхронного запроса, чтобы получить данные из подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2494">Begins an asynchronous request to receive data from a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="f6353-2495"><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-2495"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="f6353-2496">По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2496">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="f6353-2497"><see langword="false" />, если операция ввода-вывода завершена синхронно.</span><span class="sxs-lookup"><span data-stu-id="f6353-2497"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="f6353-2498">В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-2498">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2499">Метод <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> используется для подключенных сокетов или связанных сокетов без подключения и используется для чтения входящих данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2499">The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</span></span> <span data-ttu-id="f6353-2500">Локальный адрес сокета должен быть известен.</span><span class="sxs-lookup"><span data-stu-id="f6353-2500">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="f6353-2501">Для привязанных сокетов без подключения эта функция ограничивает адреса, из которых принимаются принимаемые сообщения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2501">For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</span></span> <span data-ttu-id="f6353-2502">Функция возвращает только сообщения с удаленного адреса, указанного в соединении.</span><span class="sxs-lookup"><span data-stu-id="f6353-2502">The function only returns messages from the remote address specified in the connection.</span></span> <span data-ttu-id="f6353-2503">Сообщения из других адресов отбрасываются без уведомления.</span><span class="sxs-lookup"><span data-stu-id="f6353-2503">Messages from other addresses are silently discarded.</span></span>  
  
 <span data-ttu-id="f6353-2504">Свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> в параметре `e` предоставляет поставщику службы оконных сокетов дополнительные сведения о запросе на чтение.</span><span class="sxs-lookup"><span data-stu-id="f6353-2504">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="f6353-2505">Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2505">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f6353-2506">Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> необходимы для успешного вызова этого метода:</span><span class="sxs-lookup"><span data-stu-id="f6353-2506">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="f6353-2507"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> или <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="f6353-2507"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="f6353-2508"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>, если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> задано</span><span class="sxs-lookup"><span data-stu-id="f6353-2508"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="f6353-2509"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>, если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> задано</span><span class="sxs-lookup"><span data-stu-id="f6353-2509"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="f6353-2510">Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>, чтобы информация была извлечена в методе обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-2510">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="f6353-2511">Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2511">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="f6353-2512">Для сокетов типа Byte входящие данные помещаются в буфер до тех пор, пока буфер не будет заполнен, соединение будет закрыто или исчерпаны внутренние буферизованные данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2512">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span>  
  
 <span data-ttu-id="f6353-2513">Для сокетов, ориентированных на сообщения, входящее сообщение помещается в буфер вплоть до общего размера буфера, связанного с параметром `e`.</span><span class="sxs-lookup"><span data-stu-id="f6353-2513">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter.</span></span> <span data-ttu-id="f6353-2514">Если размер сообщения превышает размер буфера, буфер заполняется первой частью сообщения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2514">If the message is larger than the buffer, the buffer is filled with the first part of the message.</span></span>  
  
 <span data-ttu-id="f6353-2515">Для сокетов, ориентированных на соединение, метод <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> может указывать на корректное завершение виртуального канала одним из двух способов, которые зависят от того, является ли сокет потоком байтов или ориентированным на сообщения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2515">For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</span></span> <span data-ttu-id="f6353-2516">Для потоковых потоков нулевое число прочитанных байтов указывает на корректное закрытие и на то, что больше байтов не будет считано.</span><span class="sxs-lookup"><span data-stu-id="f6353-2516">For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</span></span> <span data-ttu-id="f6353-2517">Для сокетов, ориентированных на сообщения, где сообщение с нулевым байтом часто разрешено, <xref:System.Net.Sockets.SocketException> с <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>, настроенным на собственный код ошибки Winsock ВСАЕДИСКОН (10101), используется для указания корректного замыкания.</span><span class="sxs-lookup"><span data-stu-id="f6353-2517">For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</span></span> <span data-ttu-id="f6353-2518">В любом случае <xref:System.Net.Sockets.SocketException> с <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>, заданным кодом ошибки ВСАЕКОННРЕСЕТ в машинном коде Winsock (10054), означает, что произошло аварийное закрытие.</span><span class="sxs-lookup"><span data-stu-id="f6353-2518">In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-2519">Аргумент был недопустимым.</span><span class="sxs-lookup"><span data-stu-id="f6353-2519">An argument was invalid.</span></span> <span data-ttu-id="f6353-2520">Свойства <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> или <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> на параметре <paramref name="e" /> должны ссылаться на допустимые буферы.</span><span class="sxs-lookup"><span data-stu-id="f6353-2520">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="f6353-2521">Может быть установлено одно из этих свойств, но нельзя одновременно устанавливать оба свойства.</span><span class="sxs-lookup"><span data-stu-id="f6353-2521">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-2522">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2522">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-2523">Этот метод доступен только в Windows XP и более поздних версиях.</span><span class="sxs-lookup"><span data-stu-id="f6353-2523">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2524"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2524">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2525">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2525">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-2526">Получает или задает значение, задающее размер приемного буфера объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2526">Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="f6353-2527">Объект <see cref="T:System.Int32" />, который содержит значение размера приемного буфера в байтах.</span><span class="sxs-lookup"><span data-stu-id="f6353-2527">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the receive buffer.</span></span> <span data-ttu-id="f6353-2528">Значение по умолчанию — 8192.</span><span class="sxs-lookup"><span data-stu-id="f6353-2528">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2529">Больший размер буфера потенциально сокращает количество пустых подтверждений (пакетов TCP без данных), но может также отложить распознавание проблем с подключением.</span><span class="sxs-lookup"><span data-stu-id="f6353-2529">A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</span></span> <span data-ttu-id="f6353-2530">Если вы передаете большие файлы или используете высокоскоростное подключение с высокой задержкой (например, поставщик широкополосного подключения), попробуйте увеличить размер буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2530">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2531">В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="f6353-2531">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2532">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2532">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2533"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2533">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-2534">Значение, указанное для операции установки, меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-2534">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-2535">Получает датаграмму и сохраняет конечную точку источника.</span><span class="sxs-lookup"><span data-stu-id="f6353-2535">Receives a datagram and stores the source endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2536">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2536">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="f6353-2537">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</span><span class="sxs-lookup"><span data-stu-id="f6353-2537">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="f6353-2538">Принимает датаграмму в буфер данных и сохраняет конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-2538">Receives a datagram into the data buffer and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="f6353-2539">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2539">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2540">Метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> считывает данные в параметре `buffer`, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2540">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="f6353-2541">Этот метод полезен, если вы собираетесь принимать неподключенные датаграммы с неизвестного узла или с нескольких узлов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2541">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="f6353-2542">Эта перегрузка требует только предоставления `buffer`получения и <xref:System.Net.EndPoint>, представляющей удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-2542">This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="f6353-2543">По умолчанию смещение буфера равно 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-2543">The buffer offset defaults to 0.</span></span> <span data-ttu-id="f6353-2544">Размер по умолчанию равен длине параметра `buffer`, а `socketFlags` значение по умолчанию — <xref:System.Net.Sockets.SocketFlags.None>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2544">The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2545">Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>необходимо явно привязать <xref:System.Net.Sockets.Socket> к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.Bind%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2545">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="f6353-2546">В противном случае <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2546">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-2547">При использовании протоколов без подключения <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать первые поставленные в очередь датаграммы, полученные в буфер локальной сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2547">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="f6353-2548">Если полученная датаграмма превышает размер `buffer`, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет заполняться `buffer` с максимально возможной частью сообщения и вызывать <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2548">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2549">При использовании ненадежного протокола избыточные данные будут потеряны.</span><span class="sxs-lookup"><span data-stu-id="f6353-2549">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="f6353-2550">Если используется надежный протокол, избыточные данные будут сохранены поставщиком услуг, и его можно будет извлечь, вызвав метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> с достаточно большим буфером.</span><span class="sxs-lookup"><span data-stu-id="f6353-2550">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="f6353-2551">Если данные для чтения недоступны, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет блокироваться до тех пор, пока данные недоступны.</span><span class="sxs-lookup"><span data-stu-id="f6353-2551">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="f6353-2552">Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2552">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2553">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2553">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2554">Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2554">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="f6353-2555">Хотя <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение.</span><span class="sxs-lookup"><span data-stu-id="f6353-2555">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="f6353-2556">Если вы решили это сделать, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или добавив входящее подключение к удаленному узлу, вызвав метод <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2556">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2557">Если не установить или не принять подключение перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, будет получен <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2557">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2558">Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2558">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2559">В любом из этих случаев метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет игнорировать параметр `remoteEP` и получить данные только с подключенного или удаленного узла по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-2559">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="f6353-2560">При использовании сокетов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать столько данных, сколько доступно до размера `buffer`.</span><span class="sxs-lookup"><span data-stu-id="f6353-2560">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="f6353-2561">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2561">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2562">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2562">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2563">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2563">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2564"><xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемых в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, должны соответствовать <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемого в <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2564">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2565">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2565">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2566">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2566">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2567">Следующий пример кода получает датаграмму без подключения от удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2567">The following code example receives a connectionless datagram from a remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2568">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2568"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-2569">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2569">-or-</span></span> 
 <span data-ttu-id="f6353-2570">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2570"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2571">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2571">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2572"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2572">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-2573">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2573">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2574">для приема подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2574">for accepting connections from the network.</span></span> <span data-ttu-id="f6353-2575">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2575">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2576">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2576">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2577">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2577">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="f6353-2578">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</span><span class="sxs-lookup"><span data-stu-id="f6353-2578">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="f6353-2579">Принимает датаграмму в буфер данных, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />, и сохраняет конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-2579">Receives a datagram into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="f6353-2580">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2580">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2581">Метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> считывает данные в параметре `buffer`, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2581">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="f6353-2582">Этот метод полезен, если вы собираетесь принимать неподключенные датаграммы с неизвестного узла или с нескольких узлов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2582">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="f6353-2583">Эта перегрузка требует только предоставления приемного буфера, необходимого <xref:System.Net.Sockets.SocketFlags>и <xref:System.Net.EndPoint>, представляющего удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-2583">This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="f6353-2584">Смещение по умолчанию равно 0, а размер по умолчанию равен длине параметра buffer.</span><span class="sxs-lookup"><span data-stu-id="f6353-2584">The offset defaults to 0 and the size defaults to the length of the buffer parameter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2585">Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>необходимо явно привязать <xref:System.Net.Sockets.Socket> к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.Bind%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2585">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="f6353-2586">В противном случае <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2586">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-2587">При использовании протоколов без подключения <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать первые поставленные в очередь датаграммы, полученные в буфер локальной сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2587">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="f6353-2588">Если полученная датаграмма превышает размер `buffer`, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет заполняться `buffer` с максимально возможной частью сообщения и вызывать <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2588">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2589">При использовании ненадежного протокола избыточные данные будут потеряны.</span><span class="sxs-lookup"><span data-stu-id="f6353-2589">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="f6353-2590">Если используется надежный протокол, избыточные данные будут сохранены поставщиком услуг, и его можно будет извлечь, вызвав метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> с достаточно большим буфером.</span><span class="sxs-lookup"><span data-stu-id="f6353-2590">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="f6353-2591">Если данные для чтения недоступны, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет блокироваться до тех пор, пока данные недоступны.</span><span class="sxs-lookup"><span data-stu-id="f6353-2591">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="f6353-2592">Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2592">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2593">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2593">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2594">Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2594">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="f6353-2595">Хотя <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение.</span><span class="sxs-lookup"><span data-stu-id="f6353-2595">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="f6353-2596">Если вы решили это сделать, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или добавив входящее подключение к удаленному узлу, вызвав метод <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2596">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2597">Если не установить или не принять подключение перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, будет получен <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2597">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2598">Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2598">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2599">В любом из этих случаев метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет игнорировать параметр `remoteEP` и получить данные только с подключенного или удаленного узла по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-2599">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="f6353-2600">При использовании сокетов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать столько данных, сколько доступно до размера `buffer`.</span><span class="sxs-lookup"><span data-stu-id="f6353-2600">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="f6353-2601">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2601">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2602">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2602">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2603">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2603">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2604"><xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемых в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, должны соответствовать <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемого в <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2604">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2605">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2605">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2606">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2606">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2607">Следующий пример кода получает датаграмму без подключения от удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2607">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="f6353-2608"><xref:System.Net.Sockets.SocketFlags> передаются методу <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2608"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2609">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2609"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-2610">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2610">-or-</span></span> 
 <span data-ttu-id="f6353-2611">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2611"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2612">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2612">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2613"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2613">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-2614">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2614">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2615">для приема подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2615">for accepting connections from the network.</span></span> <span data-ttu-id="f6353-2616">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2616">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2617">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2617">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-2618">Количество байтов, которые необходимо получить.</span><span class="sxs-lookup"><span data-stu-id="f6353-2618">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2619">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2619">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="f6353-2620">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</span><span class="sxs-lookup"><span data-stu-id="f6353-2620">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="f6353-2621">Получает указанное число байтов во входной буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />, и сохраняет конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-2621">Receives the specified number of bytes into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="f6353-2622">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2622">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2623">Метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> считывает данные в параметре `buffer`, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2623">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="f6353-2624">Этот метод полезен, если вы собираетесь принимать неподключенные датаграммы с неизвестного узла или с нескольких узлов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2624">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="f6353-2625">Эта перегрузка требует только предоставления буфера приема, числа принимаемых байтов, необходимого <xref:System.Net.Sockets.SocketFlags>и <xref:System.Net.EndPoint>, представляющего удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-2625">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="f6353-2626">По умолчанию смещение буфера равно 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-2626">The buffer offset defaults to 0.</span></span>  
  
 <span data-ttu-id="f6353-2627">При использовании протоколов без подключения <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать первые поставленные в очередь датаграммы, полученные в буфер локальной сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2627">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="f6353-2628">Если полученная датаграмма превышает размер `buffer`, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет заполняться `buffer` с максимально возможной частью сообщения и вызывать <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2628">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2629">При использовании ненадежного протокола избыточные данные будут потеряны.</span><span class="sxs-lookup"><span data-stu-id="f6353-2629">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="f6353-2630">Если используется надежный протокол, избыточные данные будут сохранены поставщиком услуг, и его можно будет извлечь, вызвав метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> с достаточно большим буфером.</span><span class="sxs-lookup"><span data-stu-id="f6353-2630">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="f6353-2631">Если данные для чтения недоступны, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет блокироваться до тех пор, пока данные недоступны.</span><span class="sxs-lookup"><span data-stu-id="f6353-2631">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="f6353-2632">Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2632">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2633">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2633">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2634">Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2634">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="f6353-2635">Хотя <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение.</span><span class="sxs-lookup"><span data-stu-id="f6353-2635">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="f6353-2636">Если вы решили это сделать, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или добавив входящее подключение к удаленному узлу, вызвав метод <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2636">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2637">Если не установить или не принять подключение перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, будет получен <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2637">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2638">Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2638">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2639">В любом из этих случаев метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет игнорировать параметр `remoteEP` и получить данные только с подключенного или удаленного узла по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-2639">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="f6353-2640">При использовании сокетов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать столько данных, сколько доступно до числа байтов, указанного параметром `size`.</span><span class="sxs-lookup"><span data-stu-id="f6353-2640">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="f6353-2641">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2641">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2642">Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>необходимо явно привязать <xref:System.Net.Sockets.Socket> к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.Bind%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2642">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="f6353-2643">В противном случае <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2643">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2644">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2644">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2645">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2645">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2646"><xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемых в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, должны соответствовать <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемого в <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2646">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2647">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2647">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2648">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2648">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2649">Следующий пример кода получает датаграмму без подключения от удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2649">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="f6353-2650">Размер буфера и <xref:System.Net.Sockets.SocketFlags> передаются методу <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2650">The buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2651">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2651"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-2652">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2652">-or-</span></span> 
 <span data-ttu-id="f6353-2653">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2653"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-2654">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-2654"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-2655">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2655">-or-</span></span> 
 <span data-ttu-id="f6353-2656">Значение<paramref name="size" /> превышает длину <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2656"><paramref name="size" /> is greater than the length of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2657"><paramref name="socketFlags" /> — недопустимое сочетание значений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2657"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="f6353-2658">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2658">-or-</span></span> 
<span data-ttu-id="f6353-2659">Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.</span><span class="sxs-lookup"><span data-stu-id="f6353-2659">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="f6353-2660">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2660">-or-</span></span> 
<span data-ttu-id="f6353-2661">Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2661">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2662"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2662">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-2663">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2663">A caller in the call stack does not have the required permissions.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2664">для приема подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2664">for accepting connections from the network.</span></span> <span data-ttu-id="f6353-2665">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2665">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2666">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2666">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-2667">Позиция в параметре <paramref name="buffer" /> для хранения полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2667">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-2668">Количество байтов, которые необходимо получить.</span><span class="sxs-lookup"><span data-stu-id="f6353-2668">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2669">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2669">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="f6353-2670">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</span><span class="sxs-lookup"><span data-stu-id="f6353-2670">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="f6353-2671">Получает указанное число байтов данных в заданном расположении буфера данных с использованием определенного параметра <see cref="T:System.Net.Sockets.SocketFlags" /> и сохраняет конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-2671">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="f6353-2672">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2672">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2673">Метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> считывает данные в параметре `buffer`, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2673">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="f6353-2674">Этот метод полезен, если вы собираетесь принимать неподключенные датаграммы с неизвестного узла или с нескольких узлов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2674">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="f6353-2675">При использовании протоколов без подключения <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать первые поставленные в очередь датаграммы, полученные в буфер локальной сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2675">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="f6353-2676">Если полученная датаграмма превышает размер `buffer`, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет заполняться `buffer` с максимально возможной частью сообщения и вызывать <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2676">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2677">При использовании ненадежного протокола избыточные данные будут потеряны.</span><span class="sxs-lookup"><span data-stu-id="f6353-2677">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="f6353-2678">Если используется надежный протокол, избыточные данные будут сохранены поставщиком услуг, и его можно будет извлечь, вызвав метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> с достаточно большим буфером.</span><span class="sxs-lookup"><span data-stu-id="f6353-2678">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="f6353-2679">Если данные для чтения недоступны, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет блокироваться до тех пор, пока данные недоступны.</span><span class="sxs-lookup"><span data-stu-id="f6353-2679">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="f6353-2680">Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2680">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2681">Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2681">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="f6353-2682">Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2682">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="f6353-2683">Хотя <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение.</span><span class="sxs-lookup"><span data-stu-id="f6353-2683">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="f6353-2684">Если вы решили это сделать, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или добавив входящее подключение к удаленному узлу, вызвав метод <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2684">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-2685">Если не установить или не принять подключение перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, будет получен <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2685">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2686">Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2686">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="f6353-2687">В любом из этих случаев метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет игнорировать параметр `remoteEP` и получить данные только с подключенного или удаленного узла по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-2687">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="f6353-2688">При использовании сокетов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать столько данных, сколько доступно в байтах, заданных параметром `size`.</span><span class="sxs-lookup"><span data-stu-id="f6353-2688">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="f6353-2689">Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и возвращать нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2689">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2690">Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>необходимо явно привязать <xref:System.Net.Sockets.Socket> к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.Bind%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2690">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="f6353-2691">В противном случае <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2691">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2692">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2692">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2693">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2693">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2694"><xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемых в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, должны соответствовать <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемого в <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2694">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2695">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2695">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2696">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2696">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2697">Следующий пример кода получает датаграмму без подключения от удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2697">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="f6353-2698">Смещение, размер буфера и <xref:System.Net.Sockets.SocketFlags> передаются методу <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2698">The offset, buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2699">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2699"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-2700">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2700">-or-</span></span> 
 <span data-ttu-id="f6353-2701">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2701"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-2702">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-2702"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-2703">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2703">-or-</span></span> 
 <span data-ttu-id="f6353-2704">Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2704"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-2705">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2705">-or-</span></span> 
 <span data-ttu-id="f6353-2706">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-2706"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-2707">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2707">-or-</span></span> 
 <span data-ttu-id="f6353-2708">Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра смещения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2708"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2709"><paramref name="socketFlags" /> — недопустимое сочетание значений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2709"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="f6353-2710">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2710">-or-</span></span> 
<span data-ttu-id="f6353-2711">Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.</span><span class="sxs-lookup"><span data-stu-id="f6353-2711">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="f6353-2712">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2712">-or-</span></span> 
<span data-ttu-id="f6353-2713">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2713">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2714"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2714">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2715">для приема подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2715">for accepting connections from the network.</span></span> <span data-ttu-id="f6353-2716">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2716">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f6353-2717">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-2717">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="f6353-2718">Начинает выполнение асинхронного приема данных с указанного сетевого устройства.</span><span class="sxs-lookup"><span data-stu-id="f6353-2718">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="f6353-2719"><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-2719"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="f6353-2720">По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2720">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="f6353-2721"><see langword="false" />, если операция ввода-вывода завершена синхронно.</span><span class="sxs-lookup"><span data-stu-id="f6353-2721"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="f6353-2722">В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-2722">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2723">Метод <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> используется в основном для получения данных в сокете без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2723">The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket.</span></span> <span data-ttu-id="f6353-2724">Локальный адрес сокета должен быть известен.</span><span class="sxs-lookup"><span data-stu-id="f6353-2724">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="f6353-2725">Вызывающий объект должен присвоить свойству <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> <xref:System.Net.IPEndPoint> удаленного узла, от которого должны быть получены данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2725">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="f6353-2726">Свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> в параметре `e` предоставляет поставщику службы оконных сокетов дополнительные сведения о запросе на чтение.</span><span class="sxs-lookup"><span data-stu-id="f6353-2726">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="f6353-2727">Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2727">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f6353-2728">Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> необходимы для успешного вызова этого метода:</span><span class="sxs-lookup"><span data-stu-id="f6353-2728">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="f6353-2729">Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>, чтобы информация была извлечена в методе обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-2729">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="f6353-2730">Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2730">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="f6353-2731">Для сокетов, ориентированных на сообщения, входящее сообщение помещается в буфер вплоть до общего размера буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2731">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="f6353-2732">Свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> и <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> определяют место размещения данных в буфере и объем данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2732">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="f6353-2733">Для сокетов типа Byte входящие данные помещаются в буфер до тех пор, пока буфер не будет заполнен, соединение будет закрыто или исчерпаны внутренние буферизованные данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2733">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span> <span data-ttu-id="f6353-2734">Свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> и <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> определяют место размещения данных в буфере и объем данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2734">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2735">Объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не может иметь значение "null".</span><span class="sxs-lookup"><span data-stu-id="f6353-2735">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-2736">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2736">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-2737">Этот метод доступен только в Windows XP и более поздних версиях.</span><span class="sxs-lookup"><span data-stu-id="f6353-2737">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2738"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2738">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2739">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2739">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2740">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2740">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-2741">Позиция в параметре <paramref name="buffer" /> для хранения полученных данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2741">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-2742">Количество байтов, которые необходимо получить.</span><span class="sxs-lookup"><span data-stu-id="f6353-2742">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2743">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2743">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="f6353-2744">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</span><span class="sxs-lookup"><span data-stu-id="f6353-2744">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="f6353-2745"><see cref="T:System.Net.Sockets.IPPacketInformation" /> сохраняет адрес и сведения об интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="f6353-2745">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> holding address and interface information.</span></span></param>
        <summary><span data-ttu-id="f6353-2746">Получает указанное число байтов данных в указанное расположение буфера данных с помощью заданного <see cref="T:System.Net.Sockets.SocketFlags" /> и сохраняет конечную точку и сведения о пакете.</span><span class="sxs-lookup"><span data-stu-id="f6353-2746">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="f6353-2747">Количество полученных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2747">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2748">Метод <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> считывает данные в параметре `buffer`, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные, а также сведения о полученных пакетах.</span><span class="sxs-lookup"><span data-stu-id="f6353-2748">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</span></span>  
  
 <span data-ttu-id="f6353-2749">Метод <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> используется в основном для получения данных сообщений в сокете без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2749">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="f6353-2750">Локальный адрес сокета должен быть известен.</span><span class="sxs-lookup"><span data-stu-id="f6353-2750">The socket's local address must be known.</span></span> <span data-ttu-id="f6353-2751">Этот метод может использоваться только с датаграммами и необработанными сокетами.</span><span class="sxs-lookup"><span data-stu-id="f6353-2751">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="f6353-2752">Перед вызовом этого метода сокет должен быть инициализирован с типом сокета, равным <xref:System.Net.Sockets.SocketType.Dgram> или <xref:System.Net.Sockets.SocketType.Raw>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2752">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="f6353-2753">Это можно сделать при создании сокета с помощью <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2753">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="f6353-2754">Для сокетов, ориентированных на сообщения, входящее сообщение помещается в параметр `buffer` вплоть до общего размера, указанного в параметре `size`.</span><span class="sxs-lookup"><span data-stu-id="f6353-2754">For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter.</span></span> <span data-ttu-id="f6353-2755">Параметр `offset` определяет, где в `buffer` размещаются данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2755">The `offset` parameter determines where in the `buffer` the data is placed.</span></span> <span data-ttu-id="f6353-2756">Фактический объем данных, помещаемых в `buffer`, возвращается методом <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2756">The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-2757">Метод <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Method автоматически задает для параметра <xref:System.Net.Sockets.SocketOptionName.PacketInformation> сокета значение `true` при первом вызове для данного <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2757">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-2758">Однако возвращенный объект <xref:System.Net.Sockets.IPPacketInformation> будет действителен только для пакетов, поступающих на локальный компьютер после установки параметра сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-2758">However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="f6353-2759">Если сокет отправляет пакеты между моментом привязки к локальной конечной точке (явно методом <xref:System.Net.Sockets.Socket.Bind%2A> или неявно одним из методов <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>или <xref:System.Net.Sockets.Socket.SendToAsync%2A>) и первым вызовом метода <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>, вызовы метода <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> будут возвращать недопустимые объекты <xref:System.Net.Sockets.IPPacketInformation> для этих пакетов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2759">If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="f6353-2760">Чтобы обеспечить допустимость всех <xref:System.Net.Sockets.IPPacketInformation> объектов, приложение должно установить параметр <xref:System.Net.Sockets.SocketOptionName.PacketInformation> сокета для `true` перед привязкой к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2760">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="f6353-2761">Приложение может проверить параметр `ipPacketInformation`, если необходимо узнать, была ли датаграмма отправлена с помощью одноадресного, многоадресного или широковещательного адреса.</span><span class="sxs-lookup"><span data-stu-id="f6353-2761">An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2762"><xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемых в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, должны соответствовать <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемого в <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2762">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2763">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2763">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2764">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2764">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2765">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2765"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-2766">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2766">-or-</span></span> 
 <span data-ttu-id="f6353-2767">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2767"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-2768">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-2768"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-2769">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2769">-or-</span></span> 
 <span data-ttu-id="f6353-2770">Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2770"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-2771">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2771">-or-</span></span> 
 <span data-ttu-id="f6353-2772">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-2772"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-2773">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2773">-or-</span></span> 
 <span data-ttu-id="f6353-2774">Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра смещения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2774"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2775"><paramref name="socketFlags" /> — недопустимое сочетание значений.</span><span class="sxs-lookup"><span data-stu-id="f6353-2775"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="f6353-2776">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2776">-or-</span></span> 
<span data-ttu-id="f6353-2777">Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.</span><span class="sxs-lookup"><span data-stu-id="f6353-2777">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="f6353-2778">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2778">-or-</span></span> 
<span data-ttu-id="f6353-2779">Платформа .NET Framework выполняется на 64-разрядном процессоре AMD.</span><span class="sxs-lookup"><span data-stu-id="f6353-2779">The .NET Framework is running on an AMD 64-bit processor.</span></span>  
  
<span data-ttu-id="f6353-2780">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-2780">-or-</span></span> 
<span data-ttu-id="f6353-2781">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2781">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2782"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2782">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-2783">Используется операционная система Windows 2000 или более ранняя версия, а для этого метода необходима операционная система Windows XP.</span><span class="sxs-lookup"><span data-stu-id="f6353-2783">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</span></span></exception>
        <permission cref="T:System.Net.SocketPermission"><span data-ttu-id="f6353-2784">для приема подключений из сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2784">for accepting connections from the network.</span></span> <span data-ttu-id="f6353-2785">Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2785">Associated enumeration: <see cref="F:System.Net.NetworkAccess.Accept" />.</span></span></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f6353-2786">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-2786">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="f6353-2787">Начинает асинхронный прием заданного числа байтов данных в указанное место буфера данных, используя заданный объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, а также сохраняет конечную точку и информацию пакета.</span><span class="sxs-lookup"><span data-stu-id="f6353-2787">Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="f6353-2788"><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-2788"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="f6353-2789">По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2789">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="f6353-2790"><see langword="false" />, если операция ввода-вывода завершена синхронно.</span><span class="sxs-lookup"><span data-stu-id="f6353-2790"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="f6353-2791">В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-2791">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2792">Метод <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> используется в основном для получения данных сообщений в сокете без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2792">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="f6353-2793">Локальный адрес сокета должен быть известен.</span><span class="sxs-lookup"><span data-stu-id="f6353-2793">The socket's local address must be known.</span></span> <span data-ttu-id="f6353-2794">Этот метод может использоваться только с датаграммами и необработанными сокетами.</span><span class="sxs-lookup"><span data-stu-id="f6353-2794">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="f6353-2795">Перед вызовом этого метода сокет должен быть инициализирован с типом сокета, равным <xref:System.Net.Sockets.SocketType.Dgram> или <xref:System.Net.Sockets.SocketType.Raw>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2795">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="f6353-2796">Это можно сделать при создании сокета с помощью <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2796">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="f6353-2797">Вызывающий объект должен присвоить свойству <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> <xref:System.Net.IPEndPoint> удаленного узла, от которого должны быть получены данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2797">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="f6353-2798">Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> необходимы для успешного вызова этого метода:</span><span class="sxs-lookup"><span data-stu-id="f6353-2798">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="f6353-2799">Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>, чтобы информация была извлечена в методе обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-2799">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="f6353-2800">Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2800">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="f6353-2801">Для сокетов, ориентированных на сообщения, входящее сообщение помещается в буфер вплоть до общего размера буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2801">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="f6353-2802">Свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> и <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> определяют место размещения данных в буфере и объем данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-2802">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="f6353-2803">Метод <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> автоматически задает для параметра <xref:System.Net.Sockets.SocketOptionName.PacketInformation> сокета значение `true` при первом вызове для данного <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2803">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-2804">Однако объект <xref:System.Net.Sockets.IPPacketInformation> будет действителен только для пакетов, поступающих на локальный компьютер после установки параметра сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-2804">However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="f6353-2805">Если сокет отправляет пакеты между моментом привязки сокета к локальной конечной точке (явно методом <xref:System.Net.Sockets.Socket.Bind%2A> или неявно по одному из методов <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>или <xref:System.Net.Sockets.Socket.SendToAsync%2A>) и при первом вызове метода <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>, вызовы метода <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> приведут к недопустимым <xref:System.Net.Sockets.IPPacketInformation> объектам для этих пакетов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2805">If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="f6353-2806">Чтобы обеспечить допустимость всех <xref:System.Net.Sockets.IPPacketInformation> объектов, приложение должно установить параметр <xref:System.Net.Sockets.SocketOptionName.PacketInformation> сокета для`true` перед привязкой к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2806">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="f6353-2807">Приложение может проверить результирующие <xref:System.Net.Sockets.IPPacketInformation> объекты, если необходимо узнать, была ли датаграмма отправлена с помощью одноадресной рассылки, многоадресной рассылки или широковещательной рассылки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2807">An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2808">Объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не может иметь значение "null".</span><span class="sxs-lookup"><span data-stu-id="f6353-2808">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-2809">Этот метод доступен только в Windows XP и более поздних версиях.</span><span class="sxs-lookup"><span data-stu-id="f6353-2809">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2810"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2810">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2811">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2811">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-2812">Получает или устанавливает значение, указывающее промежуток времени, после которого для синхронного вызова <see cref="Overload:System.Net.Sockets.Socket.Receive" /> истечет время тайм-аута.</span><span class="sxs-lookup"><span data-stu-id="f6353-2812">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="f6353-2813">Значение времени ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="f6353-2813">The time-out value, in milliseconds.</span></span> <span data-ttu-id="f6353-2814">По умолчанию используется значение 0, указывающее на бесконечное значение интервала для тайм-аута</span><span class="sxs-lookup"><span data-stu-id="f6353-2814">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="f6353-2815">Задание значения -1 также указывает на бесконечное значение интервала для тайм-аута.</span><span class="sxs-lookup"><span data-stu-id="f6353-2815">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2816">Этот параметр применяется только к синхронным вызовам <xref:System.Net.Sockets.Socket.Receive%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2816">This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only.</span></span> <span data-ttu-id="f6353-2817">При превышении времени ожидания метод <xref:System.Net.Sockets.Socket.Receive%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2817">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2818">В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="f6353-2818">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2819">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2819">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2820"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2820">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-2821">Значение, указанное для операции задания, меньше –1.</span><span class="sxs-lookup"><span data-stu-id="f6353-2821">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-2822">Возвращает удаленную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-2822">Gets the remote endpoint.</span></span></summary>
        <value><span data-ttu-id="f6353-2823">Объект <see cref="T:System.Net.EndPoint" />, с которым взаимодействует объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2823">The <see cref="T:System.Net.EndPoint" /> with which the <see cref="T:System.Net.Sockets.Socket" /> is communicating.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2824">Если используется протокол, ориентированный на соединение, свойство <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> получает <xref:System.Net.EndPoint>, содержащий удаленный IP-адрес и номер порта, к которому подключена <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2824">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected.</span></span> <span data-ttu-id="f6353-2825">Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> содержит удаленный IP-адрес по умолчанию и номер порта, с которым будет взаимодействовать <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2825">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate.</span></span> <span data-ttu-id="f6353-2826">Перед получением каких-либо сведений необходимо привести этот <xref:System.Net.EndPoint> к <xref:System.Net.IPEndPoint>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2826">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="f6353-2827">Затем можно вызвать метод <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> для получения удаленного <xref:System.Net.IPAddress>и метод <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> для получения номера удаленного порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-2827">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the remote port number.</span></span>  
  
 <span data-ttu-id="f6353-2828"><xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> задается после вызова либо <xref:System.Net.Sockets.Socket.Accept%2A>, либо <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2828">The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-2829">Если попытаться получить доступ к этому свойству ранее, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2829">If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2830">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2830">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2831">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2831">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2832">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2832">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2833">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2833">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2834">В следующем примере кода извлекаются и отображаются локальные и удаленные конечные точки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2834">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2835">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2835">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2836"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2836">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-2837">Получает <see cref="T:System.Net.Sockets.SafeSocketHandle" />, представляющий дескриптор сокета, инкапсулируемый текущим объектом <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2837">Gets a <see cref="T:System.Net.Sockets.SafeSocketHandle" /> that represents the socket handle that the current <see cref="T:System.Net.Sockets.Socket" /> object encapsulates.</span></span></summary>
        <value><span data-ttu-id="f6353-2838">Открытый в безопасном режиме обработчик сокета, который инкапсулирует текущий объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2838">A socket handle exposed in a safe manner for the socket that the current <see cref="T:System.Net.Sockets.Socket" /> object encapsulates.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!IMPORTANT]
> <span data-ttu-id="f6353-2839">Использование <xref:System.Net.Sockets.SafeSocketHandle> для прямого взаимодействия с сокетом может привести к недокументированному состоянию.</span><span class="sxs-lookup"><span data-stu-id="f6353-2839">Using the <xref:System.Net.Sockets.SafeSocketHandle> to operate on the socket directly may result in an undocumented state.</span></span> 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="checkRead"><span data-ttu-id="f6353-2840"><see cref="T:System.Collections.IList" /> экземпляров <see cref="T:System.Net.Sockets.Socket" /> для проверки удобства чтения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2840">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for readability.</span></span></param>
        <param name="checkWrite"><span data-ttu-id="f6353-2841"><see cref="T:System.Collections.IList" /> экземпляров <see cref="T:System.Net.Sockets.Socket" /> для проверки удобства ведения записи.</span><span class="sxs-lookup"><span data-stu-id="f6353-2841">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for writability.</span></span></param>
        <param name="checkError"><span data-ttu-id="f6353-2842"><see cref="T:System.Collections.IList" /> экземпляров <see cref="T:System.Net.Sockets.Socket" /> для проверки ошибок.</span><span class="sxs-lookup"><span data-stu-id="f6353-2842">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for errors.</span></span></param>
        <param name="microSeconds"><span data-ttu-id="f6353-2843">Значение времени ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="f6353-2843">The time-out value, in microseconds.</span></span> <span data-ttu-id="f6353-2844">Значение -1 указывает на бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-2844">A -1 value indicates an infinite time-out.</span></span></param>
        <summary><span data-ttu-id="f6353-2845">Определяет состояние одного или нескольких сокетов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2845">Determines the status of one or more sockets.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2846"><xref:System.Net.Sockets.Socket.Select%2A> является статическим методом, который определяет состояние одного или нескольких экземпляров <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2846"><xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances.</span></span> <span data-ttu-id="f6353-2847">Перед использованием метода <xref:System.Net.Sockets.Socket.Select%2A> необходимо поместить один или несколько сокетов в <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2847">You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span> <span data-ttu-id="f6353-2848">Проверьте наличие удобочитаемости, вызвав <xref:System.Net.Sockets.Socket.Select%2A> с <xref:System.Collections.IList> в качестве параметра `checkRead`.</span><span class="sxs-lookup"><span data-stu-id="f6353-2848">Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter.</span></span> <span data-ttu-id="f6353-2849">Чтобы проверить сокеты для записи, используйте параметр `checkWrite`.</span><span class="sxs-lookup"><span data-stu-id="f6353-2849">To check your sockets for writability, use the `checkWrite` parameter.</span></span> <span data-ttu-id="f6353-2850">Для обнаружения условий возникновения ошибок используйте `checkError`.</span><span class="sxs-lookup"><span data-stu-id="f6353-2850">For detecting error conditions, use `checkError`.</span></span> <span data-ttu-id="f6353-2851">После вызова <xref:System.Net.Sockets.Socket.Select%2A><xref:System.Collections.IList> будут заполнены только теми сокетами, которые отвечают условиям.</span><span class="sxs-lookup"><span data-stu-id="f6353-2851">After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.</span></span>  
  
 <span data-ttu-id="f6353-2852">В состоянии прослушивания удобочитаемость означает, что вызов <xref:System.Net.Sockets.Socket.Accept%2A> будет выполняться без блокировки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2852">If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking.</span></span> <span data-ttu-id="f6353-2853">Если вы уже приняли подключение, удобочитаемость означает, что данные доступны для чтения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2853">If you have already accepted the connection, readability means that data is available for reading.</span></span> <span data-ttu-id="f6353-2854">В таких случаях все операции получения будут выполняться без блокировки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2854">In these cases, all receive operations will succeed without blocking.</span></span> <span data-ttu-id="f6353-2855">Удобочитаемость может также указывать, завершил ли удаленный <xref:System.Net.Sockets.Socket> подключение. в этом случае вызов <xref:System.Net.Sockets.Socket.Receive%2A> будет немедленно возвращать, при этом возвращаются нулевые байты.</span><span class="sxs-lookup"><span data-stu-id="f6353-2855">Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.</span></span>  
  
 <span data-ttu-id="f6353-2856"><xref:System.Net.Sockets.Socket.Select%2A> возвращает, когда по крайней мере один из нужных сокетов (сокеты в списках `checkRead`, `checkWrite`и `checkError`) соответствует заданным условиям, или превышено значение параметра `microSeconds`, в зависимости от того, что происходит раньше.</span><span class="sxs-lookup"><span data-stu-id="f6353-2856"><xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first.</span></span> <span data-ttu-id="f6353-2857">При установке `microSeconds` в значение-1 указывается бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-2857">Setting `microSeconds` to -1 specifies an infinite time-out.</span></span>  
  
 <span data-ttu-id="f6353-2858">Если вы сделаете неблокирующий вызов <xref:System.Net.Sockets.Socket.Connect%2A>, записи означает, что подключение выполнено успешно.</span><span class="sxs-lookup"><span data-stu-id="f6353-2858">If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully.</span></span> <span data-ttu-id="f6353-2859">Если соединение уже установлено, записи означает, что все операции отправки будут выполнены без блокировки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2859">If you already have a connection established, writability means that all send operations will succeed without blocking.</span></span>  
  
 <span data-ttu-id="f6353-2860">Если вы выполнили неблокирующий вызов <xref:System.Net.Sockets.Socket.Connect%2A>, параметр `checkerror` определяет сокеты, которые не были успешно подключены.</span><span class="sxs-lookup"><span data-stu-id="f6353-2860">If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2861">Если требуется только определить состояние одного <xref:System.Net.Sockets.Socket>, используйте метод <xref:System.Net.Sockets.Socket.Poll%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2861">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2862">Этот метод не может обнаружить некоторые виды проблем с подключением, например обрыв сетевого кабеля или некорректное завершение работы удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="f6353-2862">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="f6353-2863">Необходимо попытаться отправить или получить данные для обнаружения ошибок этих типов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2863">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2864">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2864">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2865">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2865">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2866">В следующем примере кода используется <xref:System.Net.Sockets.Socket.Select%2A>, чтобы определить, какие сокеты прослушивания имеют запрос на соединение.</span><span class="sxs-lookup"><span data-stu-id="f6353-2866">The following code example uses <xref:System.Net.Sockets.Socket.Select%2A> to determine which listening sockets have a connection request.</span></span>  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2867">Параметр <paramref name="checkRead" /> имеет значение <see langword="null" /> или является пустым.</span><span class="sxs-lookup"><span data-stu-id="f6353-2867">The <paramref name="checkRead" /> parameter is <see langword="null" /> or empty.</span></span>  
  
<span data-ttu-id="f6353-2868">- и -</span><span class="sxs-lookup"><span data-stu-id="f6353-2868">-and-</span></span> 
<span data-ttu-id="f6353-2869">Параметр <paramref name="checkWrite" /> имеет значение <see langword="null" /> или является пустым.</span><span class="sxs-lookup"><span data-stu-id="f6353-2869">The <paramref name="checkWrite" /> parameter is <see langword="null" /> or empty</span></span> 
<span data-ttu-id="f6353-2870">- и -</span><span class="sxs-lookup"><span data-stu-id="f6353-2870">-and-</span></span> 
<span data-ttu-id="f6353-2871">Параметр <paramref name="checkError" /> имеет значение <see langword="null" /> или является пустым.</span><span class="sxs-lookup"><span data-stu-id="f6353-2871">The <paramref name="checkError" /> parameter is <see langword="null" /> or empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2872">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2872">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-2873">Передает данные в подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2873">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2874">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2874">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="f6353-2875">Передает данные в подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2875">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2876">Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2876">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2877"><xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2877"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="f6353-2878"><xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2878"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="f6353-2879">Для этой перегрузки требуется буфер, содержащий данные, которые необходимо отправить.</span><span class="sxs-lookup"><span data-stu-id="f6353-2879">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="f6353-2880">Значение <xref:System.Net.Sockets.SocketFlags> по умолчанию равно 0, смещение буфера по умолчанию равно 0, а число байтов для отправки по умолчанию равно размеру буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2880">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>  
  
 <span data-ttu-id="f6353-2881">Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2881">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2882">Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2882">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="f6353-2883">Если вы используете протокол без подключения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2883">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="f6353-2884">Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2884">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="f6353-2885">Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2885">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-2886">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2886">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="f6353-2887">Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2887">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2888">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2888">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2889">В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может быть успешно завершен даже при отправке меньшего числа байтов в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-2889">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="f6353-2890">Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-2890">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="f6353-2891">Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2891">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-2892">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-2892">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-2893">Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-2893">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2894">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2894">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2895">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2895">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2896">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-2896">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-2897">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-2897">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2898">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2898">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2899">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2899">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2900">В следующем примере кода показано, как отправлять данные на подключенном <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2900">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2901">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2901"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2902">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2902">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2903"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2903">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="f6353-2904">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих данные для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2904">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="f6353-2905">Отправляет набор буферов в список на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2905">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2906">Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2906">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2907"><xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2907"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="f6353-2908">Для этой перегрузки требуется по крайней мере один буфер, содержащий данные, которые необходимо отправить.</span><span class="sxs-lookup"><span data-stu-id="f6353-2908">This overload requires at least one buffer that contains the data you want to send.</span></span>  
  
 <span data-ttu-id="f6353-2909">Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2909">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2910">Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2910">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="f6353-2911">Если вы используете протокол без подключения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2911">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="f6353-2912">Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2912">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="f6353-2913">Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2913">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-2914">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2914">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="f6353-2915">Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2915">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2916">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2916">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2917">В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может быть успешно завершен даже при отправке меньшего числа байтов в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-2917">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="f6353-2918">Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-2918">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="f6353-2919">Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2919">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-2920">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-2920">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-2921">Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-2921">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2922">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2922">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2923">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2923">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2924">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-2924">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-2925">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-2925">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2926">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2926">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2927">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2927">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2928">Свойство <paramref name="buffers" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2928"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-2929">Параметр <paramref name="buffers" /> пуст.</span><span class="sxs-lookup"><span data-stu-id="f6353-2929"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2930">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2930">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="f6353-2931">См. ниже примeчания к данному разделу.</span><span class="sxs-lookup"><span data-stu-id="f6353-2931">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2932"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2932">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2933">Диапазон байтов, содержащий отправляемые данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-2933">A span of bytes that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="f6353-2934">Передает данные в подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2934">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2935">Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2935">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="f6353-2936"><xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2936"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="f6353-2937"><xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2937"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>

<span data-ttu-id="f6353-2938">Для этой перегрузки требуется буфер, содержащий данные, которые необходимо отправить.</span><span class="sxs-lookup"><span data-stu-id="f6353-2938">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="f6353-2939">Значение <xref:System.Net.Sockets.SocketFlags> по умолчанию равно 0, смещение буфера по умолчанию равно 0, а число байтов для отправки по умолчанию равно размеру буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2939">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>

<span data-ttu-id="f6353-2940">Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2940">If you're using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2941">Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2941">If you're using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>

<span data-ttu-id="f6353-2942">Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2942">If you're using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="f6353-2943">Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2943">If you don't use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you'll have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="f6353-2944">Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2944">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-2945">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2945">You can also change the default remote host before calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>

<span data-ttu-id="f6353-2946">Если вы используете протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2946">If you're using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2947">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2947">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2948">В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может быть успешно завершен даже при отправке меньшего числа байтов в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-2948">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="f6353-2949">Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-2949">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="f6353-2950">Также нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2950">There's also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-2951">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-2951">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-2952">Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-2952">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>

> [!NOTE]
><span data-ttu-id="f6353-2953">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2953">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2954">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2954">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="f6353-2955">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2955">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2956">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2956">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>

> [!IMPORTANT]
><span data-ttu-id="f6353-2957">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-2957">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-2958">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-2958">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2959">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2959">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2960"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2960">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-2961">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2961">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2962">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2962">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="f6353-2963">Передает данные в подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2963">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2964">Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2964">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2965"><xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, установленный в <xref:System.Net.Sockets.Socket.Connect%2A> или методе <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2965"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="f6353-2966">Метод <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2966">The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="f6353-2967">Для этой перегрузки требуется буфер, содержащий данные, которые необходимо отправить, и побитовое сочетание <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2967">This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="f6353-2968">По умолчанию смещение буфера равно 0, а число байтов для отправки по умолчанию равно размеру буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-2968">The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span> <span data-ttu-id="f6353-2969">Если в качестве значения параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-2969">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="f6353-2970">Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2970">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2971">Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-2971">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="f6353-2972">Если вы используете протокол без подключения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2972">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="f6353-2973">Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2973">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="f6353-2974">Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2974">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-2975">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2975">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="f6353-2976">Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2976">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-2977">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2977">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2978">В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может быть успешно завершен даже при отправке меньшего числа байтов в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-2978">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="f6353-2979">Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-2979">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="f6353-2980">Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2980">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-2981">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-2981">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-2982">Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-2982">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2983">Необходимо убедиться, что размер буфера не превышает максимальный размер пакета базового поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-2983">You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-2984">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2984">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-2985">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2985">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-2986">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2986">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2987">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-2987">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-2988">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-2988">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-2989">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-2989">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-2990">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-2990">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-2991">В следующем примере кода показано, как отправлять данные на подключенном <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-2991">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-2992">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2992"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-2993">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-2993">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-2994"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-2994">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="f6353-2995">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих данные для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-2995">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-2996">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2996">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="f6353-2997">Отправляет набор буферов в список на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя указанный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2997">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-2998">Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-2998">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-2999">Для этой перегрузки требуется по крайней мере один буфер, содержащий данные, которые необходимо отправить.</span><span class="sxs-lookup"><span data-stu-id="f6353-2999">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="f6353-3000">Значение по умолчанию для <xref:System.Net.Sockets.SocketFlags> равно 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-3000">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="f6353-3001">Если в качестве параметра `socketFlags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-3001">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="f6353-3002">Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3002">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3003">Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3003">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="f6353-3004">Если вы используете протокол без подключения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3004">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="f6353-3005">Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3005">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="f6353-3006">Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3006">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-3007">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3007">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="f6353-3008">Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3008">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-3009">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3009">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3010">В режиме без блокировки <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно, даже если число байтов в буфере меньше числа.</span><span class="sxs-lookup"><span data-stu-id="f6353-3010">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="f6353-3011">Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-3011">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="f6353-3012">Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3012">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-3013">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-3013">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-3014">Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-3014">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3015">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3015">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3016">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3016">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3017">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-3017">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-3018">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-3018">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3019">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3019">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3020">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3020">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-3021">Свойство <paramref name="buffers" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3021"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-3022">Параметр <paramref name="buffers" /> пуст.</span><span class="sxs-lookup"><span data-stu-id="f6353-3022"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3023">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3023">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3024"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3024">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-3025">Диапазон байтов, содержащий отправляемые данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-3025">A span of bytes that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-3026">Побитовое сочетание значений перечисления, которое задает поведение получения и отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3026">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <summary><span data-ttu-id="f6353-3027">Передает данные в подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3027">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-3028">Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3028">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  

  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3029">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3029">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3030"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3030">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-3031">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3031">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-3032">Количество байтов для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3032">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-3033">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3033">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="f6353-3034">Посылает указанное число байтов данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3034">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-3035">Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3035">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="f6353-3036"><xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, установленный в <xref:System.Net.Sockets.Socket.Connect%2A> или методе <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3036"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="f6353-3037"><xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3037"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>

<span data-ttu-id="f6353-3038">Для этой перегрузки требуется буфер, содержащий данные, которые необходимо отправить, число байтов, которое необходимо отправить, и побитовое сочетание любого <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3038">This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="f6353-3039">Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-3039">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you're sending won't be routed.</span></span>

<span data-ttu-id="f6353-3040">Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3040">If you're using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3041">Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3041">If you're using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>

<span data-ttu-id="f6353-3042">Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3042">If you're using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="f6353-3043">Если вы дон'тусе метод <xref:System.Net.Sockets.Socket.SendTo%2A>, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом метода <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3043">If you don'tuse the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you'll have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="f6353-3044">Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3044">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you've established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-3045">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3045">You can also change the default remote host before calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>

<span data-ttu-id="f6353-3046">При использовании протокола, ориентированного на соединение, <xref:System.Net.Sockets.Socket.Send%2A> блокируется до тех пор, пока не будет отправлено запрошенное число байтов, пока не будет задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3046">With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-3047">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3047">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3048">В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно, даже если он пересылает меньшее количество байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3048">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="f6353-3049">Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3049">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="f6353-3050">Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3050">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-3051">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-3051">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-3052">Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-3052">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>

> [!NOTE]
> <span data-ttu-id="f6353-3053">Необходимо убедиться, что размер не превышает максимальный размер пакета для базового поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-3053">You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-3054">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3054">If it does, the datagram won't be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3055">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3055">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3056">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3056">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="f6353-3057">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3057">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3058">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3058">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>

> [!IMPORTANT]
><span data-ttu-id="f6353-3059">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-3059">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-3060">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-3060">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>

## Examples

<span data-ttu-id="f6353-3061">Следующий пример кода отправляет данные, найденные в буфере, и указывает <xref:System.Net.Sockets.SocketFlags.None> для <xref:System.Net.Sockets.SocketFlags>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3061">The following code example sends the data found in buffer, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>

[!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
[!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
[!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-3062">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3062"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-3063">Значение параметра <paramref name="size" /> меньше 0 или превышает размер буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-3063"><paramref name="size" /> is less than 0 or exceeds the size of the buffer.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3064"><paramref name="socketFlags" /> — недопустимое сочетание значений.</span><span class="sxs-lookup"><span data-stu-id="f6353-3064"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="f6353-3065">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3065">-or-</span></span> 
<span data-ttu-id="f6353-3066">Сбой операционной системы при доступе к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3066">An operating system error occurs while accessing the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3067"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3067">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="f6353-3068">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих данные для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3068">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-3069">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3069">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="f6353-3070">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-3070">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="f6353-3071">Отправляет набор буферов в список на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя указанный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3071">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-3072">Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3072">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3073">Для этой перегрузки требуется по крайней мере один буфер, содержащий данные, которые необходимо отправить.</span><span class="sxs-lookup"><span data-stu-id="f6353-3073">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="f6353-3074">Значение по умолчанию для <xref:System.Net.Sockets.SocketFlags> равно 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-3074">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="f6353-3075">Если в качестве параметра `socketFlags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-3075">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="f6353-3076">Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3076">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3077">Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3077">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="f6353-3078">Если вы используете протокол без подключения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3078">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="f6353-3079">Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3079">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="f6353-3080">Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3080">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-3081">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3081">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="f6353-3082">Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3082">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-3083">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3083">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3084">В режиме без блокировки <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно, даже если число байтов в буфере меньше числа.</span><span class="sxs-lookup"><span data-stu-id="f6353-3084">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="f6353-3085">Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-3085">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="f6353-3086">Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3086">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-3087">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-3087">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-3088">Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-3088">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3089">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3089">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3090">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3090">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3091">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-3091">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-3092">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-3092">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3093">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3093">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3094">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3094">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-3095">Свойство <paramref name="buffers" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3095"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-3096">Параметр <paramref name="buffers" /> пуст.</span><span class="sxs-lookup"><span data-stu-id="f6353-3096"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3097">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3097">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3098"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3098">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-3099">Диапазон байтов, содержащий отправляемые данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-3099">A span of bytes that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-3100">Побитовое сочетание значений перечисления, которое задает поведение получения и отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3100">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <param name="errorCode"><span data-ttu-id="f6353-3101">При возврате из этого метода содержит одно из значений перечисления, которое определяет коды ошибок для сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-3101">When this method returns, contains one of the enumeration values that defines error codes for the socket.</span></span></param>
        <summary><span data-ttu-id="f6353-3102">Передает данные в подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3102">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-3103">Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3103">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="f6353-3104"><xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3104"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="f6353-3105"><xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3105"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>

<span data-ttu-id="f6353-3106">Для этой перегрузки требуется буфер, содержащий данные, которые необходимо отправить.</span><span class="sxs-lookup"><span data-stu-id="f6353-3106">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="f6353-3107">Значение <xref:System.Net.Sockets.SocketFlags> по умолчанию равно 0, смещение буфера по умолчанию равно 0, а число байтов для отправки по умолчанию равно размеру буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-3107">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>

<span data-ttu-id="f6353-3108">Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3108">If you're using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3109">Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3109">If you're using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>

<span data-ttu-id="f6353-3110">Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3110">If you're using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="f6353-3111">Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3111">If you don't use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you'll have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="f6353-3112">Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3112">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you've established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-3113">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3113">You can also change the default remote host before calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>

<span data-ttu-id="f6353-3114">Если вы используете протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3114">If you're using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-3115">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3115">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3116">В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может быть успешно завершен даже при отправке меньшего числа байтов в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-3116">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="f6353-3117">Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-3117">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="f6353-3118">Также нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3118">There's also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-3119">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-3119">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-3120">Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-3120">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>

> [!NOTE]
><span data-ttu-id="f6353-3121">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3121">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3122">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3122">After you've obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="f6353-3123">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3123">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3124">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3124">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>

> [!IMPORTANT]
><span data-ttu-id="f6353-3125">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-3125">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-3126">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-3126">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3127">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3127">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3128"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3128">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-3129">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3129">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-3130">Положение в буфере данных, с которого начинается отправка данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-3130">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-3131">Количество байтов для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3131">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-3132">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3132">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="f6353-3133">Отправляет указанное количество байтов данных в подключенный <see cref="T:System.Net.Sockets.Socket" />, начиная с заданного смещения и используя заданный параметр <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3133">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-3134">Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3134">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3135"><xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3135"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="f6353-3136"><xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3136"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="f6353-3137">В этой перегрузке, если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-3137">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="f6353-3138">Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3138">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3139">Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3139">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="f6353-3140">Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3140">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="f6353-3141">Если <xref:System.Net.Sockets.Socket.SendTo%2A>не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3141">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="f6353-3142">Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3142">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-3143">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3143">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="f6353-3144">Кроме того, необходимо убедиться, что размер не превышает максимальный размер пакета для базового поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-3144">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-3145">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3145">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-3146">Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> блокируется до тех пор, пока не будет отправлено запрошенное число байтов, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3146">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-3147">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3147">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3148">В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно, даже если он пересылает меньшее количество байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3148">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="f6353-3149">Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3149">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="f6353-3150">Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3150">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-3151">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-3151">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-3152">Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-3152">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3153">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3153">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3154">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3154">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3155">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-3155">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-3156">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-3156">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3157">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3157">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3158">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3158">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3159">В следующем примере кода задаются буфер данных, смещение, размер и <xref:System.Net.Sockets.SocketFlags> для отправки данных в подключенную <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3159">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-3160">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3160"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-3161">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-3161"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-3162">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3162">-or-</span></span> 
 <span data-ttu-id="f6353-3163">Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3163"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-3164">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3164">-or-</span></span> 
 <span data-ttu-id="f6353-3165">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-3165"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-3166">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3166">-or-</span></span> 
 <span data-ttu-id="f6353-3167">Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3167"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3168"><paramref name="socketFlags" /> — недопустимое сочетание значений.</span><span class="sxs-lookup"><span data-stu-id="f6353-3168"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="f6353-3169">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3169">-or-</span></span> 
<span data-ttu-id="f6353-3170">Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3170">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3171"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3171">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-3172">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3172">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-3173">Положение в буфере данных, с которого начинается отправка данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-3173">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-3174">Количество байтов для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3174">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-3175">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3175">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="f6353-3176">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-3176">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="f6353-3177">Посылает указанное число байтов данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, начиная с указанного смещения и используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3177">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" /></span></span></summary>
        <returns><span data-ttu-id="f6353-3178">Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3178">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3179"><xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3179"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="f6353-3180"><xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3180"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="f6353-3181">В этой перегрузке, если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-3181">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="f6353-3182">Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3182">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3183">Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3183">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="f6353-3184">Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3184">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="f6353-3185">Если <xref:System.Net.Sockets.Socket.SendTo%2A>не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3185">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="f6353-3186">Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3186">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="f6353-3187">Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3187">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="f6353-3188">Кроме того, необходимо убедиться, что размер не превышает максимальный размер пакета для базового поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-3188">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-3189">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3189">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-3190">Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> блокируется до тех пор, пока не будет отправлено запрошенное число байтов, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3190">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-3191">Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3191">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3192">В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно, даже если он пересылает меньшее количество байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3192">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="f6353-3193">Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3193">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="f6353-3194">Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3194">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-3195">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-3195">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-3196">Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-3196">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3197">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3197">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3198">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3198">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3199">Успешное завершение отправки не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-3199">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="f6353-3200">Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.</span><span class="sxs-lookup"><span data-stu-id="f6353-3200">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3201">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3201">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3202">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3202">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3203">В следующем примере кода задаются буфер данных, смещение, размер и <xref:System.Net.Sockets.SocketFlags> для отправки данных в подключенную <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3203">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-3204">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3204"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-3205">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-3205"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-3206">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3206">-or-</span></span> 
 <span data-ttu-id="f6353-3207">Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3207"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-3208">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3208">-or-</span></span> 
 <span data-ttu-id="f6353-3209">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-3209"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-3210">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3210">-or-</span></span> 
 <span data-ttu-id="f6353-3211">Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3211"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3212"><paramref name="socketFlags" /> — недопустимое сочетание значений.</span><span class="sxs-lookup"><span data-stu-id="f6353-3212"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="f6353-3213">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3213">-or-</span></span> 
<span data-ttu-id="f6353-3214">Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3214">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3215"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3215">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f6353-3216">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-3216">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="f6353-3217">Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3217">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="f6353-3218"><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-3218"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="f6353-3219">По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3219">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="f6353-3220"><see langword="false" />, если операция ввода-вывода завершена синхронно.</span><span class="sxs-lookup"><span data-stu-id="f6353-3220"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="f6353-3221">В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-3221">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3222">Метод <xref:System.Net.Sockets.Socket.SendAsync%2A> используется для записи исходящих данных из одного или нескольких буферов на сокете, ориентированном на соединение.</span><span class="sxs-lookup"><span data-stu-id="f6353-3222">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</span></span> <span data-ttu-id="f6353-3223">Однако этот метод можно также использовать для сокетов без подключения, которые указали удаленный узел в операции подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3223">This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</span></span>  
  
 <span data-ttu-id="f6353-3224">Метод <xref:System.Net.Sockets.Socket.SendAsync%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или в методе <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3224">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-3225">Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> необходимы для успешного вызова этого метода:</span><span class="sxs-lookup"><span data-stu-id="f6353-3225">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="f6353-3226"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> или <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="f6353-3226"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="f6353-3227"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>, если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> задано</span><span class="sxs-lookup"><span data-stu-id="f6353-3227"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="f6353-3228"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>, если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> задано</span><span class="sxs-lookup"><span data-stu-id="f6353-3228"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="f6353-3229">Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.SendAsync%2A>, чтобы информация была извлечена в методе обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-3229">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="f6353-3230">Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3230">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="f6353-3231">Метод <xref:System.Net.Sockets.Socket.SendAsync%2A> вызывает исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3231">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span></span>  
  
 <span data-ttu-id="f6353-3232">Вызов метода <xref:System.Net.Sockets.Socket.SendAsync%2A> дает возможность отправки данных в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3232">Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="f6353-3233">Для сокетов, ориентированных на сообщения, не следует превысить максимальный размер сообщения в базовом поставщике службы Windows Sockets.</span><span class="sxs-lookup"><span data-stu-id="f6353-3233">For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</span></span> <span data-ttu-id="f6353-3234">Если данные слишком длинны для передачи атомарным образом через базового поставщика услуг, данные не передаются, а метод <xref:System.Net.Sockets.Socket.SendAsync%2A> создает <xref:System.Net.Sockets.SocketException> с <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>ным кодом ошибки Winsock ВСАЕМСГСИЗЕ (10040).</span><span class="sxs-lookup"><span data-stu-id="f6353-3234">If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEMSGSIZE error code (10040).</span></span>  
  
 <span data-ttu-id="f6353-3235">Обратите внимание, что успешное завершение метода <xref:System.Net.Sockets.Socket.SendAsync%2A> не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-3235">Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-3236">Свойства <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> или <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> на параметре <paramref name="e" /> должны ссылаться на допустимые буферы.</span><span class="sxs-lookup"><span data-stu-id="f6353-3236">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="f6353-3237">Может быть установлено одно из этих свойств, но нельзя одновременно устанавливать оба свойства.</span><span class="sxs-lookup"><span data-stu-id="f6353-3237">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-3238">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3238">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-3239">Этот метод доступен только в Windows XP и более поздних версиях.</span><span class="sxs-lookup"><span data-stu-id="f6353-3239">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3240"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3240">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3241">Объект <see cref="T:System.Net.Sockets.Socket" /> уже не подключен или он был получен посредством метода <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> или <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3241">The <see cref="T:System.Net.Sockets.Socket" /> is not yet connected or was not obtained via an <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />,or <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, method.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-3242">Получает или задает значение, определяющее размер буфера передачи объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3242">Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="f6353-3243">Объект <see cref="T:System.Int32" />, который содержит значение размера буфера передачи в байтах.</span><span class="sxs-lookup"><span data-stu-id="f6353-3243">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the send buffer.</span></span> <span data-ttu-id="f6353-3244">Значение по умолчанию — 8192.</span><span class="sxs-lookup"><span data-stu-id="f6353-3244">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3245">Больший размер буфера может замедлить распознавание проблем с подключением.</span><span class="sxs-lookup"><span data-stu-id="f6353-3245">A larger buffer size might delay the recognition of connection difficulties.</span></span> <span data-ttu-id="f6353-3246">Если вы передаете большие файлы или используете высокоскоростное подключение с высокой задержкой (например, поставщик широкополосного подключения), попробуйте увеличить размер буфера.</span><span class="sxs-lookup"><span data-stu-id="f6353-3246">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3247">В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.SendBufferSize%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="f6353-3247">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3248">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3248">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3249"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3249">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-3250">Значение, указанное для операции установки, меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-3250">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-3251">Выполняет синхронную передачу файла и дополнительных данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3251">Sends a file and optional data synchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="f6353-3252">Параметр типа <see cref="T:System.String" />, содержащий имя отправляемого файла и путь к нему.</span><span class="sxs-lookup"><span data-stu-id="f6353-3252">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="f6353-3253">Этот параметр может иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3253">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="f6353-3254">Отправляет файл <paramref name="fileName" /> на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя флаг передачи <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3254">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object with the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> transmit flag.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3255">Эта перегрузка отправляет файл `fileName` подключенному сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3255">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="f6353-3256">Параметр `flags` по умолчанию имеет значение <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), а параметры `preBuffer` и `postBuffer` по умолчанию — `null`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3256">The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`.</span></span> <span data-ttu-id="f6353-3257">Если `fileName` находится в локальном каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-3257">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="f6353-3258">Подстановочные знаки ("..\\\мифиле.ткст ") и имена общих UNC-папок ("\\\\\\Directory\\\мифиле.ткст ") поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="f6353-3258">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="f6353-3259">Если файл не найден, вызывается исключение <xref:System.IO.FileNotFoundException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3259">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="f6353-3260">Этот метод использует функцию `TransmitFile`, которая находится в API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="f6353-3260">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="f6353-3261">Дополнительные сведения о функции `TransmitFile` и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="f6353-3261">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="f6353-3262"><xref:System.Net.Sockets.Socket.SendFile%2A> синхронно отправляет файл на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3262"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-3263"><xref:System.Net.Sockets.Socket.SendFile%2A> можно использовать как для подключений, так и для протоколов без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3263"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="f6353-3264">Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, в противном случае <xref:System.Net.Sockets.Socket.SendFile%2A> выдаст исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3264">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span> <span data-ttu-id="f6353-3265">Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3265">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="f6353-3266">Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.SendFile%2A> блокируется до отправки файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-3266">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent.</span></span> <span data-ttu-id="f6353-3267">В неблокирующем режиме <xref:System.Net.Sockets.Socket.SendFile%2A> могут успешно завершиться до отправки всего файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-3267">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="f6353-3268">Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3268">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-3269">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-3269">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-3270">Успешное завершение метода <xref:System.Net.Sockets.Socket.SendFile%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-3270">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3271">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3271">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3272">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3272">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3273">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3273">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3274">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3274">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3275">В следующем примере кода создается и подключается сокет, а затем файл отправляется на удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-3275">The following code example creates and connects a socket and then sends a file to the remote host.</span></span> <span data-ttu-id="f6353-3276">Файл Test. txt находится в корневом каталоге локального компьютера.</span><span class="sxs-lookup"><span data-stu-id="f6353-3276">The file "test.txt" is located in the root directory of the local machine.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-3277">Сокет не подключен к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-3277">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3278">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3278">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-3279">Объект <see cref="T:System.Net.Sockets.Socket" /> не находится в режиме блокировки и не может принять этот синхронный вызов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3279">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f6353-3280">Файл <paramref name="fileName" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="f6353-3280">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3281">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3281">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="f6353-3282">Параметр типа <see cref="T:System.String" />, содержащий имя отправляемого файла и путь к нему.</span><span class="sxs-lookup"><span data-stu-id="f6353-3282">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="f6353-3283">Этот параметр может иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3283">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="f6353-3284">Массив <see cref="T:System.Byte" />, содержащий данные, отправляемые перед передачей файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-3284">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="f6353-3285">Этот параметр может иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3285">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="f6353-3286">Массив <see cref="T:System.Byte" />, содержащий данные, отправляемые после передачи файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-3286">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="f6353-3287">Этот параметр может иметь значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3287">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="f6353-3288">Одно или несколько значений <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3288">One or more of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <summary><span data-ttu-id="f6353-3289">Отправляет файл <paramref name="fileName" /> и буферы данных в подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя указанное значение <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3289">Sends the file <paramref name="fileName" /> and buffers of data to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the specified <see cref="T:System.Net.Sockets.TransmitFileOptions" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3290">Для этой перегрузки требуется имя файла, который требуется отправить, и побитовое сочетание значений <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3290">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="f6353-3291">Параметр `preBuffer` содержит все данные, которые необходимо указать перед файлом.</span><span class="sxs-lookup"><span data-stu-id="f6353-3291">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="f6353-3292">`postBuffer` содержит данные, которые необходимо отслеживать в файле.</span><span class="sxs-lookup"><span data-stu-id="f6353-3292">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="f6353-3293">Если `fileName` находится в текущем рабочем каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-3293">If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="f6353-3294">Подстановочные знаки ("..\\\мифиле.ткст ") и имена общих UNC-папок ("\\\\\\Directory\\\мифиле.ткст ") поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="f6353-3294">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span>  
  
 <span data-ttu-id="f6353-3295">Параметр `flags` предоставляет поставщику службы оконных сокетов дополнительные сведения о переносе файлов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3295">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="f6353-3296">Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3296">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="f6353-3297">Этот метод использует функцию `TransmitFile`, которая находится в API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="f6353-3297">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="f6353-3298">Дополнительные сведения о функции `TransmitFile` и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="f6353-3298">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="f6353-3299"><xref:System.Net.Sockets.Socket.SendFile%2A> синхронно отправляет файл на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3299"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-3300"><xref:System.Net.Sockets.Socket.SendFile%2A> можно использовать как для подключений, так и для протоколов без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3300"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="f6353-3301">Если используется протокол без установления соединения, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода; в противном случае <xref:System.Net.Sockets.Socket.SendFile%2A> создает исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3301">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3302">Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3302">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="f6353-3303">Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.SendFile%2A> блокируется до тех пор, пока не будет отправлен весь файл.</span><span class="sxs-lookup"><span data-stu-id="f6353-3303">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="f6353-3304">В неблокирующем режиме <xref:System.Net.Sockets.Socket.SendFile%2A> могут успешно завершиться до отправки всего файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-3304">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="f6353-3305">Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3305">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-3306">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-3306">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-3307">Успешное завершение метода <xref:System.Net.Sockets.Socket.SendFile%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-3307">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3308">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3308">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3309">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3309">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3310">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3310">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3311">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3311">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3312">В следующем примере кода создается и подключается сокет.</span><span class="sxs-lookup"><span data-stu-id="f6353-3312">The following code example creates and connects a socket.</span></span> <span data-ttu-id="f6353-3313">Файл Test. txt находится в корневом каталоге локального компьютера.</span><span class="sxs-lookup"><span data-stu-id="f6353-3313">The file "test.txt" is located in the root directory of the local machine.</span></span> <span data-ttu-id="f6353-3314">В этом примере мы создадим предбуферную и буферизованную передачу данных и отправим их на удаленный узел с помощью файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-3314">In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</span></span> <span data-ttu-id="f6353-3315">Используются <xref:System.Net.Sockets.TransmitFileOptions> по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-3315">The default <xref:System.Net.Sockets.TransmitFileOptions> are used.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-3316">Операционной системой не является Windows NT или более поздняя версия.</span><span class="sxs-lookup"><span data-stu-id="f6353-3316">The operating system is not Windows NT or later.</span></span>  
  
<span data-ttu-id="f6353-3317">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3317">-or-</span></span>
  
 <span data-ttu-id="f6353-3318">Сокет не подключен к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-3318">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3319">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3319">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-3320">Объект <see cref="T:System.Net.Sockets.Socket" /> не находится в режиме блокировки и не может принять этот синхронный вызов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3320">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f6353-3321">Файл <paramref name="fileName" /> не найден.</span><span class="sxs-lookup"><span data-stu-id="f6353-3321">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3322">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3322">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f6353-3323">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-3323">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="f6353-3324">Выполняет асинхронную передачу набора файла или буферов данных в памяти на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3324">Sends a collection of files or in memory data buffers asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="f6353-3325"><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-3325"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="f6353-3326">По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3326">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="f6353-3327"><see langword="false" />, если операция ввода-вывода завершена синхронно.</span><span class="sxs-lookup"><span data-stu-id="f6353-3327"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="f6353-3328">В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-3328">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3329">Метод <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> используется для отправки коллекции файлов или буферов данных в памяти на удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-3329">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host.</span></span> <span data-ttu-id="f6353-3330"><xref:System.Net.Sockets.Socket> уже должен быть подключен к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-3330">The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.</span></span>  
  
 <span data-ttu-id="f6353-3331">Если <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> ссылается на файл в рабочем каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла.</span><span class="sxs-lookup"><span data-stu-id="f6353-3331">If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="f6353-3332">Поддерживаются подстановочные знаки и имена общих папок в формате UNC.</span><span class="sxs-lookup"><span data-stu-id="f6353-3332">Wildcards and UNC share names are supported.</span></span> <span data-ttu-id="f6353-3333">Если файл не найден, выдается <xref:System.IO.FileNotFoundException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3333">If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="f6353-3334">Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик события EventHandler\<SocketAsyncEventArgs > делегат и присоединить обратный вызов к событию <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3334">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="f6353-3335">Свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> в параметре `e` предоставляет поставщику службы оконных сокетов дополнительные сведения о переносе файлов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3335">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="f6353-3336">Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3336">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="f6353-3337">Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> необходимы для успешного вызова этого метода:</span><span class="sxs-lookup"><span data-stu-id="f6353-3337">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="f6353-3338">Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>, чтобы информация была извлечена в методе обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-3338">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="f6353-3339">Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3339">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="f6353-3340">Этот метод использует функцию Трансмитпаккетс, находящийся в API Windows Sockets 2.</span><span class="sxs-lookup"><span data-stu-id="f6353-3340">This method uses the TransmitPackets function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="f6353-3341">Дополнительные сведения о функции Трансмитпаккетс и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="f6353-3341">For more information about the TransmitPackets function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="f6353-3342">Хотя для протоколов, ориентированных на соединение, метод <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, чтобы установить удаленный узел по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-3342">Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host.</span></span> <span data-ttu-id="f6353-3343">При использовании протоколов без подключения необходимо также убедиться в том, что размер файла не превышает максимальный размер пакета для базового поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-3343">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-3344">Если это так, датаграмма не отправляется, а <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> вызывает исключение <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3344">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
 <span data-ttu-id="f6353-3345">Метод <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> оптимизирован в соответствии с операционной системой, в которой он используется.</span><span class="sxs-lookup"><span data-stu-id="f6353-3345">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used.</span></span> <span data-ttu-id="f6353-3346">В выпусках Windows Server метод <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> оптимизирован для обеспечения высокой производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-3346">On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.</span></span>  
  
 <span data-ttu-id="f6353-3347">В выпусках клиента Windows метод <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> оптимизирован для минимального использования памяти и ресурсов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3347">On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.</span></span>  
  
 <span data-ttu-id="f6353-3348">Использование флага <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> в свойстве <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> в параметре `e` может обеспечить значительные преимущества производительности.</span><span class="sxs-lookup"><span data-stu-id="f6353-3348">Use of the <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter can deliver significant performance benefits.</span></span> <span data-ttu-id="f6353-3349">Если поток, инициирующий вызов метода <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>, используется для интенсивных вычислений, можно, хотя маловероятно, избежать запуска APC.</span><span class="sxs-lookup"><span data-stu-id="f6353-3349">If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</span></span> <span data-ttu-id="f6353-3350">Обратите внимание, что существует разница между ядром и пользовательским режимом APC.</span><span class="sxs-lookup"><span data-stu-id="f6353-3350">Note that there is a difference between kernel and user-mode APCs.</span></span> <span data-ttu-id="f6353-3351">Ядро APC запуск, когда поток находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-3351">Kernel APCs launch when a thread is in a wait state.</span></span> <span data-ttu-id="f6353-3352">Пользовательский режим APC запуск, когда поток находится в состоянии ожидания с оповещением</span><span class="sxs-lookup"><span data-stu-id="f6353-3352">User-mode APCs launch when a thread is in an alertable wait state</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="f6353-3353">Файл, указанный в свойстве <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" />, не найден.</span><span class="sxs-lookup"><span data-stu-id="f6353-3353">The file specified in the <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> property was not found.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-3354">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3354">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-3355">Этот метод доступен только в Windows XP и более поздних версиях.</span><span class="sxs-lookup"><span data-stu-id="f6353-3355">Windows XP or later is required for this method.</span></span> <span data-ttu-id="f6353-3356">Это исключение возникает также в том случае, когда объект <see cref="T:System.Net.Sockets.Socket" /> не подключен к удаленному узлу.</span><span class="sxs-lookup"><span data-stu-id="f6353-3356">This exception also occurs if the <see cref="T:System.Net.Sockets.Socket" /> is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3357"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3357">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3358">Используется объект <see cref="T:System.Net.Sockets.Socket" />, функционирующий без установления соединения, и размер отправляемого файла превышает максимальный размер пакета основного транспортного средства.</span><span class="sxs-lookup"><span data-stu-id="f6353-3358">A connectionless <see cref="T:System.Net.Sockets.Socket" /> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-3359">Получает или устанавливает значение, указывающее промежуток времени, после которого для синхронного вызова <see cref="Overload:System.Net.Sockets.Socket.Send" /> истечет время тайм-аута.</span><span class="sxs-lookup"><span data-stu-id="f6353-3359">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="f6353-3360">Значение времени ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="f6353-3360">The time-out value, in milliseconds.</span></span> <span data-ttu-id="f6353-3361">Если для этого свойства задать значение от 1 до 499, значение будет изменено на 500.</span><span class="sxs-lookup"><span data-stu-id="f6353-3361">If you set the property with a value between 1 and 499, the value will be changed to 500.</span></span> <span data-ttu-id="f6353-3362">По умолчанию используется значение 0, указывающее на бесконечное значение интервала для тайм-аута</span><span class="sxs-lookup"><span data-stu-id="f6353-3362">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="f6353-3363">Задание значения -1 также указывает на бесконечное значение интервала для тайм-аута.</span><span class="sxs-lookup"><span data-stu-id="f6353-3363">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3364">Этот параметр применяется только к синхронным вызовам <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3364">This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only.</span></span> <span data-ttu-id="f6353-3365">При превышении времени ожидания метод <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3365">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3366">В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.SendTimeout%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="f6353-3366">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3367">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3367">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3368"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3368">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-3369">Значение, указанное для операции задания, меньше –1.</span><span class="sxs-lookup"><span data-stu-id="f6353-3369">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-3370">Посылает данные на указанную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-3370">Sends data to a specific endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-3371">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3371">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="f6353-3372">Объект <see cref="T:System.Net.EndPoint" />, представляющий пункт назначения для данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-3372">The <see cref="T:System.Net.EndPoint" /> that represents the destination for the data.</span></span></param>
        <summary><span data-ttu-id="f6353-3373">Посылает данные на указанную конечную точку.</span><span class="sxs-lookup"><span data-stu-id="f6353-3373">Sends data to the specified endpoint.</span></span></summary>
        <returns><span data-ttu-id="f6353-3374">Число отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3374">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3375">В этой перегрузке смещение буфера по умолчанию равно 0, число отправляемых байтов по умолчанию равно размеру параметра `buffer`, а <xref:System.Net.Sockets.SocketFlags> значение по умолчанию равно 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-3375">In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span>  
  
 <span data-ttu-id="f6353-3376">Если используется протокол без подключения, то перед вызовом <xref:System.Net.Sockets.Socket.SendTo%2A>не нужно устанавливать удаленный узел по умолчанию с помощью метода <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3376">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="f6353-3377">Это необходимо сделать только в том случае, если предполагается вызывать метод <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3377">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="f6353-3378">При вызове метода <xref:System.Net.Sockets.Socket.Connect%2A> до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>параметр `remoteEP` переопределит указанный удаленный узел по умолчанию только для этой операции отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3378">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="f6353-3379">Также не требуется вызывать метод <xref:System.Net.Sockets.Socket.Bind%2A>, так как базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-3379">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="f6353-3380">Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> после успешного завершения метода <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3380">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="f6353-3381">Несмотря на то, что предназначен для протоколов без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> также работает с протоколами, ориентированными на подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3381">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="f6353-3382">Если используется протокол, ориентированный на соединение, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или приняв входящий запрос на соединение с помощью метода <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3382">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-3383">Если не установить или принять подключение к удаленному узлу, <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3383">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3384">Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3384">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="f6353-3385">В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> пропустит параметр `remoteEP` и отправит данные только подключенному или удаленному узлу по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-3385">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="f6353-3386">Блокирующие сокеты блокируются до тех пор, пока не будут отправлены все байты в буфере.</span><span class="sxs-lookup"><span data-stu-id="f6353-3386">Blocking sockets will block until the all of the bytes in the buffer are sent.</span></span> <span data-ttu-id="f6353-3387">Поскольку незаблокированный <xref:System.Net.Sockets.Socket> завершается немедленно, он может не отправить все байты в `buffer`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3387">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="f6353-3388">Вы обязаны следить за количеством отправленных байтов и повторять операцию до тех пор, пока приложение не отправит все байты в `buffer`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3388">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="f6353-3389">Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3389">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-3390">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-3390">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="f6353-3391">Успешное завершение метода <xref:System.Net.Sockets.Socket.SendTo%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-3391">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="f6353-3392">Если в блокирующем режиме используется протокол без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> будет блокироваться до отправки датаграммы.</span><span class="sxs-lookup"><span data-stu-id="f6353-3392">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="f6353-3393">Если вы хотите отправить данные на широковещательный адрес, сначала необходимо вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3393">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-3394">Кроме того, необходимо убедиться, что число отправленных байтов не превышает максимальный размер пакета для базового поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-3394">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-3395">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3395">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3396">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3396">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3397">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3397">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3398">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3398">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3399">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3399">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3400">В следующем примере кода датаграмма без подключения отправляется на указанный удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-3400">The following code example sends a connectionless datagram to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-3401">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3401"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-3402">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3402">-or-</span></span> 
 <span data-ttu-id="f6353-3403">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3403"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3404">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3404">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3405"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3405">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-3406">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3406">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-3407">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3407">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="f6353-3408">Объект <see cref="T:System.Net.EndPoint" />, представляющий пункт назначения для данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-3408">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="f6353-3409">Передает данные на указанную конечную точку, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3409">Sends data to a specific endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-3410">Число отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3410">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3411">В этой перегрузке смещение буфера по умолчанию равно 0, а число байтов для отправки по умолчанию равно размеру `buffer`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3411">In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`.</span></span> <span data-ttu-id="f6353-3412">Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-3412">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="f6353-3413">Если используется протокол без подключения, то перед вызовом <xref:System.Net.Sockets.Socket.SendTo%2A>не нужно устанавливать удаленный узел по умолчанию с помощью метода <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3413">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="f6353-3414">Это необходимо сделать только в том случае, если предполагается вызывать метод <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3414">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="f6353-3415">При вызове метода <xref:System.Net.Sockets.Socket.Connect%2A> до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>параметр `remoteEP` переопределит указанный удаленный узел по умолчанию только для этой операции отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3415">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="f6353-3416">Также не требуется вызывать метод <xref:System.Net.Sockets.Socket.Bind%2A>, так как базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-3416">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="f6353-3417">Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> после успешного завершения метода <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3417">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="f6353-3418">Несмотря на то, что предназначен для протоколов без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> также работает с протоколами, ориентированными на подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3418">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="f6353-3419">Если используется протокол, ориентированный на соединение, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или приняв входящий запрос на соединение с помощью метода <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3419">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-3420">Если не установить или принять подключение к удаленному узлу, <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3420">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3421">Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3421">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="f6353-3422">В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> пропустит параметр `remoteEP` и отправит данные только подключенному или удаленному узлу по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-3422">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="f6353-3423">Блокирующие сокеты блокируются до тех пор, пока не будут отправлены все байты в `buffer`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3423">Blocking sockets will block until the requested all of the bytes in the `buffer` are sent.</span></span> <span data-ttu-id="f6353-3424">Поскольку незаблокированный <xref:System.Net.Sockets.Socket> завершается немедленно, он может не отправить все байты в `buffer`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3424">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="f6353-3425">Вы обязаны следить за количеством отправленных байтов и повторять операцию до тех пор, пока приложение не отправит все байты в `buffer`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3425">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="f6353-3426">Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3426">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-3427">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-3427">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="f6353-3428">Успешное завершение метода <xref:System.Net.Sockets.Socket.SendTo%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-3428">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="f6353-3429">Если в блокирующем режиме используется протокол без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> будет блокироваться до отправки датаграммы.</span><span class="sxs-lookup"><span data-stu-id="f6353-3429">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="f6353-3430">Если вы хотите отправить данные на широковещательный адрес, сначала необходимо вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3430">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-3431">Кроме того, необходимо убедиться, что число отправленных байтов не превышает максимальный размер пакета для базового поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-3431">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-3432">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3432">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3433">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3433">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3434">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3434">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3435">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3435">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3436">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3436">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3437">В следующем примере кода датаграмма без подключения отправляется на указанный удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-3437">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="f6353-3438"><xref:System.Net.Sockets.SocketFlags> передаются методу <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3438"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-3439">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3439"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-3440">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3440">-or-</span></span> 
 <span data-ttu-id="f6353-3441">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3441"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3442">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3442">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3443"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3443">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-3444">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3444">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-3445">Количество байтов для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3445">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-3446">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3446">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="f6353-3447">Объект <see cref="T:System.Net.EndPoint" />, представляющий пункт назначения для данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-3447">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="f6353-3448">Посылает указанное число байтов данных на указанную конечную точку, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3448">Sends the specified number of bytes of data to the specified endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-3449">Число отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3449">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3450">В этой перегрузке смещение буфера по умолчанию равно 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-3450">In this overload, the buffer offset defaults to 0.</span></span> <span data-ttu-id="f6353-3451">Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-3451">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="f6353-3452">Если используется протокол без подключения, то перед вызовом <xref:System.Net.Sockets.Socket.SendTo%2A>не нужно устанавливать удаленный узел по умолчанию с помощью метода <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3452">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="f6353-3453">Это необходимо сделать только в том случае, если предполагается вызывать метод <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3453">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="f6353-3454">При вызове метода <xref:System.Net.Sockets.Socket.Connect%2A> до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>параметр `remoteEP` переопределит указанный удаленный узел по умолчанию только для этой операции отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3454">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="f6353-3455">Также не требуется вызывать метод <xref:System.Net.Sockets.Socket.Bind%2A>, так как базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-3455">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="f6353-3456">Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> после успешного завершения метода <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3456">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="f6353-3457">Несмотря на то, что предназначен для протоколов без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> также работает с протоколами, ориентированными на подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3457">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="f6353-3458">Если используется протокол, ориентированный на соединение, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или приняв входящий запрос на соединение с помощью метода <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3458">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-3459">Если не установить или принять подключение к удаленному узлу, <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3459">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3460">Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3460">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="f6353-3461">В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> пропустит параметр `remoteEP` и отправит данные только подключенному или удаленному узлу по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-3461">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="f6353-3462">Блокирующие сокеты блокируются до тех пор, пока не будет отправлено запрошенное число байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3462">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="f6353-3463">Поскольку незаблокированный <xref:System.Net.Sockets.Socket> завершается немедленно, он может не отправить все запрошенные байты в одной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-3463">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="f6353-3464">Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3464">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="f6353-3465">Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3465">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-3466">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-3466">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="f6353-3467">Успешное завершение метода <xref:System.Net.Sockets.Socket.SendTo%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-3467">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="f6353-3468">Если в блокирующем режиме используется протокол без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> будет блокироваться до отправки датаграммы.</span><span class="sxs-lookup"><span data-stu-id="f6353-3468">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="f6353-3469">Если вы хотите отправить данные на широковещательный адрес, сначала необходимо вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3469">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-3470">Кроме того, необходимо убедиться, что число отправленных байтов не превышает максимальный размер пакета для базового поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-3470">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-3471">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3471">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3472">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3472">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3473">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3473">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3474">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3474">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3475">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3475">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3476">В следующем примере кода датаграмма без подключения отправляется на указанный удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-3476">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="f6353-3477">Размер и <xref:System.Net.Sockets.SocketFlags> передаются методу <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3477">The size and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-3478">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3478"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-3479">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3479">-or-</span></span> 
 <span data-ttu-id="f6353-3480">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3480"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-3481">Заданное значение <paramref name="size" /> превышает размер параметра <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3481">The specified <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3482">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3482">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3483"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3483">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="f6353-3484">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3484">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="f6353-3485">Положение в буфере данных, с которого начинается отправка данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-3485">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="f6353-3486">Количество байтов для отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3486">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="f6353-3487">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3487">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="f6353-3488">Объект <see cref="T:System.Net.EndPoint" />, представляющий пункт назначения для данных.</span><span class="sxs-lookup"><span data-stu-id="f6353-3488">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="f6353-3489">Посылает указанное число байтов данных на указанную конечную точку, начиная с заданной позиции буфера и используя указанный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3489">Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="f6353-3490">Число отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3490">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3491">В этой перегрузке, если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-3491">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="f6353-3492">Если используется протокол без подключения, то перед вызовом <xref:System.Net.Sockets.Socket.SendTo%2A>не нужно устанавливать удаленный узел по умолчанию с помощью метода <xref:System.Net.Sockets.Socket.Connect%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3492">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="f6353-3493">Это необходимо сделать только в том случае, если предполагается вызывать метод <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3493">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="f6353-3494">При вызове метода <xref:System.Net.Sockets.Socket.Connect%2A> до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>параметр `remoteEP` переопределит указанный удаленный узел по умолчанию только для этой операции отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3494">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="f6353-3495">Также не требуется вызывать метод <xref:System.Net.Sockets.Socket.Bind%2A>, так как базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-3495">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="f6353-3496">Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> после успешного завершения метода <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3496">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="f6353-3497">Несмотря на то, что предназначен для протоколов без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> также работает с протоколами, ориентированными на подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3497">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="f6353-3498">Если используется протокол, ориентированный на соединение, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или приняв входящий запрос на соединение с помощью метода <xref:System.Net.Sockets.Socket.Accept%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3498">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="f6353-3499">Если не установить или принять подключение к удаленному узлу, <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3499">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3500">Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3500">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="f6353-3501">В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> пропустит параметр `remoteEP` и отправит данные только подключенному или удаленному узлу по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="f6353-3501">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="f6353-3502">Блокирующие сокеты блокируются до тех пор, пока не будет отправлено запрошенное число байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3502">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="f6353-3503">Поскольку Неблокирующая <xref:System.Net.Sockets.Socket> завершается немедленно, она может не отправить все запрошенные байты в одной операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-3503">Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="f6353-3504">Мы обязаны следить за количеством отправленных байтов и повторить операцию до тех пор, пока приложение не отправит запрошенное число байтов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3504">It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="f6353-3505">Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3505">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="f6353-3506">Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих.</span><span class="sxs-lookup"><span data-stu-id="f6353-3506">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="f6353-3507">Успешное завершение метода <xref:System.Net.Sockets.Socket.SendTo%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.</span><span class="sxs-lookup"><span data-stu-id="f6353-3507">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="f6353-3508">Если в блокирующем режиме используется протокол без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> будет блокироваться до отправки датаграммы.</span><span class="sxs-lookup"><span data-stu-id="f6353-3508">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="f6353-3509">Если вы хотите отправить данные на широковещательный адрес, сначала необходимо вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3509">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6353-3510">Кроме того, необходимо убедиться, что размер не превышает максимальный размер пакета для базового поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-3510">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-3511">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3511">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3512">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3512">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3513">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3513">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3514">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3514">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3515">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3515">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3516">В следующем примере кода датаграмма без подключения отправляется на указанный удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-3516">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="f6353-3517">Смещение, размер и <xref:System.Net.Sockets.SocketFlags> передаются методу <xref:System.Net.Sockets.Socket.SendTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3517">The offset, size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-3518">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3518"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="f6353-3519">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3519">-or-</span></span> 
 <span data-ttu-id="f6353-3520">Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3520"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-3521">Значение параметра <paramref name="offset" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-3521"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-3522">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3522">-or-</span></span> 
 <span data-ttu-id="f6353-3523">Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3523"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="f6353-3524">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3524">-or-</span></span> 
 <span data-ttu-id="f6353-3525">Значение параметра <paramref name="size" /> меньше 0.</span><span class="sxs-lookup"><span data-stu-id="f6353-3525"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6353-3526">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3526">-or-</span></span> 
 <span data-ttu-id="f6353-3527">Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3527"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3528"><paramref name="socketFlags" /> — недопустимое сочетание значений.</span><span class="sxs-lookup"><span data-stu-id="f6353-3528"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="f6353-3529">- или -</span><span class="sxs-lookup"><span data-stu-id="f6353-3529">-or-</span></span> 
<span data-ttu-id="f6353-3530">Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3530">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3531"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3531">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="f6353-3532">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</span><span class="sxs-lookup"><span data-stu-id="f6353-3532">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="f6353-3533">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-3533">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="f6353-3534">Асинхронно передает данные на конкретный удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="f6353-3534">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="f6353-3535"><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания.</span><span class="sxs-lookup"><span data-stu-id="f6353-3535"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="f6353-3536">По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3536">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="f6353-3537"><see langword="false" />, если операция ввода-вывода завершена синхронно.</span><span class="sxs-lookup"><span data-stu-id="f6353-3537"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="f6353-3538">В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</span><span class="sxs-lookup"><span data-stu-id="f6353-3538">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3539">Метод <xref:System.Net.Sockets.Socket.SendToAsync%2A> запускает асинхронную операцию отправки на удаленный узел, указанный в свойстве <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> параметра `e`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3539">The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property of the `e` parameter.</span></span> <span data-ttu-id="f6353-3540">Вызов метода <xref:System.Net.Sockets.Socket.SendToAsync%2A> дает возможность отправки данных в отдельном потоке выполнения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3540">Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="f6353-3541">Хотя этот метод предназначен для протоколов без подключения, <xref:System.Net.Sockets.Socket.SendToAsync%2A> работает с протоколами, ориентированными на подключения и без подключения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3541">Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="f6353-3542">Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик события EventHandler\<SocketAsyncEventArgs > делегат и присоединить обратный вызов к событию <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3542">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="f6353-3543">Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> необходимы для успешного вызова этого метода:</span><span class="sxs-lookup"><span data-stu-id="f6353-3543">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="f6353-3544">Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.SendToAsync%2A>, чтобы информация была извлечена в методе обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="f6353-3544">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="f6353-3545">Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3545">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="f6353-3546">При использовании протокола, ориентированного на соединение, необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3546">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span> <span data-ttu-id="f6353-3547">В противном случае <xref:System.Net.Sockets.Socket.SendToAsync%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3547">Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3548">При использовании протокола, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.SendToAsync%2A> игнорирует свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> и отправляет данные в <xref:System.Net.EndPoint?displayProperty=nameWithType>, установленные в <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или методе <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3548">When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property and send data to the <xref:System.Net.EndPoint?displayProperty=nameWithType> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-3549">Если используется протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод перед вызовом <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3549">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span></span> <span data-ttu-id="f6353-3550">Это необходимо сделать только в том случае, если предполагается вызывать методы <xref:System.Net.Sockets.Socket.BeginSend%2A> или <xref:System.Net.Sockets.Socket.SendAsync%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3550">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods.</span></span> <span data-ttu-id="f6353-3551">При вызове метода <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> до вызова <xref:System.Net.Sockets.Socket.SendToAsync%2A>свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> переопределит указанный удаленный узел по умолчанию только для этой операции отправки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3551">If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="f6353-3552">Также не требуется вызывать метод <xref:System.Net.Sockets.Socket.Bind%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3552">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="f6353-3553">В этом случае базовый поставщик услуг будет назначать наиболее подходящий IP-адрес локальной сети и номер порта.</span><span class="sxs-lookup"><span data-stu-id="f6353-3553">In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</span></span> <span data-ttu-id="f6353-3554">Если необходимо, чтобы базовый поставщик услуг выберет свободный порт, используйте нуль-порт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3554">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="f6353-3555">Если необходимо указать назначенный локальный сетевой IP-адрес и номер порта, можно использовать свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> после сигнализации события <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> и вызова связанных делегатов.</span><span class="sxs-lookup"><span data-stu-id="f6353-3555">If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event is signaled and the associated delegates are called.</span></span>  
  
 <span data-ttu-id="f6353-3556">Если вы хотите отправить данные на широковещательный адрес, сначала необходимо вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета для <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> в значение true.</span><span class="sxs-lookup"><span data-stu-id="f6353-3556">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> to true.</span></span> <span data-ttu-id="f6353-3557">Кроме того, необходимо убедиться, что размер буфера не превышает максимальный размер пакета для базового поставщика услуг.</span><span class="sxs-lookup"><span data-stu-id="f6353-3557">You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="f6353-3558">Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.SendToAsync%2A> выдаст <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3558">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="f6353-3559">Если указать флаг Донтрауте в свойстве <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>, отправляемые данные не будут маршрутизироваться.</span><span class="sxs-lookup"><span data-stu-id="f6353-3559">If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="f6353-3560">Для сокетов, ориентированных на сообщения, необходимо не превышать максимальный размер сообщения базового транспорта.</span><span class="sxs-lookup"><span data-stu-id="f6353-3560">For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</span></span> <span data-ttu-id="f6353-3561">Если размер буфера превышает максимальный размер пакета основного поставщика услуг, датаграмма не отправляется, а <xref:System.Net.Sockets.Socket.SendToAsync%2A> выдает <xref:System.Net.Sockets.SocketException>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3561">If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="f6353-3562">Успешное завершение метода <xref:System.Net.Sockets.Socket.SendToAsync%2A> не означает, что данные были успешно доставлены.</span><span class="sxs-lookup"><span data-stu-id="f6353-3562">The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-3563">Объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не может иметь значение "null".</span><span class="sxs-lookup"><span data-stu-id="f6353-3563">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-3564">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3564">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-3565">Этот метод доступен только в Windows XP и более поздних версиях.</span><span class="sxs-lookup"><span data-stu-id="f6353-3565">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3566"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3566">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3567">Указанный протокол работает с установлением соединения, но объект <see cref="T:System.Net.Sockets.Socket" /> еще не подключен.</span><span class="sxs-lookup"><span data-stu-id="f6353-3567">The protocol specified is connection-oriented, but the <see cref="T:System.Net.Sockets.Socket" /> is not yet connected.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="level"><span data-ttu-id="f6353-3568">Уровень защиты IP, который надо установить для сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-3568">The IP protection level to set on this socket.</span></span></param>
        <summary><span data-ttu-id="f6353-3569">Задается стандартный уровень защиты IP для сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-3569">Set the IP protection level on a socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3570">Метод <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> позволяет ограничить сокеты IPv6 или IP для прослушивания указанной области, например адресов с одинаковой локальной ссылкой или локальным префиксом сайта.</span><span class="sxs-lookup"><span data-stu-id="f6353-3570">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</span></span> <span data-ttu-id="f6353-3571">Этот параметр сокета позволяет приложениям размещать ограничения доступа к сокетам IPv6 или IP.</span><span class="sxs-lookup"><span data-stu-id="f6353-3571">This socket option enables applications to place access restrictions on IPv6 or IP sockets.</span></span> <span data-ttu-id="f6353-3572">Такие ограничения позволяют приложению, работающему в частной локальной сети, просто и надежно защититься от внешних атак.</span><span class="sxs-lookup"><span data-stu-id="f6353-3572">Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</span></span> <span data-ttu-id="f6353-3573">Этот параметр сокета также можно использовать для удаления ограничений доступа, если для параметра `level` задано значение <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3573">This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span></span> <span data-ttu-id="f6353-3574">Этот параметр сокета расширяет или сужает диапазон прослушивающего сокета, обеспечивая при необходимости неограниченный доступ со стороны открытых и закрытых пользователей или ограничивая доступ только тем же сайтом.</span><span class="sxs-lookup"><span data-stu-id="f6353-3574">This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</span></span>  
  
 <span data-ttu-id="f6353-3575">Определенные уровни защиты этого параметра сокета указаны в перечислении <xref:System.Net.Sockets.IPProtectionLevel>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3575">This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.</span></span>  
  
 <span data-ttu-id="f6353-3576">Метод <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> используется для включения или отключения обхода сетевых адресов (NAT) для экземпляра <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3576">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance.</span></span> <span data-ttu-id="f6353-3577">Обход NAT может быть предоставлен с помощью Teredo, 6to4 или туннеля ISATAP.</span><span class="sxs-lookup"><span data-stu-id="f6353-3577">NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</span></span>  
  
 <span data-ttu-id="f6353-3578">Если параметр `level` имеет значение <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>или <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, это явно отключает обход NAT для экземпляра <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3578">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance.</span></span>  
  
 <span data-ttu-id="f6353-3579">Если параметр `level` имеет значение <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, это может разрешить обход NAT для <xref:System.Net.Sockets.Socket> в зависимости от правил брандмауэра на компьютере.</span><span class="sxs-lookup"><span data-stu-id="f6353-3579">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6353-3580">Параметр <paramref name="level" /> не может иметь значение <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3580">The <paramref name="level" /> parameter cannot be <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span></span> <span data-ttu-id="f6353-3581">Уровень защиты IP не может быть неопределенным.</span><span class="sxs-lookup"><span data-stu-id="f6353-3581">The IP protection level cannot be set to unspecified.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-3582"><see cref="T:System.Net.Sockets.AddressFamily" /> сокета должен быть либо <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />, либо <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3582">The <see cref="T:System.Net.Sockets.AddressFamily" /> of the socket must be either <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span></span></exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6353-3583">Устанавливает параметр <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3583">Sets a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="f6353-3584">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3584">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="f6353-3585">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3585">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="f6353-3586">Значение параметра, представленное в виде объекта <see cref="T:System.Boolean" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3586">The value of the option, represented as a <see cref="T:System.Boolean" />.</span></span></param>
        <summary><span data-ttu-id="f6353-3587">Устанавливает для заданного параметра <see cref="T:System.Net.Sockets.Socket" /> указанное значение <see cref="T:System.Boolean" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3587">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified <see cref="T:System.Boolean" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3588">Параметры <xref:System.Net.Sockets.Socket> определяют поведение текущего <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3588"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-3589">Задайте для параметра `optionValue` значение `true`, чтобы включить параметр, или `false`, чтобы отключить параметр.</span><span class="sxs-lookup"><span data-stu-id="f6353-3589">Set `optionValue` to `true` to enable the option, or to `false` to disable the option.</span></span>  
  
 <span data-ttu-id="f6353-3590">Параметры <xref:System.Net.Sockets.Socket> группируются по уровню поддержки протокола.</span><span class="sxs-lookup"><span data-stu-id="f6353-3590"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="f6353-3591">Ниже приведены различные параметры <xref:System.Net.Sockets.Socket>, которые можно задать с помощью этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3591">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="f6353-3592">Эти параметры группируются по соответствующему <xref:System.Net.Sockets.SocketOptionLevel>у значению.</span><span class="sxs-lookup"><span data-stu-id="f6353-3592">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value.</span></span> <span data-ttu-id="f6353-3593">Если вы собираетесь задать любой из этих параметров, обязательно используйте соответствующее значение <xref:System.Net.Sockets.SocketOptionLevel> для параметра `optionLevel`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3593">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter.</span></span> <span data-ttu-id="f6353-3594">Параметр, выбранный для установки, должен быть указан в параметре `optionName`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3594">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="f6353-3595">Если вы хотите получить текущее значение любого из перечисленных параметров, используйте метод <xref:System.Net.Sockets.Socket.GetSocketOption%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3595">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-3596"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3596"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <span data-ttu-id="f6353-3597"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3597"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="f6353-3598"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3598"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="f6353-3599"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3599"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="f6353-3600">Дополнительные сведения об этих параметрах см. в описании перечисления <xref:System.Net.Sockets.SocketOptionName>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3600">For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3601">При получении исключения <xref:System.Net.Sockets.SocketException> используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3601">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3602">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3602">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3603">В следующем примере кода открывается сокет и включаются параметры `DontLinger` и `OutOfBandInline` сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-3603">The following code example opens a socket and enables the `DontLinger` and the `OutOfBandInline` socket options.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3604">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3604">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3605">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3605">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="f6353-3606">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3606">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="f6353-3607">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3607">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="f6353-3608">Массив типа <see cref="T:System.Byte" />, который представляет значение параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-3608">An array of type <see cref="T:System.Byte" /> that represents the value of the option.</span></span></param>
        <summary><span data-ttu-id="f6353-3609">Устанавливает для указанного параметра <see cref="T:System.Net.Sockets.Socket" /> заданное значение, представленное в виде байтового массива.</span><span class="sxs-lookup"><span data-stu-id="f6353-3609">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3610">Параметры <xref:System.Net.Sockets.Socket> определяют поведение текущего <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3610"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-3611">Используйте эту перегрузку, чтобы задать параметры <xref:System.Net.Sockets.Socket>, для которых требуется массив байтов в качестве значения параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-3611">Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3612">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3612">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3613">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3613">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3614">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3614">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3615">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3615">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3616">В следующем примере кода задаются значения времени ожидания <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3616">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3617">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3617">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3618"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3618">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="f6353-3619">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3619">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="f6353-3620">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3620">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="f6353-3621">Значение параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-3621">A value of the option.</span></span></param>
        <summary><span data-ttu-id="f6353-3622">Устанавливает заданное целое значение для указанного параметра <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3622">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3623">Параметры <xref:System.Net.Sockets.Socket> определяют поведение текущего <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3623"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-3624">Для параметра с типом данных <xref:System.Boolean> укажите ненулевое значение, чтобы включить параметр, и нулевое значение для отключения параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-3624">For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</span></span> <span data-ttu-id="f6353-3625">Для параметра с целочисленным типом данных укажите соответствующее значение.</span><span class="sxs-lookup"><span data-stu-id="f6353-3625">For an option with an integer data type, specify the appropriate value.</span></span> <span data-ttu-id="f6353-3626">Параметры <xref:System.Net.Sockets.Socket> группируются по уровню поддержки протокола.</span><span class="sxs-lookup"><span data-stu-id="f6353-3626"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="f6353-3627">Ниже приведены различные параметры <xref:System.Net.Sockets.Socket>, которые можно задать с помощью этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3627">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="f6353-3628">Эти параметры группируются по соответствующему <xref:System.Net.Sockets.SocketOptionLevel>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3628">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>.</span></span> <span data-ttu-id="f6353-3629">Если вы собираетесь задать любой из этих параметров, обязательно используйте соответствующие <xref:System.Net.Sockets.SocketOptionLevel> для параметра `optionLevel`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3629">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter.</span></span> <span data-ttu-id="f6353-3630">Параметр, выбранный для установки, должен быть указан в параметре `optionName`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3630">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="f6353-3631">Если вы хотите получить текущее значение любого из перечисленных параметров, используйте метод <xref:System.Net.Sockets.Socket.GetSocketOption%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3631">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="f6353-3632"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3632"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <span data-ttu-id="f6353-3633"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3633"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="f6353-3634"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3634"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="f6353-3635"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3635"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="f6353-3636"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3636"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 <span data-ttu-id="f6353-3637">Дополнительные сведения об этих параметрах см. в описании перечисления <xref:System.Net.Sockets.SocketOptionName>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3637">For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3638">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3638">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3639">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3639">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3640">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3640">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3641">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3641">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3642">В следующем примере кода задаются значения времени ожидания <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3642">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3643">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3643">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3644"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3644">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="f6353-3645">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3645">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="f6353-3646">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3646">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="f6353-3647">Объект <see cref="T:System.Net.Sockets.LingerOption" /> или <see cref="T:System.Net.Sockets.MulticastOption" />, содержащий значение параметра.</span><span class="sxs-lookup"><span data-stu-id="f6353-3647">A <see cref="T:System.Net.Sockets.LingerOption" /> or <see cref="T:System.Net.Sockets.MulticastOption" /> that contains the value of the option.</span></span></param>
        <summary><span data-ttu-id="f6353-3648">Устанавливает для указанного параметра <see cref="T:System.Net.Sockets.Socket" /> заданное значение, представленное в виде объекта.</span><span class="sxs-lookup"><span data-stu-id="f6353-3648">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3649">Параметры <xref:System.Net.Sockets.Socket> определяют поведение текущего <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3649"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-3650">Используйте эту перегрузку, чтобы задать параметры <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>и <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3650">Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="f6353-3651">Для параметра <xref:System.Net.Sockets.SocketOptionName.Linger> используйте <xref:System.Net.Sockets.Socket> для параметра `optionLevel`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3651">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="f6353-3652">Для <xref:System.Net.Sockets.SocketOptionName.AddMembership> и <xref:System.Net.Sockets.SocketOptionName.DropMembership>используйте <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3652">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="f6353-3653">Если вы хотите получить текущее значение любого из перечисленных выше параметров, используйте метод <xref:System.Net.Sockets.Socket.GetSocketOption%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3653">If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3654">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3654">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3655">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3655">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3656">В следующем примере кода задаются значения времени ожидания <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3656">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6353-3657">Свойство <paramref name="optionValue" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3657"><paramref name="optionValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3658">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3658">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3659"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3659">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how"><span data-ttu-id="f6353-3660">Одно из значений <see cref="T:System.Net.Sockets.SocketShutdown" />, указывающее на то, что операция более не разрешена.</span><span class="sxs-lookup"><span data-stu-id="f6353-3660">One of the <see cref="T:System.Net.Sockets.SocketShutdown" /> values that specifies the operation that will no longer be allowed.</span></span></param>
        <summary><span data-ttu-id="f6353-3661">Блокирует передачу и получение данных для объекта <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3661">Disables sends and receives on a <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3662">При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, перед закрытием <xref:System.Net.Sockets.Socket>всегда вызывайте метод <xref:System.Net.Sockets.Socket.Shutdown%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3662">When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-3663">Это гарантирует, что все данные отправляются и получаются на подключенном сокете до его закрытия.</span><span class="sxs-lookup"><span data-stu-id="f6353-3663">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="f6353-3664">Вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>, чтобы освободить все управляемые и неуправляемые ресурсы, связанные с <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3664">Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-3665">Не пытайтесь повторно использовать <xref:System.Net.Sockets.Socket> после закрытия.</span><span class="sxs-lookup"><span data-stu-id="f6353-3665">Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.</span></span>  
  
 <span data-ttu-id="f6353-3666">В следующей таблице приведены значения перечисления <xref:System.Net.Sockets.SocketShutdown>, допустимые для параметра `how`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3666">The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter.</span></span>  
  
|<span data-ttu-id="f6353-3667">Значение</span><span class="sxs-lookup"><span data-stu-id="f6353-3667">Value</span></span>|<span data-ttu-id="f6353-3668">Описание</span><span class="sxs-lookup"><span data-stu-id="f6353-3668">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="f6353-3669">Отправить</span><span class="sxs-lookup"><span data-stu-id="f6353-3669">Send</span></span>|<span data-ttu-id="f6353-3670">Отключить отправку на этом <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3670">Disable sending on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="f6353-3671">Получить</span><span class="sxs-lookup"><span data-stu-id="f6353-3671">Receive</span></span>|<span data-ttu-id="f6353-3672">Отключить получение на этом <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3672">Disable receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="f6353-3673">Оба</span><span class="sxs-lookup"><span data-stu-id="f6353-3673">Both</span></span>|<span data-ttu-id="f6353-3674">Отключите отправку и получение на этом <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3674">Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
  
 <span data-ttu-id="f6353-3675">Установка `how` в значение <xref:System.Net.Sockets.SocketShutdown.Send> указывает, что последующие вызовы <xref:System.Net.Sockets.Socket.Send%2A> запрещены.</span><span class="sxs-lookup"><span data-stu-id="f6353-3675">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed.</span></span> <span data-ttu-id="f6353-3676">Если используется <xref:System.Net.Sockets.Socket>без подключения, то указание <xref:System.Net.Sockets.SocketShutdown.Send> не будет действовать.</span><span class="sxs-lookup"><span data-stu-id="f6353-3676">If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.</span></span>  
  
 <span data-ttu-id="f6353-3677">Установка `how` в значение <xref:System.Net.Sockets.SocketShutdown.Receive> указывает, что последующие вызовы <xref:System.Net.Sockets.Socket.Receive%2A> запрещены.</span><span class="sxs-lookup"><span data-stu-id="f6353-3677">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed.</span></span> <span data-ttu-id="f6353-3678">Это не влияет на более низкие уровни протокола.</span><span class="sxs-lookup"><span data-stu-id="f6353-3678">This has no effect on lower protocol layers.</span></span> <span data-ttu-id="f6353-3679">Если используется протокол, ориентированный на соединение, соединение завершается, если после вызова <xref:System.Net.Sockets.Socket.Shutdown%2A> выполняется одно из следующих условий.</span><span class="sxs-lookup"><span data-stu-id="f6353-3679">If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span></span>  
  
-   <span data-ttu-id="f6353-3680">Данные находятся в входящем сетевом буфере, ожидающем получения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3680">Data is in the incoming network buffer waiting to be received.</span></span>  
  
-   <span data-ttu-id="f6353-3681">Получены дополнительные данные.</span><span class="sxs-lookup"><span data-stu-id="f6353-3681">More data has arrived.</span></span>  
  
 <span data-ttu-id="f6353-3682">Если используется протокол без установления соединения, датаграммы принимаются и ставятся в очередь.</span><span class="sxs-lookup"><span data-stu-id="f6353-3682">If you are using a connectionless protocol, datagrams are accepted and queued.</span></span> <span data-ttu-id="f6353-3683">Однако если для дополнительных входящих датаграмм нет буферного пространства, они будут удалены, а отправителю не будет возвращено сообщение об ошибке.</span><span class="sxs-lookup"><span data-stu-id="f6353-3683">However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</span></span> <span data-ttu-id="f6353-3684">Использовать <xref:System.Net.Sockets.Socket.Shutdown%2A> для <xref:System.Net.Sockets.Socket> без подключения не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="f6353-3684">Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.</span></span>  
  
 <span data-ttu-id="f6353-3685">При установке `how` <xref:System.Net.Sockets.SocketShutdown.Both> отключает обе операции отправки и получения, как описано выше.</span><span class="sxs-lookup"><span data-stu-id="f6353-3685">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3686">При получении <xref:System.Net.Sockets.SocketException> при вызове метода <xref:System.Net.Sockets.Socket.Shutdown%2A> используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3686">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3687">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3687">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6353-3688">Данный член генерирует сведения трассировки, если в приложении включена трассировка сети.</span><span class="sxs-lookup"><span data-stu-id="f6353-3688">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="f6353-3689">Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3689">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3690">В следующем примере кода для отключения <xref:System.Net.Sockets.Socket>используется <xref:System.Net.Sockets.Socket.Shutdown%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3690">The following code example uses <xref:System.Net.Sockets.Socket.Shutdown%2A> to disable the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3691">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3691">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3692"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3692">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-3693">Возвращает тип службы <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3693">Gets the type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="f6353-3694">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketType" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3694">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3695"><xref:System.Net.Sockets.Socket.SocketType%2A> доступен только для чтения и задается при создании <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3695"><xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3696">В следующем примере кода выводятся <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>и <xref:System.Net.Sockets.ProtocolType> на консоль.</span><span class="sxs-lookup"><span data-stu-id="f6353-3696">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-3697">Возвращает значение, указывающее, доступна ли на текущем узле поддержка протокола IPv4 и включена ли эта функция.</span><span class="sxs-lookup"><span data-stu-id="f6353-3697">Gets a value indicating whether IPv4 support is available and enabled on the current host.</span></span></summary>
        <value><span data-ttu-id="f6353-3698">Значение <see langword="true" />, если текущий узел поддерживает протокол IPv4; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3698"><see langword="true" /> if the current host supports the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3699">Операционная система может поддерживать протоколы IPv4 и IPv6.</span><span class="sxs-lookup"><span data-stu-id="f6353-3699">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-3700">Получает значение, указывающее, поддерживает ли Framework протокол IPv6 для определенных устаревших членов <see cref="T:System.Net.Dns" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3700">Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> members.</span></span></summary>
        <value><span data-ttu-id="f6353-3701">Значение <see langword="true" />, если Framework поддерживает протокол IPv6 для определенных устаревших методов <see cref="T:System.Net.Dns" />; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3701"><see langword="true" /> if the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> methods; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3702">Операционная система может поддерживать протоколы IPv4 и IPv6.</span><span class="sxs-lookup"><span data-stu-id="f6353-3702">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6353-3703">Освобождает все ресурсы, занятые модулем <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3703">Releases all resources used by the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="f6353-3704">Вызовите IDisposable. Dispose по завершении использования <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3704">Call IDisposable.Dispose when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-3705">Метод IDisposable. Dispose оставляет <xref:System.Net.Sockets.Socket> в непригодном для использования состоянии.</span><span class="sxs-lookup"><span data-stu-id="f6353-3705">The IDisposable.Dispose method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="f6353-3706">После вызова IDisposable. Dispose необходимо освободить все ссылки на <xref:System.Net.Sockets.Socket>, чтобы сборщик мусора мог высвободить память, занимаемую <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3706">After calling IDisposable.Dispose, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span> <span data-ttu-id="f6353-3707">Дополнительные сведения см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="f6353-3707">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>

> [!NOTE] 
> <span data-ttu-id="f6353-3708">Всегда вызывайте IDisposable. Dispose перед освобождением последней ссылки на <xref:System.Net.Sockets.Socket>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3708">Always call IDisposable.Dispose before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="f6353-3709">В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Net.Sockets.Socket> метод `Finalize`.</span><span class="sxs-lookup"><span data-stu-id="f6353-3709">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-3710">Получает или задает значение, задающее время существования (TTL) IP-пакетов, отправленных объектом <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3710">Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="f6353-3711">Значение времени существования TTL.</span><span class="sxs-lookup"><span data-stu-id="f6353-3711">The TTL value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3712">Значение TTL указывает максимальное число маршрутизаторов, которые может пройти пакет, прежде чем маршрутизатор отклоняет пакет и сообщение об ошибке TTL (ICMP), полученное по истечении срока жизни, возвращается отправителю.</span><span class="sxs-lookup"><span data-stu-id="f6353-3712">The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</span></span>  
  
 <span data-ttu-id="f6353-3713">Для значения TTL можно задать значение от 0 до 255.</span><span class="sxs-lookup"><span data-stu-id="f6353-3713">The TTL value may be set to a value from 0 to 255.</span></span> <span data-ttu-id="f6353-3714">Если это свойство не задано, значение TTL по умолчанию для сокета равно 32.</span><span class="sxs-lookup"><span data-stu-id="f6353-3714">When this property is not set, the default TTL value for a socket is 32.</span></span>  
  
 <span data-ttu-id="f6353-3715">Установка этого свойства для сокета TCP/IP пропускается стеком TCP/SSL, если установлено успешное соединение с помощью сокета.</span><span class="sxs-lookup"><span data-stu-id="f6353-3715">Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</span></span>  
  
 <span data-ttu-id="f6353-3716">Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3716">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="f6353-3717">После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.</span><span class="sxs-lookup"><span data-stu-id="f6353-3717">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6353-3718">В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.Ttl%2A> свойство.</span><span class="sxs-lookup"><span data-stu-id="f6353-3718">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.Ttl%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6353-3719">В качестве величины срока жизни нельзя задать отрицательное число.</span><span class="sxs-lookup"><span data-stu-id="f6353-3719">The TTL value can't be set to a negative number.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6353-3720">Это свойство может быть установлено только для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3720">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="f6353-3721">Произошла ошибка при попытке доступа к сокету.</span><span class="sxs-lookup"><span data-stu-id="f6353-3721">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="f6353-3722">Эта ошибка также возвращается при попытке задать срок жизни больше, чем 255.</span><span class="sxs-lookup"><span data-stu-id="f6353-3722">This error is also returned when an attempt was made to set TTL to a value higher than 255.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="f6353-3723"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</span><span class="sxs-lookup"><span data-stu-id="f6353-3723">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6353-3724">Указывает, должен ли сокет использовать только режим ввода-вывода Overlapped.</span><span class="sxs-lookup"><span data-stu-id="f6353-3724">Specifies whether the socket should only use Overlapped I/O mode.</span></span></summary>
        <value><span data-ttu-id="f6353-3725">Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> использует только режим перекрывающего ввода-вывода; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3725"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses only overlapped I/O; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="f6353-3726">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f6353-3726">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6353-3727">Присвойте этому свойству значение `true` для <xref:System.Net.Sockets.Socket>, который необходимо вызвать <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3727">Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span> <span data-ttu-id="f6353-3728">В противном случае платформа может назначить порту завершения сокету, что запрещает использование <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6353-3728">Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f6353-3729">Сокет привязан к порту завершения.</span><span class="sxs-lookup"><span data-stu-id="f6353-3729">The socket has been bound to a completion port.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
