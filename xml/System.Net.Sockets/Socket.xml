<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e1c7068ad313832df1fe6dd1a97a29597baf2c2b" /><Meta Name="ms.sourcegitcommit" Value="385ff23cc00fe9aa1c93460c62603b45c2041d0b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/22/2019" /><Meta Name="ms.locfileid" Value="74386022" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implements the Berkeley sockets interface.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Net.Sockets.Socket> предоставляет широкий набор методов и свойств для сетевого взаимодействия. Класс <xref:System.Net.Sockets.Socket> позволяет выполнять синхронную и асинхронную передачу данных с помощью любого из протоколов связи, перечисленных в перечислении <xref:System.Net.Sockets.ProtocolType>.  
  
 Класс <xref:System.Net.Sockets.Socket> соответствует шаблону именования .NET Framework для асинхронных методов. Например, синхронный метод <xref:System.Net.Sockets.Socket.Receive%2A> соответствует асинхронным методам <xref:System.Net.Sockets.Socket.BeginReceive%2A> и <xref:System.Net.Sockets.Socket.EndReceive%2A>.  
  
 Если приложению требуется только один поток во время выполнения, используйте следующие методы, предназначенные для работы в синхронном режиме.  
  
-   Если используется протокол, ориентированный на подключение, например TCP, сервер может прослушивать подключения с помощью метода <xref:System.Net.Sockets.Socket.Listen%2A>. Метод <xref:System.Net.Sockets.Socket.Accept%2A> обрабатывает все входящие запросы на подключение и возвращает <xref:System.Net.Sockets.Socket>, который можно использовать для передачи данных с удаленного узла. Используйте возвращенный <xref:System.Net.Sockets.Socket>, чтобы вызвать метод <xref:System.Net.Sockets.Socket.Send%2A> или <xref:System.Net.Sockets.Socket.Receive%2A>. Вызовите метод <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом метода <xref:System.Net.Sockets.Socket.Listen%2A>, если требуется указать локальный IP-адрес и номер порта. Если вы хотите, чтобы базовый поставщик услуг назначит свободный порт, используйте нулевой номер порта. Если вы хотите подключиться к узлу прослушивания, вызовите метод <xref:System.Net.Sockets.Socket.Connect%2A>. Чтобы передать данные, вызовите метод <xref:System.Net.Sockets.Socket.Send%2A> или <xref:System.Net.Sockets.Socket.Receive%2A>.  
  
-   Если используется протокол без установления соединения, например UDP, нет необходимости прослушивать подключения вообще. Вызовите метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, чтобы принимать все входящие датаграммы. Используйте метод <xref:System.Net.Sockets.Socket.SendTo%2A> для отправки датаграмм на удаленный узел.  
  
 Для обработки обмена данными с помощью отдельных потоков во время выполнения используйте следующие методы, предназначенные для асинхронного режима работы.  
  
-   Если используется протокол, ориентированный на подключение, например TCP, используйте методы <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>и <xref:System.Net.Sockets.Socket.EndConnect%2A> для подключения к узлу прослушивания. Используйте методы <xref:System.Net.Sockets.Socket.BeginSend%2A> и <xref:System.Net.Sockets.Socket.EndSend%2A> или <xref:System.Net.Sockets.Socket.BeginReceive%2A> и <xref:System.Net.Sockets.Socket.EndReceive%2A> для асинхронной передачи данных. Входящие запросы на подключение могут обрабатываться с помощью <xref:System.Net.Sockets.Socket.BeginAccept%2A> и <xref:System.Net.Sockets.Socket.EndAccept%2A>.  
  
-   Если используется протокол без установления соединения, например UDP, можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> и <xref:System.Net.Sockets.Socket.EndSendTo%2A> для отправки датаграмм, а <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> и <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> для получения датаграмм.  
  
 При выполнении нескольких асинхронных операций на сокете они не обязательно завершаются в том порядке, в котором они были запущены.  
  
 После завершения отправки и получения данных используйте метод <xref:System.Net.Sockets.Socket.Shutdown%2A>, чтобы отключить <xref:System.Net.Sockets.Socket>. После вызова <xref:System.Net.Sockets.Socket.Shutdown%2A>вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>, чтобы освободить все ресурсы, связанные с <xref:System.Net.Sockets.Socket>.  
  
 Класс <xref:System.Net.Sockets.Socket> позволяет настроить <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.SetSocketOption%2A>. Извлеките эти параметры с помощью метода <xref:System.Net.Sockets.Socket.GetSocketOption%2A>.  
  
> [!NOTE]
>  Если вы создаете относительно простое приложение и не требует максимальной производительности, рассмотрите возможность использования <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>и <xref:System.Net.Sockets.UdpClient>. Эти классы предоставляют более простой и удобный интерфейс для <xref:System.Net.Sockets.Socket> взаимодействия.  
  
   
  
## Examples  
 В следующем примере кода показано, как можно использовать класс <xref:System.Net.Sockets.Socket> для отправки данных на HTTP-сервер и получения ответа. Этот пример блокируется до получения всей страницы.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Чтобы установить исходящее подключение или принять входящий запрос.</permission>
    <threadsafe>Экземпляры этого класса являются потокобезопасными.</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">Сетевое программирование в .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">Рекомендации по использованию классов System.Net</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">Управление кэшем для сетевых приложений</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">протокол IP версии 6</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">Примеры сетевого программирования</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">Трассировка сети в .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">Безопасность в сетевом программировании</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">Улучшения производительности сокетов в версии 3.5</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="socketInformation">The socket information returned by <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified value returned from <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы вызываете конструктор <xref:System.Net.Sockets.Socket.%23ctor%2A> несколько раз с тем же массивом байтов, что и аргумент для каждого вызова, вы создадите несколько управляемых <xref:System.Net.Sockets.Socket>s с одним и тем же базовым сокетом. Этот подход настоятельно не рекомендуется.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</param>
        <param name="protocolType">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified socket type and protocol.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `socketType` задает тип <xref:System.Net.Sockets.Socket> класса, а параметр `protocolType` указывает протокол, используемый <xref:System.Net.Sockets.Socket>. Два параметра не являются независимыми. Часто тип <xref:System.Net.Sockets.Socket> является неявным в протоколе. Если сочетание типа <xref:System.Net.Sockets.Socket> и типа протокола приводит к недопустимому <xref:System.Net.Sockets.Socket>, этот конструктор создает исключение <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если этот конструктор создает исключение <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">The combination of  <paramref name="socketType" /> and <paramref name="protocolType" /> results in an invalid socket.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</param>
        <param name="socketType">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</param>
        <param name="protocolType">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified address family, socket type and protocol.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `addressFamily` указывает схему адресации, используемую классом <xref:System.Net.Sockets.Socket>, параметр `socketType` указывает тип класса <xref:System.Net.Sockets.Socket>, а параметр `protocolType` указывает протокол, используемый <xref:System.Net.Sockets.Socket>. Три параметра не являются независимыми. Некоторые семейства адресов ограничивают, какие протоколы можно использовать с ними, и часто тип <xref:System.Net.Sockets.Socket> неявным в протоколе. Если сочетание семейства адресов, типа <xref:System.Net.Sockets.Socket> и типа протокола приводит к недопустимому <xref:System.Net.Sockets.Socket>, этот конструктор создает исключение <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если этот конструктор создает исключение <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как создать экземпляр класса <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">The combination of <paramref name="addressFamily" />, <paramref name="socketType" />, and <paramref name="protocolType" /> results in an invalid socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> синхронно извлекает из очереди запросов на подключение прослушивающего сокета первый ожидающий запрос на подключение, а затем создает и возвращает новый <xref:System.Net.Sockets.Socket>. Этот возвращенный <xref:System.Net.Sockets.Socket> нельзя использовать для принятия дополнительных соединений из очереди подключения. Однако можно вызвать метод <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> возвращенной <xref:System.Net.Sockets.Socket>, чтобы узнать сетевой адрес и номер порта удаленного узла.  
  
 В режиме блокировки <xref:System.Net.Sockets.Socket.Accept%2A> блокируется до тех пор, пока не помещается в очередь входящих подключений. Когда подключение будет принято, исходное <xref:System.Net.Sockets.Socket> продолжит постановку в очередь входящих запросов на подключение, пока вы не закроете его.  
  
 При вызове этого метода с помощью неблокирующего <xref:System.Net.Sockets.Socket>и отсутствии запросов на подключение <xref:System.Net.Sockets.Socket.Accept%2A> выдает <xref:System.Net.Sockets.SocketException>. Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Перед вызовом метода <xref:System.Net.Sockets.Socket.Accept%2A> необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.Listen%2A> для прослушивания и постановки в очередь входящих запросов на подключение.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода принимается простое <xref:System.Net.Sockets.Socket> соединение.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">The accepting socket is not listening for connections. You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.Accept" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
        <summary>Begins an asynchronous operation to accept an incoming connection attempt.</summary>
        <returns><see langword="true" /> if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.  
  
 <see langword="false" /> if the I/O operation completed synchronously. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Протоколы, ориентированные на подключение, могут использовать метод <xref:System.Net.Sockets.Socket.AcceptAsync%2A> для асинхронной обработки входящих попыток подключения. Асинхронное принятие подключений дает возможность отправлять и получать данные в отдельном потоке выполнения. Перед вызовом метода <xref:System.Net.Sockets.Socket.AcceptAsync%2A> необходимо вызвать метод <xref:System.Net.Sockets.Socket.Listen%2A> для прослушивания и постановки в очередь входящих запросов на подключение.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик события EventHandler\<SocketAsyncEventArgs > делегата и привязать его к событию <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>.  
  
 Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> являются обязательными:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающий объект может дополнительно указать существующий <xref:System.Net.Sockets.Socket>, который будет использоваться для входящего подключения, указав <xref:System.Net.Sockets.Socket> для использования со свойством <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>.  
  
 Если свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> имеет значение null, создается новая <xref:System.Net.Sockets.Socket> с тем же <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>и <xref:System.Net.Sockets.Socket.ProtocolType%2A> в качестве текущего <xref:System.Net.Sockets.Socket> и устанавливается как свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>.  
  
 Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 При необходимости можно указать буфер, в котором будет получен начальный блок данных на сокете после того, как метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> будет выполнен. В этом случае для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> необходимо задать буфер, содержащий получаемые данные, а для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> необходимо задать максимальное число байтов данных для получения в буфере. Эти свойства можно задать с помощью метода <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType>. Часть переданного буфера будет использоваться внутренне для использования базовым вызовом Winsock Акцептекс. Это означает, что объем возвращаемых данных всегда будет меньше значения свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> в предоставленном экземпляре <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>. Объем буфера, используемый внутри, зависит от семейства адресов сокета. Минимальный требуемый размер буфера составляет 288 байт. Если указан больший размер буфера, <xref:System.Net.Sockets.Socket> ожидает некоторые дополнительные данные, кроме данных адреса, полученных вызовом Winsock Акцептекс, и ждет, пока эти дополнительные данные не будут получены. В случае истечения времени ожидания соединение сбрасывается. Поэтому, если требуются дополнительные данные определенного объема, то размер буфера должен быть минимальным размером буфера и этим значением.  
  
 Метод обратного вызова завершения должен проверять свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>, чтобы определить, была ли операция <xref:System.Net.Sockets.Socket.AcceptAsync%2A> выполнена успешно.  
  
 Событие <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> может возникать в некоторых случаях, если соединение не было принято, и для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> задано значение <xref:System.Net.Sockets.SocketError.ConnectionReset>. Это может произойти в результате сканирования портов с использованием половины открытой проверки типа SYN (с последовательностью SYN-> SYN-ACK-> RST). Приложения, использующие метод <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, должны быть готовы к обработке этого условия.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">An argument is not valid. This exception occurs if the buffer provided is not large enough. The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.  
  
This exception also occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">An argument is out of range. The exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> is less than 0.</exception>
        <exception cref="T:System.InvalidOperationException">An invalid operation was requested. This exception occurs if the accepting <see cref="T:System.Net.Sockets.Socket" /> is not listening for connections or the accepted socket is bound.  
  
You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.  
  
This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <paramref name="e" /> parameter.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP or later is required for this method.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the address family of the <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Одно из значений <see cref="T:System.Net.Sockets.AddressFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily> указывает схему адресации, которую может использовать экземпляр класса <xref:System.Net.Sockets.Socket>. Это свойство доступно только для чтения и задается при создании <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 В следующем примере кода выводятся <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>и <xref:System.Net.Sockets.ProtocolType> на консоль.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of data that has been received from the network and is available to be read.</summary>
        <value>Количество байтов данных, полученных из сети и доступных для чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы используете неблокирующий <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> является хорошим способом определить, помещаются ли данные в очередь для чтения, перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Доступные данные — это общий объем данных, помещенных в очередь сетевого буфера для чтения. Если в сетевом буфере нет данных, <xref:System.Net.Sockets.Socket.Available%2A> возвращает 0.  
  
 Если удаленный узел завершает работу или закрывает соединение, <xref:System.Net.Sockets.Socket.Available%2A> может вызвать <xref:System.Net.Sockets.SocketException>. Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода сравниваются результаты вызова Иоконтрол с ФИОНРЕАД и доступным свойством.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins an asynchronous operation to accept an incoming connection attempt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">An object that contains state information for this request.</param>
        <summary>Begins an asynchronous operation to accept an incoming connection attempt.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Протоколы, ориентированные на подключение, могут использовать метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> для асинхронной обработки входящих попыток подключения. Асинхронное принятие подключений дает возможность отправлять и получать данные в отдельном потоке выполнения. Перед вызовом метода <xref:System.Net.Sockets.Socket.BeginAccept%2A> необходимо вызвать метод <xref:System.Net.Sockets.Socket.Listen%2A> для прослушивания и постановки в очередь входящих запросов на подключение.  
  
 Необходимо создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Для этого, как минимум, необходимо передать объект <xref:System.Net.Sockets.Socket> прослушивания для <xref:System.Net.Sockets.Socket.BeginAccept%2A> с помощью параметра `state`. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> с помощью параметра `state`.  
  
 Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndAccept%2A>. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginAccept%2A>, система обычно использует отдельный поток для выполнения указанного метода обратного вызова и блокируется на <xref:System.Net.Sockets.Socket.EndAccept%2A> до тех пор, пока не будет получено ожидающее подключение. <xref:System.Net.Sockets.Socket.EndAccept%2A> вернет новый объект <xref:System.Net.Sockets.Socket>, который можно использовать для отправки и получения данных с удаленного узла. Этот возвращенный <xref:System.Net.Sockets.Socket> нельзя использовать для принятия дополнительных соединений из очереди подключения. Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginAccept%2A>, используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение.  
  
 Система также может использовать вызывающий поток для вызова метода обратного вызова. В этом случае свойство <xref:System.IAsyncResult.CompletedSynchronously%2A> в возвращаемом <xref:System.IAsyncResult> будет установлено, чтобы указать, что метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> завершился синхронно.  
  
 Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginAccept%2A>, закройте <xref:System.Net.Sockets.Socket>. При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginAccept%2A>.  При последующем вызове метода <xref:System.Net.Sockets.Socket.EndAccept%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.  
  
> [!NOTE]
>  Чтобы указать сетевой адрес и номер порта удаленного узла, можно использовать свойство <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> возвращенной <xref:System.Net.Sockets.Socket>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
   
  
## Examples  
 В следующем примере кода выполняется попытка асинхронного получения входящего подключения.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT is required for this method.</exception>
        <exception cref="T:System.InvalidOperationException">The accepting socket is not listening for connections. You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
-or- 
The accepted socket is bound.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> is less than 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="receiveSize">The number of bytes to accept from the sender.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">An object that contains state information for this request.</param>
        <summary>Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Протоколы, ориентированные на подключение, могут использовать метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> для асинхронной обработки входящих попыток подключения. Асинхронное принятие подключений позволяет отправлять и получать данные в отдельном потоке выполнения. Эта перегрузка позволяет указать число байтов, которое будет принято в начальной пересылку в параметре `receiveSize`.  
  
 Перед вызовом метода <xref:System.Net.Sockets.Socket.BeginAccept%2A> необходимо вызвать метод <xref:System.Net.Sockets.Socket.Listen%2A> для прослушивания и постановки в очередь входящих запросов на подключение.  
  
 Необходимо создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Для этого, как минимум, необходимо передать объект <xref:System.Net.Sockets.Socket> прослушивания для <xref:System.Net.Sockets.Socket.BeginAccept%2A> с помощью параметра `state`. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> с помощью параметра `state`.  
  
 Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndAccept%2A>. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginAccept%2A>, система обычно использует отдельный поток для выполнения указанного метода обратного вызова и блокируется на <xref:System.Net.Sockets.Socket.EndAccept%2A> до тех пор, пока не будет получено ожидающее подключение.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> возвращает новую <xref:System.Net.Sockets.Socket>, которую можно использовать для отправки и получения данных с удаленного узла. Этот возвращенный <xref:System.Net.Sockets.Socket> нельзя использовать для принятия дополнительных соединений из очереди подключения. Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginAccept%2A>, используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение.  
  
 Система также может использовать вызывающий поток для вызова метода обратного вызова. В этом случае свойство <xref:System.IAsyncResult.CompletedSynchronously%2A> в возвращаемом <xref:System.IAsyncResult> будет установлено, чтобы указать, что метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> завершился синхронно.  
  
 Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginAccept%2A>, закройте <xref:System.Net.Sockets.Socket>.  При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginAccept%2A>.  При последующем вызове метода <xref:System.Net.Sockets.Socket.EndAccept%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.  
  
> [!NOTE]
>  Чтобы указать сетевой адрес и номер порта удаленного узла, можно вызвать метод, используя свойство <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> возвращенного объекта <xref:System.Net.Sockets.Socket>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
   
  
## Examples  
 В следующем примере кода открывается сокет и принимается асинхронное соединение. В этом примере сокет принимает начальные 10 байт данных. Число полученных байтов и данные отображаются в консоли делегатом обратного вызова. Описание того, как получены оставшиеся данные, см. в разделе <xref:System.Net.Sockets.Socket.BeginReceive%2A>.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT is required for this method.</exception>
        <exception cref="T:System.InvalidOperationException">The accepting socket is not listening for connections. You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
-or- 
The accepted socket is bound.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> is less than 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">The accepted <see cref="T:System.Net.Sockets.Socket" /> object. This value may be <see langword="null" />.</param>
        <param name="receiveSize">The maximum number of bytes to receive.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">An object that contains state information for this request.</param>
        <summary>Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> object creation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Протоколы, ориентированные на подключение, могут использовать метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> для асинхронной обработки входящих попыток подключения. Асинхронное принятие подключений дает возможность отправлять и получать данные в отдельном потоке выполнения. Эта перегрузка позволяет указать обслуживаемый сокет в параметре `acceptSocket`. Если этот параметр имеет значение `null`, то принятый сокет создается методом <xref:System.Net.Sockets.Socket.BeginAccept%2A>. В параметре `receiveSize` можно указать число байтов, которое будет принято в ходе начальной пересылки.  
  
 Перед вызовом метода <xref:System.Net.Sockets.Socket.BeginAccept%2A> необходимо вызвать метод <xref:System.Net.Sockets.Socket.Listen%2A> для прослушивания и постановки в очередь входящих запросов на подключение.  
  
 Необходимо создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Для этого, как минимум, необходимо передать объект <xref:System.Net.Sockets.Socket> прослушивания для <xref:System.Net.Sockets.Socket.BeginAccept%2A> с помощью параметра `state`. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> с помощью параметра `state`.  
  
 Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndAccept%2A>. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginAccept%2A>, система обычно использует отдельный поток для выполнения указанного метода обратного вызова и блокируется на <xref:System.Net.Sockets.Socket.EndAccept%2A> до тех пор, пока не будет получено ожидающее подключение.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> возвращает новый объект <xref:System.Net.Sockets.Socket>, который можно использовать для отправки и получения данных с удаленного узла. Этот возвращенный <xref:System.Net.Sockets.Socket> нельзя использовать для принятия дополнительных соединений из очереди подключения. Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginAccept%2A>, используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение.  
  
 Система также может использовать вызывающий поток для вызова метода обратного вызова. В этом случае свойство <xref:System.IAsyncResult.CompletedSynchronously%2A> в возвращаемом <xref:System.IAsyncResult> будет установлено, чтобы указать, что метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> завершился синхронно.  
  
 Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginAccept%2A>, закройте <xref:System.Net.Sockets.Socket>. При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginAccept%2A>.  При последующем вызове метода <xref:System.Net.Sockets.Socket.EndAccept%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.  
  
> [!NOTE]
>  Можно использовать свойство <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> возвращаемого объекта <xref:System.Net.Sockets.Socket>, чтобы указать сетевой адрес и номер порта удаленного узла.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
   
  
## Examples  
 В следующем примере кода открывается сокет и принимается асинхронное соединение. В этом примере сокет принимает начальные 10 байт данных, а параметр `acceptSocket` — `null`, что заставляет метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> создать обслуживаемый сокет. Число полученных байтов и данные отображаются в консоли делегатом обратного вызова. Описание того, как получены оставшиеся данные, см. в разделе <xref:System.Net.Sockets.Socket.BeginReceive%2A>.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT is required for this method.</exception>
        <exception cref="T:System.InvalidOperationException">The accepting socket is not listening for connections. You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
-or- 
The accepted socket is bound.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> is less than 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins an asynchronous request for a remote host connection.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</param>
        <param name="end_point">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">An object that contains state information for this request.</param>
        <summary>Begins an asynchronous request for a remote host connection.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании протокола, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.BeginConnect%2A> запускает асинхронный запрос соединения с параметром `remoteEP`. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.BeginConnect%2A> устанавливает удаленный узел по умолчанию. Подключение или установка удаленного узла по умолчанию асинхронно дает возможность отправлять и получать данные в отдельном потоке выполнения.  
  
 Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Как минимум, необходимо передать <xref:System.Net.Sockets.Socket> в <xref:System.Net.Sockets.Socket.BeginConnect%2A> с помощью параметра `state`. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket>и другие необходимые сведения. Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginConnect%2A> с помощью параметра `state`.  
  
 Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndConnect%2A>. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginConnect%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет блокироваться на <xref:System.Net.Sockets.Socket.EndConnect%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не подключится к серверу или не выдаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginConnect%2A>, используйте <xref:System.Threading.WaitHandle.WaitOne%2A>. Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.BeginConnect%2A> перед отправкой и получением данных. Для взаимодействия с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> и <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>. При вызове <xref:System.Net.Sockets.Socket.BeginConnect%2A>все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут удалены. Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, сначала необходимо вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и настроить вещание на `true`. Если это невозможно, <xref:System.Net.Sockets.Socket.BeginConnect%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
 Если вы используете протокол, ориентированный на подключение, и не вызываете <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.BeginConnect%2A>, базовый поставщик услуг присвоит наиболее подходящий локальный сетевой адрес и номер порта. Если используется протокол без установления соединения, поставщик услуг не присвоит адрес локальной сети и номер порта, пока не будет вызван метод <xref:System.Net.Sockets.Socket.BeginSend%2A> или <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. Если вы хотите изменить удаленный узел по умолчанию, вызовите метод <xref:System.Net.Sockets.Socket.BeginConnect%2A> еще раз, указав нужную конечную точку.  
  
 Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginConnect%2A>, закройте <xref:System.Net.Sockets.Socket>. При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginConnect%2A>.  При последующем вызове метода <xref:System.Net.Sockets.Socket.EndConnect%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Если этот сокет ранее был отключен, то <xref:System.Net.Sockets.Socket.BeginConnect%2A> должен быть вызван в потоке, который не будет выходить до завершения операции. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
   
  
## Examples  
 В следующем примере кода инициируется асинхронная попытка соединения.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">The <see cref="T:System.Net.IPAddress" /> of the remote host.</param>
        <param name="port">The port number of the remote host.</param>
        <param name="requestCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</param>
        <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</param>
        <param name="state">A user-defined object that contains information about the connect operation. This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</param>
        <summary>Begins an asynchronous request for a remote host connection. The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginConnect%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndConnect%2A>. Как правило, метод вызывается делегатом `requestCallback`.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из <xref:System.Net.Sockets.Socket.Connect%2A> перегрузок метода или <xref:System.Net.Sockets.Socket.EndConnect%2A>.  
  
 Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginConnect%2A>, закройте <xref:System.Net.Sockets.Socket>. При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginConnect%2A>.  При последующем вызове метода <xref:System.Net.Sockets.Socket.EndConnect%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Если этот сокет ранее был отключен, то <xref:System.Net.Sockets.Socket.BeginConnect%2A> должен быть вызван в потоке, который не будет выходить до завершения операции. Это ограничение базового поставщика. Кроме того, используемое <xref:System.Net.EndPoint> должно отличаться.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
   
  
## Examples  
 В следующем примере кода инициируется асинхронная попытка соединения.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Net.Sockets.Socket" /> is not in the socket family.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The port number is not valid.</exception>
        <exception cref="T:System.ArgumentException">The length of <paramref name="address" /> is zero.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</param>
        <param name="port">The port number of the remote host.</param>
        <param name="requestCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</param>
        <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</param>
        <param name="state">A user-defined object that contains information about the connect operation. This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</param>
        <summary>Begins an asynchronous request for a remote host connection. The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginConnect%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndConnect%2A>. Как правило, метод вызывается делегатом `requestCallback`.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из перегрузок метода <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginConnect%2A>, закройте <xref:System.Net.Sockets.Socket>. При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginConnect%2A>.  При последующем вызове метода <xref:System.Net.Sockets.Socket.EndConnect%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Если этот сокет ранее был отключен, то <xref:System.Net.Sockets.Socket.BeginConnect%2A> должен быть вызван в потоке, который не будет выходить до завершения операции. Это ограничение базового поставщика. Кроме того, используемое <xref:System.Net.EndPoint> должно отличаться.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
   
  
## Examples  
 В следующем примере кода инициируется асинхронная попытка соединения.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.NotSupportedException">This method is valid for sockets that use <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The port number is not valid.</exception>
        <exception cref="T:System.ArgumentException">The length of <paramref name="address" /> is zero.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, requestCallback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">The name of the remote host.</param>
        <param name="port">The port number of the remote host.</param>
        <param name="requestCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</param>
        <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</param>
        <param name="state">A user-defined object that contains information about the connect operation. This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</param>
        <summary>Begins an asynchronous request for a remote host connection. The host is specified by a host name and a port number.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginConnect%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndConnect%2A>. Как правило, метод вызывается делегатом `requestCallback`.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из перегрузок метода <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Чтобы отменить отложенный вызов метода <xref:System.Net.Sockets.Socket.BeginConnect%2A>, закройте <xref:System.Net.Sockets.Socket>. При вызове метода <xref:System.Net.Sockets.Socket.Close%2A> во время выполнения асинхронной операции вызывается обратный вызов, предоставленный методу <xref:System.Net.Sockets.Socket.BeginConnect%2A>.  При последующем вызове метода <xref:System.Net.Sockets.Socket.EndConnect%2A> создается <xref:System.ObjectDisposedException>, чтобы указать, что операция была отменена.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Если этот сокет ранее был отключен, то <xref:System.Net.Sockets.Socket.BeginConnect%2A> должен быть вызван в потоке, который не будет выходить до завершения операции. Это ограничение базового поставщика. Кроме того, используемое <xref:System.Net.EndPoint> должно отличаться.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
   
  
## Examples  
 В следующем примере кода инициируется асинхронная попытка соединения.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.NotSupportedException">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The port number is not valid.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><see langword="true" /> if this socket can be reused after the connection is closed; otherwise, <see langword="false" />.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">An object that contains state information for this request.</param>
        <summary>Begins an asynchronous request to disconnect from a remote endpoint.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании протокола, ориентированного на соединение, можно вызвать метод <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>, чтобы запросить отключение от удаленной конечной точки. Если `reuseSocket` `true`, можно повторно использовать сокет.  
  
 Метод <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> использует отдельный поток для вызова указанного метода обратного вызова. Метод <xref:System.Net.Sockets.Socket.EndDisconnect%2A> блокируется до завершения ожидающего отключения. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  При получении исключения <xref:System.Net.Sockets.SocketException> используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается сокет для асинхронного взаимодействия и данные отправляются на удаленный узел. После отправки данных вызывается <xref:System.Net.Sockets.Socket.Shutdown%2A> для отмены действия Send и Receive. Затем вызывается <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> для начала запроса на отключение. По завершении запроса свойство <xref:System.Net.Sockets.Socket.Connected%2A> запрашивается, чтобы проверить, отключен ли сокет.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</param>
        <param name="state">A user-defined object that contains information about the receive operation. This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</param>
        <summary>Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndReceive%2A>. Как правило, метод вызывается делегатом `callback`.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из перегрузок метода <xref:System.Net.Sockets.Socket.Receive%2A>.  
  
 Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром определяемого пользователем класса.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</param>
        <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</param>
        <param name="state">A user-defined object that contains information about the receive operation. This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</param>
        <summary>Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndReceive%2A>. Как правило, метод вызывается делегатом `callback`.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из перегрузок метода <xref:System.Net.Sockets.Socket.Receive%2A>.  
  
 Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром определяемого пользователем класса.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</param>
        <param name="offset">The zero-based position in the <paramref name="buffer" /> parameter at which to store the received data.</param>
        <param name="size">The number of bytes to receive.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="socket_flags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</param>
        <param name="state">A user-defined object that contains information about the receive operation. This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</param>
        <summary>Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndReceive%2A>. Как правило, метод вызывается делегатом `callback`.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из перегрузок метода <xref:System.Net.Sockets.Socket.Receive%2A>.  
  
 Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром определяемого пользователем класса.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
   
  
## Examples  
 В следующем примере кода начинается асинхронный прием данных из подключенной <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, errorCode, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</param>
        <param name="offset">The location in <paramref name="buffer" /> to store the received data.</param>
        <param name="size">The number of bytes to receive.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="flags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</param>
        <param name="error">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</param>
        <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</param>
        <param name="state">A user-defined object that contains information about the receive operation. This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</param>
        <summary>Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndReceive%2A>. Как правило, метод вызывается делегатом `callback`.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из перегрузок метода <xref:System.Net.Sockets.Socket.Receive%2A>.  
  
 Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром определяемого пользователем класса.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</param>
        <param name="offset">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</param>
        <param name="size">The number of bytes to receive.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="socket_flags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="remoteEP">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</param>
        <param name="remote_end">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">An object that contains state information for this request.</param>
        <summary>Begins to asynchronously receive data from a specified network device.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> запускает асинхронное чтение датаграмм без подключения с удаленного узла. Вызов метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> дает возможность получения данных в отдельном потоке выполнения.  
  
 Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>. Для этого, как минимум, параметр `state` должен содержать подключенный или <xref:System.Net.Sockets.Socket> по умолчанию, используемый для связи. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> с помощью параметра `state`.  
  
 Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова, и он будет заблокирован на <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не прочитает данные или не выдаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, используйте <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>необходимо явно привязать <xref:System.Net.Sockets.Socket> к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.Bind%2A>, иначе <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> выдаст исключение <xref:System.Net.Sockets.SocketException>.  
  
 Этот метод считывает данные в параметр `buffer` и фиксирует конечную точку удаленного узла, из которой отправляются данные. Сведения о том, как получить эту конечную точку, см. в разделе <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Этот метод наиболее удобен, если предполагается асинхронное получение датаграмм без подключения из неизвестного узла или с нескольких узлов. В таких случаях <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> будет считывать из буфера локальной сети полученную датаграмму из очереди. Если полученная датаграмма превышает размер `buffer`, метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> будет заполняться `buffer` с максимально возможной частью сообщения и вызывать <xref:System.Net.Sockets.SocketException>. При использовании ненадежного протокола избыточные данные будут потеряны. Если используется надежный протокол, избыточные данные будут сохранены поставщиком услуг, и его можно будет извлечь, вызвав метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> с достаточно большим буфером.  
  
 Чтобы гарантировать, что конечная точка удаленного узла всегда возвращается, приложение должно явно привязать <xref:System.Net.Sockets.Socket> к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.Bind%2A>, а затем вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> с параметром `optionLevel`, для которого задано значение <xref:System.Net.Sockets.SocketOptionLevel.IP> или <xref:System.Net.Sockets.SocketOptionLevel.IPv6> подходящим образом, для параметра `optionName` задано значение <xref:System.Net.Sockets.SocketOptionName.PacketInformation>и параметр `optionValue`, чтобы включить этот параметр перед вызовом метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>. В противном случае конечная точка удаленного узла может быть не возвращена, когда отправитель отправил число датаграмм, прежде чем получатель вызвал метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>.  
  
 Хотя <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение. Если вы решили сделать это, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> или приняв входящий запрос на подключение, вызвав метод <xref:System.Net.Sockets.Socket.Accept%2A> или <xref:System.Net.Sockets.Socket.BeginAccept%2A>. При вызове метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> перед установкой или приемом соединения вы получите <xref:System.Net.Sockets.SocketException>. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>. В любом из этих случаев метод <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> будет игнорировать параметр `remoteEP` и получить данные только с подключенного или удаленного узла по умолчанию.  
  
 При использовании сокетов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> будет считывать столько данных, сколько доступно до числа байтов, указанного параметром `size`.  
  
 Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
   
  
## Examples  
 В следующем примере кода асинхронно принимаются датаграммы без установления соединения с удаленного узла.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.  
  
-or- 
 <paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</param>
        <param name="offset">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</param>
        <param name="size">The number of bytes to receive.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="remoteEP">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">An object that contains state information for this request.</param>
        <summary>Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная операция получения должна быть завершена путем вызова метода <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A>. Как правило, метод вызывается делегатом `asyncCallback`.  
  
 Этот метод не блокируется до завершения операции. Для блокировки до завершения операции используйте метод <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>.  
  
 Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Этот метод считывает данные в параметр `buffer` и захватывает конечную точку удаленного узла, из которой отправляются данные, а также сведения о полученных пакетах. Сведения о том, как получить эту конечную точку, см. в разделе <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Этот метод наиболее удобен, если предполагается асинхронное получение датаграмм без подключения из неизвестного узла или с нескольких узлов.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.  
  
-or- 
 <paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.NotSupportedException">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">An array of type <see cref="T:System.Byte" /> that contains the data to send.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">An object that contains state information for this request.</param>
        <summary>Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.BeginSend%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в методе <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A>. <xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Вызов метода <xref:System.Net.Sockets.Socket.BeginSend%2A> дает возможность отправки данных в отдельном потоке выполнения.  
  
 Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginSend%2A>. Для этого, как минимум, параметр `state` должен содержать подключенный или <xref:System.Net.Sockets.Socket> по умолчанию, используемый для связи. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginSend%2A> с помощью параметра `state`.  
  
 Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSend%2A>. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет блокироваться на <xref:System.Net.Sockets.Socket.EndSend%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginSend%2A>, используйте метод <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Хотя для протоколов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginSend%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>, чтобы установить удаленный узел по умолчанию. Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. При использовании протоколов без подключения необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
 Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром определяемого пользователем класса.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> is empty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See remarks section below.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">An array of type <see cref="T:System.Byte" /> that contains the data to send.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">An object that contains state information for this request.</param>
        <summary>Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.BeginSend%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в методе <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A>. <xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Вызов метода <xref:System.Net.Sockets.Socket.BeginSend%2A> дает возможность отправки данных в отдельном потоке выполнения.  
  
 Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginSend%2A>. Для этого, как минимум, параметр `state` должен содержать подключенный или <xref:System.Net.Sockets.Socket> по умолчанию, используемый для связи. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginSend%2A> с помощью параметра `state`.  
  
 Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSend%2A>. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет блокироваться на <xref:System.Net.Sockets.Socket.EndSend%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginSend%2A>, используйте метод <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Хотя для протоколов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginSend%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>, чтобы установить удаленный узел по умолчанию. Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. При использовании протоколов без подключения необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
 Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром определяемого пользователем класса.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> is empty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See remarks section below.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to send.</param>
        <param name="offset">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</param>
        <param name="size">The number of bytes to send.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">An object that contains state information for this request.</param>
        <summary>Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.BeginSend%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в методе <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A>. <xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Вызов метода <xref:System.Net.Sockets.Socket.BeginSend%2A> дает возможность отправки данных в отдельном потоке выполнения.  
  
 Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginSend%2A>. Для этого, как минимум, параметр `state` должен содержать подключенный или <xref:System.Net.Sockets.Socket> по умолчанию, используемый для связи. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginSend%2A> с помощью параметра `state`.  
  
 Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSend%2A>. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет блокироваться на <xref:System.Net.Sockets.Socket.EndSend%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginSend%2A>, используйте метод <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Хотя для протоколов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginSend%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>, чтобы установить удаленный узел по умолчанию. Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. При использовании протоколов без подключения необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
 Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром определяемого пользователем класса.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See remarks section below.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is less than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to send.</param>
        <param name="offset">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</param>
        <param name="size">The number of bytes to send.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="socket_flags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">An object that contains state information for this request.</param>
        <summary>Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.BeginSend%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в методе <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A>. <xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Вызов метода <xref:System.Net.Sockets.Socket.BeginSend%2A> дает возможность отправки данных в отдельном потоке выполнения.  
  
 Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginSend%2A>. Для этого, как минимум, параметр `state` должен содержать подключенный или <xref:System.Net.Sockets.Socket> по умолчанию, используемый для связи. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginSend%2A> с помощью параметра `state`.  
  
 Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSend%2A>. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет блокироваться на <xref:System.Net.Sockets.Socket.EndSend%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginSend%2A>, используйте метод <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Хотя для протоколов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginSend%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>, чтобы установить удаленный узел по умолчанию. Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. При использовании протоколов без подключения необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.BeginSend%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
 Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state` является экземпляром определяемого пользователем класса.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
   
  
## Examples  
 В следующем примере кода начинается асинхронная отправка данных на удаленный узел.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See remarks section below.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is less than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sends a file asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">A string that contains the path and name of the file to send. This parameter can be <see langword="null" />.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">An object that contains state information for this request.</param>
        <summary>Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous send.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка отправляет файл `fileName` подключенному сокету. Если `fileName` находится в локальном каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла. Подстановочные знаки ("..\\\мифиле.ткст ") и имена общих UNC-папок ("\\\\\\Directory\\\мифиле.ткст ") поддерживаются. Если файл не найден, вызывается исключение <xref:System.IO.FileNotFoundException>.  
  
 Этот метод использует функцию `TransmitFile`, которая находится в API Windows Sockets 2. Дополнительные сведения о функции `TransmitFile` и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .  
  
 Метод <xref:System.Net.Sockets.Socket.BeginSendFile%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в методах <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A>. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> создает исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Вызов метода <xref:System.Net.Sockets.Socket.BeginSendFile%2A> позволяет отправить файл в отдельном потоке выполнения.  
  
 Чтобы завершить операцию, можно создать метод обратного вызова, вызываемый параметром делегата <xref:System.AsyncCallback>. Для этого, как минимум, параметр `state` должен содержать объект <xref:System.Net.Sockets.Socket>, используемый для связи. Если для обратного вызова требуются дополнительные сведения, можно создать класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого пользовательского объекта методу <xref:System.Net.Sockets.Socket.BeginSendFile%2A> с помощью параметра `state`.  
  
 Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSendFile%2A>. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, система использует отдельный поток для выполнения указанного метода обратного вызова и блокируется на <xref:System.Net.Sockets.Socket.EndSendFile%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит весь файл или не выдаст исключение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Хотя для протоколов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>, чтобы установить удаленный узел по умолчанию. При использовании протоколов без подключения необходимо убедиться, что размер файла не превышает максимальный размер пакета поставщика услуг. Если это так, датаграмма не отправляется, а <xref:System.Net.Sockets.Socket.BeginSendFile%2A> вызывает исключение <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  При получении исключения <xref:System.Net.Sockets.SocketException> используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
   
  
## Examples  
 В следующем примере кода создается и подключается сокет для асинхронного взаимодействия. Сначала файл "Text. txt" отправляется асинхронно на удаленный узел. Делегат обратного вызова вызывает <xref:System.Net.Sockets.Socket.EndSendFile%2A> для завершения передачи.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.NotSupportedException">The socket is not connected to a remote host.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file <paramref name="fileName" /> was not found.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See remarks section below.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">A string that contains the path and name of the file to be sent. This parameter can be <see langword="null" />.</param>
        <param name="preBuffer">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent. This parameter can be <see langword="null" />.</param>
        <param name="postBuffer">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent. This parameter can be <see langword="null" />.</param>
        <param name="flags">A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</param>
        <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate to be invoked when this operation completes. This parameter can be <see langword="null" />.</param>
        <param name="state">A user-defined object that contains state information for this request. This parameter can be <see langword="null" />.</param>
        <summary>Sends a file and buffers of data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для этой перегрузки требуется имя файла, который требуется отправить, и побитовое сочетание значений <xref:System.Net.Sockets.TransmitFileOptions>. Параметр `preBuffer` содержит все данные, которые необходимо указать перед файлом. `postBuffer` содержит данные, которые необходимо отслеживать в файле. Если `fileName` находится в локальном каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла. Подстановочные знаки ("..\\\мифиле.ткст ") и имена общих UNC-папок ("\\\\\\Directory\\\мифиле.ткст ") поддерживаются. Если файл не найден, вызывается исключение <xref:System.IO.FileNotFoundException>.  
  
 Параметр `flags` предоставляет поставщику службы оконных сокетов дополнительные сведения о переносе файлов. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Этот метод использует функцию `TransmitFile`, которая находится в API Windows Sockets 2. Дополнительные сведения о функции `TransmitFile` и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .  
  
 Метод <xref:System.Net.Sockets.Socket.BeginSendFile%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в методах <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A>. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> создает исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Вызов метода <xref:System.Net.Sockets.Socket.BeginSendFile%2A> дает возможность отправить файл в отдельном потоке выполнения.  
  
 Чтобы завершить операцию, можно создать метод обратного вызова, вызываемый параметром делегата <xref:System.AsyncCallback>. Для этого, как минимум, параметр `state` должен содержать объект <xref:System.Net.Sockets.Socket>, используемый для связи. Если для обратного вызова требуются дополнительные сведения, можно создать класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого пользовательского объекта методу <xref:System.Net.Sockets.Socket.BeginSendFile%2A> с помощью параметра `state`.  
  
 Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSendFile%2A>. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, система использует отдельный поток для выполнения указанного метода обратного вызова и блокируется на <xref:System.Net.Sockets.Socket.EndSendFile%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит весь файл или не выдаст исключение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Хотя для протоколов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A>, чтобы установить удаленный узел по умолчанию. При использовании протоколов без подключения необходимо также убедиться в том, что размер файла не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не отправляется, а <xref:System.Net.Sockets.Socket.BeginSendFile%2A> вызывает исключение <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  При получении исключения <xref:System.Net.Sockets.SocketException> используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
   
  
## Examples  
 Следующий пример кода создает и подключает сокет для асинхронного взаимодействия и начинает асинхронно отправлять файл "Text. txt" на удаленный узел. В этом примере создается `preBuffer` и `postBuffer` данных для отправки с файлом и используется значение по умолчанию <xref:System.Net.Sockets.TransmitFileOptions>. Делегат обратного вызова вызывает <xref:System.Net.Sockets.Socket.EndSendFile%2A> для завершения передачи.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See remarks section below.</exception>
        <exception cref="T:System.NotSupportedException">The operating system is not Windows NT or later.  
  
-or-
  
 The socket is not connected to a remote host.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file <paramref name="fileName" /> was not found.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to send.</param>
        <param name="offset">The zero-based position in <paramref name="buffer" /> at which to begin sending data.</param>
        <param name="size">The number of bytes to send.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="socket_flags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="remoteEP">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</param>
        <param name="remote_end">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</param>
        <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate.</param>
        <param name="state">An object that contains state information for this request.</param>
        <summary>Sends data asynchronously to a specific remote host.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.BeginSendTo%2A> запускает асинхронную операцию отправки на удаленный узел, указанный в параметре `remoteEP`. Вызов метода <xref:System.Net.Sockets.Socket.BeginSendTo%2A> дает возможность отправки данных в отдельном потоке выполнения. Несмотря на то, что предназначен для протоколов без подключения, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> работает с протоколами, ориентированными на подключения и без подключения.  
  
 Можно создать метод обратного вызова, который реализует делегат <xref:System.AsyncCallback> и передать его имя в метод <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Для этого, как минимум, параметр `state` должен содержать подключенный или <xref:System.Net.Sockets.Socket> по умолчанию, используемый для связи. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket>и другие необходимые сведения. Передайте экземпляр этого класса в метод <xref:System.Net.Sockets.Socket.BeginSendTo%2A> с помощью параметра `state`.  
  
 Метод обратного вызова должен вызывать метод <xref:System.Net.Sockets.Socket.EndSendTo%2A>. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет блокироваться на <xref:System.Net.Sockets.Socket.EndSendTo%2A> до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова метода <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, используйте метод <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 При использовании протокола, ориентированного на соединение, необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A> или <xref:System.Net.Sockets.Socket.BeginSendTo%2A> выдаст исключение <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> будет игнорировать параметр `remoteEP` и отправить данные в <xref:System.Net.EndPoint>, установленные в <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или методе <xref:System.Net.Sockets.Socket.BeginAccept%2A>.  
  
 Если используется протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод перед вызовом <xref:System.Net.Sockets.Socket.SendTo%2A>. Это необходимо сделать только в том случае, если предполагается вызывать метод <xref:System.Net.Sockets.Socket.BeginSend%2A>. При вызове метода <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.BeginConnect%2A> до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>параметр `remoteEP` переопределит указанный удаленный узел по умолчанию только для этой операции отправки. Также не требуется вызывать метод <xref:System.Net.Sockets.Socket.Bind%2A>. В этом случае базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта. Если необходимо, чтобы базовый поставщик услуг выберет свободный порт, используйте нуль-порт. Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> после успешного завершения метода <xref:System.Net.Sockets.Socket.EndSendTo%2A>.  
  
 Если вы хотите отправить данные на широковещательный адрес, сначала необходимо вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. — Необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.EndSendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
 Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного метода <xref:System.Net.Sockets.Socket>, определенного экземпляра <xref:System.Net.Sockets.Socket> и конкретного обратного вызова), последующие применения этого контекста приводят к повышению производительности.  
  
   
  
## Examples  
 В следующем примере кода асинхронно отправляются данные на указанный удаленный узел.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.  
  
-or- 
 <paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">The local <see cref="T:System.Net.EndPoint" /> to associate with the <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Associates a <see cref="T:System.Net.Sockets.Socket" /> with a local endpoint.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если необходимо использовать определенную локальную конечную точку, используйте метод <xref:System.Net.Sockets.Socket.Bind%2A>. Необходимо вызвать <xref:System.Net.Sockets.Socket.Bind%2A>, прежде чем можно будет вызвать метод <xref:System.Net.Sockets.Socket.Listen%2A>. Не нужно вызывать <xref:System.Net.Sockets.Socket.Bind%2A> перед использованием метода <xref:System.Net.Sockets.Socket.Connect%2A>, если не требуется использовать определенную локальную конечную точку. Вы можете использовать метод <xref:System.Net.Sockets.Socket.Bind%2A> для протоколов, ориентированных на подключения и без подключения.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.Bind%2A>необходимо сначала создать локальный <xref:System.Net.IPEndPoint>, из которого предполагается передавать данные. Если вы не хотите, чтобы локальный адрес был назначен, можно создать <xref:System.Net.IPEndPoint> с помощью <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> в качестве параметра адреса, и базовый поставщик услуг присвоит наиболее подходящий сетевой адрес. Это может помочь упростить приложение при наличии нескольких сетевых интерфейсов. Если вы не хотите узнать, какой локальный порт используется, можно создать <xref:System.Net.IPEndPoint>, используя значение 0 для номера порта. В этом случае поставщик услуг присвоит доступному номеру порта от 1024 до 5000.  
  
 При использовании описанного выше подхода можно определить, какой локальный сетевой адрес и номер порта были назначены путем вызова <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. При использовании протокола, ориентированного на соединение, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> не возвращает локально назначенный сетевой адрес до тех пор, пока не будет выполнен вызов метода <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.EndConnect%2A>. Если используется протокол без подключения, вы не сможете получить доступ к этим данным, пока не завершите отправку или получение.  
  
 Если сокету UDP требуется получать сведения о интерфейсе для полученных пакетов, то метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> должен быть явно вызван с параметром Socket, установленным в <xref:System.Net.Sockets.SocketOptionName.PacketInformation> сразу после вызова метода <xref:System.Net.Sockets.Socket.Bind%2A>.  
  
> [!NOTE]
>  Если предполагается получение датаграмм многоадресной рассылки, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Bind%2A> с номером многоадресного порта.  
  
> [!NOTE]
>  Необходимо вызвать метод <xref:System.Net.Sockets.Socket.Bind%2A>, если предполагается получение датаграмм без подключения с помощью метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.  
  
> [!NOTE]
>  При получении <xref:System.Net.Sockets.SocketException> при вызове метода <xref:System.Net.Sockets.Socket.Bind%2A> используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода выполняется привязка <xref:System.Net.Sockets.Socket> с помощью указанной локальной конечной точки.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема соединений с узла, определенного <paramref name="localEP" />. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</summary>
        <value><see langword="true" />, если <see cref="T:System.Net.Sockets.Socket" /> будет блокироваться; в противном случае <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.Sockets.Socket.Blocking%2A> указывает, находится ли <xref:System.Net.Sockets.Socket> в блокирующем режиме.  
  
 Если вы используете режим блокировки и вы выполняете вызов метода, который не завершается немедленно, приложение будет блокировать выполнение до тех пор, пока не завершится запрошенная операция. Если требуется продолжить выполнение, даже если запрошенная операция не завершена, измените свойство <xref:System.Net.Sockets.Socket.Blocking%2A> на `false`. Свойство <xref:System.Net.Sockets.Socket.Blocking%2A> не влияет на асинхронные методы. Если вы отправляете и получаете данные асинхронно и хотите блокировать выполнение, используйте класс <xref:System.Threading.ManualResetEvent>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object used to request the connection to the remote host by calling one of the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> methods.</param>
        <summary>Cancels an asynchronous request for a remote host connection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> отменяет асинхронный запрос для подключения к удаленному узлу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.Close%2A> закрывает подключение к удаленному узлу и освобождает все управляемые и неуправляемые ресурсы, связанные с <xref:System.Net.Sockets.Socket>. После закрытия свойству <xref:System.Net.Sockets.Socket.Connected%2A> присваивается значение `false`.  
  
 Для протоколов, ориентированных на соединение, рекомендуется вызвать <xref:System.Net.Sockets.Socket.Shutdown%2A> перед вызовом метода <xref:System.Net.Sockets.Socket.Close%2A>. Это гарантирует, что все данные отправляются и получаются на подключенном сокете до его закрытия.  
  
 Если необходимо вызвать <xref:System.Net.Sockets.Socket.Close%2A> без первого вызова <xref:System.Net.Sockets.Socket.Shutdown%2A>, можно убедиться, что данные, поставленные в очередь для исходящей передачи, будут отправлены, задав для параметра <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> значение `false` и указав интервал времени ожидания, отличный от нуля. <xref:System.Net.Sockets.Socket.Close%2A> будет блокироваться до тех пор, пока эти данные не будут отправлены или пока не истечет указанное время ожидания. Если для <xref:System.Net.Sockets.SocketOptionName.DontLinger> задано значение `false` и задан интервал нулевого времени ожидания, то <xref:System.Net.Sockets.Socket.Close%2A> освобождает соединение и автоматически удаляет исходящие данные из очереди.  
  
> [!NOTE]
>  Чтобы задать для параметра <xref:System.Net.Sockets.SocketOptionName.DontLinger> сокета значение `false`, создайте <xref:System.Net.Sockets.LingerOption>, задайте для свойства Enabled значение `true`и задайте для свойства <xref:System.Net.Sockets.LingerOption.LingerTime%2A> значение нужного времени ожидания. Используйте этот <xref:System.Net.Sockets.LingerOption> вместе с параметром сокета <xref:System.Net.Sockets.SocketOptionName.DontLinger>, чтобы вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода закрывается <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout">Wait up to <paramref name="timeout" /> seconds to send any remaining data, then close the socket.</param>
        <summary>Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.Close%2A> закрывает подключение к удаленному узлу и освобождает все управляемые и неуправляемые ресурсы, связанные с <xref:System.Net.Sockets.Socket>. После закрытия свойству <xref:System.Net.Sockets.Socket.Connected%2A> присваивается значение `false`.  
  
 Для протоколов, ориентированных на соединение, рекомендуется вызывать <xref:System.Net.Sockets.Socket.Shutdown%2A> перед вызовом <xref:System.Net.Sockets.Socket.Close%2A>. Это гарантирует, что все данные отправляются и получаются на подключенном сокете до его закрытия.  
  
 Если необходимо вызвать <xref:System.Net.Sockets.Socket.Close%2A> без первого вызова <xref:System.Net.Sockets.Socket.Shutdown%2A>, можно убедиться, что данные, поставленные в очередь для исходящей передачи, будут отправлены, установив для параметра <xref:System.Net.Sockets.SocketOptionName.DontLinger> значение `false` и указав интервал времени ожидания, отличный от нуля. <xref:System.Net.Sockets.Socket.Close%2A> будет блокироваться до тех пор, пока эти данные не будут отправлены или пока не истечет указанное время ожидания. Если для <xref:System.Net.Sockets.SocketOptionName.DontLinger> задано значение `false` и задан интервал нулевого времени ожидания, то <xref:System.Net.Sockets.Socket.Close%2A> освобождает соединение и автоматически удаляет исходящие данные из очереди.  
  
> [!NOTE]
>  Чтобы задать для параметра <xref:System.Net.Sockets.SocketOptionName.DontLinger> сокета значение `false`, создайте <xref:System.Net.Sockets.LingerOption>, задайте для свойства Enabled значение `true`, а для свойства <xref:System.Net.Sockets.LingerOption.LingerTime%2A> задайте требуемый период времени ожидания. Используйте этот <xref:System.Net.Sockets.LingerOption> вместе с параметром сокета <xref:System.Net.Sockets.SocketOptionName.DontLinger>, чтобы вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как закрыть <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establishes a connection to a remote host.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</param>
        <summary>Establishes a connection to a remote host.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если используется протокол, ориентированный на подключение, например TCP, метод <xref:System.Net.Sockets.Socket.Connect%2A> синхронно устанавливает сетевое подключение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанной удаленной конечной точкой. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию. После вызова <xref:System.Net.Sockets.Socket.Connect%2A>можно отправить данные на удаленное устройство с помощью метода <xref:System.Net.Sockets.Socket.Send%2A> или получить данные с удаленного устройства с помощью метода <xref:System.Net.Sockets.Socket.Receive%2A>.  
  
 Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.Connect%2A> перед отправкой и получением данных. Для синхронной связи с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> и <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. При вызове <xref:System.Net.Sockets.Socket.Connect%2A>все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут удалены. Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>или <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 Метод <xref:System.Net.Sockets.Socket.Connect%2A> будет блокироваться, если только вы не установили для свойства <xref:System.Net.Sockets.Socket.Blocking%2A> значение `false` до вызова <xref:System.Net.Sockets.Socket.Connect%2A>. Если вы используете протокол, ориентированный на подключение, например TCP, и отключите блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>, так как требуется время для подключения. Протоколы без подключения не вызовут исключение, так как они просто устанавливают удаленный узел по умолчанию. Для получения конкретного кода ошибки можно использовать <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки. Если ошибка вернула ВСАЕВАУЛДБЛОКК, подключение к удаленному узлу было инициировано <xref:System.Net.Sockets.Socket>, ориентированного на подключение, но еще не завершено успешно. Чтобы определить время завершения подключения <xref:System.Net.Sockets.Socket>, используйте метод <xref:System.Net.Sockets.Socket.Poll%2A>.  
  
> [!NOTE]
>  Если вы используете протокол, ориентированный на подключение, и не вызывали <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.Connect%2A>, базовый поставщик услуг присвоит локальный сетевой адрес и номер порта. Если используется протокол без подключения, поставщик услуг не будет назначать локальный сетевой адрес и номер порта, пока не завершится операция отправки или получения. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> еще раз, указав нужную конечную точку.  
  
> [!NOTE]
>  Если сокет был ранее отключен, использовать этот метод для восстановления соединения нельзя. Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методов для повторного подключения. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода подключается к удаленной конечной точке, а затем проверяет подключение.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
        <permission cref="T:System.Net.SocketPermission">для подключения к удаленному узлу. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">The IP address of the remote host.</param>
        <param name="port">The port number of the remote host.</param>
        <summary>Establishes a connection to a remote host. The host is specified by an IP address and a port number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если используется протокол, ориентированный на подключение, например TCP, метод <xref:System.Net.Sockets.Socket.Connect%2A> синхронно устанавливает сетевое подключение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанной удаленной конечной точкой. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию. После вызова <xref:System.Net.Sockets.Socket.Connect%2A> можно отправить данные на удаленное устройство с помощью метода <xref:System.Net.Sockets.Socket.Send%2A> или получить данные с удаленного устройства с помощью метода <xref:System.Net.Sockets.Socket.Receive%2A>.  
  
 Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.Connect%2A> перед отправкой и получением данных. Для синхронной связи с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> и <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. При вызове <xref:System.Net.Sockets.Socket.Connect%2A> все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут отклонены. Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>или <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> метод будет блокироваться, если только вы не установили для свойства <xref:System.Net.Sockets.Socket.Blocking%2A> значение `false` до вызова <xref:System.Net.Sockets.Socket.Connect%2A>. Если вы используете протокол, ориентированный на подключение, например TCP, и отключите блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>, так как требуется время для подключения. Протоколы без подключения не вызовут исключение, так как они просто устанавливают удаленный узел по умолчанию. Для получения конкретного кода ошибки можно использовать <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки. Если ошибка вернула ВСАЕВАУЛДБЛОКК, подключение к удаленному узлу было инициировано <xref:System.Net.Sockets.Socket>, ориентированного на подключение, но еще не завершено успешно. Чтобы определить время завершения подключения <xref:System.Net.Sockets.Socket>, используйте метод <xref:System.Net.Sockets.Socket.Poll%2A>.  
  
> [!NOTE]
>  Если вы используете протокол, ориентированный на подключение, и не вызывали <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.Connect%2A>, базовый поставщик услуг присвоит локальный сетевой адрес и номер порта. Если используется протокол без подключения, поставщик услуг не будет назначать локальный сетевой адрес и номер порта, пока не завершится операция отправки или получения. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> еще раз, указав нужную конечную точку.  
  
> [!NOTE]
>  Если сокет был ранее отключен, использовать этот метод для восстановления соединения нельзя. Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методов для повторного подключения. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода подключается к удаленной конечной точке, а затем проверяет подключение.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The port number is not valid.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.NotSupportedException">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</exception>
        <exception cref="T:System.ArgumentException">The length of <paramref name="address" /> is zero.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">The IP addresses of the remote host.</param>
        <param name="port">The port number of the remote host.</param>
        <summary>Establishes a connection to a remote host. The host is specified by an array of IP addresses and a port number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обычно используется сразу после вызова <xref:System.Net.Dns.GetHostAddresses%2A>, который может возвращать несколько IP-адресов для одного узла. Если используется протокол, ориентированный на подключение, например TCP, метод <xref:System.Net.Sockets.Socket.Connect%2A> синхронно устанавливает сетевое подключение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанной удаленной конечной точкой. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию. После вызова <xref:System.Net.Sockets.Socket.Connect%2A> можно отправить данные на удаленное устройство с помощью метода <xref:System.Net.Sockets.Socket.Send%2A> или получить данные с удаленного устройства с помощью метода <xref:System.Net.Sockets.Socket.Receive%2A>.  
  
 Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.Connect%2A> перед отправкой и получением данных. Для синхронной связи с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> и <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. При вызове <xref:System.Net.Sockets.Socket.Connect%2A> все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут отклонены. Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>или <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> метод будет блокироваться, если только вы не установили для свойства <xref:System.Net.Sockets.Socket.Blocking%2A> значение `false` до вызова <xref:System.Net.Sockets.Socket.Connect%2A>. Если вы используете протокол, ориентированный на подключение, например TCP, и отключите блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>, так как требуется время для подключения. Протоколы без подключения не вызовут исключение, так как они просто устанавливают удаленный узел по умолчанию. Для получения конкретного кода ошибки можно использовать <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки. Если ошибка вернула ВСАЕВАУЛДБЛОКК, подключение к удаленному узлу было инициировано <xref:System.Net.Sockets.Socket>, ориентированного на подключение, но еще не завершено успешно. Чтобы определить время завершения подключения <xref:System.Net.Sockets.Socket>, используйте метод <xref:System.Net.Sockets.Socket.Poll%2A>.  
  
> [!NOTE]
>  Если вы используете протокол, ориентированный на подключение, и не вызывали <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.Connect%2A>, базовый поставщик услуг присвоит локальный сетевой адрес и номер порта. Если используется протокол без подключения, поставщик услуг не будет назначать локальный сетевой адрес и номер порта, пока не завершится операция отправки или получения. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> еще раз, указав нужную конечную точку.  
  
> [!NOTE]
>  Если сокет был ранее отключен, использовать этот метод для восстановления соединения нельзя. Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методов для повторного подключения. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода подключается к удаленной конечной точке, а затем проверяет подключение.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The port number is not valid.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.NotSupportedException">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</exception>
        <exception cref="T:System.ArgumentException">The length of <paramref name="address" /> is zero.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">The name of the remote host.</param>
        <param name="port">The port number of the remote host.</param>
        <summary>Establishes a connection to a remote host. The host is specified by a host name and a port number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если используется протокол, ориентированный на подключение, например TCP, метод <xref:System.Net.Sockets.Socket.Connect%2A> синхронно устанавливает сетевое подключение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанным удаленным узлом. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию. После вызова <xref:System.Net.Sockets.Socket.Connect%2A> можно отправить данные на удаленное устройство с помощью метода <xref:System.Net.Sockets.Socket.Send%2A> или получить данные с удаленного устройства с помощью метода <xref:System.Net.Sockets.Socket.Receive%2A>.  
  
 Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.Connect%2A> перед отправкой и получением данных. Для синхронной связи с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> и <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. При вызове <xref:System.Net.Sockets.Socket.Connect%2A> все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут отклонены. Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>или <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> метод будет блокироваться, если только вы не установили для свойства <xref:System.Net.Sockets.Socket.Blocking%2A> значение `false` до вызова <xref:System.Net.Sockets.Socket.Connect%2A>. Если вы используете протокол, ориентированный на подключение, например TCP, и отключите блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> выдаст <xref:System.Net.Sockets.SocketException>, так как требуется время для подключения. Протоколы без подключения не вызовут исключение, так как они просто устанавливают удаленный узел по умолчанию. Для получения конкретного кода ошибки можно использовать <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки. Если ошибка вернула ВСАЕВАУЛДБЛОКК, подключение к удаленному узлу было инициировано <xref:System.Net.Sockets.Socket>, ориентированного на подключение, но еще не завершено успешно. Чтобы определить время завершения подключения <xref:System.Net.Sockets.Socket>, используйте метод <xref:System.Net.Sockets.Socket.Poll%2A>.  
  
 Если включена поддержка протокола IPv6 и вызывается метод <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> для подключения к узлу, который разрешается как в IPv6, так и в IPv4-адресах, сначала будет предпринята попытка подключения к IPv6-адресу. Это может привести к задержке времени для установления соединения, если узел не прослушивает IPv6-адрес.  
  
> [!NOTE]
>  Если вы используете протокол, ориентированный на подключение, и не вызывали <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.Connect%2A>, базовый поставщик услуг присвоит локальный сетевой адрес и номер порта. Если используется протокол без подключения, поставщик услуг не будет назначать локальный сетевой адрес и номер порта, пока не завершится операция отправки или получения. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> еще раз, указав нужную конечную точку.  
  
> [!NOTE]
>  Если сокет был ранее отключен, использовать этот метод для восстановления соединения нельзя. Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методов для повторного подключения. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода подключается к удаленной конечной точке, а затем проверяет подключение.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The port number is not valid.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.NotSupportedException">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Begins an asynchronous request for a connection to a remote host.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
        <summary>Begins an asynchronous request for a connection to a remote host.</summary>
        <returns><see langword="true" /> if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.  
  
 <see langword="false" /> if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании протокола, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> запускает асинхронный запрос подключения к удаленному узлу. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> устанавливает удаленный узел по умолчанию.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик события EventHandler\<SocketAsyncEventArgs > делегат и присоединить обратный вызов к событию <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>.  
  
 Вызывающий объект должен задать свойству <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> <xref:System.Net.IPEndPoint> удаленного узла для подключения.  
  
 Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.ConnectAsync%2A> перед отправкой и получением данных. Для взаимодействия с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.SendToAsync%2A> и <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>. При вызове <xref:System.Net.Sockets.Socket.ConnectAsync%2A>все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут удалены. Если вы хотите изменить удаленный узел по умолчанию, вызовите метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> еще раз, указав нужную конечную точку.  
  
 Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, сначала необходимо вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и настроить вещание на `true`. Если это не сделано, метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
 Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> являются обязательными:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 При необходимости можно указать буфер, который будет атомарно отправлен на сокет после того, как метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> завершится с ошибкой. В этом случае свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> должно быть установлено в буфер, содержащий данные для отправки, а свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> должно иметь значение, равное числу байтов данных, отправляемых из буфера. После установления соединения отправляется этот буфер данных.  
  
 Если вы используете протокол, ориентированный на подключение, и не вызываете <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, базовый поставщик услуг присвоит наиболее подходящий локальный сетевой адрес и номер порта.  
  
 Если используется протокол без подключения, поставщик услуг не будет назначать IP-адрес и номер порта локальной сети, пока не будут вызваны методы <xref:System.Net.Sockets.Socket.SendAsync%2A> или <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>.  
  
 Метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> вызывает исключение <xref:System.NotSupportedException>, если семейство адресов <xref:System.Net.Sockets.Socket> и <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> не совпадают с семейством адресов.  
  
> [!NOTE]
>  При получении <xref:System.Net.Sockets.SocketException> при вызове этого метода используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">An argument is not valid. This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP or later is required for this method. This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</param>
        <param name="protocolType">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</param>
        <param name="e">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
        <summary>Begins an asynchronous request for a connection to a remote host.</summary>
        <returns><see langword="true" /> if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.  
  
 <see langword="false" /> if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если используется протокол, ориентированный на соединение, метод М:систем.нет.соккетс.соккет.коннектасинк (System .NET. Sockets. Соккеттипе, System .NET. Sockets. ProtocolType, System .NET. Sockets. SocketAsyncEventArgs) запускает асинхронный запрос для подключение к удаленному узлу. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> устанавливает удаленный узел по умолчанию, заданный параметрами `socketType` и `protocolType`.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик события EventHandler\<SocketAsyncEventArgs > делегат и присоединить обратный вызов к событию <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>.  
  
 Вызывающий объект должен задать свойству <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> <xref:System.Net.IPEndPoint> удаленного узла для подключения.  
  
 Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 Если используется протокол без установления соединения, например UDP, не нужно вызывать <xref:System.Net.Sockets.Socket.ConnectAsync%2A> перед отправкой и получением данных. Для взаимодействия с удаленным узлом можно использовать <xref:System.Net.Sockets.Socket.SendToAsync%2A> и <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>. При вызове <xref:System.Net.Sockets.Socket.ConnectAsync%2A>все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут удалены. Если вы хотите изменить удаленный узел по умолчанию, вызовите метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> еще раз, указав нужную конечную точку.  
  
 Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, сначала необходимо вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и настроить вещание на `true`. Если это не сделано, метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
 Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> являются обязательными:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 При необходимости можно указать буфер, который будет атомарно отправлен на сокет после того, как метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> завершится с ошибкой. В этом случае свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> должно быть установлено в буфер, содержащий данные для отправки, а свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> должно иметь значение, равное числу байтов данных, отправляемых из буфера. После установления соединения отправляется этот буфер данных.  
  
 Если вы используете протокол, ориентированный на подключение, и не вызываете <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, базовый поставщик услуг присвоит наиболее подходящий локальный сетевой адрес и номер порта.  
  
 Если используется протокол без подключения, поставщик услуг не будет назначать IP-адрес и номер порта локальной сети, пока не будут вызваны методы <xref:System.Net.Sockets.Socket.SendAsync%2A> или <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>.  
  
 Метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> вызывает исключение <xref:System.NotSupportedException>, если семейство адресов <xref:System.Net.Sockets.Socket> и <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> не совпадают с семейством адресов.  
  
> [!NOTE]
>  При получении <xref:System.Net.Sockets.SocketException> при вызове этого метода используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">An argument is not valid. This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP or later is required for this method. This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="Overload:System.Net.Sockets.Socket.Send" /> or <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operation.</summary>
        <value><see langword="true" />, если <see cref="T:System.Net.Sockets.Socket" /> был подключен к удаленному ресурсу в соответствии с последней операцией; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство `Connected` возвращает состояние соединения <xref:System.Net.Sockets.Socket> на последней операции ввода-вывода. Когда он возвращает `false`, <xref:System.Net.Sockets.Socket> не был подключен или больше не подключен.  
  
 Значение свойства <xref:System.Net.Sockets.Socket.Connected%2A> отражает состояние соединения в последней операции. Если необходимо определить текущее состояние соединения, сделайте неблокирующий вызов send с нулевым байтом. Если вызов завершается успешно или вызывается код ошибки ВАЕВАУЛДБЛОКК (10035), сокет все еще подключен; в противном случае сокет больше не будет подключен.  
  
 При вызове <xref:System.Net.Sockets.Socket.Connect%2A> для сокета UDP, свойство <xref:System.Net.Sockets.Socket.Connected%2A> всегда возвращает `true`; Однако это действие не изменяет характер протокола UDP без подключения.  
  
   
  
## Examples  
 Следующий пример кода подключается к удаленной конечной точке, проверяет свойство <xref:System.Net.Sockets.Socket.Connected%2A> и проверяет текущее состояние соединения.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><see langword="true" /> if this socket can be reused after the current connection is closed; otherwise, <see langword="false" />.</param>
        <summary>Closes the socket connection and allows reuse of the socket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании протокола, ориентированного на подключение, этот метод можно использовать для закрытия сокета. Этот метод завершает соединение и задает для свойства <xref:System.Net.Sockets.Socket.Connected%2A> значение `false`. Однако если `reuseSocket` `true`, можно повторно использовать сокет.  
  
 Чтобы обеспечить отправку и получение всех данных перед закрытием сокета, следует вызвать метод <xref:System.Net.Sockets.Socket.Shutdown%2A> перед вызовом метода <xref:System.Net.Sockets.Socket.Disconnect%2A>.  
  
 Если необходимо вызвать <xref:System.Net.Sockets.Socket.Disconnect%2A> без первого вызова <xref:System.Net.Sockets.Socket.Shutdown%2A>, можно установить параметр <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket>, чтобы `false`, и указать ненулевой интервал времени ожидания, чтобы гарантировать отправку данных, поставленных в очередь для исходящей передачи. <xref:System.Net.Sockets.Socket.Disconnect%2A> затем блокируется до тех пор, пока данные не будут отправлены или пока не истечет указанное время ожидания. Если для <xref:System.Net.Sockets.SocketOptionName.DontLinger> задано значение `false` и задан интервал нулевого времени ожидания, то <xref:System.Net.Sockets.Socket.Close%2A> освобождает соединение и автоматически удаляет исходящие данные из очереди.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается сокет для синхронного взаимодействия и отправляются некоторые данные на удаленный узел. Затем он вызывает <xref:System.Net.Sockets.Socket.Shutdown%2A>, чтобы завершить действие Send и Receive, и <xref:System.Net.Sockets.Socket.Disconnect%2A>, чтобы закрыть подключение к сокету.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">This method requires Windows 2000 or earlier, or the exception will be thrown.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
        <summary>Begins an asynchronous request to disconnect from a remote endpoint.</summary>
        <returns><see langword="true" /> if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.  
  
 <see langword="false" /> if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании протокола, ориентированного на соединение, вызов метода <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> запрашивает отключение от удаленной конечной точки. Если для параметра <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> задано значение `true` в параметре `e`, сокет можно использовать повторно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="e" /> parameter cannot be null.</exception>
        <exception cref="T:System.InvalidOperationException">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP or later is required for this method.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод `Dispose` по окончании использования класса <xref:System.Net.Sockets.Socket>. Метод `Dispose` оставляет класс <xref:System.Net.Sockets.Socket> в непригодном для использования состоянии. После вызова метода `Dispose` необходимо освободить все ссылки на объект <xref:System.Net.Sockets.Socket>, чтобы сборщик мусора мог освободить память, занимаемую объектом <xref:System.Net.Sockets.Socket>.  
  
 Дополнительные сведения см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Всегда вызывайте метод `Dispose` перед освобождением последней ссылки на класс <xref:System.Net.Sockets.Socket>. В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Net.Sockets.Socket> метод `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.Socket" />, and optionally disposes of the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом Public `Dispose()` и методом <xref:System.Object.Finalize%2A>. `Dispose()` вызывает защищенный метод `Dispose(Boolean)` с параметром `disposing`, для которого задано значение `true`. <xref:System.Object.Finalize%2A> вызывает `Dispose`, для `disposing` задано значение `false`.  
  
 Если параметр `disposing` имеет значение `true`, то данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, на которые ссылается этот объект <xref:System.Net.Sockets.Socket>. Этот метод вызывает метод `Dispose()` каждого объекта, на который есть ссылка.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> можно вызывать несколько раз другими объектами. При переопределении метода <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами метода <see langword="Dispose" />. Дополнительные сведения о реализации <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />см. в разделе [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Дополнительные сведения о <see langword="Dispose" /> и <see cref="M:System.Object.Finalize" />см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Переопределение метода Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows Internet Protocol (IP) datagrams to be fragmented.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> разрешает фрагментацию датаграмм; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для датаграмм требуется фрагментация, если их размер превышает максимальную единицу передачи (MTU) носителя передачи. Датаграммы могут быть фрагментированы отправляющим узлом (все версии протокола IP) или промежуточным маршрутизатором (только для протокола IP версии 4). Если датаграмма должна быть фрагментирована, а параметр <xref:System.Net.Sockets.Socket.DontFragment%2A> установлен, датаграмма отбрасывается, а сообщение об ошибке протокола ICMP отправляется обратно отправителю датаграммы.  
  
 Установка этого свойства для сокета протокола TCP не будет действовать.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.DontFragment%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> is a dual-mode socket used for both IPv4 and IPv6.</summary>
        <value>Значение <see langword="true" />, если <see cref="T:System.Net.Sockets.Socket" /> — сокет с двойным режимом. В противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">The ID of the target process where a duplicate of the socket reference is created.</param>
        <summary>Duplicates the socket reference for the target process, and closes the socket for this process.</summary>
        <returns>The socket reference to be passed to the target process.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания повторяющегося экземпляра сокета целевой процесс должен использовать <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Если вы вызываете конструктор <xref:System.Net.Sockets.Socket.%23ctor%2A> несколько раз с тем же массивом байтов, что и аргумент для каждого вызова, вы создадите несколько управляемых экземпляров <xref:System.Net.Sockets.Socket> с одним и тем же базовым сокетом. Этот подход настоятельно не рекомендуется.  
  
 Если процесс создания сокета использует асинхронные методы (<xref:System.Net.Sockets.Socket.BeginReceive%2A> или <xref:System.Net.Sockets.Socket.BeginSend%2A>), процесс должен сначала установить свойство <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> в значение true. в противном случае сокет привязывается к порту завершения процесса создания, что может привести к возникновению <xref:System.ArgumentNullException> в целевом процессе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="targetProcessID" /> is not a valid process id. 
-or- 
Duplication of the socket reference failed.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> can send or receive broadcast packets.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> разрешает использование широковещательных пакетов; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Широковещательная рассылка ограничена определенной подсетью и должна использовать протокол UDP. Для протокола IP версии 4 можно выполнить широковещательную рассылку в локальную подсеть, отправив пакет в 255.255.255.255; также можно использовать направленный широковещательный адрес, который представляет собой сетевую часть IP-адреса со всеми битами, заданными в части узла. Например, если IP-адрес — 192.168.1.40 (адрес класса C, маска 255.255.255.0--, часть сети — первые три октета, а часть узла — последний октет), направленный широковещательный адрес 192.168.1.255.  
  
 Установка этого свойства для сокета протокола TCP не будет действовать.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">This option is valid for a datagram socket only.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asynchronously accepts an incoming connection attempt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</param>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</param>
        <summary>Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication. This method returns a buffer that contains the initial data transferred.</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> завершает вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A>необходимо создать метод обратного вызова, который вызывается делегатом <xref:System.AsyncCallback>. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> возвращает.  
  
 В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра `asyncResult`, чтобы получить <xref:System.Net.Sockets.Socket>, на который устанавливается попытка подключения. После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndAccept%2A> для успешного завершения попытки подключения. Параметр `buffer` этой перегрузки содержит данные, полученные при вызове функции <xref:System.Net.Sockets.Socket.BeginAccept%2A>, а параметр `bytesTransferred` содержит число байтов, переданных в вызове.  
  
 Метод <xref:System.Net.Sockets.Socket.EndAccept%2A> блокируется до тех пор, пока не будет ожидание подключения в очереди входящих подключений. Метод <xref:System.Net.Sockets.Socket.EndAccept%2A> принимает входящее подключение и возвращает новый <xref:System.Net.Sockets.Socket>, который можно использовать для отправки и получения данных с удаленного узла.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.Sockets.Socket.BeginAccept%2A>, чтобы создать и подключить сокет и принять начальные 10 байт данных. Делегат обратного вызова вызывает <xref:System.Net.Sockets.Socket.EndAccept%2A> для завершения асинхронного запроса. Число переданных байтов и данные возвращаются в `buffer` и `bytesTransferred` параметров этого метода и отображаются в консоли.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT is required for this method.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is empty.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" /></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</param>
        <param name="result">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</param>
        <summary>Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> to handle communication with the remote host.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> завершает вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> возвращает. Он должен принять параметр `asyncResult`, возвращенный методом <xref:System.Net.Sockets.Socket.BeginAccept%2A>.  
  
 В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра `asyncResult`, чтобы получить <xref:System.Net.Sockets.Socket>, на который устанавливается попытка подключения. После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndAccept%2A> для успешного завершения попытки подключения.  
  
 Метод <xref:System.Net.Sockets.Socket.EndAccept%2A> блокируется до тех пор, пока не будет ожидание подключения в очереди входящих подключений. Метод <xref:System.Net.Sockets.Socket.EndAccept%2A> принимает входящее подключение и возвращает новый <xref:System.Net.Sockets.Socket>, который можно использовать для отправки и получения данных с удаленного узла.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается асинхронный запрос и создается новый <xref:System.Net.Sockets.Socket> для принятия входящего запроса на подключение. Полный пример, демонстрирующий асинхронную связь с сокетами, см. в статье [примеры кода для сокетов](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT is required for this method.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * int * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</param>
        <param name="bytesTransferred">The number of bytes transferred.</param>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</param>
        <summary>Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication. This method returns a buffer that contains the initial data and the number of bytes transferred.</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> завершает вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A>необходимо создать метод обратного вызова, который вызывается делегатом <xref:System.AsyncCallback>. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как метод <xref:System.Net.Sockets.Socket.BeginAccept%2A> возвращает. Он должен принять параметр `asyncResult`, возвращенный методом <xref:System.Net.Sockets.Socket.BeginAccept%2A>.  
  
 В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра `asyncResult`, чтобы получить <xref:System.Net.Sockets.Socket>, на который устанавливается попытка подключения. После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndAccept%2A> для успешного завершения попытки подключения. Параметр `buffer` этой перегрузки содержит данные, полученные при вызове функции <xref:System.Net.Sockets.Socket.BeginAccept%2A>, а параметр `bytesTransferred` содержит число байтов, переданных в вызове.  
  
 Метод <xref:System.Net.Sockets.Socket.EndAccept%2A> блокируется до тех пор, пока не будет ожидание подключения в очереди входящих подключений. Метод <xref:System.Net.Sockets.Socket.EndAccept%2A> принимает входящее подключение и возвращает новый <xref:System.Net.Sockets.Socket>, который можно использовать для отправки и получения данных с удаленного узла.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.Sockets.Socket.BeginAccept%2A>, чтобы создать и подключить сокет и принять начальные 10 байт данных. Делегат обратного вызова вызывает <xref:System.Net.Sockets.Socket.EndAccept%2A> для завершения асинхронного запроса. Число переданных байтов и данные возвращаются в `buffer` и `bytesTransferred` параметров этого метода и отображаются в консоли.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT is required for this method.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is empty.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</param>
        <param name="result">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</param>
        <summary>Ends a pending asynchronous connection request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> — это блокирующий метод, который завершает асинхронный запрос на подключение к удаленному узлу, запущенный в методе <xref:System.Net.Sockets.Socket.BeginConnect%2A>.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginConnect%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginConnect%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginConnect%2A> в качестве параметра.  
  
 В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра <xref:System.IAsyncResult>, чтобы получить <xref:System.Net.Sockets.Socket>, на который устанавливается попытка подключения. После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndConnect%2A> для успешного завершения попытки подключения.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается асинхронная попытки подключения. Полный пример, демонстрирующий асинхронную связь с сокетами, см. в статье [примеры кода для сокетов](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation.</param>
        <summary>Ends a pending asynchronous disconnect request.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> завершает вызов <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. Метод <xref:System.Net.Sockets.Socket.EndDisconnect%2A> блокируется до завершения отключения. Дополнительные сведения об асинхронных операциях см. в разделе Общие сведения о асинхронном программировании в библиотеке MSDN.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается сокет для асинхронного взаимодействия и данные отправляются на удаленный узел. После отправки данных вызывается <xref:System.Net.Sockets.Socket.Shutdown%2A> для отмены действия Send и Receive. Затем вызывается <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> для начала запроса на отключение. Делегат обратного вызова вызывает <xref:System.Net.Sockets.Socket.EndDisconnect%2A> для завершения асинхронного запроса. По завершении запроса свойство <xref:System.Net.Sockets.Socket.Connected%2A> запрашивается, чтобы проверить, отключен ли сокет.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.Net.WebException">The disconnect request has timed out.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ends a pending asynchronous read.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</param>
        <param name="result">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</param>
        <summary>Ends a pending asynchronous read.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.EndReceive%2A> завершает операцию асинхронного чтения, запущенную в методе <xref:System.Net.Sockets.Socket.BeginReceive%2A>.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceive%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginReceive%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginReceive%2A> в качестве параметра.  
  
 В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>, чтобы получить объект состояния, переданный методу <xref:System.Net.Sockets.Socket.BeginReceive%2A>. Извлеките <xref:System.Net.Sockets.Socket> получения из этого объекта состояния. После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndReceive%2A> для успешного завершения операции чтения и возврата числа считанных байтов.  
  
 Метод <xref:System.Net.Sockets.Socket.EndReceive%2A> будет блокироваться до тех пор, пока данные недоступны. Если используется протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndReceive%2A> прочитает первую поставленную в очередь датаграмму, доступную во входящем сетевом буфере. При использовании протокола, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.EndReceive%2A> будет считывать столько данных, сколько доступно до числа байтов, указанных в параметре `size` метода <xref:System.Net.Sockets.Socket.BeginReceive%2A>. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.EndReceive%2A> будет завершен немедленно и возвращать нулевые байты.  
  
 Чтобы получить полученные данные, вызовите метод <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>и извлеките буфер, содержащийся в результирующем объекте состояния.  
  
 Чтобы отменить ожидающее <xref:System.Net.Sockets.Socket.BeginReceive%2A>, вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается ожидание асинхронного чтения. Полный пример, демонстрирующий асинхронную связь с сокетами, см. в статье [примеры кода для сокетов](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult * SocketError -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</param>
        <summary>Ends a pending asynchronous read.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.EndReceive%2A> завершает операцию асинхронного чтения, запущенную в методе <xref:System.Net.Sockets.Socket.BeginReceive%2A>.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceive%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginReceive%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginReceive%2A> в качестве параметра.  
  
 В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>, чтобы получить объект состояния, переданный методу <xref:System.Net.Sockets.Socket.BeginReceive%2A>. Извлеките <xref:System.Net.Sockets.Socket> получения из этого объекта состояния. После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndReceive%2A> для успешного завершения операции чтения и возврата числа считанных байтов.  
  
 Метод <xref:System.Net.Sockets.Socket.EndReceive%2A> будет блокироваться до тех пор, пока данные недоступны. Если используется протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndReceive%2A> прочитает первую поставленную в очередь датаграмму, доступную во входящем сетевом буфере. При использовании протокола, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.EndReceive%2A> будет считывать столько данных, сколько доступно до числа байтов, указанных в параметре `size` метода <xref:System.Net.Sockets.Socket.BeginReceive%2A>. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.EndReceive%2A> будет завершен немедленно и возвращать нулевые байты.  
  
 Чтобы получить полученные данные, вызовите метод <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>и извлеките буфер, содержащийся в результирующем объекте состояния.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (asyncResult, endPoint)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</param>
        <param name="result">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</param>
        <param name="endPoint">The source <see cref="T:System.Net.EndPoint" />.</param>
        <param name="end_point">The source <see cref="T:System.Net.EndPoint" />.</param>
        <summary>Ends a pending asynchronous read from a specific endpoint.</summary>
        <returns>If successful, the number of bytes received. If unsuccessful, returns 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> завершает операцию асинхронного чтения, запущенную в методе <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> в качестве параметра.  
  
 В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>, чтобы получить объект состояния, переданный методу <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>. Извлеките <xref:System.Net.Sockets.Socket> получения из этого объекта состояния. После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> для успешного завершения операции чтения и возврата числа считанных байтов.  
  
 Метод <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> будет блокироваться до тех пор, пока данные недоступны. Если используется протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> прочитает первую поставленную в очередь датаграмму, доступную во входящем сетевом буфере. При использовании протокола, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> будет считывать столько данных, сколько доступно до числа байтов, указанных в параметре `size` метода <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> будет завершен немедленно и возвращать нулевые байты. Чтобы получить полученные данные, вызовите метод <xref:System.IAsyncResult.AsyncState%2A> объекта <xref:System.IAsyncResult> и извлеките буфер, содержащийся в результирующем объекте состояния. Чтобы найти исходный узел, извлеките <xref:System.Net.EndPoint> и приведите его к <xref:System.Net.IPEndPoint>. Используйте метод <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>, чтобы получить IP-адрес и метод <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> для получения номера порта.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается ожидание асинхронного чтения из определенного <xref:System.Net.EndPoint>.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> was previously called for the asynchronous read.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values for the received packet.</param>
        <param name="endPoint">The source <see cref="T:System.Net.EndPoint" />.</param>
        <param name="ipPacketInformation">The <see cref="T:System.Net.IPAddress" /> and interface of the received packet.</param>
        <summary>Ends a pending asynchronous read from a specific endpoint. This method also reveals more information about the packet than <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</summary>
        <returns>If successful, the number of bytes received. If unsuccessful, returns 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если операция не завершена, этот метод блокируется до тех пор, пока он не завершится.  
  
 Чтобы выполнить эту операцию синхронно, используйте метод <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>.  
  
 Изучите `ipPacketInformation`, если необходимо узнать, была ли датаграмма отправлена с помощью одноадресной рассылки, многоадресной рассылки или широковещательной рассылки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is <see langword="null" />  
  
-or- 
 <paramref name="endPoint" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> was previously called for the asynchronous read.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ends a pending asynchronous send.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</param>
        <param name="result">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</param>
        <summary>Ends a pending asynchronous send.</summary>
        <returns>If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> завершает операцию асинхронной отправки, запущенную в <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginSend%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginSend%2A> в качестве параметра.  
  
 В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра <xref:System.IAsyncResult>, чтобы получить <xref:System.Net.Sockets.Socket>отправки. После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndSend%2A> для успешного завершения операции отправки и возврата числа отправленных байтов.  
  
 Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.EndSend%2A> будет блокироваться до отправки датаграммы. Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.EndSend%2A> будет блокироваться до отправки некоторых буферов. Если возвращаемое значение из <xref:System.Net.Sockets.Socket.EndSend%2A> указывает, что буфер не был полностью отправлен, вызовите метод <xref:System.Net.Sockets.Socket.BeginSend%2A> еще раз, изменив буфер, чтобы вместить неотправленные данные.  
  
 Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.BeginSend%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается отложенная асинхронная отправка.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult * SocketError -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</param>
        <summary>Ends a pending asynchronous send.</summary>
        <returns>If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> завершает операцию асинхронной отправки, запущенную в <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginSend%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginSend%2A> в качестве параметра.  
  
 В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра <xref:System.IAsyncResult>, чтобы получить <xref:System.Net.Sockets.Socket>отправки. После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndSend%2A> для успешного завершения операции отправки и возврата числа отправленных байтов.  
  
 Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.EndSend%2A> будет блокироваться до отправки датаграммы. Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.EndSend%2A> будет блокироваться до отправки некоторых буферов. Если возвращаемое значение из <xref:System.Net.Sockets.Socket.EndSend%2A> указывает, что буфер не был полностью отправлен, вызовите метод <xref:System.Net.Sockets.Socket.BeginSend%2A> еще раз, изменив буфер, чтобы вместить неотправленные данные.  
  
 Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.BeginSend%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation.</param>
        <summary>Ends a pending asynchronous send of a file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> завершает операцию асинхронной отправки, запущенную в <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginSendFile%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginSendFile%2A> возвращает. Метод обратного вызова должен принимать объект <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginSendFile%2A> в качестве параметра.  
  
 В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра <xref:System.IAsyncResult>, чтобы получить <xref:System.Net.Sockets.Socket>отправки. После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndSendFile%2A> для успешного завершения операции Send.  
  
 Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.EndSendFile%2A> блокируется до отправки датаграммы. Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.EndSendFile%2A> блокируется до тех пор, пока не будет отправлен весь файл. Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.BeginSendFile%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода создает и подключает сокет для асинхронного взаимодействия и начинает асинхронно отправлять файл "Text. txt" на удаленный узел. Делегат обратного вызова вызывает <xref:System.Net.Sockets.Socket.EndSendFile%2A> для завершения передачи.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT is required for this method.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is empty.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> was previously called for the asynchronous <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See remarks section below.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo asyncResult" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</param>
        <param name="result">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</param>
        <summary>Ends a pending asynchronous send to a specific location.</summary>
        <returns>If successful, the number of bytes sent; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> завершает операцию асинхронной отправки, запущенную в <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginSendTo%2A>необходимо создать метод обратного вызова, реализующий делегат <xref:System.AsyncCallback>. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, как <xref:System.Net.Sockets.Socket.BeginReceive%2A> возвращает. Метод обратного вызова должен принимать <xref:System.IAsyncResult>, возвращаемый методом <xref:System.Net.Sockets.Socket.BeginSendTo%2A> в качестве параметра.  
  
 В методе обратного вызова вызовите метод <xref:System.IAsyncResult.AsyncState%2A> параметра <xref:System.IAsyncResult>, чтобы получить <xref:System.Net.Sockets.Socket>отправки. После получения <xref:System.Net.Sockets.Socket>можно вызвать метод <xref:System.Net.Sockets.Socket.EndSendTo%2A> для успешного завершения операции отправки и возврата числа отправленных байтов.  
  
 Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.EndSendTo%2A> будет блокироваться до отправки датаграммы. Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.EndSendTo%2A> будет блокироваться до отправки запрошенного числа байтов. Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.BeginSendTo%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается асинхронная отправка в определенное расположение.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> was previously called for the asynchronous send.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows only one process to bind to a port.</summary>
        <value><see langword="true" />, если <see cref="T:System.Net.Sockets.Socket" /> допускает привязку только одного сокета к определенному порту; в противном случае <see langword="false" />. Значение по умолчанию — <see langword="true" /> для Windows Server 2003 и Windows XP с пакетом обновления 2, а <see langword="false" /> для всех остальных версий.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> `false`, то несколько сокетов могут использовать метод <xref:System.Net.Sockets.Socket.Bind%2A> для привязки к определенному порту; Однако только один из сокетов может выполнять операции с сетевым трафиком, отправляемым на порт. Если несколько сокетов пытаются использовать метод <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> для привязки к определенному порту, то один из них с более конкретным IP-адресом будет работать с сетевым трафиком, отправляемым на этот порт.  
  
 Если <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> `true`, то при первом использовании метода <xref:System.Net.Sockets.Socket.Bind%2A> для попытки привязки к определенному порту, независимо от IP-адреса, будет выполнена успешная попытка. все последующие применения метода <xref:System.Net.Sockets.Socket.Bind%2A> для попыток привязки к этому порту завершатся ошибкой, пока не будет разрушен исходный связанный сокет.  
  
 Это свойство должно быть установлено перед вызовом <xref:System.Net.Sockets.Socket.Bind%2A>; в противном случае будет выдано исключение <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> has been called for this <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Frees resources used by the <see cref="T:System.Net.Sockets.Socket" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Финализатор класса <xref:System.Net.Sockets.Socket> вызывает метод <xref:System.Net.Sockets.Socket.Close%2A>, чтобы закрыть <xref:System.Net.Sockets.Socket> и свободные ресурсы, связанные с <xref:System.Net.Sockets.Socket>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a hash value for a <see cref="T:System.Net.Sockets.Socket" /> instance.</summary>
        <returns>An integer hash value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Метод GetHashCode возвращает хэш-код этого экземпляра. Это значение можно использовать в качестве ключа в хэш-таблицах.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the value of a <see cref="T:System.Net.Sockets.Socket" /> option.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</param>
        <param name="optionName">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</param>
        <summary>Returns the value of a specified <see cref="T:System.Net.Sockets.Socket" /> option, represented as an object.</summary>
        <returns>An object that represents the value of the option. When the <paramref name="optionName" /> parameter is set to <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> the return value is an instance of the <see cref="T:System.Net.Sockets.LingerOption" /> class. When <paramref name="optionName" /> is set to <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> or <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, the return value is an instance of the <see cref="T:System.Net.Sockets.MulticastOption" /> class. When <paramref name="optionName" /> is any other value, the return value is an integer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры <xref:System.Net.Sockets.Socket> определяют поведение текущего <xref:System.Net.Sockets.Socket>. Используйте эту перегрузку для получения параметров <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>и <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>. Для параметра <xref:System.Net.Sockets.SocketOptionName.Linger> используйте <xref:System.Net.Sockets.Socket> для параметра `optionLevel`. Для <xref:System.Net.Sockets.SocketOptionName.AddMembership> и <xref:System.Net.Sockets.SocketOptionName.DropMembership>используйте <xref:System.Net.Sockets.SocketOptionLevel.IP>. Если вы хотите задать значение любого из перечисленных выше параметров, используйте метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода извлекает значения времени ожидания <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A> и отображает их в консоли.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.  
  
-or- 
 <paramref name="optionName" /> was set to the unsupported value <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</param>
        <param name="optionName">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</param>
        <param name="optionValue">An array of type <see cref="T:System.Byte" /> that is to receive the option setting.</param>
        <summary>Returns the specified <see cref="T:System.Net.Sockets.Socket" /> option setting, represented as a byte array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры <xref:System.Net.Sockets.Socket> определяют поведение текущего <xref:System.Net.Sockets.Socket>. После успешного завершения этого метода массив, заданный параметром `optionValue`, содержит значение указанного параметра <xref:System.Net.Sockets.Socket>.  
  
 Если длина массива `optionValue` меньше, чем число байтов, необходимое для хранения значения указанного параметра <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки. Используйте эту перегрузку для всех сокетов, представленных логическими значениями или целыми числами.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода извлекает значения времени ожидания <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A> и отображает их в консоли.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.  
  
-or- 
In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes. You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</param>
        <param name="optionName">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</param>
        <param name="optionLength">The length, in bytes, of the expected return value.</param>
        <summary>Returns the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option in an array.</summary>
        <returns>An array of type <see cref="T:System.Byte" /> that contains the value of the socket option.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `optionLength` задает максимальный размер возвращаемого массива байтов. Если значение параметра требует меньше байт, массив будет содержать только столько байтов. Если значение параметра требует больше байтов, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> выдаст <xref:System.Net.Sockets.SocketException>. Используйте эту перегрузку для всех сокетов, представленных логическими значениями или целыми числами.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода извлекает значения времени ожидания <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A> и отображает их в консоли.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.  
  
-or- 
In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes. You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value><see cref="T:System.IntPtr" />, представляющий обработчик операционной системы для <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">An <see cref="T:System.Int32" /> value that specifies the control code of the operation to perform.</param>
        <param name="optionInValue">A <see cref="T:System.Byte" /> array that contains the input data required by the operation.</param>
        <param name="optionOutValue">A <see cref="T:System.Byte" /> array that contains the output data returned by the operation.</param>
        <summary>Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using numerical control codes.</summary>
        <returns>The number of bytes in the <paramref name="optionOutValue" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.IOControl%2A> предоставляет низкоуровневый доступ к операционной системе <xref:System.Net.Sockets.Socket> базовому экземпляру класса <xref:System.Net.Sockets.Socket>. Дополнительные сведения см. в документации по [всаиоктл](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) .  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода сравниваются результаты ФИОНРЕАД и доступного свойства.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для выполнения неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">A <see cref="T:System.Net.Sockets.IOControlCode" /> value that specifies the control code of the operation to perform.</param>
        <param name="optionInValue">An array of type <see cref="T:System.Byte" /> that contains the input data required by the operation.</param>
        <param name="optionOutValue">An array of type <see cref="T:System.Byte" /> that contains the output data returned by the operation.</param>
        <summary>Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="T:System.Net.Sockets.IOControlCode" /> enumeration to specify control codes.</summary>
        <returns>The number of bytes in the <paramref name="optionOutValue" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обеспечивает низкоуровневый доступ к операционной системе <xref:System.Net.Sockets.Socket> базовом экземпляре класса <xref:System.Net.Sockets.Socket>. Дополнительные сведения см. в документации по [всаиоктл](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) .  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода сравниваются результаты вызова <xref:System.Net.Sockets.Socket.IOControl%2A> с <xref:System.Net.Sockets.IOControlCode.DataToRead> и свойством <xref:System.Net.Sockets.Socket.Available%2A>.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для выполнения неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is bound to a specific local port.</summary>
        <value><see langword="true" />, если <see cref="T:System.Net.Sockets.Socket" /> привязан к локальному порту; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сокет считается привязанным к локальному порту, если он явно привязан путем вызова метода <xref:System.Net.Sockets.Socket.Bind%2A> или неявно привязан путем вызова членов, таких как <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>или <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, использующих временный локальный порт (бесплатный порт, превышающий 1024 , выбранная операционной системой.) Серверы используют метод <xref:System.Net.Sockets.Socket.Bind%2A> для привязки к хорошо известному порту, чтобы клиенты могли подключаться к ним.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.IsBound%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> will delay closing a socket in an attempt to send all pending data.</summary>
        <value><see cref="T:System.Net.Sockets.LingerOption" />, указывающий, как исходящее время ожидания при закрытии сокета.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.Sockets.Socket.LingerState%2A> изменяет способ, которым <xref:System.Net.Sockets.Socket.Close%2A> метод. Это свойство задается при изменении условий, при которых подключение может быть сброшено с помощью Winsock. Сброс соединения по-прежнему может происходить в зависимости от поведения протокола IP.  
  
 Это свойство управляет длительностью времени, в течение которого соединение, ориентированное на соединение, остается открытым после вызова <xref:System.Net.Sockets.Socket.Close%2A>, когда данные остаются для отправки.  
  
 При вызове методов для отправки данных одноранговой сети эти данные помещаются в исходящий сетевой буфер. Это свойство можно использовать, чтобы убедиться, что эти данные отправляются на удаленный узел перед тем, как метод <xref:System.Net.Sockets.TcpClient.Close%2A> удаляет подключение.  
  
 Чтобы включить ожидание, создайте экземпляр <xref:System.Net.Sockets.LingerOption>, содержащий нужные значения, и задайте для свойства <xref:System.Net.Sockets.Socket.LingerState%2A> значение этого экземпляра.  
  
 В следующей таблице описывается поведение метода <xref:System.Net.Sockets.Socket.Close%2A> для возможных значений свойства <xref:System.Net.Sockets.LingerOption.Enabled%2A> и свойства <xref:System.Net.Sockets.LingerOption.LingerTime%2A>, хранящегося в свойстве <xref:System.Net.Sockets.Socket.LingerState%2A>.  
  
|Линжерстате. Enabled|Линжерстате. Линжертиме|Поведение|  
|-------------------------|----------------------------|--------------|  
|`false` (отключено), значение по умолчанию|Время ожидания неприменимо (по умолчанию).|Пытается отправить ожидающие данные до истечения времени ожидания протокола IP по умолчанию.|  
|`true` (включено)|Ненулевое время ожидания|Пытается отправить ожидающие данные до истечения заданного времени ожидания. Если попытка не удалась, Winsock сбрасывает подключение.|  
|`true` (включено)|Нулевое время ожидания.|Отменяет все ожидающие данные. Для сокета, ориентированного на подключение (например, TCP), Winsock сбрасывает подключение.|  
  
 В стеке IP-адресов используется период ожидания протокола IP по умолчанию, используемый в зависимости от времени кругового пути соединения. В большинстве случаев время ожидания, вычисленное стеком, больше релевантно, чем определено приложением. Это поведение по умолчанию для сокета, если не задано свойство <xref:System.Net.Sockets.Socket.LingerState%2A>.  
  
 Если свойство <xref:System.Net.Sockets.LingerOption.LingerTime%2A>, хранящееся в свойстве <xref:System.Net.Sockets.Socket.LingerState%2A>, установлено больше, чем время ожидания протокола IP по умолчанию, по умолчанию время ожидания протокола IP по-прежнему будет применяться и переопределено.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.LingerState%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">The maximum length of the pending connections queue.</param>
        <summary>Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> вызывает <xref:System.Net.Sockets.Socket>, ориентированный на подключение, для прослушивания входящих попыток подключения. Параметр `backlog` указывает количество входящих подключений, которые могут быть поставлены в очередь на принятие. Чтобы определить максимальное количество подключений, которое можно указать, извлеките значение <xref:System.Net.Sockets.SocketOptionName.MaxConnections>. <xref:System.Net.Sockets.Socket.Listen%2A> не блокируется.  
  
 Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки. Используйте <xref:System.Net.Sockets.Socket.Accept%2A> или <xref:System.Net.Sockets.Socket.BeginAccept%2A>, чтобы принимать подключение из очереди.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.Listen%2A>необходимо вызвать метод <xref:System.Net.Sockets.Socket.Bind%2A> или <xref:System.Net.Sockets.Socket.Listen%2A> вызовет <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Параметр невыполненной работы ограничен различными значениями в зависимости от операционной системы. Вы можете указать более высокое значение, но невыполненная работа будет ограничена в зависимости от операционной системы.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.Sockets.Socket> используется для прослушивания входящих подключений.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the local endpoint.</summary>
        <value><see cref="T:System.Net.EndPoint" />, используемая <see cref="T:System.Net.Sockets.Socket" /> для обмена данными.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> возвращает <xref:System.Net.EndPoint>, который содержит локальный IP-адрес и номер порта, к которым привязан <xref:System.Net.Sockets.Socket>. Перед получением каких-либо сведений необходимо привести этот <xref:System.Net.EndPoint> к <xref:System.Net.IPEndPoint>. Затем можно вызвать метод <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> для получения локального <xref:System.Net.IPAddress>и метод <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> для получения номера локального порта.  
  
 Свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> обычно задается после вызова метода <xref:System.Net.Sockets.Socket.Bind%2A>. Если разрешить системе назначать локальный IP-адрес сокета и номер порта, свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> будет установлено после первой операции ввода-вывода. Для протоколов, ориентированных на соединение, первая операция ввода-вывода будет вызывать метод <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. Для протоколов без подключения первая операция ввода-вывода будет иметь любой из вызовов Send или Receive.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода извлекаются и отображаются локальные и удаленные конечные точки.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> получает исходящие пакеты многоадресной рассылки; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Многоадресная рассылка — это масштабируемый метод для связи "многие ко многим" в Интернете. Процесс подписывается на адрес многоадресной рассылки; Затем все пакеты, отправленные подписанным процессом, получаются любым другим процессом, подписанным на адрес многоадресной рассылки.  
  
 Установка этого свойства для сокета протокола TCP не будет действовать.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the stream <see cref="T:System.Net.Sockets.Socket" /> is using the Nagle algorithm.</summary>
        <value><see langword="false" />, если <see cref="T:System.Net.Sockets.Socket" /> использует алгоритм Nagle; в противном случае <see langword="true" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Алгоритм Nagle предназначен для уменьшения сетевого трафика, вызывая буферизацию небольших пакетов через сокет, а затем объединять и отсылать их в одном пакете при определенных обстоятельствах. Пакет TCP состоит из 40 байт заголовка и отправляемых данных. Когда небольшие пакеты данных отправляются по протоколу TCP, накладные расходы, полученные из заголовка TCP, могут стать значительным частью сетевого трафика. В сильно загруженных сетях перегрузка, полученная в результате этой дополнительной нагрузки, может привести к потере датаграмм и повторных передач, а также к чрезмерному времени распространения, вызванному перегрузкой. Алгоритм Nagle запрещает отправку новых TCP-сегментов при поступлении новых исходящих данных от пользователя, если все ранее переданные подключения не подтверждены.  
  
 Большинство сетевых приложений должны использовать алгоритм Nagle.  
  
 Задание этого свойства для сокета UDP не будет действовать.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.NoDelay%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</summary>
        <value><see langword="true" />, поддерживает ли операционная система и сетевые адаптеры протокол IPv4; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операционная система может поддерживать протоколы IPv4 и IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</summary>
        <value><see langword="true" />, поддерживает ли операционная система и сетевые адаптеры протокол IPv6; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операционная система может поддерживать протоколы IPv4 и IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="microSeconds">The time to wait for a response, in microseconds.</param>
        <param name="mode">One of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</param>
        <summary>Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.  
  
 <list type="table"><listheader><term> Mode 
 </term><description> Return Value 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" /> if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending; 
-or- 
 <see langword="true" /> if data is available for reading; 
-or- 
 <see langword="true" /> if the connection has been closed, reset, or terminated; 
otherwise, returns <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded; 
-or- 
 <see langword="true" /> if data can be sent; 
otherwise, returns <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" /> if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed; 
-or- 
 <see langword="true" /> if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available; 
otherwise, returns <see langword="false" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.Poll%2A> проверит состояние <xref:System.Net.Sockets.Socket>. Укажите <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> для параметра `selectMode`, чтобы определить, доступен ли <xref:System.Net.Sockets.Socket> для чтения. Укажите <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType>, чтобы определить, доступна ли <xref:System.Net.Sockets.Socket> для записи. Для обнаружения состояния ошибки используйте <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType>. <xref:System.Net.Sockets.Socket.Poll%2A> будет блокировать выполнение до истечения указанного периода времени, измеряемого в `microseconds`. Задайте для параметра `microSeconds` отрицательное целое число, если вы хотите подождать неопределенное время ответа. Если вы хотите проверить состояние нескольких сокетов, можно использовать метод <xref:System.Net.Sockets.Socket.Select%2A>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Этот метод не может обнаружить некоторые виды проблем с подключением, например обрыв сетевого кабеля или некорректное завершение работы удаленного узла. Необходимо попытаться отправить или получить данные для обнаружения ошибок этих типов.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается сокет, подключается к серверу и используется <xref:System.Net.Sockets.Socket.Poll%2A> для проверки состояния сокета.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The <paramref name="mode" /> parameter is not one of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See remarks below.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the protocol type of the <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Одно из значений <see cref="T:System.Net.Sockets.ProtocolType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Net.Sockets.Socket.ProtocolType%2A> задается при создании <xref:System.Net.Sockets.Socket> и указывает протокол, используемый <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 В следующем примере кода выводятся <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>и <xref:System.Net.Sockets.ProtocolType> на консоль.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</param>
        <summary>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов. Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.  
  
 Эта перегрузка требует только предоставления буфера приема. По умолчанию смещение буфера равно 0, размер по умолчанию равен длине параметра buffer, а <xref:System.Net.Sockets.SocketFlags> значение по умолчанию равно <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Receive%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.  
  
 Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>. Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода получает данные на подключенном <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</param>
        <summary>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает данные в параметр Buffers и возвращает число успешно считанных байтов. Вы можете вызывать из сокетов, ориентированных на подключение, и без подключения.  
  
 Эта перегрузка требует предоставления одного или нескольких буферов приема.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с подключения к удаленному узлу, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Receive%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.  
  
 Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую из указанных в очереди датаграмму из адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>. Если полученная датаграмма превышает размер параметра `buffers`, `buffers` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 **Примечание** . Этот элемент выводит данные трассировки при включении трассировки сети в приложении. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">A span of bytes that is the storage location for the received data.</param>
        <summary>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов. Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.

Эта перегрузка требует только предоставления буфера приема. По умолчанию смещение буфера равно 0, размер по умолчанию равен длине параметра buffer, а <xref:System.Net.Sockets.SocketFlags> значение по умолчанию равно <xref:System.Net.Sockets.SocketFlags.None>.

Если используется протокол, ориентированный на подключение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> для установления соединения с удаленным узлом, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. Если вы используете протокол без установления соединения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.

Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Когда значение времени ожидания превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов выдаст исключение <xref:System.Net.Sockets.SocketException>. Если вы находитесь в режиме без блокировки и в буфере стека протоколов нет данных, то метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.

Если вы используете <xref:System.Net.Sockets.Socket>, ориентированную на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.

Если вы используете <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>. Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается исключение <xref:System.Net.Sockets.SocketException>.

> [!NOTE]
> Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.

Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Net.SocketPermission">Принятие подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <summary>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов. Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.  
  
 Эта перегрузка требует только предоставления буфера получения и необходимых <xref:System.Net.Sockets.SocketFlags>. По умолчанию смещение буфера равно 0, а размер по умолчанию равен длине параметра Byte.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.  
  
 Если данные для чтения недоступны, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные недоступны. Если вы используете неблокирующий режим и в буфере стека протокола нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет выполнен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равен нулю, повторите операцию получения.  
  
 При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно до размера буфера. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.  
  
 Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую из указанных в очереди датаграмму из адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>. Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода задается буфер данных и <xref:System.Net.Sockets.SocketFlags> для получения данных в подключенной <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Net.SocketPermission">Принятие подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <summary>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает данные в параметр `buffers` и возвращает число успешно считанных байтов. Вы можете вызывать из сокетов, ориентированных на подключение, и без подключения.  
  
 Эта перегрузка требует предоставления одного или нескольких буферов приема. Значение <xref:System.Net.Sockets.SocketFlags> по умолчанию равно <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с подключения к удаленному узлу, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов создает исключение <xref:System.Net.Sockets.SocketException>. Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.  
  
 Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую из указанных в очереди датаграмму из адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>. Если полученная датаграмма превышает размер параметра `buffers`, `buffers` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как получить данные на подключенном <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> is <see langword="null" />.  
  
-or- 
 <paramref name="buffers" />.Count is zero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">A span of bytes that is the storage location for the received data.</param>
        <param name="socketFlags">A bitwise combination of the enumeration values that specifies send and receive behaviors.</param>
        <summary>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов. Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.

Эта перегрузка требует только предоставления буфера приема. По умолчанию смещение буфера равно 0, размер по умолчанию равен длине параметра buffer, а <xref:System.Net.Sockets.SocketFlags> значение по умолчанию равно <xref:System.Net.Sockets.SocketFlags.None>.

Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. Если вы используете протокол без установления соединения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.

Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Когда значение времени ожидания превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов выдаст исключение <xref:System.Net.Sockets.SocketException>. Если вы находитесь в неблокирующем режиме и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет выполнен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.

Если вы используете <xref:System.Net.Sockets.Socket>, ориентированную на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.

Если вы используете <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>. Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается исключение <xref:System.Net.Sockets.SocketException>.

> [!NOTE]
> Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.

Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</param>
        <param name="size">The number of bytes to receive.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <summary>Receives the specified number of bytes of data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметр `buffer` и возвращает число успешно считанных байтов. Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.  
  
 Эта перегрузка требует только предоставить буфер приема, число принимаемых байтов и необходимое <xref:System.Net.Sockets.SocketFlags>.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Receive%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равен нулю, повторите операцию получения.  
  
 При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до числа байтов, заданного параметром `size`. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.  
  
 Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>. Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример получает данные, найденные в `buffer`, и указывает <xref:System.Net.Sockets.SocketFlags.None> для <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> exceeds the size of <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</param>
        <summary>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает данные в параметр `buffers` и возвращает число успешно считанных байтов. Вы можете вызывать из сокетов, ориентированных на подключение, и без подключения.  
  
 Эта перегрузка требует предоставления одного или нескольких буферов приема. Значение <xref:System.Net.Sockets.SocketFlags> по умолчанию равно <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с подключения к удаленному узлу, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов создает исключение <xref:System.Net.Sockets.SocketException>. Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.  
  
 Если используется <xref:System.Net.Sockets.Socket>без подключения,<xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>. Если полученная датаграмма превышает размер параметра `buffers`, `buffers` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> is <see langword="null" />.  
  
-or- 
 <paramref name="buffers" />.Count is zero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">A span of bytes that is the storage location for the received data.</param>
        <param name="socketFlags">A bitwise combination of the enumeration values that specifies send and receive behaviors.</param>
        <param name="errorCode">When this method returns, contains one of the enumeration values that defines error codes for the socket.</param>
        <summary>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов. Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.  

Эта перегрузка требует только предоставления буфера приема. По умолчанию смещение буфера равно 0, размер по умолчанию равен длине параметра buffer, а <xref:System.Net.Sockets.SocketFlags> значение по умолчанию равно <xref:System.Net.Sockets.SocketFlags.None>.  

Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. Если вы используете протокол без установления соединения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.  

Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Когда значение времени ожидания превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов выдаст исключение <xref:System.Net.Sockets.SocketException>. Если вы находитесь в режиме без блокировки и в буфере стека протоколов нет данных, то метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  

Если вы используете <xref:System.Net.Sockets.Socket>, ориентированную на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до размера буфера. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.  

Если вы используете <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>. Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.  

> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  

> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</param>
        <param name="offset">The location in <paramref name="buffer" /> to store the received data.</param>
        <param name="size">The number of bytes to receive.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <summary>Receives the specified number of bytes from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified offset position of the receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов. Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Receive%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Произошла ошибка при попытке доступа к сокету. См. примечания ниже. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до числа байтов, заданного параметром size. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.  
  
 Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>. Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода задается буфер данных, смещение, размер и флаг сокета перед получением данных на подключенном <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> is not a valid combination of values.  
  
-or- 
The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.  
  
-or- 
An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</param>
        <param name="offset">The position in the <paramref name="buffer" /> parameter to store the received data.</param>
        <param name="size">The number of bytes to receive.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</param>
        <summary>Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.Receive%2A> считывает данные в параметре buffer и возвращает число успешно считанных байтов. Вы можете вызвать <xref:System.Net.Sockets.Socket.Receive%2A> как с сокетами, ориентированными на подключение, так и без подключения.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать только данные, поступающие с удаленного узла, установленного в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. Если используется протокол без подключения, можно также использовать метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> позволит получить данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет блокироваться до тех пор, пока данные не будут доступны, если не было задано значение времени ожидания с помощью <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Receive%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Произошла ошибка при попытке доступа к сокету. См. примечания ниже. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать столько данных, сколько доступно, вплоть до числа байтов, заданного параметром size. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.Receive%2A> будет завершен немедленно и возвращать нулевые байты.  
  
 Если используется <xref:System.Net.Sockets.Socket>без подключения, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первую датаграмму в очереди с адреса назначения, указанного в методе <xref:System.Net.Sockets.Socket.Connect%2A>. Если полученная датаграмма превышает размер параметра `buffer`, `buffer` заполняется первой частью сообщения, лишние данные теряются и создается <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> is not a valid combination of values.  
  
-or- 
The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is not set.  
  
-or- 
An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
        <summary>Begins an asynchronous request to receive data from a connected <see cref="T:System.Net.Sockets.Socket" /> object.</summary>
        <returns><see langword="true" /> if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.  
  
 <see langword="false" /> if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> используется для подключенных сокетов или связанных сокетов без подключения и используется для чтения входящих данных. Локальный адрес сокета должен быть известен.  
  
 Для привязанных сокетов без подключения эта функция ограничивает адреса, из которых принимаются принимаемые сообщения. Функция возвращает только сообщения с удаленного адреса, указанного в соединении. Сообщения из других адресов отбрасываются без уведомления.  
  
 Свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> в параметре `e` предоставляет поставщику службы оконных сокетов дополнительные сведения о запросе на чтение. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> необходимы для успешного вызова этого метода:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> или <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>, если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> задано  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>, если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> задано  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 Для сокетов типа Byte входящие данные помещаются в буфер до тех пор, пока буфер не будет заполнен, соединение будет закрыто или исчерпаны внутренние буферизованные данные.  
  
 Для сокетов, ориентированных на сообщения, входящее сообщение помещается в буфер вплоть до общего размера буфера, связанного с параметром `e`. Если размер сообщения превышает размер буфера, буфер заполняется первой частью сообщения.  
  
 Для сокетов, ориентированных на соединение, метод <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> может указывать на корректное завершение виртуального канала одним из двух способов, которые зависят от того, является ли сокет потоком байтов или ориентированным на сообщения. Для потоковых потоков нулевое число прочитанных байтов указывает на корректное закрытие и на то, что больше байтов не будет считано. Для сокетов, ориентированных на сообщения, где сообщение с нулевым байтом часто разрешено, <xref:System.Net.Sockets.SocketException> с <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>, настроенным на собственный код ошибки Winsock ВСАЕДИСКОН (10101), используется для указания корректного замыкания. В любом случае <xref:System.Net.Sockets.SocketException> с <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>, заданным кодом ошибки ВСАЕКОННРЕСЕТ в машинном коде Winsock (10054), означает, что произошло аварийное закрытие.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">An argument was invalid. The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers. One or the other of these properties may be set, but not both at the same time.</exception>
        <exception cref="T:System.InvalidOperationException">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP or later is required for this method.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value><see cref="T:System.Int32" />, содержащий размер буфера приема в байтах. Значение по умолчанию — 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Больший размер буфера потенциально сокращает количество пустых подтверждений (пакетов TCP без данных), но может также отложить распознавание проблем с подключением. Если вы передаете большие файлы или используете высокоскоростное подключение с высокой задержкой (например, поставщик широкополосного подключения), попробуйте увеличить размер буфера.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Receives a datagram and stores the source endpoint.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</param>
        <param name="remoteEP">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</param>
        <summary>Receives a datagram into the data buffer and stores the endpoint.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> считывает данные в параметре `buffer`, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные. Этот метод полезен, если вы собираетесь принимать неподключенные датаграммы с неизвестного узла или с нескольких узлов.  
  
 Эта перегрузка требует только предоставления `buffer`получения и <xref:System.Net.EndPoint>, представляющей удаленный узел. По умолчанию смещение буфера равно 0. Размер по умолчанию равен длине параметра `buffer`, а `socketFlags` значение по умолчанию — <xref:System.Net.Sockets.SocketFlags.None>.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>необходимо явно привязать <xref:System.Net.Sockets.Socket> к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.Bind%2A>. В противном случае <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
 При использовании протоколов без подключения <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать первые поставленные в очередь датаграммы, полученные в буфер локальной сети. Если полученная датаграмма превышает размер `buffer`, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет заполняться `buffer` с максимально возможной частью сообщения и вызывать <xref:System.Net.Sockets.SocketException>. При использовании ненадежного протокола избыточные данные будут потеряны. Если используется надежный протокол, избыточные данные будут сохранены поставщиком услуг, и его можно будет извлечь, вызвав метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> с достаточно большим буфером.  
  
 Если данные для чтения недоступны, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет блокироваться до тех пор, пока данные недоступны. Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Хотя <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение. Если вы решили это сделать, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или добавив входящее подключение к удаленному узлу, вызвав метод <xref:System.Net.Sockets.Socket.Accept%2A>. Если не установить или не принять подключение перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, будет получен <xref:System.Net.Sockets.SocketException>. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. В любом из этих случаев метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет игнорировать параметр `remoteEP` и получить данные только с подключенного или удаленного узла по умолчанию.  
  
 При использовании сокетов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать столько данных, сколько доступно до размера `buffer`. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и возвращать нулевые байты.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемых в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, должны соответствовать <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемого в <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода получает датаграмму без подключения от удаленного узла.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.  
  
-or- 
 <paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="remoteEP">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</param>
        <summary>Receives a datagram into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> считывает данные в параметре `buffer`, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные. Этот метод полезен, если вы собираетесь принимать неподключенные датаграммы с неизвестного узла или с нескольких узлов.  
  
 Эта перегрузка требует только предоставления приемного буфера, необходимого <xref:System.Net.Sockets.SocketFlags>и <xref:System.Net.EndPoint>, представляющего удаленный узел. Смещение по умолчанию равно 0, а размер по умолчанию равен длине параметра buffer.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>необходимо явно привязать <xref:System.Net.Sockets.Socket> к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.Bind%2A>. В противном случае <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
 При использовании протоколов без подключения <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать первые поставленные в очередь датаграммы, полученные в буфер локальной сети. Если полученная датаграмма превышает размер `buffer`, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет заполняться `buffer` с максимально возможной частью сообщения и вызывать <xref:System.Net.Sockets.SocketException>. При использовании ненадежного протокола избыточные данные будут потеряны. Если используется надежный протокол, избыточные данные будут сохранены поставщиком услуг, и его можно будет извлечь, вызвав метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> с достаточно большим буфером.  
  
 Если данные для чтения недоступны, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет блокироваться до тех пор, пока данные недоступны. Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Хотя <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение. Если вы решили это сделать, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или добавив входящее подключение к удаленному узлу, вызвав метод <xref:System.Net.Sockets.Socket.Accept%2A>. Если не установить или не принять подключение перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, будет получен <xref:System.Net.Sockets.SocketException>. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. В любом из этих случаев метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет игнорировать параметр `remoteEP` и получить данные только с подключенного или удаленного узла по умолчанию.  
  
 При использовании сокетов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать столько данных, сколько доступно до размера `buffer`. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и возвращать нулевые байты.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемых в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, должны соответствовать <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемого в <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода получает датаграмму без подключения от удаленного узла. <xref:System.Net.Sockets.SocketFlags> передаются методу <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.  
  
-or- 
 <paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</param>
        <param name="size">The number of bytes to receive.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="remoteEP">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</param>
        <summary>Receives the specified number of bytes into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> считывает данные в параметре `buffer`, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные. Этот метод полезен, если вы собираетесь принимать неподключенные датаграммы с неизвестного узла или с нескольких узлов.  
  
 Эта перегрузка требует только предоставления буфера приема, числа принимаемых байтов, необходимого <xref:System.Net.Sockets.SocketFlags>и <xref:System.Net.EndPoint>, представляющего удаленный узел. По умолчанию смещение буфера равно 0.  
  
 При использовании протоколов без подключения <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать первые поставленные в очередь датаграммы, полученные в буфер локальной сети. Если полученная датаграмма превышает размер `buffer`, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет заполняться `buffer` с максимально возможной частью сообщения и вызывать <xref:System.Net.Sockets.SocketException>. При использовании ненадежного протокола избыточные данные будут потеряны. Если используется надежный протокол, избыточные данные будут сохранены поставщиком услуг, и его можно будет извлечь, вызвав метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> с достаточно большим буфером.  
  
 Если данные для чтения недоступны, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет блокироваться до тех пор, пока данные недоступны. Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Хотя <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение. Если вы решили это сделать, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или добавив входящее подключение к удаленному узлу, вызвав метод <xref:System.Net.Sockets.Socket.Accept%2A>. Если не установить или не принять подключение перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, будет получен <xref:System.Net.Sockets.SocketException>. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. В любом из этих случаев метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет игнорировать параметр `remoteEP` и получить данные только с подключенного или удаленного узла по умолчанию.  
  
 При использовании сокетов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать столько данных, сколько доступно до числа байтов, указанного параметром `size`. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и возвращать нулевые байты.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>необходимо явно привязать <xref:System.Net.Sockets.Socket> к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.Bind%2A>. В противном случае <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемых в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, должны соответствовать <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемого в <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода получает датаграмму без подключения от удаленного узла. Размер буфера и <xref:System.Net.Sockets.SocketFlags> передаются методу <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.  
  
-or- 
 <paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> is not a valid combination of values.  
  
-or- 
The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.  
  
-or- 
An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</param>
        <param name="offset">The position in the <paramref name="buffer" /> parameter to store the received data.</param>
        <param name="size">The number of bytes to receive.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="remoteEP">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</param>
        <summary>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> считывает данные в параметре `buffer`, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные. Этот метод полезен, если вы собираетесь принимать неподключенные датаграммы с неизвестного узла или с нескольких узлов.  
  
 При использовании протоколов без подключения <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать первые поставленные в очередь датаграммы, полученные в буфер локальной сети. Если полученная датаграмма превышает размер `buffer`, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет заполняться `buffer` с максимально возможной частью сообщения и вызывать <xref:System.Net.Sockets.SocketException>. При использовании ненадежного протокола избыточные данные будут потеряны. Если используется надежный протокол, избыточные данные будут сохранены поставщиком услуг, и его можно будет извлечь, вызвав метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> с достаточно большим буфером.  
  
 Если данные для чтения недоступны, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет блокироваться до тех пор, пока данные недоступны. Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и выдаст <xref:System.Net.Sockets.SocketException>. Чтобы определить, доступны ли данные для чтения, можно использовать свойство <xref:System.Net.Sockets.Socket.Available%2A>. Если <xref:System.Net.Sockets.Socket.Available%2A> не равно нулю, повторите операцию получения.  
  
 Хотя <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение. Если вы решили это сделать, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или добавив входящее подключение к удаленному узлу, вызвав метод <xref:System.Net.Sockets.Socket.Accept%2A>. Если не установить или не принять подключение перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, будет получен <xref:System.Net.Sockets.SocketException>. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>. В любом из этих случаев метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет игнорировать параметр `remoteEP` и получить данные только с подключенного или удаленного узла по умолчанию.  
  
 При использовании сокетов, ориентированных на соединение, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет считывать столько данных, сколько доступно в байтах, заданных параметром `size`. Если удаленный узел завершает подключение <xref:System.Net.Sockets.Socket> с помощью метода <xref:System.Net.Sockets.Socket.Shutdown%2A> и получены все доступные данные, метод <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> будет завершен немедленно и возвращать нулевые байты.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>необходимо явно привязать <xref:System.Net.Sockets.Socket> к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.Bind%2A>. В противном случае <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемых в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, должны соответствовать <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемого в <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода получает датаграмму без подключения от удаленного узла. Смещение, размер буфера и <xref:System.Net.Sockets.SocketFlags> передаются методу <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.  
  
-or- 
 <paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> is not a valid combination of values.  
  
-or- 
The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.  
  
-or- 
An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
        <summary>Begins to asynchronously receive data from a specified network device.</summary>
        <returns><see langword="true" /> if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.  
  
 <see langword="false" /> if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> используется в основном для получения данных в сокете без подключения. Локальный адрес сокета должен быть известен.  
  
 Вызывающий объект должен присвоить свойству <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> <xref:System.Net.IPEndPoint> удаленного узла, от которого должны быть получены данные.  
  
 Свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> в параметре `e` предоставляет поставщику службы оконных сокетов дополнительные сведения о запросе на чтение. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> необходимы для успешного вызова этого метода:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 Для сокетов, ориентированных на сообщения, входящее сообщение помещается в буфер вплоть до общего размера буфера. Свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> и <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> определяют место размещения данных в буфере и объем данных.  
  
 Для сокетов типа Byte входящие данные помещаются в буфер до тех пор, пока буфер не будет заполнен, соединение будет закрыто или исчерпаны внутренние буферизованные данные. Свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> и <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> определяют место размещения данных в буфере и объем данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</exception>
        <exception cref="T:System.InvalidOperationException">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP or later is required for this method.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</param>
        <param name="offset">The position in the <paramref name="buffer" /> parameter to store the received data.</param>
        <param name="size">The number of bytes to receive.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="remoteEP">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</param>
        <param name="ipPacketInformation">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> holding address and interface information.</param>
        <summary>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</summary>
        <returns>The number of bytes received.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> считывает данные в параметре `buffer`, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные, а также сведения о полученных пакетах.  
  
 Метод <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> используется в основном для получения данных сообщений в сокете без подключения. Локальный адрес сокета должен быть известен. Этот метод может использоваться только с датаграммами и необработанными сокетами. Перед вызовом этого метода сокет должен быть инициализирован с типом сокета, равным <xref:System.Net.Sockets.SocketType.Dgram> или <xref:System.Net.Sockets.SocketType.Raw>. Это можно сделать при создании сокета с помощью <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Для сокетов, ориентированных на сообщения, входящее сообщение помещается в параметр `buffer` вплоть до общего размера, указанного в параметре `size`. Параметр `offset` определяет, где в `buffer` размещаются данные. Фактический объем данных, помещаемых в `buffer`, возвращается методом <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>.  
  
 Метод <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Method автоматически задает для параметра <xref:System.Net.Sockets.SocketOptionName.PacketInformation> сокета значение `true` при первом вызове для данного <xref:System.Net.Sockets.Socket>. Однако возвращенный объект <xref:System.Net.Sockets.IPPacketInformation> будет действителен только для пакетов, поступающих на локальный компьютер после установки параметра сокета. Если сокет отправляет пакеты между моментом привязки к локальной конечной точке (явно методом <xref:System.Net.Sockets.Socket.Bind%2A> или неявно одним из методов <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>или <xref:System.Net.Sockets.Socket.SendToAsync%2A>) и первым вызовом метода <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> , вызовы метода <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> будут возвращать недопустимые <xref:System.Net.Sockets.IPPacketInformation> объекты для этих пакетов.  
  
 Чтобы обеспечить допустимость всех <xref:System.Net.Sockets.IPPacketInformation> объектов, приложение должно установить параметр <xref:System.Net.Sockets.SocketOptionName.PacketInformation> сокета для `true` перед привязкой к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>.  
  
 Приложение может проверить параметр `ipPacketInformation`, если необходимо узнать, была ли датаграмма отправлена с помощью одноадресного, многоадресного или широковещательного адреса.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемых в <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, должны соответствовать <xref:System.Net.Sockets.AddressFamily> <xref:System.Net.EndPoint>, используемого в <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.  
  
-or- 
 <paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> is not a valid combination of values.  
  
-or- 
The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.  
  
-or- 
The .NET Framework is running on an AMD 64-bit processor.  
  
-or- 
An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.NotSupportedException">The operating system is Windows 2000 or earlier, and this method requires Windows XP.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
        <summary>Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, and stores the endpoint and packet information.</summary>
        <returns><see langword="true" /> if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.  
  
 <see langword="false" /> if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> используется в основном для получения данных сообщений в сокете без подключения. Локальный адрес сокета должен быть известен. Этот метод может использоваться только с датаграммами и необработанными сокетами. Перед вызовом этого метода сокет должен быть инициализирован с типом сокета, равным <xref:System.Net.Sockets.SocketType.Dgram> или <xref:System.Net.Sockets.SocketType.Raw>. Это можно сделать при создании сокета с помощью <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Вызывающий объект должен присвоить свойству <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> <xref:System.Net.IPEndPoint> удаленного узла, от которого должны быть получены данные.  
  
 Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> необходимы для успешного вызова этого метода:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 Для сокетов, ориентированных на сообщения, входящее сообщение помещается в буфер вплоть до общего размера буфера. Свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> и <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> определяют место размещения данных в буфере и объем данных.  
  
 Метод <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> автоматически задает для параметра <xref:System.Net.Sockets.SocketOptionName.PacketInformation> сокета значение `true` при первом вызове для данного <xref:System.Net.Sockets.Socket>. Однако объект <xref:System.Net.Sockets.IPPacketInformation> будет действителен только для пакетов, поступающих на локальный компьютер после установки параметра сокета. Если сокет отправляет пакеты между моментом привязки сокета к локальной конечной точке (явно методом <xref:System.Net.Sockets.Socket.Bind%2A> или неявно одним из методов <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>или <xref:System.Net.Sockets.Socket.SendToAsync%2A>) и первым вызовом метода <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> , вызовы метода <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> приведут к недопустимым <xref:System.Net.Sockets.IPPacketInformation> объектам для этих пакетов.  
  
 Чтобы обеспечить допустимость всех <xref:System.Net.Sockets.IPPacketInformation> объектов, приложение должно установить параметр <xref:System.Net.Sockets.SocketOptionName.PacketInformation> сокета для`true` перед привязкой к локальной конечной точке с помощью метода <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>.  
  
 Приложение может проверить результирующие <xref:System.Net.Sockets.IPPacketInformation> объекты, если необходимо узнать, была ли датаграмма отправлена с помощью одноадресной рассылки, многоадресной рассылки или широковещательной рассылки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP or later is required for this method.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> call will time out.</summary>
        <value>Значение времени ожидания в миллисекундах. Значение по умолчанию — 0, что указывает на бесконечное время ожидания. При указании параметра-1 также указывается бесконечный период ожидания.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот параметр применяется только к синхронным вызовам <xref:System.Net.Sockets.Socket.Receive%2A>. При превышении времени ожидания метод <xref:System.Net.Sockets.Socket.Receive%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the remote endpoint.</summary>
        <value><see cref="T:System.Net.EndPoint" />, с которой взаимодействует <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если используется протокол, ориентированный на соединение, свойство <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> получает <xref:System.Net.EndPoint>, содержащий удаленный IP-адрес и номер порта, к которому подключена <xref:System.Net.Sockets.Socket>. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> содержит удаленный IP-адрес по умолчанию и номер порта, с которым будет взаимодействовать <xref:System.Net.Sockets.Socket>. Перед получением каких-либо сведений необходимо привести этот <xref:System.Net.EndPoint> к <xref:System.Net.IPEndPoint>. Затем можно вызвать метод <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> для получения удаленного <xref:System.Net.IPAddress>и метод <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> для получения номера удаленного порта.  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> задается после вызова либо <xref:System.Net.Sockets.Socket.Accept%2A>, либо <xref:System.Net.Sockets.Socket.Connect%2A>. Если попытаться получить доступ к этому свойству ранее, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода извлекаются и отображаются локальные и удаленные конечные точки.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Net.Sockets.SafeSocketHandle" /> that represents the socket handle that the current <see cref="T:System.Net.Sockets.Socket" /> object encapsulates.</summary>
        <value>Открытый в безопасном режиме обработчик сокета, который инкапсулирует текущий объект <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!IMPORTANT]
> Использование <xref:System.Net.Sockets.SafeSocketHandle> для прямого взаимодействия с сокетом может привести к недокументированному состоянию. 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="checkRead">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for readability.</param>
        <param name="checkWrite">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for writability.</param>
        <param name="checkError">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for errors.</param>
        <param name="microSeconds">The time-out value, in microseconds. A -1 value indicates an infinite time-out.</param>
        <summary>Determines the status of one or more sockets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> является статическим методом, который определяет состояние одного или нескольких экземпляров <xref:System.Net.Sockets.Socket>. Перед использованием метода <xref:System.Net.Sockets.Socket.Select%2A> необходимо поместить один или несколько сокетов в <xref:System.Collections.IList>. Проверьте наличие удобочитаемости, вызвав <xref:System.Net.Sockets.Socket.Select%2A> с <xref:System.Collections.IList> в качестве параметра `checkRead`. Чтобы проверить сокеты для записи, используйте параметр `checkWrite`. Для обнаружения условий возникновения ошибок используйте `checkError`. После вызова <xref:System.Net.Sockets.Socket.Select%2A><xref:System.Collections.IList> будут заполнены только теми сокетами, которые отвечают условиям.  
  
 В состоянии прослушивания удобочитаемость означает, что вызов <xref:System.Net.Sockets.Socket.Accept%2A> будет выполняться без блокировки. Если вы уже приняли подключение, удобочитаемость означает, что данные доступны для чтения. В таких случаях все операции получения будут выполняться без блокировки. Удобочитаемость может также указывать, завершил ли удаленный <xref:System.Net.Sockets.Socket> подключение. в этом случае вызов <xref:System.Net.Sockets.Socket.Receive%2A> будет немедленно возвращать, при этом возвращаются нулевые байты.  
  
 <xref:System.Net.Sockets.Socket.Select%2A> возвращает, когда по крайней мере один из нужных сокетов (сокеты в списках `checkRead`, `checkWrite`и `checkError`) соответствует заданным условиям, или превышено значение параметра `microSeconds`, в зависимости от того, что происходит раньше. При установке `microSeconds` в значение-1 указывается бесконечное время ожидания.  
  
 Если вы сделаете неблокирующий вызов <xref:System.Net.Sockets.Socket.Connect%2A>, записи означает, что подключение выполнено успешно. Если соединение уже установлено, записи означает, что все операции отправки будут выполнены без блокировки.  
  
 Если вы выполнили неблокирующий вызов <xref:System.Net.Sockets.Socket.Connect%2A>, параметр `checkerror` определяет сокеты, которые не были успешно подключены.  
  
> [!NOTE]
>  Если требуется только определить состояние одного <xref:System.Net.Sockets.Socket>, используйте метод <xref:System.Net.Sockets.Socket.Poll%2A>.  
  
> [!NOTE]
>  Этот метод не может обнаружить некоторые виды проблем с подключением, например обрыв сетевого кабеля или некорректное завершение работы удаленного узла. Необходимо попытаться отправить или получить данные для обнаружения ошибок этих типов.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.Sockets.Socket.Select%2A>, чтобы определить, какие сокеты прослушивания имеют запрос на соединение.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="checkRead" /> parameter is <see langword="null" /> or empty.  
  
-and- 
The <paramref name="checkWrite" /> parameter is <see langword="null" /> or empty 
-and- 
The <paramref name="checkError" /> parameter is <see langword="null" /> or empty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</param>
        <summary>Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов. <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.  
  
 Для этой перегрузки требуется буфер, содержащий данные, которые необходимо отправить. Значение <xref:System.Net.Sockets.SocketFlags> по умолчанию равно 0, смещение буфера по умолчанию равно 0, а число байтов для отправки по умолчанию равно размеру буфера.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без подключения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>. Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может быть успешно завершен даже при отправке меньшего числа байтов в буфере. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как отправлять данные на подключенном <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</param>
        <summary>Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.  
  
 Для этой перегрузки требуется по крайней мере один буфер, содержащий данные, которые необходимо отправить.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без подключения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>. Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может быть успешно завершен даже при отправке меньшего числа байтов в буфере. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> is empty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See remarks section below.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">A span of bytes that contains the data to be sent.</param>
        <summary>Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов. <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.

Для этой перегрузки требуется буфер, содержащий данные, которые необходимо отправить. Значение <xref:System.Net.Sockets.SocketFlags> по умолчанию равно 0, смещение буфера по умолчанию равно 0, а число байтов для отправки по умолчанию равно размеру буфера.

Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.

Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>. Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.

Если вы используете протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может быть успешно завершен даже при отправке меньшего числа байтов в буфере. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере. Также нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.

> [!NOTE]
>Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.

Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).

> [!IMPORTANT]
>Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <summary>Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, установленный в <xref:System.Net.Sockets.Socket.Connect%2A> или методе <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов. Метод <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.  
  
 Для этой перегрузки требуется буфер, содержащий данные, которые необходимо отправить, и побитовое сочетание <xref:System.Net.Sockets.SocketFlags>. По умолчанию смещение буфера равно 0, а число байтов для отправки по умолчанию равно размеру буфера. Если в качестве значения параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без подключения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>. Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может быть успешно завершен даже при отправке меньшего числа байтов в буфере. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Необходимо убедиться, что размер буфера не превышает максимальный размер пакета базового поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как отправлять данные на подключенном <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <summary>Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для этой перегрузки требуется по крайней мере один буфер, содержащий данные, которые необходимо отправить. Значение по умолчанию для <xref:System.Net.Sockets.SocketFlags> равно 0. Если в качестве параметра `socketFlags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без подключения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>. Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. В режиме без блокировки <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно, даже если число байтов в буфере меньше числа. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> is empty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">A span of bytes that contains the data to be sent.</param>
        <param name="socketFlags">A bitwise combination of the enumeration values that specifies send and receive behaviors.</param>
        <summary>Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  

  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</param>
        <param name="size">The number of bytes to send.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <summary>Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, установленный в <xref:System.Net.Sockets.Socket.Connect%2A> или методе <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов. <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.

Для этой перегрузки требуется буфер, содержащий данные, которые необходимо отправить, число байтов, которое необходимо отправить, и побитовое сочетание любого <xref:System.Net.Sockets.SocketFlags>. Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.

Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.

Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>. Если вы дон'тусе метод <xref:System.Net.Sockets.Socket.SendTo%2A>, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом метода <xref:System.Net.Sockets.Socket.Send%2A>. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.

При использовании протокола, ориентированного на соединение, <xref:System.Net.Sockets.Socket.Send%2A> блокируется до тех пор, пока не будет отправлено запрошенное число байтов, пока не будет задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно, даже если он пересылает меньшее количество байтов. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.

> [!NOTE]
> Необходимо убедиться, что размер не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.

Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).

> [!IMPORTANT]
>Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.

## Examples

Следующий пример кода отправляет данные, найденные в буфере, и указывает <xref:System.Net.Sockets.SocketFlags.None> для <xref:System.Net.Sockets.SocketFlags>.

[!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
[!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
[!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> is less than 0 or exceeds the size of the buffer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> is not a valid combination of values.  
  
-or- 
An operating system error occurs while accessing the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</param>
        <summary>Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для этой перегрузки требуется по крайней мере один буфер, содержащий данные, которые необходимо отправить. Значение по умолчанию для <xref:System.Net.Sockets.SocketFlags> равно 0. Если в качестве параметра `socketFlags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без подключения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>. Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. В режиме без блокировки <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно, даже если число байтов в буфере меньше числа. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> is empty.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">A span of bytes that contains the data to be sent.</param>
        <param name="socketFlags">A bitwise combination of the enumeration values that specifies send and receive behaviors.</param>
        <param name="errorCode">When this method returns, contains one of the enumeration values that defines error codes for the socket.</param>
        <summary>Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов. <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.

Для этой перегрузки требуется буфер, содержащий данные, которые необходимо отправить. Значение <xref:System.Net.Sockets.SocketFlags> по умолчанию равно 0, смещение буфера по умолчанию равно 0, а число байтов для отправки по умолчанию равно размеру буфера.

Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.

Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать метод <xref:System.Net.Sockets.Socket.SendTo%2A>. Если метод <xref:System.Net.Sockets.Socket.SendTo%2A> не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.

Если вы используете протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может быть успешно завершен даже при отправке меньшего числа байтов в буфере. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере. Также нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.

> [!NOTE]
>Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.

Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).

> [!IMPORTANT]
>Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</param>
        <param name="offset">The position in the data buffer at which to begin sending data.</param>
        <param name="size">The number of bytes to send.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <summary>Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов. <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.  
  
 В этой перегрузке, если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A>. Если <xref:System.Net.Sockets.Socket.SendTo%2A>не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Кроме того, необходимо убедиться, что размер не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> блокируется до тех пор, пока не будет отправлено запрошенное число байтов, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно, даже если он пересылает меньшее количество байтов. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода задаются буфер данных, смещение, размер и <xref:System.Net.Sockets.SocketFlags> для отправки данных в подключенную <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> is not a valid combination of values.  
  
-or- 
An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</param>
        <param name="offset">The position in the data buffer at which to begin sending data.</param>
        <param name="size">The number of bytes to send.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="errorCode">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</param>
        <summary>Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" /></summary>
        <returns>The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> синхронно отправляет данные на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>, и возвращает число успешно отправленных байтов. <xref:System.Net.Sockets.Socket.Send%2A> можно использовать для протоколов, ориентированных на подключение и без подключения.  
  
 В этой перегрузке, если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, иначе <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A>. Если <xref:System.Net.Sockets.Socket.SendTo%2A>не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A>, сделав еще один вызов <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Кроме того, необходимо убедиться, что размер не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> блокируется до тех пор, пока не будет отправлено запрошенное число байтов, если не было задано время ожидания с помощью <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Если значение времени ожидания было превышено, вызов <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>. В неблокирующем режиме <xref:System.Net.Sockets.Socket.Send%2A> может завершиться успешно, даже если он пересылает меньшее количество байтов. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.Send%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода задаются буфер данных, смещение, размер и <xref:System.Net.Sockets.SocketFlags> для отправки данных в подключенную <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> is not a valid combination of values.  
  
-or- 
An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
        <summary>Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</summary>
        <returns><see langword="true" /> if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.  
  
 <see langword="false" /> if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.SendAsync%2A> используется для записи исходящих данных из одного или нескольких буферов на сокете, ориентированном на соединение. Однако этот метод можно также использовать для сокетов без подключения, которые указали удаленный узел в операции подключения.  
  
 Метод <xref:System.Net.Sockets.Socket.SendAsync%2A> запускает асинхронную операцию отправки на удаленный узел, установленный в <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или в методе <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  
  
 Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> необходимы для успешного вызова этого метода:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> или <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>, если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> задано  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>, если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> задано  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.SendAsync%2A>, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 Метод <xref:System.Net.Sockets.Socket.SendAsync%2A> вызывает исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  
  
 Вызов метода <xref:System.Net.Sockets.Socket.SendAsync%2A> дает возможность отправки данных в отдельном потоке выполнения.  
  
 Для сокетов, ориентированных на сообщения, не следует превысить максимальный размер сообщения в базовом поставщике службы Windows Sockets. Если данные слишком длинны для передачи атомарным образом через базового поставщика услуг, данные не передаются, а метод <xref:System.Net.Sockets.Socket.SendAsync%2A> создает <xref:System.Net.Sockets.SocketException> с <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>ным кодом ошибки Winsock ВСАЕМСГСИЗЕ (10040).  
  
 Обратите внимание, что успешное завершение метода <xref:System.Net.Sockets.Socket.SendAsync%2A> не означает, что данные были успешно доставлены.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers. One or the other of these properties may be set, but not both at the same time.</exception>
        <exception cref="T:System.InvalidOperationException">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP or later is required for this method.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">The <see cref="T:System.Net.Sockets.Socket" /> is not yet connected or was not obtained via an <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />,or <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, method.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value><see cref="T:System.Int32" />, содержащий размер буфера отправки (в байтах). Значение по умолчанию — 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Больший размер буфера может замедлить распознавание проблем с подключением. Если вы передаете большие файлы или используете высокоскоростное подключение с высокой задержкой (например, поставщик широкополосного подключения), попробуйте увеличить размер буфера.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.SendBufferSize%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sends a file and optional data synchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> that contains the path and name of the file to be sent. This parameter can be <see langword="null" />.</param>
        <summary>Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object with the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> transmit flag.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка отправляет файл `fileName` подключенному сокету. Параметр `flags` по умолчанию имеет значение <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), а параметры `preBuffer` и `postBuffer` по умолчанию — `null`. Если `fileName` находится в локальном каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла. Подстановочные знаки ("..\\\мифиле.ткст ") и имена общих UNC-папок ("\\\\\\Directory\\\мифиле.ткст ") поддерживаются. Если файл не найден, вызывается исключение <xref:System.IO.FileNotFoundException>.  
  
 Этот метод использует функцию `TransmitFile`, которая находится в API Windows Sockets 2. Дополнительные сведения о функции `TransmitFile` и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> синхронно отправляет файл на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. <xref:System.Net.Sockets.Socket.SendFile%2A> можно использовать как для подключений, так и для протоколов без подключения.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода, в противном случае <xref:System.Net.Sockets.Socket.SendFile%2A> выдаст исключение <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.SendFile%2A> блокируется до отправки файла. В неблокирующем режиме <xref:System.Net.Sockets.Socket.SendFile%2A> могут успешно завершиться до отправки всего файла. Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.SendFile%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается и подключается сокет, а затем файл отправляется на удаленный узел. Файл Test. txt находится в корневом каталоге локального компьютера.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The socket is not connected to a remote host.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file <paramref name="fileName" /> was not found.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> that contains the path and name of the file to be sent. This parameter can be <see langword="null" />.</param>
        <param name="preBuffer">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent. This parameter can be <see langword="null" />.</param>
        <param name="postBuffer">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent. This parameter can be <see langword="null" />.</param>
        <param name="flags">One or more of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</param>
        <summary>Sends the file <paramref name="fileName" /> and buffers of data to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the specified <see cref="T:System.Net.Sockets.TransmitFileOptions" /> value.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для этой перегрузки требуется имя файла, который требуется отправить, и побитовое сочетание значений <xref:System.Net.Sockets.TransmitFileOptions>. Параметр `preBuffer` содержит все данные, которые необходимо указать перед файлом. `postBuffer` содержит данные, которые необходимо отслеживать в файле. Если `fileName` находится в текущем рабочем каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла. Подстановочные знаки ("..\\\мифиле.ткст ") и имена общих UNC-папок ("\\\\\\Directory\\\мифиле.ткст ") поддерживаются.  
  
 Параметр `flags` предоставляет поставщику службы оконных сокетов дополнительные сведения о переносе файлов. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Этот метод использует функцию `TransmitFile`, которая находится в API Windows Sockets 2. Дополнительные сведения о функции `TransmitFile` и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> синхронно отправляет файл на удаленный узел, указанный в методе <xref:System.Net.Sockets.Socket.Connect%2A> или <xref:System.Net.Sockets.Socket.Accept%2A>. <xref:System.Net.Sockets.Socket.SendFile%2A> можно использовать как для подключений, так и для протоколов без подключения.  
  
 Если используется протокол без установления соединения, необходимо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> перед вызовом этого метода; в противном случае <xref:System.Net.Sockets.Socket.SendFile%2A> создает исключение <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на подключение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A>, чтобы установить подключение к удаленному узлу, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.SendFile%2A> блокируется до тех пор, пока не будет отправлен весь файл. В неблокирующем режиме <xref:System.Net.Sockets.Socket.SendFile%2A> могут успешно завершиться до отправки всего файла. Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.SendFile%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается и подключается сокет. Файл Test. txt находится в корневом каталоге локального компьютера. В этом примере мы создадим предбуферную и буферизованную передачу данных и отправим их на удаленный узел с помощью файла. Используются <xref:System.Net.Sockets.TransmitFileOptions> по умолчанию.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The operating system is not Windows NT or later.  
  
-or-
  
 The socket is not connected to a remote host.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file <paramref name="fileName" /> was not found.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
        <summary>Sends a collection of files or in memory data buffers asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</summary>
        <returns><see langword="true" /> if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.  
  
 <see langword="false" /> if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> используется для отправки коллекции файлов или буферов данных в памяти на удаленный узел. <xref:System.Net.Sockets.Socket> уже должен быть подключен к удаленному узлу.  
  
 Если <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> ссылается на файл в рабочем каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла. Поддерживаются подстановочные знаки и имена общих папок в формате UNC. Если файл не найден, выдается <xref:System.IO.FileNotFoundException>.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик события EventHandler\<SocketAsyncEventArgs > делегат и присоединить обратный вызов к событию <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>.  
  
 Свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> в параметре `e` предоставляет поставщику службы оконных сокетов дополнительные сведения о переносе файлов. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> необходимы для успешного вызова этого метода:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 Этот метод использует функцию Трансмитпаккетс, находящийся в API Windows Sockets 2. Дополнительные сведения о функции Трансмитпаккетс и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .  
  
 Хотя для протоколов, ориентированных на соединение, метод <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> работает и для протоколов без подключения, при условии, что сначала вызывается метод <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, чтобы установить удаленный узел по умолчанию. При использовании протоколов без подключения необходимо также убедиться в том, что размер файла не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не отправляется, а <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> вызывает исключение <xref:System.Net.Sockets.SocketException>.  
  
 Метод <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> оптимизирован в соответствии с операционной системой, в которой он используется. В выпусках Windows Server метод <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> оптимизирован для обеспечения высокой производительности.  
  
 В выпусках клиента Windows метод <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> оптимизирован для минимального использования памяти и ресурсов.  
  
 Использование флага <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> в свойстве <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> в параметре `e` может обеспечить значительные преимущества производительности. Если поток, инициирующий вызов метода <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>, используется для интенсивных вычислений, можно, хотя маловероятно, избежать запуска APC. Обратите внимание, что существует разница между ядром и пользовательским режимом APC. Ядро APC запуск, когда поток находится в состоянии ожидания. Пользовательский режим APC запуск, когда поток находится в состоянии ожидания с оповещением  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">The file specified in the <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> property was not found.</exception>
        <exception cref="T:System.InvalidOperationException">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP or later is required for this method. This exception also occurs if the <see cref="T:System.Net.Sockets.Socket" /> is not connected to a remote host.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">A connectionless <see cref="T:System.Net.Sockets.Socket" /> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> call will time out.</summary>
        <value>Значение времени ожидания в миллисекундах. Если задать для свойства значение от 1 до 499, значение будет изменено на 500. Значение по умолчанию — 0, что указывает на бесконечное время ожидания. При указании параметра-1 также указывается бесконечный период ожидания.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот параметр применяется только к синхронным вызовам <xref:System.Net.Sockets.Socket.Send%2A>. При превышении времени ожидания метод <xref:System.Net.Sockets.Socket.Send%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.SendTimeout%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value specified for a set operation is less than -1.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sends data to a specific endpoint.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</param>
        <param name="remoteEP">The <see cref="T:System.Net.EndPoint" /> that represents the destination for the data.</param>
        <summary>Sends data to the specified endpoint.</summary>
        <returns>The number of bytes sent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этой перегрузке смещение буфера по умолчанию равно 0, число отправляемых байтов по умолчанию равно размеру параметра `buffer`, а <xref:System.Net.Sockets.SocketFlags> значение по умолчанию равно 0.  
  
 Если используется протокол без подключения, то перед вызовом <xref:System.Net.Sockets.Socket.SendTo%2A>не нужно устанавливать удаленный узел по умолчанию с помощью метода <xref:System.Net.Sockets.Socket.Connect%2A>. Это необходимо сделать только в том случае, если предполагается вызывать метод <xref:System.Net.Sockets.Socket.Send%2A>. При вызове метода <xref:System.Net.Sockets.Socket.Connect%2A> до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>параметр `remoteEP` переопределит указанный удаленный узел по умолчанию только для этой операции отправки. Также не требуется вызывать метод <xref:System.Net.Sockets.Socket.Bind%2A>, так как базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта. Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> после успешного завершения метода <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
 Несмотря на то, что предназначен для протоколов без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> также работает с протоколами, ориентированными на подключения. Если используется протокол, ориентированный на соединение, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или приняв входящий запрос на соединение с помощью метода <xref:System.Net.Sockets.Socket.Accept%2A>. Если не установить или принять подключение к удаленному узлу, <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.SendTo%2A>. В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> пропустит параметр `remoteEP` и отправит данные только подключенному или удаленному узлу по умолчанию.  
  
 Блокирующие сокеты блокируются до тех пор, пока не будут отправлены все байты в буфере. Поскольку незаблокированный <xref:System.Net.Sockets.Socket> завершается немедленно, он может не отправить все байты в `buffer`. Вы обязаны следить за количеством отправленных байтов и повторять операцию до тех пор, пока приложение не отправит все байты в `buffer`. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.SendTo%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
 Если в блокирующем режиме используется протокол без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> будет блокироваться до отправки датаграммы. Если вы хотите отправить данные на широковещательный адрес, сначала необходимо вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Кроме того, необходимо убедиться, что число отправленных байтов не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода датаграмма без подключения отправляется на указанный удаленный узел.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.  
  
-or- 
 <paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="remoteEP">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</param>
        <summary>Sends data to a specific endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes sent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этой перегрузке смещение буфера по умолчанию равно 0, а число байтов для отправки по умолчанию равно размеру `buffer`. Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без подключения, то перед вызовом <xref:System.Net.Sockets.Socket.SendTo%2A>не нужно устанавливать удаленный узел по умолчанию с помощью метода <xref:System.Net.Sockets.Socket.Connect%2A>. Это необходимо сделать только в том случае, если предполагается вызывать метод <xref:System.Net.Sockets.Socket.Send%2A>. При вызове метода <xref:System.Net.Sockets.Socket.Connect%2A> до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>параметр `remoteEP` переопределит указанный удаленный узел по умолчанию только для этой операции отправки. Также не требуется вызывать метод <xref:System.Net.Sockets.Socket.Bind%2A>, так как базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта. Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> после успешного завершения метода <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
 Несмотря на то, что предназначен для протоколов без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> также работает с протоколами, ориентированными на подключения. Если используется протокол, ориентированный на соединение, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или приняв входящий запрос на соединение с помощью метода <xref:System.Net.Sockets.Socket.Accept%2A>. Если не установить или принять подключение к удаленному узлу, <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.SendTo%2A>. В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> пропустит параметр `remoteEP` и отправит данные только подключенному или удаленному узлу по умолчанию.  
  
 Блокирующие сокеты блокируются до тех пор, пока не будут отправлены все байты в `buffer`. Поскольку незаблокированный <xref:System.Net.Sockets.Socket> завершается немедленно, он может не отправить все байты в `buffer`. Вы обязаны следить за количеством отправленных байтов и повторять операцию до тех пор, пока приложение не отправит все байты в `buffer`. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.SendTo%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
 Если в блокирующем режиме используется протокол без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> будет блокироваться до отправки датаграммы. Если вы хотите отправить данные на широковещательный адрес, сначала необходимо вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Кроме того, необходимо убедиться, что число отправленных байтов не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода датаграмма без подключения отправляется на указанный удаленный узел. <xref:System.Net.Sockets.SocketFlags> передаются методу <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.  
  
-or- 
 <paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</param>
        <param name="size">The number of bytes to send.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="remoteEP">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</param>
        <summary>Sends the specified number of bytes of data to the specified endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes sent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этой перегрузке смещение буфера по умолчанию равно 0. Если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без подключения, то перед вызовом <xref:System.Net.Sockets.Socket.SendTo%2A>не нужно устанавливать удаленный узел по умолчанию с помощью метода <xref:System.Net.Sockets.Socket.Connect%2A>. Это необходимо сделать только в том случае, если предполагается вызывать метод <xref:System.Net.Sockets.Socket.Send%2A>. При вызове метода <xref:System.Net.Sockets.Socket.Connect%2A> до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>параметр `remoteEP` переопределит указанный удаленный узел по умолчанию только для этой операции отправки. Также не требуется вызывать метод <xref:System.Net.Sockets.Socket.Bind%2A>, так как базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта. Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> после успешного завершения метода <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
 Несмотря на то, что предназначен для протоколов без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> также работает с протоколами, ориентированными на подключения. Если используется протокол, ориентированный на соединение, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или приняв входящий запрос на соединение с помощью метода <xref:System.Net.Sockets.Socket.Accept%2A>. Если не установить или принять подключение к удаленному узлу, <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.SendTo%2A>. В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> пропустит параметр `remoteEP` и отправит данные только подключенному или удаленному узлу по умолчанию.  
  
 Блокирующие сокеты блокируются до тех пор, пока не будет отправлено запрошенное число байтов. Поскольку незаблокированный <xref:System.Net.Sockets.Socket> завершается немедленно, он может не отправить все запрошенные байты в одной операции. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.SendTo%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
 Если в блокирующем режиме используется протокол без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> будет блокироваться до отправки датаграммы. Если вы хотите отправить данные на широковещательный адрес, сначала необходимо вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Кроме того, необходимо убедиться, что число отправленных байтов не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода датаграмма без подключения отправляется на указанный удаленный узел. Размер и <xref:System.Net.Sockets.SocketFlags> передаются методу <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.  
  
-or- 
 <paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The specified <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</param>
        <param name="offset">The position in the data buffer at which to begin sending data.</param>
        <param name="size">The number of bytes to send.</param>
        <param name="socketFlags">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</param>
        <param name="remoteEP">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</param>
        <summary>Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>The number of bytes sent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этой перегрузке, если в качестве параметра `socketflags` указан флаг <xref:System.Net.Sockets.SocketFlags.DontRoute>, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без подключения, то перед вызовом <xref:System.Net.Sockets.Socket.SendTo%2A>не нужно устанавливать удаленный узел по умолчанию с помощью метода <xref:System.Net.Sockets.Socket.Connect%2A>. Это необходимо сделать только в том случае, если предполагается вызывать метод <xref:System.Net.Sockets.Socket.Send%2A>. При вызове метода <xref:System.Net.Sockets.Socket.Connect%2A> до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>параметр `remoteEP` переопределит указанный удаленный узел по умолчанию только для этой операции отправки. Также не требуется вызывать метод <xref:System.Net.Sockets.Socket.Bind%2A>, так как базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта. Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> после успешного завершения метода <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
 Несмотря на то, что предназначен для протоколов без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> также работает с протоколами, ориентированными на подключения. Если используется протокол, ориентированный на соединение, необходимо сначала установить соединение с удаленным узлом, вызвав метод <xref:System.Net.Sockets.Socket.Connect%2A> или приняв входящий запрос на соединение с помощью метода <xref:System.Net.Sockets.Socket.Accept%2A>. Если не установить или принять подключение к удаленному узлу, <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед вызовом метода <xref:System.Net.Sockets.Socket.SendTo%2A>. В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> пропустит параметр `remoteEP` и отправит данные только подключенному или удаленному узлу по умолчанию.  
  
 Блокирующие сокеты блокируются до тех пор, пока не будет отправлено запрошенное число байтов. Поскольку Неблокирующая <xref:System.Net.Sockets.Socket> завершается немедленно, она может не отправить все запрошенные байты в одной операции. Мы обязаны следить за количеством отправленных байтов и повторить операцию до тех пор, пока приложение не отправит запрошенное число байтов. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение метода <xref:System.Net.Sockets.Socket.SendTo%2A> означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
 Если в блокирующем режиме используется протокол без подключения, <xref:System.Net.Sockets.Socket.SendTo%2A> будет блокироваться до отправки датаграммы. Если вы хотите отправить данные на широковещательный адрес, сначала необходимо вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета в значение <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Кроме того, необходимо убедиться, что размер не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.SendTo%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода датаграмма без подключения отправляется на указанный удаленный узел. Смещение, размер и <xref:System.Net.Sockets.SocketFlags> передаются методу <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is <see langword="null" />.  
  
-or- 
 <paramref name="remoteEP" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is less than 0.  
  
-or- 
 <paramref name="offset" /> is greater than the length of <paramref name="buffer" />.  
  
-or- 
 <paramref name="size" /> is less than 0.  
  
-or- 
 <paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> is not a valid combination of values.  
  
-or- 
An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
        <summary>Sends data asynchronously to a specific remote host.</summary>
        <returns><see langword="true" /> if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.  
  
 <see langword="false" /> if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.SendToAsync%2A> запускает асинхронную операцию отправки на удаленный узел, указанный в свойстве <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> параметра `e`. Вызов метода <xref:System.Net.Sockets.Socket.SendToAsync%2A> дает возможность отправки данных в отдельном потоке выполнения. Хотя этот метод предназначен для протоколов без подключения, <xref:System.Net.Sockets.Socket.SendToAsync%2A> работает с протоколами, ориентированными на подключения и без подключения.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, который реализует обработчик события EventHandler\<SocketAsyncEventArgs > делегат и присоединить обратный вызов к событию <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>.  
  
 Следующие свойства и события для объекта <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> необходимы для успешного вызова этого метода:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающий объект может задать для свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> значение любого объекта пользовательского состояния, требуемого перед вызовом метода <xref:System.Net.Sockets.Socket.SendToAsync%2A>, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 При использовании протокола, ориентированного на соединение, необходимо сначала вызвать метод <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.ConnectAsync%2A>. В противном случае <xref:System.Net.Sockets.Socket.SendToAsync%2A> выдаст <xref:System.Net.Sockets.SocketException>. При использовании протокола, ориентированного на соединение, метод <xref:System.Net.Sockets.Socket.SendToAsync%2A> игнорирует свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> и отправляет данные в <xref:System.Net.EndPoint?displayProperty=nameWithType>, установленные в <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или методе <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  
  
 Если используется протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод перед вызовом <xref:System.Net.Sockets.Socket.SendToAsync%2A>. Это необходимо сделать только в том случае, если предполагается вызывать методы <xref:System.Net.Sockets.Socket.BeginSend%2A> или <xref:System.Net.Sockets.Socket.SendAsync%2A>. При вызове метода <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> до вызова <xref:System.Net.Sockets.Socket.SendToAsync%2A>свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> переопределит указанный удаленный узел по умолчанию только для этой операции отправки. Также не требуется вызывать метод <xref:System.Net.Sockets.Socket.Bind%2A>. В этом случае базовый поставщик услуг будет назначать наиболее подходящий IP-адрес локальной сети и номер порта. Если необходимо, чтобы базовый поставщик услуг выберет свободный порт, используйте нуль-порт. Если необходимо указать назначенный локальный сетевой IP-адрес и номер порта, можно использовать свойство <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> после сигнализации события <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> и вызова связанных делегатов.  
  
 Если вы хотите отправить данные на широковещательный адрес, сначала необходимо вызвать метод <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр сокета для <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> в значение true. Кроме того, необходимо убедиться, что размер буфера не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена, а <xref:System.Net.Sockets.Socket.SendToAsync%2A> выдаст <xref:System.Net.Sockets.SocketException>.  
  
 Если указать флаг Донтрауте в свойстве <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>, отправляемые данные не будут маршрутизироваться.  
  
 Для сокетов, ориентированных на сообщения, необходимо не превышать максимальный размер сообщения базового транспорта. Если размер буфера превышает максимальный размер пакета основного поставщика услуг, датаграмма не отправляется, а <xref:System.Net.Sockets.Socket.SendToAsync%2A> выдает <xref:System.Net.Sockets.SocketException>. Успешное завершение метода <xref:System.Net.Sockets.Socket.SendToAsync%2A> не означает, что данные были успешно доставлены.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</exception>
        <exception cref="T:System.InvalidOperationException">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</exception>
        <exception cref="T:System.NotSupportedException">Windows XP or later is required for this method.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">The protocol specified is connection-oriented, but the <see cref="T:System.Net.Sockets.Socket" /> is not yet connected.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="level">The IP protection level to set on this socket.</param>
        <summary>Set the IP protection level on a socket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> позволяет ограничить сокеты IPv6 или IP для прослушивания указанной области, например адресов с одинаковой локальной ссылкой или локальным префиксом сайта. Этот параметр сокета позволяет приложениям размещать ограничения доступа к сокетам IPv6 или IP. Такие ограничения позволяют приложению, работающему в частной локальной сети, просто и надежно защититься от внешних атак. Этот параметр сокета также можно использовать для удаления ограничений доступа, если для параметра `level` задано значение <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Этот параметр сокета расширяет или сужает диапазон прослушивающего сокета, обеспечивая при необходимости неограниченный доступ со стороны открытых и закрытых пользователей или ограничивая доступ только тем же сайтом.  
  
 Определенные уровни защиты этого параметра сокета указаны в перечислении <xref:System.Net.Sockets.IPProtectionLevel>.  
  
 Метод <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> используется для включения или отключения обхода сетевых адресов (NAT) для экземпляра <xref:System.Net.Sockets.Socket>. Обход NAT может быть предоставлен с помощью Teredo, 6to4 или туннеля ISATAP.  
  
 Если параметр `level` имеет значение <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>или <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, это явно отключает обход NAT для экземпляра <xref:System.Net.Sockets.Socket>.  
  
 Если параметр `level` имеет значение <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, это может разрешить обход NAT для <xref:System.Net.Sockets.Socket> в зависимости от правил брандмауэра на компьютере.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The <paramref name="level" /> parameter cannot be <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />. The IP protection level cannot be set to unspecified.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Net.Sockets.AddressFamily" /> of the socket must be either <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets a <see cref="T:System.Net.Sockets.Socket" /> option.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</param>
        <param name="optionName">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</param>
        <param name="optionValue">The value of the option, represented as a <see cref="T:System.Boolean" />.</param>
        <summary>Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified <see cref="T:System.Boolean" /> value.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры <xref:System.Net.Sockets.Socket> определяют поведение текущего <xref:System.Net.Sockets.Socket>. Задайте для параметра `optionValue` значение `true`, чтобы включить параметр, или `false`, чтобы отключить параметр.  
  
 Параметры <xref:System.Net.Sockets.Socket> группируются по уровню поддержки протокола.  
  
 Ниже приведены различные параметры <xref:System.Net.Sockets.Socket>, которые можно задать с помощью этой перегрузки. Эти параметры группируются по соответствующему <xref:System.Net.Sockets.SocketOptionLevel>у значению. Если вы собираетесь задать любой из этих параметров, обязательно используйте соответствующее значение <xref:System.Net.Sockets.SocketOptionLevel> для параметра `optionLevel`. Параметр, выбранный для установки, должен быть указан в параметре `optionName`. Если вы хотите получить текущее значение любого из перечисленных параметров, используйте метод <xref:System.Net.Sockets.Socket.GetSocketOption%2A>.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 Дополнительные сведения об этих параметрах см. в описании перечисления <xref:System.Net.Sockets.SocketOptionName>.  
  
> [!NOTE]
>  При получении исключения <xref:System.Net.Sockets.SocketException> используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
   
  
## Examples  
 В следующем примере кода открывается сокет и включаются параметры `DontLinger` и `OutOfBandInline` сокета.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</param>
        <param name="optionName">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</param>
        <param name="optionValue">An array of type <see cref="T:System.Byte" /> that represents the value of the option.</param>
        <summary>Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as a byte array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры <xref:System.Net.Sockets.Socket> определяют поведение текущего <xref:System.Net.Sockets.Socket>. Используйте эту перегрузку, чтобы задать параметры <xref:System.Net.Sockets.Socket>, для которых требуется массив байтов в качестве значения параметра.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода задаются значения времени ожидания <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A>.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</param>
        <param name="optionName">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</param>
        <param name="optionValue">A value of the option.</param>
        <summary>Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified integer value.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры <xref:System.Net.Sockets.Socket> определяют поведение текущего <xref:System.Net.Sockets.Socket>. Для параметра с типом данных <xref:System.Boolean> укажите ненулевое значение, чтобы включить параметр, и нулевое значение для отключения параметра. Для параметра с целочисленным типом данных укажите соответствующее значение. Параметры <xref:System.Net.Sockets.Socket> группируются по уровню поддержки протокола.  
  
 Ниже приведены различные параметры <xref:System.Net.Sockets.Socket>, которые можно задать с помощью этой перегрузки. Эти параметры группируются по соответствующему <xref:System.Net.Sockets.SocketOptionLevel>. Если вы собираетесь задать любой из этих параметров, обязательно используйте соответствующие <xref:System.Net.Sockets.SocketOptionLevel> для параметра `optionLevel`. Параметр, выбранный для установки, должен быть указан в параметре `optionName`. Если вы хотите получить текущее значение любого из перечисленных параметров, используйте метод <xref:System.Net.Sockets.Socket.GetSocketOption%2A>.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 Дополнительные сведения об этих параметрах см. в описании перечисления <xref:System.Net.Sockets.SocketOptionName>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода задаются значения времени ожидания <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A>.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</param>
        <param name="optionName">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</param>
        <param name="optionValue">A <see cref="T:System.Net.Sockets.LingerOption" /> or <see cref="T:System.Net.Sockets.MulticastOption" /> that contains the value of the option.</param>
        <summary>Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as an object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры <xref:System.Net.Sockets.Socket> определяют поведение текущего <xref:System.Net.Sockets.Socket>. Используйте эту перегрузку, чтобы задать параметры <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>и <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>. Для параметра <xref:System.Net.Sockets.SocketOptionName.Linger> используйте <xref:System.Net.Sockets.Socket> для параметра `optionLevel`. Для <xref:System.Net.Sockets.SocketOptionName.AddMembership> и <xref:System.Net.Sockets.SocketOptionName.DropMembership>используйте <xref:System.Net.Sockets.SocketOptionLevel.IP>. Если вы хотите получить текущее значение любого из перечисленных выше параметров, используйте метод <xref:System.Net.Sockets.Socket.GetSocketOption%2A>.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
   
  
## Examples  
 В следующем примере кода задаются значения времени ожидания <xref:System.Net.Sockets.LingerOption> и <xref:System.Net.Sockets.Socket.Send%2A>.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">One of the <see cref="T:System.Net.Sockets.SocketShutdown" /> values that specifies the operation that will no longer be allowed.</param>
        <summary>Disables sends and receives on a <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании <xref:System.Net.Sockets.Socket>, ориентированного на соединение, перед закрытием <xref:System.Net.Sockets.Socket>всегда вызывайте метод <xref:System.Net.Sockets.Socket.Shutdown%2A>. Это гарантирует, что все данные отправляются и получаются на подключенном сокете до его закрытия.  
  
 Вызовите метод <xref:System.Net.Sockets.Socket.Close%2A>, чтобы освободить все управляемые и неуправляемые ресурсы, связанные с <xref:System.Net.Sockets.Socket>. Не пытайтесь повторно использовать <xref:System.Net.Sockets.Socket> после закрытия.  
  
 В следующей таблице приведены значения перечисления <xref:System.Net.Sockets.SocketShutdown>, допустимые для параметра `how`.  
  
|Значение|Описание|  
|-----------|-----------------|  
|Отправить|Отключить отправку на этом <xref:System.Net.Sockets.Socket>.|  
|Получить|Отключить получение на этом <xref:System.Net.Sockets.Socket>.|  
|Оба|Отключите отправку и получение на этом <xref:System.Net.Sockets.Socket>.|  
  
 Установка `how` в значение <xref:System.Net.Sockets.SocketShutdown.Send> указывает, что последующие вызовы <xref:System.Net.Sockets.Socket.Send%2A> запрещены. Если используется <xref:System.Net.Sockets.Socket>без подключения, то указание <xref:System.Net.Sockets.SocketShutdown.Send> не будет действовать.  
  
 Установка `how` в значение <xref:System.Net.Sockets.SocketShutdown.Receive> указывает, что последующие вызовы <xref:System.Net.Sockets.Socket.Receive%2A> запрещены. Это не влияет на более низкие уровни протокола. Если используется протокол, ориентированный на соединение, соединение завершается, если после вызова <xref:System.Net.Sockets.Socket.Shutdown%2A> выполняется одно из следующих условий.  
  
-   Данные находятся в входящем сетевом буфере, ожидающем получения.  
  
-   Получены дополнительные данные.  
  
 Если используется протокол без установления соединения, датаграммы принимаются и ставятся в очередь. Однако если для дополнительных входящих датаграмм нет буферного пространства, они будут удалены, а отправителю не будет возвращено сообщение об ошибке. Использовать <xref:System.Net.Sockets.Socket.Shutdown%2A> для <xref:System.Net.Sockets.Socket> без подключения не рекомендуется.  
  
 При установке `how` <xref:System.Net.Sockets.SocketShutdown.Both> отключает обе операции отправки и получения, как описано выше.  
  
> [!NOTE]
>  При получении <xref:System.Net.Sockets.SocketException> при вызове метода <xref:System.Net.Sockets.Socket.Shutdown%2A> используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода для отключения <xref:System.Net.Sockets.Socket>используется <xref:System.Net.Sockets.Socket.Shutdown%2A>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type of the <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Одно из значений <see cref="T:System.Net.Sockets.SocketType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> доступен только для чтения и задается при создании <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 В следующем примере кода выводятся <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>и <xref:System.Net.Sockets.ProtocolType> на консоль.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether IPv4 support is available and enabled on the current host.</summary>
        <value><see langword="true" />, если текущий узел поддерживает протокол IPv4; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операционная система может поддерживать протоколы IPv4 и IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> members.</summary>
        <value><see langword="true" />, если платформа поддерживает IPv6 для определенных устаревших методов <see cref="T:System.Net.Dns" />; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операционная система может поддерживать протоколы IPv4 и IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases all resources used by the <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Вызовите IDisposable. Dispose по завершении использования <xref:System.Net.Sockets.Socket>. Метод IDisposable. Dispose оставляет <xref:System.Net.Sockets.Socket> в непригодном для использования состоянии. После вызова IDisposable. Dispose необходимо освободить все ссылки на <xref:System.Net.Sockets.Socket>, чтобы сборщик мусора мог высвободить память, занимаемую <xref:System.Net.Sockets.Socket>. Дополнительные сведения см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE] 
> Всегда вызывайте IDisposable. Dispose перед освобождением последней ссылки на <xref:System.Net.Sockets.Socket>. В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Net.Sockets.Socket> метод `Finalize`.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Значение времени существования TTL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение TTL указывает максимальное число маршрутизаторов, которые может пройти пакет, прежде чем маршрутизатор отклоняет пакет и сообщение об ошибке TTL (ICMP), полученное по истечении срока жизни, возвращается отправителю.  
  
 Для значения TTL можно задать значение от 0 до 255. Если это свойство не задано, значение TTL по умолчанию для сокета равно 32.  
  
 Установка этого свойства для сокета TCP/IP пропускается стеком TCP/SSL, если установлено успешное соединение с помощью сокета.  
  
 Если вы получаете <xref:System.Net.Sockets.SocketException>, используйте свойство <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.Ttl%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The TTL value can't be set to a negative number.</exception>
        <exception cref="T:System.NotSupportedException">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. This error is also returned when an attempt was made to set TTL to a value higher than 255.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies whether the socket should only use Overlapped I/O mode.</summary>
        <value><see langword="true" />, если <see cref="T:System.Net.Sockets.Socket" /> использует только перекрывающиеся операции ввода-вывода; в противном случае <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присвойте этому свойству значение `true` для <xref:System.Net.Sockets.Socket>, который необходимо вызвать <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. В противном случае платформа может назначить порту завершения сокету, что запрещает использование <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The socket has been bound to a completion port.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
