<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0e76abada1c0fd76185042cd11feb08da2fac8ab" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70511565" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Реализует интерфейс сокетов Berkeley.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Класс предоставляет широкий набор методов и свойств для сетевого взаимодействия. Класс позволяет выполнять синхронную и асинхронную передачу данных с помощью любого из протоколов связи, <xref:System.Net.Sockets.ProtocolType> перечисленных в перечислении. <xref:System.Net.Sockets.Socket>  
  
 <xref:System.Net.Sockets.Socket> Класс соответствует шаблону именования .NET Framework для асинхронных методов. Например, синхронным <xref:System.Net.Sockets.Socket.Receive%2A> методом соответствует асинхронный <xref:System.Net.Sockets.Socket.BeginReceive%2A> метод и <xref:System.Net.Sockets.Socket.EndReceive%2A> .  
  
 Если приложению требуется только один поток во время выполнения, используйте следующие методы, предназначенные для работы в синхронном режиме.  
  
-   Если используется протокол, ориентированный на подключение, например TCP, сервер может прослушивать соединения с помощью <xref:System.Net.Sockets.Socket.Listen%2A> метода. Метод обрабатывает все входящие запросы на подключение и возвращает объект <xref:System.Net.Sockets.Socket> , который можно использовать для передачи данных с удаленного узла. <xref:System.Net.Sockets.Socket.Accept%2A> Используйте метод, <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Send%2A> возвращаемый для вызова <xref:System.Net.Sockets.Socket.Receive%2A> метода или. Вызовите <xref:System.Net.Sockets.Socket.Listen%2A> метод перед вызовом метода, если требуется указать локальный IP-адрес и номер порта. <xref:System.Net.Sockets.Socket.Bind%2A> Если вы хотите, чтобы базовый поставщик услуг назначит свободный порт, используйте нулевой номер порта. Если вы хотите подключиться к узлу прослушивания, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> метод. Чтобы передать данные, вызовите <xref:System.Net.Sockets.Socket.Send%2A> метод <xref:System.Net.Sockets.Socket.Receive%2A> или.  
  
-   Если используется протокол без установления соединения, например UDP, нет необходимости прослушивать подключения вообще. Вызовите <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод, чтобы принимать все входящие датаграммы. <xref:System.Net.Sockets.Socket.SendTo%2A> Используйте метод для отправки датаграмм на удаленный узел.  
  
 Для обработки обмена данными с помощью отдельных потоков во время выполнения используйте следующие методы, предназначенные для асинхронного режима работы.  
  
-   Если используется протокол <xref:System.Net.Sockets.Socket>, ориентированный на подключение, например TCP, используйте методы, <xref:System.Net.Sockets.Socket.BeginConnect%2A>и <xref:System.Net.Sockets.Socket.EndConnect%2A> для подключения к узлу прослушивания. Используйте методы and <xref:System.Net.Sockets.Socket.EndSend%2A> или <xref:System.Net.Sockets.Socket.BeginReceive%2A> и для асинхронной передачи данных. <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.EndReceive%2A> Входящие запросы на подключение могут обрабатываться <xref:System.Net.Sockets.Socket.BeginAccept%2A> с <xref:System.Net.Sockets.Socket.EndAccept%2A>помощью и.  
  
-   Если используется протокол без установления соединения, например UDP, можно <xref:System.Net.Sockets.Socket.BeginSendTo%2A> использовать и <xref:System.Net.Sockets.Socket.EndSendTo%2A> для <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> отправки датаграмм, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> а также для получения датаграмм.  
  
 При выполнении нескольких асинхронных операций на сокете они не обязательно завершаются в том порядке, в котором они были запущены.  
  
 После завершения отправки и получения данных используйте <xref:System.Net.Sockets.Socket.Shutdown%2A> метод, чтобы <xref:System.Net.Sockets.Socket>отключить. После вызова <xref:System.Net.Sockets.Socket.Shutdown%2A> <xref:System.Net.Sockets.Socket.Close%2A> вызовите метод, чтобы освободить все ресурсы, <xref:System.Net.Sockets.Socket>связанные с объектом.  
  
 Класс позволяет настроить с помощью  <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метода. <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket> Извлеките эти параметры с <xref:System.Net.Sockets.Socket.GetSocketOption%2A> помощью метода.  
  
> [!NOTE]
>  Если вы создаете относительно простое приложение и не требует максимальной производительности, рассмотрите возможность использования <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>и <xref:System.Net.Sockets.UdpClient>. Эти классы предоставляют простой и понятный пользователю интерфейс для <xref:System.Net.Sockets.Socket> обмена данными.  
  
   
  
## Examples  
 В следующем примере кода показано, <xref:System.Net.Sockets.Socket> как класс можно использовать для отправки данных на HTTP-сервер и получения ответа. Этот пример блокируется до получения всей страницы.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Чтобы установить исходящее подключение или принять входящий запрос.</permission>
    <threadsafe>Экземпляры этого класса являются потокобезопасными.</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">Сетевое программирование в .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">Рекомендации по использованию классов System.Net</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">Управление кэшем для сетевых приложений</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">протокол IP версии 6</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">Примеры сетевого программирования</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">Трассировка сети в .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">Безопасность в сетевом программировании</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">Улучшения производительности сокетов в версии 3.5</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="socketInformation">Информация сокета, возвращенная объектом <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.Socket" /> с помощью указанного значения, возвращенного из объекта <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы вызываете <xref:System.Net.Sockets.Socket.%23ctor%2A> конструктор несколько раз с тем же массивом байтов, что и аргумент для каждого вызова, вы создадите несколько <xref:System.Net.Sockets.Socket>управляемых объектов с одним и тем же базовым сокетом. Этот подход настоятельно не рекомендуется.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Одно из значений <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.Socket" />, используя указанный тип сокетов и протокол.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр задает тип <xref:System.Net.Sockets.Socket> класса, а `protocolType` параметр указывает протокол, <xref:System.Net.Sockets.Socket>используемый. `socketType` Два параметра не являются независимыми. <xref:System.Net.Sockets.Socket> Часто тип является неявным в протоколе. Если сочетание <xref:System.Net.Sockets.Socket> типа и типа протокола приводит к недопустимому <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.SocketException>, этот конструктор создает исключение.  
  
> [!NOTE]
>  Если этот конструктор создает исключение <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Сочетание параметров <paramref name="socketType" /> и <paramref name="protocolType" /> приводит к недопустимому сокету.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">Одно из значений перечисления <see cref="T:System.Net.Sockets.AddressFamily" />.</param>
        <param name="socketType">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Одно из значений перечисления <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Net.Sockets.Socket" />, используя заданные семейство адресов, тип сокета и протокол.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> `socketType` <xref:System.Net.Sockets.Socket> `protocolType` <xref:System.Net.Sockets.Socket>Параметр задает схему адресации, используемую классом, параметр задает тип класса, а параметр указывает протокол, используемый. `addressFamily` Три параметра не являются независимыми. Некоторые семейства адресов ограничивают, какие протоколы можно использовать с ними, и <xref:System.Net.Sockets.Socket> часто тип является неявным в протоколе. Если сочетание семейства адресов, <xref:System.Net.Sockets.Socket> типа и типа протокола приводит к недопустимому <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.SocketException>, этот конструктор создает исключение.  
  
> [!NOTE]
>  Если этот конструктор создает исключение <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как создать экземпляр <xref:System.Net.Sockets.Socket> класса.  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Сочетание параметров <paramref name="addressFamily" />, <paramref name="socketType" /> и <paramref name="protocolType" /> приводит к неработоспособному сокету.</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый объект <see cref="T:System.Net.Sockets.Socket" /> для заново созданного подключения.</summary>
        <returns>Объект <see cref="T:System.Net.Sockets.Socket" /> для заново созданного подключения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A>синхронно извлекает из очереди запросов на подключение прослушивающего сокета первый ожидающий запрос на подключение, а затем создает и возвращает новый <xref:System.Net.Sockets.Socket>объект. Этот параметр нельзя использовать <xref:System.Net.Sockets.Socket> для приема любых дополнительных соединений из очереди подключения. Однако можно вызвать <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> метод возвращаемого <xref:System.Net.Sockets.Socket> метода, чтобы найти сетевой адрес и номер порта удаленного узла.  
  
 В блокирующем режиме <xref:System.Net.Sockets.Socket.Accept%2A> блокируется до постановки входящего подключения в очередь. После того как подключение будет принято, исходное <xref:System.Net.Sockets.Socket> состояние продолжит постановку в очередь входящих запросов на подключение, пока вы не закроете его.  
  
 Если этот метод вызывается с помощью неблокирующего <xref:System.Net.Sockets.Socket>, а запросы на <xref:System.Net.Sockets.SocketException>подключение не помещаются в <xref:System.Net.Sockets.Socket.Accept%2A> очередь, вызывает исключение. Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.Accept%2A> метода необходимо сначала <xref:System.Net.Sockets.Socket.Listen%2A> вызвать метод для прослушивания и постановки в очередь входящих запросов на подключение.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода принимается простое <xref:System.Net.Sockets.Socket> соединение.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Принимающий сокет не производит прослушивание подключений. Необходимо вызвать <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> до вызова объекта <see cref="M:System.Net.Sockets.Socket.Accept" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает асинхронную операцию, чтобы принять попытку входящего подключения.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. Событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не произойдет и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Протоколы, ориентированные на подключение <xref:System.Net.Sockets.Socket.AcceptAsync%2A> , могут использовать метод для асинхронной обработки входящих попыток подключения. Асинхронное принятие подключений дает возможность отправлять и получать данные в отдельном потоке выполнения. Перед вызовом <xref:System.Net.Sockets.Socket.AcceptAsync%2A> метода необходимо <xref:System.Net.Sockets.Socket.Listen%2A> вызвать метод для прослушивания и постановки в очередь входящих запросов на подключение.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, реализующий\<обработчик EventHandler SocketAsyncEventArgs > делегата и привязать его <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> к событию.  
  
 Для <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> объекта требуются следующие свойства и события:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающий объект может дополнительно указать существующий <xref:System.Net.Sockets.Socket> объект для входящего подключения, указав объект <xref:System.Net.Sockets.Socket> для использования со <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> свойством.  
  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A> <xref:System.Net.Sockets.Socket.SocketType%2A> <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.AddressFamily%2A> <xref:System.Net.Sockets.Socket> Если свойство имеет значение null, новый объект создается с тем же,, и в качестве текущего и задается как <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> свойство. <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> для свойства любой объект пользовательского состояния, необходимый перед <xref:System.Net.Sockets.Socket.AcceptAsync%2A> вызовом метода, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 При необходимости можно указать буфер, в котором будет получен начальный блок данных на сокете после того, как метод будет <xref:System.Net.Sockets.Socket.ConnectAsync%2A> выполнен. В этом случае <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> свойство должно быть установлено в буфер, содержащий получаемые данные <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> , а свойство должно быть установлено равным максимальному числу байтов данных, получаемых в буфере. Эти свойства можно задать с помощью <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> метода. Часть переданного буфера будет использоваться внутренне для использования базовым вызовом Winsock Акцептекс. Это означает, что объем возвращаемых данных всегда будет меньше значения <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> свойства <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> в предоставленном экземпляре. Объем буфера, используемый внутри, зависит от семейства адресов сокета. Минимальный требуемый размер буфера составляет 288 байт. Если указан больший размер буфера, то ожидается, что <xref:System.Net.Sockets.Socket> некоторые дополнительные данные будут отличаться от данных адреса, полученных вызовом Winsock акцептекс, и будут ожидать получения этих дополнительных данных. В случае истечения времени ожидания соединение сбрасывается. Поэтому, если требуются дополнительные данные определенного объема, то размер буфера должен быть минимальным размером буфера и этим значением.  
  
 Метод обратного вызова завершения должен проверить <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> свойство, чтобы определить, <xref:System.Net.Sockets.Socket.AcceptAsync%2A> была ли операция успешной.  
  
 Это <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> событие может возникать в некоторых случаях, когда соединение не было принято, и <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> <xref:System.Net.Sockets.SocketError.ConnectionReset>свойство должно иметь значение. Это может произойти в результате сканирования портов с использованием половины открытой проверки типа SYN (с последовательностью SYN-> SYN-ACK-> RST). Приложения, использующие <xref:System.Net.Sockets.Socket.AcceptAsync%2A> метод, должны быть готовы к обработке этого условия.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Аргумент является недопустимым. Это исключение возникает, если обеспечиваемый буфер имеет недостаточный размер. Буфер должен иметь размер, равный, по крайней мере, 2 * (размер(SOCKADDR_STORAGE + 16) байт.  
  
Это исключение также возникает, если задано несколько буферов, свойство <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> не имеет значение "null".</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Аргумент вне диапазона. Исключение возникает, если объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> имеет значение меньше 0.</exception>
        <exception cref="T:System.InvalidOperationException">Предпринят запрос выполнения недопустимой операции. Это исключение возникает, если принимающий объект <see cref="T:System.Net.Sockets.Socket" /> не производит прослушивание подключений или принимающий сокет является связанным.  
  
Требуется вызвать объект <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и метод <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> перед вызовом метода <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />.  
  
Это исключение также происходит, если сокет уже подключен или работа с сокетом уже выполнялась с использованием указанного параметра <paramref name="e" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает семейство адресов объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Net.Sockets.AddressFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указывает схему адресации, которую может использовать экземпляр <xref:System.Net.Sockets.Socket> класса. <xref:System.Net.Sockets.AddressFamily> Это свойство доступно только для чтения и задается при <xref:System.Net.Sockets.Socket> создании.  
  
   
  
## Examples  
 В следующем примере кода в консоль <xref:System.Net.Sockets.AddressFamily>выводятся <xref:System.Net.Sockets.ProtocolType> , <xref:System.Net.Sockets.SocketType>и.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее количество полученных из сети и доступных для чтения данных.</summary>
        <value>Количество байтов данных, полученных из сети и доступных для чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы используете неблокирующий <xref:System.Net.Sockets.Socket>метод, <xref:System.Net.Sockets.Socket.Available%2A> это хороший способ определить, находятся ли данные в очереди для чтения перед вызовом метода <xref:System.Net.Sockets.Socket.Receive%2A>. Доступные данные — это общий объем данных, помещенных в очередь сетевого буфера для чтения. Если в сетевом буфере нет данных, <xref:System.Net.Sockets.Socket.Available%2A> функция возвращает 0.  
  
 Если удаленный узел завершает работу или закрывает соединение, <xref:System.Net.Sockets.Socket.Available%2A> может <xref:System.Net.Sockets.SocketException>вызвать исключение. Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода сравниваются результаты вызова Иоконтрол с ФИОНРЕАД и доступным свойством.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает асинхронную операцию, чтобы принять попытку входящего подключения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает асинхронную операцию, чтобы принять попытку входящего подключения.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное создание объекта <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Протоколы, ориентированные на подключение <xref:System.Net.Sockets.Socket.BeginAccept%2A> , могут использовать метод для асинхронной обработки входящих попыток подключения. Асинхронное принятие подключений дает возможность отправлять и получать данные в отдельном потоке выполнения. Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода необходимо <xref:System.Net.Sockets.Socket.Listen%2A> вызвать метод для прослушивания и постановки в очередь входящих запросов на подключение.  
  
 Необходимо создать метод обратного вызова, реализующий <xref:System.AsyncCallback> делегат, и передать его имя <xref:System.Net.Sockets.Socket.BeginAccept%2A> в метод. Для этого, как минимум, необходимо передать <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.BeginAccept%2A> объект прослушивания через `state` параметр. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод `state` через параметр.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndAccept%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginAccept%2A>, система обычно использует отдельный поток для выполнения указанного метода обратного вызова и <xref:System.Net.Sockets.Socket.EndAccept%2A> блокируется до тех пор, пока не будет получено ожидающее подключение. <xref:System.Net.Sockets.Socket.EndAccept%2A>Возвращает новый <xref:System.Net.Sockets.Socket> объект, который можно использовать для отправки и получения данных с удаленного узла. Этот параметр нельзя использовать <xref:System.Net.Sockets.Socket> для приема любых дополнительных соединений из очереди подключения. Если вы хотите, чтобы исходный поток блокировался после вызова <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода, используйте. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение.  
  
 Система также может использовать вызывающий поток для вызова метода обратного вызова. В этом случае <xref:System.IAsyncResult.CompletedSynchronously%2A> свойство в возвращаемом <xref:System.IAsyncResult> элементе будет <xref:System.Net.Sockets.Socket.BeginAccept%2A> установлено, чтобы указать, что метод завершился синхронно.  
  
 Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Чтобы отменить отложенный вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода, <xref:System.Net.Sockets.Socket>закройте. При вызове  <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода во время выполнения асинхронной операции вызывается обратный вызов, предоставленный для метода. <xref:System.Net.Sockets.Socket.Close%2A>  <xref:System.Net.Sockets.Socket.EndAccept%2A> При <xref:System.ObjectDisposedException>  последующем вызове метода будет выдано исключение, указывающее, что операция была отменена.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> Свойство возвращаемого <xref:System.Net.Sockets.Socket> значения можно использовать для задания сетевого адреса и номера порта удаленного узла.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
   
  
## Examples  
 В следующем примере кода выполняется попытка асинхронного получения входящего подключения.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <exception cref="T:System.InvalidOperationException">Принимающий сокет не производит прослушивание подключений. Необходимо вызвать <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> до вызова объекта <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
- или - 
Производится связывание принимающего сокета.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="receiveSize" /> меньше 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="receiveSize">Число байтов, которые необходимо принять от отправителя.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает асинхронную операцию, чтобы принять попытку входящего подключения и получить первый блок данных, посланных клиентским приложением.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное создание объекта <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Протоколы, ориентированные на подключение <xref:System.Net.Sockets.Socket.BeginAccept%2A> , могут использовать метод для асинхронной обработки входящих попыток подключения. Асинхронное принятие подключений позволяет отправлять и получать данные в отдельном потоке выполнения. Эта перегрузка позволяет указать число байтов, принимаемых при начальной перегрузке в `receiveSize` параметре.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода необходимо <xref:System.Net.Sockets.Socket.Listen%2A> вызвать метод для прослушивания и постановки в очередь входящих запросов на подключение.  
  
 Необходимо создать метод обратного вызова, реализующий <xref:System.AsyncCallback> делегат, и передать его имя <xref:System.Net.Sockets.Socket.BeginAccept%2A> в метод. Для этого, как минимум, необходимо передать <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.BeginAccept%2A> объект прослушивания через `state` параметр. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод `state` через параметр.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndAccept%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginAccept%2A>, система обычно использует отдельный поток для выполнения указанного метода обратного вызова и <xref:System.Net.Sockets.Socket.EndAccept%2A> блокируется до тех пор, пока не будет получено ожидающее подключение.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>Возвращает новый <xref:System.Net.Sockets.Socket> объект, который можно использовать для отправки и получения данных с удаленного узла. Этот параметр нельзя использовать <xref:System.Net.Sockets.Socket> для приема любых дополнительных соединений из очереди подключения. Если вы хотите, чтобы исходный поток блокировался после вызова <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода, используйте. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение.  
  
 Система также может использовать вызывающий поток для вызова метода обратного вызова. В этом случае <xref:System.IAsyncResult.CompletedSynchronously%2A> свойство в возвращаемом <xref:System.IAsyncResult> элементе будет <xref:System.Net.Sockets.Socket.BeginAccept%2A> установлено, чтобы указать, что метод завершился синхронно.  
  
 Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Чтобы отменить отложенный вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода, <xref:System.Net.Sockets.Socket>закройте.  При вызове  <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода во время выполнения асинхронной операции вызывается обратный вызов, предоставленный для метода. <xref:System.Net.Sockets.Socket.Close%2A>  <xref:System.Net.Sockets.Socket.EndAccept%2A> При <xref:System.ObjectDisposedException>  последующем вызове метода будет выдано исключение, указывающее, что операция была отменена.  
  
> [!NOTE]
>  Чтобы указать сетевой адрес и <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> номер порта удаленного узла <xref:System.Net.Sockets.Socket> , можно вызвать метод с помощью свойства возвращенного объекта.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
   
  
## Examples  
 В следующем примере кода открывается сокет и принимается асинхронное соединение. В этом примере сокет принимает начальные 10 байт данных. Число полученных байтов и данные отображаются в консоли делегатом обратного вызова. Описание <xref:System.Net.Sockets.Socket.BeginReceive%2A> того, как получены оставшиеся данные, см. в разделе.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <exception cref="T:System.InvalidOperationException">Принимающий сокет не производит прослушивание подключений. Необходимо вызвать <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> до вызова объекта <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
- или - 
Производится связывание принимающего сокета.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="receiveSize" /> меньше 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">Принятый объект <see cref="T:System.Net.Sockets.Socket" />. Это значение может быть равно <see langword="null" />.</param>
        <param name="receiveSize">Максимальное число принимаемых байтов.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает асинхронную операцию, чтобы принять попытку входящего подключения с указанного сокета и получить первый блок данных, посланных клиентским приложением.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное создание объекта <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Протоколы, ориентированные на подключение <xref:System.Net.Sockets.Socket.BeginAccept%2A> , могут использовать метод для асинхронной обработки входящих попыток подключения. Асинхронное принятие подключений дает возможность отправлять и получать данные в отдельном потоке выполнения. Эта перегрузка позволяет указать обслуживаемый сокет в `acceptSocket` параметре. Если этот параметр имеет `null`значение, то принятый сокет создается <xref:System.Net.Sockets.Socket.BeginAccept%2A> методом. В `receiveSize` параметре можно указать число байтов, которое будет принято в ходе начальной пересылки.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода необходимо <xref:System.Net.Sockets.Socket.Listen%2A> вызвать метод для прослушивания и постановки в очередь входящих запросов на подключение.  
  
 Необходимо создать метод обратного вызова, реализующий <xref:System.AsyncCallback> делегат, и передать его имя <xref:System.Net.Sockets.Socket.BeginAccept%2A> в метод. Для этого, как минимум, необходимо передать <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.BeginAccept%2A> объект прослушивания через `state` параметр. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод `state` через параметр.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndAccept%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginAccept%2A>, система обычно использует отдельный поток для выполнения указанного метода обратного вызова и <xref:System.Net.Sockets.Socket.EndAccept%2A> блокируется до тех пор, пока не будет получено ожидающее подключение.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>Возвращает новый <xref:System.Net.Sockets.Socket> объект, который можно использовать для отправки и получения данных с удаленного узла. Этот параметр нельзя использовать <xref:System.Net.Sockets.Socket> для приема любых дополнительных соединений из очереди подключения. Если вы хотите, чтобы исходный поток блокировался после вызова <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода, используйте. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение.  
  
 Система также может использовать вызывающий поток для вызова метода обратного вызова. В этом случае <xref:System.IAsyncResult.CompletedSynchronously%2A> свойство в возвращаемом <xref:System.IAsyncResult> элементе будет <xref:System.Net.Sockets.Socket.BeginAccept%2A> установлено, чтобы указать, что метод завершился синхронно.  
  
 Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Чтобы отменить отложенный вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода, <xref:System.Net.Sockets.Socket>закройте. При вызове  <xref:System.Net.Sockets.Socket.BeginAccept%2A> метода во время выполнения асинхронной операции вызывается обратный вызов, предоставленный для метода. <xref:System.Net.Sockets.Socket.Close%2A>  <xref:System.Net.Sockets.Socket.EndAccept%2A> При <xref:System.ObjectDisposedException>  последующем вызове метода будет выдано исключение, указывающее, что операция была отменена.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> Свойство возвращенного <xref:System.Net.Sockets.Socket> объекта можно использовать для задания сетевого адреса и номера порта удаленного узла.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
   
  
## Examples  
 В следующем примере кода открывается сокет и принимается асинхронное соединение. В этом примере сокет принимает начальные 10 байт данных, а `acceptSocket` параметр — `null`, что заставляет <xref:System.Net.Sockets.Socket.BeginAccept%2A> метод создать обслуживаемый сокет. Число полученных байтов и данные отображаются в консоли делегатом обратного вызова. Описание <xref:System.Net.Sockets.Socket.BeginReceive%2A> того, как получены оставшиеся данные, см. в разделе.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <exception cref="T:System.InvalidOperationException">Принимающий сокет не производит прослушивание подключений. Необходимо вызвать <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> и <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> до вызова объекта <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
- или - 
Производится связывание принимающего сокета.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="receiveSize" /> меньше 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный узел.</param>
        <param name="end_point">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный узел.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное подключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании протокола, ориентированного на соединение, <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод запускает асинхронный запрос соединения `remoteEP` с параметром. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.BeginConnect%2A> устанавливает удаленный узел по умолчанию. Подключение или установка удаленного узла по умолчанию асинхронно дает возможность отправлять и получать данные в отдельном потоке выполнения.  
  
 Можно создать метод обратного вызова, реализующий <xref:System.AsyncCallback> делегат, и передать его имя <xref:System.Net.Sockets.Socket.BeginConnect%2A> в метод. Как минимум, необходимо передать <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.BeginConnect%2A> в с помощью `state` параметра. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket>и другие необходимые сведения. Передайте экземпляр этого класса в <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод `state` через параметр.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndConnect%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginConnect%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и <xref:System.Net.Sockets.Socket.EndConnect%2A> заблокируется до тех пор, <xref:System.Net.Sockets.Socket> пока не будет успешно установлено соединение или не создаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова <xref:System.Net.Sockets.Socket.BeginConnect%2A> метода, используйте. <xref:System.Threading.WaitHandle.WaitOne%2A> Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Если используется протокол без установления соединения, например UDP, нет необходимости вызывать метод <xref:System.Net.Sockets.Socket.BeginConnect%2A> перед отправкой и получением данных. Для взаимодействия с <xref:System.Net.Sockets.Socket.BeginSendTo%2A> удаленным узлом можно использовать и. <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> При вызове <xref:System.Net.Sockets.Socket.BeginConnect%2A>все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут удалены. Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр Broadcast в. `true` <xref:System.Net.Sockets.Socket.BeginConnect%2A> В <xref:System.Net.Sockets.SocketException> противном случае выдаст исключение.  
  
 Если вы используете протокол, ориентированный на подключение, и не вызываете <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.BeginConnect%2A>, базовый поставщик услуг присвоит наиболее подходящий локальный сетевой адрес и номер порта. Если используется протокол без установления соединения, поставщик услуг не будет назначать локальный сетевой адрес и номер порта до вызова <xref:System.Net.Sockets.Socket.BeginSend%2A> метода или. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод еще раз с нужной конечной точкой.  
  
 Чтобы отменить отложенный вызов <xref:System.Net.Sockets.Socket.BeginConnect%2A> метода, <xref:System.Net.Sockets.Socket>закройте. При вызове  <xref:System.Net.Sockets.Socket.BeginConnect%2A> метода во время выполнения асинхронной операции вызывается обратный вызов, предоставленный для метода. <xref:System.Net.Sockets.Socket.Close%2A>  <xref:System.Net.Sockets.Socket.EndConnect%2A> При <xref:System.ObjectDisposedException>  последующем вызове метода будет выдано исключение, указывающее, что операция была отменена.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Если этот сокет ранее был отключен, <xref:System.Net.Sockets.Socket.BeginConnect%2A> он должен быть вызван в потоке, который не будет выходить до завершения операции. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
   
  
## Examples  
 В следующем примере кода инициируется асинхронная попытка соединения.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, либо асинхронная операция уже выполняется.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">Адрес <see cref="T:System.Net.IPAddress" /> удаленного узла.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <param name="requestCallback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции подключения. Этот объект передается делегату <paramref name="requestCallback" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу. узел задается объектом <see cref="T:System.Net.IPAddress" /> и номером порта.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное подключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginConnect%2A> операция должна быть завершена путем <xref:System.Net.Sockets.Socket.EndConnect%2A> вызова метода. Как правило, метод вызывается `requestCallback` делегатом.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из <xref:System.Net.Sockets.Socket.Connect%2A> перегрузок метода или. <xref:System.Net.Sockets.Socket.EndConnect%2A>  
  
 Чтобы отменить отложенный вызов <xref:System.Net.Sockets.Socket.BeginConnect%2A> метода, <xref:System.Net.Sockets.Socket>закройте. При вызове  <xref:System.Net.Sockets.Socket.BeginConnect%2A> метода во время выполнения асинхронной операции вызывается обратный вызов, предоставленный для метода. <xref:System.Net.Sockets.Socket.Close%2A>  <xref:System.Net.Sockets.Socket.EndConnect%2A> При <xref:System.ObjectDisposedException>  последующем вызове метода будет выдано исключение, указывающее, что операция была отменена.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Если этот сокет ранее был отключен, <xref:System.Net.Sockets.Socket.BeginConnect%2A> он должен быть вызван в потоке, который не будет выходить до завершения операции. Это ограничение базового поставщика. Кроме того <xref:System.Net.EndPoint> , используемое значение должно отличаться.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
   
  
## Examples  
 В следующем примере кода инициируется асинхронная попытка соединения.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="address" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Net.Sockets.Socket" /> не входит в состав семейства сокетов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="address" /> равна нулю.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, либо асинхронная операция уже выполняется.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">По крайней мере, один объект <see cref="T:System.Net.IPAddress" />, определяющий удаленный узел.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <param name="requestCallback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции подключения. Этот объект передается делегату <paramref name="requestCallback" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу. узел задается массивом <see cref="T:System.Net.IPAddress" /> и номером порта.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронные подключения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginConnect%2A> операция должна быть завершена путем <xref:System.Net.Sockets.Socket.EndConnect%2A> вызова метода. Как правило, метод вызывается `requestCallback` делегатом.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из <xref:System.Net.Sockets.Socket.Connect%2A> перегрузок метода.  
  
 Чтобы отменить отложенный вызов <xref:System.Net.Sockets.Socket.BeginConnect%2A> метода, <xref:System.Net.Sockets.Socket>закройте. При вызове  <xref:System.Net.Sockets.Socket.BeginConnect%2A> метода во время выполнения асинхронной операции вызывается обратный вызов, предоставленный для метода. <xref:System.Net.Sockets.Socket.Close%2A>  <xref:System.Net.Sockets.Socket.EndConnect%2A> При <xref:System.ObjectDisposedException>  последующем вызове метода будет выдано исключение, указывающее, что операция была отменена.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Если этот сокет ранее был отключен, <xref:System.Net.Sockets.Socket.BeginConnect%2A> он должен быть вызван в потоке, который не будет выходить до завершения операции. Это ограничение базового поставщика. Кроме того <xref:System.Net.EndPoint> , используемое значение должно отличаться.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
   
  
## Examples  
 В следующем примере кода инициируется асинхронная попытка соединения.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод применим для сокетов, которые используют объект <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="address" /> равна нулю.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, либо асинхронная операция уже выполняется.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">Имя удаленного узла.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <param name="requestCallback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, который следует вызвать по завершении операции подключения.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции подключения. Этот объект передается делегату <paramref name="requestCallback" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу. Узел задается именем узла и номером порта.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное подключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginConnect%2A> операция должна быть завершена путем <xref:System.Net.Sockets.Socket.EndConnect%2A> вызова метода. Как правило, метод вызывается `requestCallback` делегатом.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из <xref:System.Net.Sockets.Socket.Connect%2A> перегрузок метода.  
  
 Чтобы отменить отложенный вызов <xref:System.Net.Sockets.Socket.BeginConnect%2A> метода, <xref:System.Net.Sockets.Socket>закройте. При вызове  <xref:System.Net.Sockets.Socket.BeginConnect%2A> метода во время выполнения асинхронной операции вызывается обратный вызов, предоставленный для метода. <xref:System.Net.Sockets.Socket.Close%2A>  <xref:System.Net.Sockets.Socket.EndConnect%2A> При <xref:System.ObjectDisposedException>  последующем вызове метода будет выдано исключение, указывающее, что операция была отменена.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Если этот сокет ранее был отключен, <xref:System.Net.Sockets.Socket.BeginConnect%2A> он должен быть вызван в потоке, который не будет выходить до завершения операции. Это ограничение базового поставщика. Кроме того <xref:System.Net.EndPoint> , используемое значение должно отличаться.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
   
  
## Examples  
 В следующем примере кода инициируется асинхронная попытка соединения.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="host" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод допустим для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> .</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, либо асинхронная операция уже выполняется.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">Значение <see langword="true" />, если этот сокет может быть повторно использован после закрытия подключения; в противном случае — значение <see langword="false" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает выполнение асинхронного запроса для отключения от удаленной конечной точки.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если используется протокол, ориентированный на соединение, можно вызвать <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> метод для запроса отключения от удаленной конечной точки. Если `reuseSocket` имеет `true`значение, можно повторно использовать сокет.  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> Метод использует отдельный поток для вызова указанного метода обратного вызова. <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Метод блокируется до завершения ожидающего отключения. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException> исключение, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается сокет для асинхронного взаимодействия и данные отправляются на удаленный узел. При отправке <xref:System.Net.Sockets.Socket.Shutdown%2A> данных вызывается для завершения действия Send и Receive. Затем <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> вызывается для начала запроса на отключение. По завершении запроса <xref:System.Net.Sockets.Socket.Connected%2A> свойство запрашивается, чтобы проверить, отключен ли сокет.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Используется операционная система Windows 2000 или более ранняя версия, а для этого метода необходима операционная система Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции приема. Этот объект передается делегату <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем <xref:System.Net.Sockets.Socket.EndReceive%2A> вызова метода. Как правило, метод вызывается `callback` делегатом.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из <xref:System.Net.Sockets.Socket.Receive%2A> перегрузок метода.  
  
 Чтобы отменить ожидание <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> вызовите метод.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state`— Это экземпляр определяемого пользователем класса.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции приема. Этот объект передается делегату <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем <xref:System.Net.Sockets.Socket.EndReceive%2A> вызова метода. Как правило, метод вызывается `callback` делегатом.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из <xref:System.Net.Sockets.Socket.Receive%2A> перегрузок метода.  
  
 Чтобы отменить ожидание <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> вызовите метод.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state`— Это экземпляр определяемого пользователем класса.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="offset">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, начиная с которой хранятся принятые данные.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции приема. Этот объект передается делегату <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем <xref:System.Net.Sockets.Socket.EndReceive%2A> вызова метода. Как правило, метод вызывается `callback` делегатом.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из <xref:System.Net.Sockets.Socket.Receive%2A> перегрузок метода.  
  
 Чтобы отменить ожидание <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> вызовите метод.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state`— Это экземпляр определяемого пользователем класса.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
   
  
## Examples  
 В следующем примере кода начинается асинхронный прием данных из подключенного <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
- или - 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="offset">Место в объекте <paramref name="buffer" />, выделенное для хранения принимаемых данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="flags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <param name="error">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, ссылающийся на метод, вызываемый по завершении данной операции.</param>
        <param name="state">Пользовательский объект, содержащий информацию об операции приема. Этот объект передается делегату <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> по завершении операции.</param>
        <summary>Начинает выполнение асинхронного приема данных с подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная <xref:System.Net.Sockets.Socket.BeginReceive%2A> операция должна быть завершена путем <xref:System.Net.Sockets.Socket.EndReceive%2A> вызова метода. Как правило, метод вызывается `callback` делегатом.  
  
 Этот метод не блокируется до завершения операции. Чтобы заблокировать блокировку до завершения операции, используйте одну из <xref:System.Net.Sockets.Socket.Receive%2A> перегрузок метода.  
  
 Чтобы отменить ожидание <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> вызовите метод.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state`— Это экземпляр определяемого пользователем класса.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
- или - 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="offset">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, начиная с которой хранятся данные.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий источник данных.</param>
        <param name="remote_end">Объект <see cref="T:System.Net.EndPoint" />, представляющий источник данных.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает выполнение асинхронного приема данных с указанного сетевого устройства.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Метод запускает асинхронное чтение датаграмм без подключения с удаленного узла. <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Вызов метода дает возможность получения данных в отдельном потоке выполнения.  
  
 Можно создать метод обратного вызова, реализующий <xref:System.AsyncCallback> делегат, и передать его имя <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> в метод. Для этого, как минимум, `state` параметр должен содержать подключенное или используемое по умолчанию <xref:System.Net.Sockets.Socket> соединение. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод `state` через параметр.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова, и он будет <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> заблокирован до тех пор, <xref:System.Net.Sockets.Socket> пока не прочитает данные или не выдаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метода, используйте. <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>Перед вызовом <xref:System.Net.Sockets.SocketException>необходимо явным образом <xref:System.Net.Sockets.Socket> привязать к локальной конечной точке с помощью <xref:System.Net.Sockets.Socket.Bind%2A> метода или <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> вызовет исключение.  
  
 Этот метод считывает данные в `buffer` параметр и фиксирует конечную точку удаленного узла, из которой отправляются данные. Сведения о том, как получить эту конечную точку, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>см. в разделе. Этот метод наиболее удобен, если предполагается асинхронное получение датаграмм без подключения из неизвестного узла или с нескольких узлов. В этих случаях будет <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> считывать первые поставленные в очередь датаграммы, полученные в буфер локальной сети. Если полученная датаграмма превышает размер `buffer` <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> , метод будет заполняться `buffer` максимально возможной частью <xref:System.Net.Sockets.SocketException>сообщения и вызывать исключение. При использовании ненадежного протокола избыточные данные будут потеряны. Если используется надежный протокол, избыточные данные будут храниться в поставщике служб, и его можно будет извлечь, вызвав <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод с достаточно большим размером буфера.  
  
 Чтобы гарантировать, что конечная точка удаленного узла всегда возвращается, приложение должно явно привязать <xref:System.Net.Sockets.Socket> к локальной конечной точке <xref:System.Net.Sockets.Socket.Bind%2A> с помощью <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метода, а затем вызвать метод с параметром, `optionLevel` для  <xref:System.Net.Sockets.SocketOptionLevel.IP> которого задано значение.  <xref:System.Net.Sockets.SocketOptionName.PacketInformation>или `optionName` , если `optionValue`  необходимо, параметр имеет значение и параметр, чтобы включить этот параметр перед вызовом <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метода. <xref:System.Net.Sockets.SocketOptionLevel.IPv6> В противном случае конечная точка удаленного узла может быть не возвращена, когда отправитель отправил число датаграмм, прежде чем получатель вызвал <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод.  
  
 Хотя <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение. Если вы решили это сделать, необходимо сначала установить соединение <xref:System.Net.Sockets.Socket.Connect%2A> с удаленным узлом, вызвав  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> метод или <xref:System.Net.Sockets.Socket.Accept%2A> приняв входящий запрос на подключение, вызвав метод или <xref:System.Net.Sockets.Socket.BeginAccept%2A> . При вызове <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метода перед установкой или приемом соединения вы <xref:System.Net.Sockets.SocketException>получите. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> вызовом метода. В любом из этих случаев <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метод будет `remoteEP` игнорировать параметр и получить данные только с подключенного или удаленного узла по умолчанию.  
  
 При использовании сокетов, ориентированных <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> на соединение, будет считывать столько данных, сколько доступно до числа байтов `size` , заданных параметром.  
  
 Чтобы отменить ожидание <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, <xref:System.Net.Sockets.Socket.Close%2A> вызовите метод.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
   
  
## Examples  
 В следующем примере кода асинхронно принимаются датаграммы без установления соединения с удаленного узла.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
- или - 
 Значение параметра <paramref name="size" /> меньше 0.  
  
- или - 
 Значение<paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" /> .</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="offset">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, начиная с которой хранятся данные.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий источник данных.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Начинает асинхронный прием заданного числа байтов данных в указанное место буфера данных, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />, а также сохраняет конечную точку и информацию пакета.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронное чтение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронная операция получения должна быть завершена путем вызова <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> метода. Как правило, метод вызывается `asyncCallback` делегатом.  
  
 Этот метод не блокируется до завершения операции. Для блокировки до завершения операции используйте <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> метод.  
  
 Чтобы отменить ожидание <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, <xref:System.Net.Sockets.Socket.Close%2A> вызовите метод.  
  
 Подробные сведения об использовании асинхронной модели программирования см. в разделе [асинхронное вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Этот метод считывает данные в `buffer` параметр и захватывает конечную точку удаленного узла, из которой отправляются данные, а также сведения о полученном пакете. Сведения о том, как получить эту конечную точку, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>см. в разделе. Этот метод наиболее удобен, если предполагается асинхронное получение датаграмм без подключения из неизвестного узла или с нескольких узлов.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
- или - 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение<paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" /> .</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Используется операционная система Windows 2000 или более ранняя версия, а для этого метода необходима операционная система Windows XP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Метод запускает асинхронную операцию отправки на удаленный узел, установленный в методе,, или. <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.BeginSend%2A>выдаст исключение, если не выполняется <xref:System.Net.Sockets.Socket.Accept%2A>первый вызов <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. <xref:System.Net.Sockets.Socket.BeginSend%2A> Вызов метода дает возможность отправки данных в отдельном потоке выполнения.  
  
 Можно создать метод обратного вызова, реализующий <xref:System.AsyncCallback> делегат, и передать его имя <xref:System.Net.Sockets.Socket.BeginSend%2A> в метод. Для этого, как минимум, `state` параметр должен содержать подключенное или используемое по умолчанию <xref:System.Net.Sockets.Socket> соединение. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в <xref:System.Net.Sockets.Socket.BeginSend%2A> метод `state` через параметр.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndSend%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет <xref:System.Net.Sockets.Socket.EndSend%2A> блокироваться до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова <xref:System.Net.Sockets.Socket.BeginSend%2A> метода, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> используйте метод. Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Хотя и предназначен для протоколов, ориентированных на подключение, <xref:System.Net.Sockets.Socket.BeginSend%2A> также работает для протоколов без подключения при условии, что сначала <xref:System.Net.Sockets.Socket.Connect%2A> вызывается метод или <xref:System.Net.Sockets.Socket.BeginConnect%2A> , чтобы установить удаленный узел по умолчанию. Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует <xref:System.Net.Sockets.Socket.BeginSendTo%2A>использовать. Его можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A> , сделав еще один <xref:System.Net.Sockets.Socket.Connect%2A> вызов или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. При использовании протоколов без подключения необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.BeginSend%2A> создаст <xref:System.Net.Sockets.SocketException>исключение.  
  
 Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> в `socketflags` качестве параметра флаг, отправляемые данные не будут маршрутизироваться.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state`— Это экземпляр определяемого пользователем класса.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="buffers" /> пуст.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Метод запускает асинхронную операцию отправки на удаленный узел, установленный в методе,, или. <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.BeginSend%2A>выдаст исключение, если не выполняется <xref:System.Net.Sockets.Socket.Accept%2A>первый вызов <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. <xref:System.Net.Sockets.Socket.BeginSend%2A> Вызов метода дает возможность отправки данных в отдельном потоке выполнения.  
  
 Можно создать метод обратного вызова, реализующий <xref:System.AsyncCallback> делегат, и передать его имя <xref:System.Net.Sockets.Socket.BeginSend%2A> в метод. Для этого, как минимум, `state` параметр должен содержать подключенное или используемое по умолчанию <xref:System.Net.Sockets.Socket> соединение. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в <xref:System.Net.Sockets.Socket.BeginSend%2A> метод `state` через параметр.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndSend%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет <xref:System.Net.Sockets.Socket.EndSend%2A> блокироваться до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова <xref:System.Net.Sockets.Socket.BeginSend%2A> метода, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> используйте метод. Вызовите метод Set для <xref:System.Threading.ManualResetEvent> в методе обратного вызова, если необходимо, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Хотя и предназначен для протоколов, ориентированных на подключение, <xref:System.Net.Sockets.Socket.BeginSend%2A> также работает для протоколов без подключения при условии, что сначала <xref:System.Net.Sockets.Socket.Connect%2A> вызывается метод или <xref:System.Net.Sockets.Socket.BeginConnect%2A> , чтобы установить удаленный узел по умолчанию. Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует <xref:System.Net.Sockets.Socket.BeginSendTo%2A>использовать. Его можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A> , сделав еще один <xref:System.Net.Sockets.Socket.Connect%2A> вызов или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. При использовании протоколов без подключения необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.BeginSend%2A> создаст <xref:System.Net.Sockets.SocketException>исключение.  
  
 Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> в `socketflags` качестве параметра флаг, отправляемые данные не будут маршрутизироваться.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state`— Это экземпляр определяемого пользователем класса.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="buffers" /> пуст.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</param>
        <param name="offset">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, с которой начинается отправка данных.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Метод запускает асинхронную операцию отправки на удаленный узел, установленный в методе,, или. <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.BeginSend%2A>выдаст исключение, если не выполняется <xref:System.Net.Sockets.Socket.Accept%2A>первый вызов <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. <xref:System.Net.Sockets.Socket.BeginSend%2A> Вызов метода дает возможность отправки данных в отдельном потоке выполнения.  
  
 Можно создать метод обратного вызова, реализующий <xref:System.AsyncCallback> делегат, и передать его имя <xref:System.Net.Sockets.Socket.BeginSend%2A> в метод. Для этого, как минимум, `state` параметр должен содержать подключенное или используемое по умолчанию <xref:System.Net.Sockets.Socket> соединение. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в <xref:System.Net.Sockets.Socket.BeginSend%2A> метод `state` через параметр.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndSend%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет <xref:System.Net.Sockets.Socket.EndSend%2A> блокироваться до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова <xref:System.Net.Sockets.Socket.BeginSend%2A> метода, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> используйте метод. Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Хотя и предназначен для протоколов, ориентированных на подключение, <xref:System.Net.Sockets.Socket.BeginSend%2A> также работает для протоколов без подключения при условии, что сначала <xref:System.Net.Sockets.Socket.Connect%2A> вызывается метод или <xref:System.Net.Sockets.Socket.BeginConnect%2A> , чтобы установить удаленный узел по умолчанию. Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует <xref:System.Net.Sockets.Socket.BeginSendTo%2A>использовать. Его можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A> , сделав еще один <xref:System.Net.Sockets.Socket.Connect%2A> вызов или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. При использовании протоколов без подключения необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.BeginSend%2A> создаст <xref:System.Net.Sockets.SocketException>исключение.  
  
 Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> в `socketflags` качестве параметра флаг, отправляемые данные не будут маршрутизироваться.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state`— Это экземпляр определяемого пользователем класса.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Значение параметра <paramref name="offset" /> меньше значения длины, указанного в параметре <paramref name="buffer" />.  
  
- или - 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение<paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" /> .</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</param>
        <param name="offset">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, с которой начинается отправка данных.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Метод запускает асинхронную операцию отправки на удаленный узел, установленный в методе,, или. <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.BeginSend%2A>выдаст исключение, если не выполняется <xref:System.Net.Sockets.Socket.Accept%2A>первый вызов <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. <xref:System.Net.Sockets.Socket.BeginSend%2A> Вызов метода дает возможность отправки данных в отдельном потоке выполнения.  
  
 Можно создать метод обратного вызова, реализующий <xref:System.AsyncCallback> делегат, и передать его имя <xref:System.Net.Sockets.Socket.BeginSend%2A> в метод. Для этого, как минимум, `state` параметр должен содержать подключенное или используемое по умолчанию <xref:System.Net.Sockets.Socket> соединение. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого класса в <xref:System.Net.Sockets.Socket.BeginSend%2A> метод `state` через параметр.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndSend%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSend%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет <xref:System.Net.Sockets.Socket.EndSend%2A> блокироваться до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова <xref:System.Net.Sockets.Socket.BeginSend%2A> метода, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> используйте метод. Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Хотя и предназначен для протоколов, ориентированных на подключение, <xref:System.Net.Sockets.Socket.BeginSend%2A> также работает для протоколов без подключения при условии, что сначала <xref:System.Net.Sockets.Socket.Connect%2A> вызывается метод или <xref:System.Net.Sockets.Socket.BeginConnect%2A> , чтобы установить удаленный узел по умолчанию. Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует <xref:System.Net.Sockets.Socket.BeginSendTo%2A>использовать. Его можно использовать <xref:System.Net.Sockets.Socket.BeginSendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A> , сделав еще один <xref:System.Net.Sockets.Socket.Connect%2A> вызов или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. При использовании протоколов без подключения необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.BeginSend%2A> создаст <xref:System.Net.Sockets.SocketException>исключение.  
  
 Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> в `socketflags` качестве параметра флаг, отправляемые данные не будут маршрутизироваться.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  `state`— Это экземпляр определяемого пользователем класса.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
   
  
## Examples  
 В следующем примере кода начинается асинхронная отправка данных на удаленный узел.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Значение параметра <paramref name="offset" /> меньше значения длины, указанного в параметре <paramref name="buffer" />.  
  
- или - 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение<paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" /> .</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Примеры асинхронных сокетов клиента</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Пример асинхронного сокета сервера</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет асинхронную передачу файла на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Строка, содержащая путь и имя отправляемого файла. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Отправляет файл <paramref name="fileName" /> на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя флаг <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который представляет асинхронную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка отправляет файл `fileName` на подключенный сокет. Если `fileName` параметр находится в локальном каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла. Подстановочные знаки (".. \\\\\\\\\мифиле.ткст ") и общие имена UNC (" \шаред Directory \мифиле.ткст ") поддерживаются. \\ Если файл не найден, возникает исключение <xref:System.IO.FileNotFoundException> .  
  
 Этот метод использует функцию `TransmitFile` , обнаруженную в API Windows Sockets 2. Дополнительные сведения о `TransmitFile` функции и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Метод запускает асинхронную операцию отправки на удаленный узел, установленный в методах,, или. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> <xref:System.Net.Sockets.Socket.BeginSendFile%2A>создает исключение, если не выполняется <xref:System.Net.Sockets.Socket.Accept%2A>первый вызов <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Вызов метода позволяет отправить файл в отдельном потоке выполнения.  
  
 Чтобы завершить операцию, можно создать метод обратного вызова, который вызывается <xref:System.AsyncCallback> параметром Delegate. Для этого, как минимум, `state` параметр должен <xref:System.Net.Sockets.Socket> содержать объект, используемый для связи. Если для обратного вызова требуются дополнительные сведения, можно создать класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого пользовательского объекта в <xref:System.Net.Sockets.Socket.BeginSendFile%2A> метод `state` через параметр.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndSendFile%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, система использует отдельный поток для выполнения указанного метода обратного вызова и <xref:System.Net.Sockets.Socket.EndSendFile%2A> блокируется до тех пор, <xref:System.Net.Sockets.Socket> пока не отправит весь файл или не выдаст исключение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Хотя и предназначен для протоколов, ориентированных на подключение, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> также работает для протоколов без подключения при условии, что сначала <xref:System.Net.Sockets.Socket.Connect%2A> вызывается метод или <xref:System.Net.Sockets.Socket.BeginConnect%2A> , чтобы установить удаленный узел по умолчанию. При использовании протоколов без подключения необходимо убедиться, что размер файла не превышает максимальный размер пакета поставщика услуг. Если это так, датаграмма не отправляется и <xref:System.Net.Sockets.Socket.BeginSendFile%2A> <xref:System.Net.Sockets.SocketException> вызывает исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException> исключение, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
   
  
## Examples  
 В следующем примере кода создается и подключается сокет для асинхронного взаимодействия. Сначала файл "Text. txt" отправляется асинхронно на удаленный узел. Вызовы <xref:System.Net.Sockets.Socket.EndSendFile%2A> делегата обратного вызова для завершения передачи.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Сокет не подключен к удаленному узлу.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="fileName" /> не найден.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Строка, содержащая путь и имя отправляемого файла. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="preBuffer">Массив <see cref="T:System.Byte" />, содержащий данные, отправляемые перед передачей файла. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="postBuffer">Массив <see cref="T:System.Byte" />, содержащий данные, отправляемые после передачи файла. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="flags">Побитовое сочетание значений <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />, который должен быть вызван, когда эта операция завершается. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="state">Определенный пользователем объект, содержащий сведения о состоянии для этого запроса. Этот параметр может иметь значение <see langword="null" />.</param>
        <summary>Выполняет асинхронную передачу файла и буферов данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную операцию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для этой перегрузки требуется имя файла, который необходимо отправить, и побитовое <xref:System.Net.Sockets.TransmitFileOptions> сочетание значений. `preBuffer` Параметр содержит все данные, которые должны предшествовать файлу. `postBuffer`содержит данные, которые необходимо отслеживать в файле. Если `fileName` параметр находится в локальном каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла. Подстановочные знаки (".. \\\\\\\\\мифиле.ткст ") и общие имена UNC (" \шаред Directory \мифиле.ткст ") поддерживаются. \\ Если файл не найден, возникает исключение <xref:System.IO.FileNotFoundException> .  
  
 `flags` Параметр предоставляет поставщику услуг Windows Sockets дополнительные сведения о переносе файлов. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Этот метод использует функцию `TransmitFile` , обнаруженную в API Windows Sockets 2. Дополнительные сведения о `TransmitFile` функции и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>Метод запускает асинхронную операцию отправки на удаленный узел, установленный в методах,, или. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> <xref:System.Net.Sockets.Socket.BeginSendFile%2A>создает исключение, если не выполняется <xref:System.Net.Sockets.Socket.Accept%2A>первый вызов <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, или <xref:System.Net.Sockets.Socket.BeginConnect%2A>. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Вызов метода дает возможность отправить файл в отдельном потоке выполнения.  
  
 Чтобы завершить операцию, можно создать метод обратного вызова, который вызывается <xref:System.AsyncCallback> параметром Delegate. Для этого, как минимум, `state` параметр должен <xref:System.Net.Sockets.Socket> содержать объект, используемый для связи. Если для обратного вызова требуются дополнительные сведения, можно создать класс или структуру для хранения <xref:System.Net.Sockets.Socket> и других необходимых сведений. Передайте экземпляр этого пользовательского объекта в <xref:System.Net.Sockets.Socket.BeginSendFile%2A> метод `state` через параметр.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndSendFile%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, система использует отдельный поток для выполнения указанного метода обратного вызова и <xref:System.Net.Sockets.Socket.EndSendFile%2A> блокируется до тех пор, <xref:System.Net.Sockets.Socket> пока не отправит весь файл или не выдаст исключение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Хотя и предназначен для протоколов, ориентированных на подключение, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> также работает для протоколов без подключения при условии, что сначала <xref:System.Net.Sockets.Socket.Connect%2A> вызывается метод или <xref:System.Net.Sockets.Socket.BeginConnect%2A> , чтобы установить удаленный узел по умолчанию. При использовании протоколов без подключения необходимо также убедиться в том, что размер файла не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не отправляется и <xref:System.Net.Sockets.Socket.BeginSendFile%2A> <xref:System.Net.Sockets.SocketException> вызывает исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException> исключение, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
   
  
## Examples  
 Следующий пример кода создает и подключает сокет для асинхронного взаимодействия и начинает асинхронно отправлять файл "Text. txt" на удаленный узел. В этом примере `preBuffer` создается и объект `postBuffer` для отправки с файлом и используется значение по умолчанию <xref:System.Net.Sockets.TransmitFileOptions> . Вызовы <xref:System.Net.Sockets.Socket.EndSendFile%2A> делегата обратного вызова для завершения передачи.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
        <exception cref="T:System.NotSupportedException">Операционной системой не является Windows NT или более поздняя версия.  
  
- или -
  
 Сокет не подключен к удаленному узлу.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="fileName" /> не найден.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который содержит передаваемые данные.</param>
        <param name="offset">Отсчитываемая с нуля позиция в параметре <paramref name="buffer" />, с которой начинается отправка данных.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="socket_flags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленное устройство.</param>
        <param name="remote_end">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленное устройство.</param>
        <param name="callback">Делегат <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Объект, содержащий сведения о состоянии для этого запроса.</param>
        <summary>Асинхронно передает данные на конкретный удаленный узел.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, который ссылается на асинхронную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод запускает асинхронную операцию отправки на удаленный узел, указанный `remoteEP` в параметре. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Вызов метода дает возможность отправки данных в отдельном потоке выполнения. Хотя и предназначен для протоколов без <xref:System.Net.Sockets.Socket.BeginSendTo%2A> подключения, работает с протоколами, ориентированными на подключения и без них.  
  
 Можно создать метод обратного вызова, реализующий <xref:System.AsyncCallback> делегат, и передать его имя <xref:System.Net.Sockets.Socket.BeginSendTo%2A> в метод. Для этого, как минимум, `state` параметр должен содержать подключенное или используемое по умолчанию <xref:System.Net.Sockets.Socket> соединение. Если для обратного вызова требуются дополнительные сведения, можно создать небольшой класс для хранения <xref:System.Net.Sockets.Socket>и другие необходимые сведения. Передайте экземпляр этого класса в <xref:System.Net.Sockets.Socket.BeginSendTo%2A> метод `state` через параметр.  
  
 Метод обратного вызова должен вызывать <xref:System.Net.Sockets.Socket.EndSendTo%2A> метод. Когда приложение вызывает <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, система будет использовать отдельный поток для выполнения указанного метода обратного вызова и будет <xref:System.Net.Sockets.Socket.EndSendTo%2A> блокироваться до тех пор, пока <xref:System.Net.Sockets.Socket> не отправит запрошенное число байтов или не выдаст исключение. Если вы хотите, чтобы исходный поток блокировался после вызова <xref:System.Net.Sockets.Socket.BeginSendTo%2A> метода, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> используйте метод. Вызовите метод Set для Т:систем.среадинг.мануалресетевент в методе обратного вызова, если нужно, чтобы исходный поток продолжал выполнение. Дополнительные сведения о написании методов обратного вызова см. в разделе [маршалирование делегата в качестве метода обратного вызова](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 При использовании <xref:System.Net.Sockets.Socket.Connect%2A>протокола, ориентированного на соединение, необходимо сначала вызвать метод, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>или <xref:System.Net.Sockets.Socket.BeginAccept%2A> , или <xref:System.Net.Sockets.Socket.BeginSendTo%2A> будет вызывать исключение <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A>будет игнорировать `remoteEP` параметр и отправить данные в объект <xref:System.Net.EndPoint> <xref:System.Net.Sockets.Socket.Connect%2A>, установленный в методе <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> или.  
  
 Если используется протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A> методом или <xref:System.Net.Sockets.Socket.BeginConnect%2A> перед вызовом <xref:System.Net.Sockets.Socket.SendTo%2A>метода. Это необходимо сделать только в том случае, если предполагается вызывать <xref:System.Net.Sockets.Socket.BeginSend%2A> метод. При вызове <xref:System.Net.Sockets.Socket.Connect%2A> метода или <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.SendTo%2A>перед вызовом параметр переопределит указанный удаленный узел по умолчанию только для этой операции отправки. `remoteEP` Также не требуется вызывать <xref:System.Net.Sockets.Socket.Bind%2A> метод. В этом случае базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта. Если необходимо, чтобы базовый поставщик услуг выберет свободный порт, используйте нуль-порт. Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> свойство <xref:System.Net.Sockets.Socket.EndSendTo%2A> после успешного завершения метода.  
  
 Если вы хотите отправить данные на широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод и установить параметр сокета в <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>значение. — Необходимо также убедиться, что размер буфера не превышает максимальный размер пакета поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.EndSendTo%2A> создаст <xref:System.Net.Sockets.SocketException>исключение.  
  
 Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> в `socketflags` качестве параметра флаг, отправляемые данные не будут маршрутизироваться.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Контекст выполнения (контекст безопасности, олицетворенный пользователь и вызывающий контекст) кэшируется для асинхронных <xref:System.Net.Sockets.Socket> методов. После первого использования определенного контекста (определенного асинхронного <xref:System.Net.Sockets.Socket> метода, конкретного <xref:System.Net.Sockets.Socket> экземпляра и конкретного обратного вызова) при последующих применениях этого контекста будет отображаться улучшение производительности.  
  
   
  
## Examples  
 В следующем примере кода асинхронно отправляются данные на указанный удаленный узел.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.  
  
-или- 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
- или - 
 Значение<paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" /> .</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Маршалинг делегата как метода обратного вызова</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">Локальный объект <see cref="T:System.Net.EndPoint" />, который необходимо связать с объектом <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Связывает объект <see cref="T:System.Net.Sockets.Socket" /> с локальной конечной точкой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.Net.Sockets.Socket.Bind%2A> , если необходимо использовать определенную локальную конечную точку. <xref:System.Net.Sockets.Socket.Bind%2A> Перед <xref:System.Net.Sockets.Socket.Listen%2A>  вызовом метода необходимо вызвать метод. Не нужно вызывать <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Connect%2A> метод перед использованием метода, если не требуется использовать определенную локальную конечную точку. Вы можете использовать <xref:System.Net.Sockets.Socket.Bind%2A> метод как для протокола, так и для протоколов, ориентированных на подключение.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.Bind%2A>необходимо сначала создать локаль <xref:System.Net.IPEndPoint> , из которого планируется передавать данные. Если вы не хотите, чтобы локальный адрес был назначен, можно создать <xref:System.Net.IPEndPoint> с помощью <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> в качестве параметра Address, и базовый поставщик услуг присвоит наиболее подходящий сетевой адрес. Это может помочь упростить приложение при наличии нескольких сетевых интерфейсов. Если вы не хотите использовать локальный порт, можно создать <xref:System.Net.IPEndPoint> с помощью значения 0 для номера порта. В этом случае поставщик услуг присвоит доступному номеру порта от 1024 до 5000.  
  
 При использовании описанного выше подхода можно определить, какой локальный сетевой адрес и номер порта были назначены путем вызова <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. При использовании протокола, ориентированного на соединение, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> не возвращает локально назначенный сетевой адрес до тех пор, пока не будет выполнен вызов <xref:System.Net.Sockets.Socket.Connect%2A> метода или <xref:System.Net.Sockets.Socket.EndConnect%2A> . Если используется протокол без подключения, вы не сможете получить доступ к этим данным, пока не завершите отправку или получение.  
  
 Если сокету UDP требуется получать сведения о интерфейсе для полученных пакетов, <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод следует вызывать явным образом с параметром Socket, <xref:System.Net.Sockets.SocketOptionName.PacketInformation> установленным сразу после вызова <xref:System.Net.Sockets.Socket.Bind%2A> метода.  
  
> [!NOTE]
>  Если предполагается получение датаграмм многоадресной рассылки, необходимо вызвать <xref:System.Net.Sockets.Socket.Bind%2A> метод с номером многоадресного порта.  
  
> [!NOTE]
>  Необходимо вызвать метод, <xref:System.Net.Sockets.Socket.Bind%2A> если предполагается получение датаграмм без подключения <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> с помощью метода.  
  
> [!NOTE]
>  При получении сообщения <xref:System.Net.Sockets.SocketException> при <xref:System.Net.Sockets.Socket.Bind%2A> вызове метода используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода выполняется привязка <xref:System.Net.Sockets.Socket> с использованием указанной локальной конечной точки.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="localEP" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема соединений с узла, определенного параметром <paramref name="localEP" />. Связанное перечисление:<see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, находится ли объект <see cref="T:System.Net.Sockets.Socket" /> в заблокированном режиме.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> будет заблокирован; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство указывает, находится ли <xref:System.Net.Sockets.Socket> объект в блокирующем режиме. <xref:System.Net.Sockets.Socket.Blocking%2A>  
  
 Если вы используете режим блокировки и вы выполняете вызов метода, который не завершается немедленно, приложение будет блокировать выполнение до тех пор, пока не завершится запрошенная операция. Если необходимо продолжить выполнение, даже если запрошенная операция не завершена, измените <xref:System.Net.Sockets.Socket.Blocking%2A> свойство на. `false` <xref:System.Net.Sockets.Socket.Blocking%2A> Свойство не влияет на асинхронные методы. Если вы отправляете и получаете данные асинхронно и хотите блокировать выполнение, используйте <xref:System.Threading.ManualResetEvent> класс.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, используемый для запроса соединения с удаленным узлом путем вызова одного из методов <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />.</param>
        <summary>Отменяет выполнение асинхронного запроса для подключения к удаленному узлу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> Метод отменяет асинхронный запрос для подключения к удаленному узлу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="e" /> и <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не могут иметь значение NULL.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Закрывает подключение <see cref="T:System.Net.Sockets.Socket" /> и освобождает все связанные ресурсы.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает подключение <see cref="T:System.Net.Sockets.Socket" /> и освобождает все связанные ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод закрывает подключение к удаленному узлу и освобождает все управляемые и неуправляемые ресурсы, <xref:System.Net.Sockets.Socket>связанные с. <xref:System.Net.Sockets.Socket.Close%2A> После закрытия <xref:System.Net.Sockets.Socket.Connected%2A> свойству присваивается `false`значение.  
  
 Для протоколов, ориентированных на соединение, рекомендуется вызывать <xref:System.Net.Sockets.Socket.Shutdown%2A> <xref:System.Net.Sockets.Socket.Close%2A> метод перед вызовом метода. Это гарантирует, что все данные отправляются и получаются на подключенном сокете до его закрытия.  
  
 <xref:System.Net.Sockets.Socket.Close%2A> Если необходимо вызвать без первого вызова <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket.Shutdown%2A>, можно убедиться, что данные, поставленные в очередь для исходящей передачи, будут отправлены, задав `false` <xref:System.Net.Sockets.Socket> для параметра значение и указав интервал времени ожидания, отличный от нуля. <xref:System.Net.Sockets.Socket.Close%2A>будет блокироваться до тех пор, пока эти данные не будут отправлены или пока не истечет указанное время ожидания. Если задано <xref:System.Net.Sockets.SocketOptionName.DontLinger> значение `false` и задан нулевой интервал времени ожидания, <xref:System.Net.Sockets.Socket.Close%2A> освобождает соединение и автоматически удаляет исходящие данные из очереди.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketOptionName.DontLinger> Чтобы присвоить `false`параметру сокета значение <xref:System.Net.Sockets.LingerOption>, создайте, задайте для `true`свойства Enabled значение, а <xref:System.Net.Sockets.LingerOption.LingerTime%2A> для свойства — требуемый период времени ожидания. Используйте его <xref:System.Net.Sockets.LingerOption> вместе <xref:System.Net.Sockets.SocketOptionName.DontLinger> с параметром <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Socket для вызова метода.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода закрывается <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout">Процесс ожидает указанное число секунд <paramref name="timeout" />, прежде чем отправить оставшиеся данные, а затем закрывает сокет.</param>
        <summary>Закрывает подключение <see cref="T:System.Net.Sockets.Socket" /> и освобождает все связанные ресурсы с заданным временем ожидания, чтобы разрешить отправку данных в очереди.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод закрывает подключение к удаленному узлу и освобождает все управляемые и неуправляемые ресурсы, <xref:System.Net.Sockets.Socket>связанные с. <xref:System.Net.Sockets.Socket.Close%2A> После закрытия <xref:System.Net.Sockets.Socket.Connected%2A> свойству присваивается `false`значение.  
  
 Для протоколов, ориентированных на соединение, рекомендуется вызывать метод <xref:System.Net.Sockets.Socket.Shutdown%2A> перед вызовом метода. <xref:System.Net.Sockets.Socket.Close%2A> Это гарантирует, что все данные отправляются и получаются на подключенном сокете до его закрытия.  
  
 Если необходимо вызвать <xref:System.Net.Sockets.Socket.Close%2A> без первого вызова <xref:System.Net.Sockets.Socket.Shutdown%2A>, можно убедиться, что данные, поставленные в очередь для исходящей передачи, будут отправлены <xref:System.Net.Sockets.SocketOptionName.DontLinger> , задав `false` для параметра значение и указав интервал времени ожидания, отличный от нуля. <xref:System.Net.Sockets.Socket.Close%2A>будет блокироваться до тех пор, пока эти данные не будут отправлены или пока не истечет указанное время ожидания. Если задано <xref:System.Net.Sockets.SocketOptionName.DontLinger> значение `false` и задан нулевой интервал времени ожидания, <xref:System.Net.Sockets.Socket.Close%2A> освобождает соединение и автоматически удаляет исходящие данные из очереди.  
  
> [!NOTE]
>  <xref:System.Net.Sockets.SocketOptionName.DontLinger> Чтобы присвоить `false`параметру сокета значение <xref:System.Net.Sockets.LingerOption>, создайте, задайте для `true`свойства Enabled значение и задайте <xref:System.Net.Sockets.LingerOption.LingerTime%2A> для свойства требуемый период ожидания. Используйте его <xref:System.Net.Sockets.LingerOption> вместе <xref:System.Net.Sockets.SocketOptionName.DontLinger> с параметром <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Socket для вызова метода.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как закрыть <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Устанавливает подключение к удаленному узлу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий удаленное устройство.</param>
        <summary>Устанавливает подключение к удаленному узлу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если используется протокол, ориентированный на подключение, например TCP, <xref:System.Net.Sockets.Socket.Connect%2A> метод синхронно устанавливает сетевое подключение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанной удаленной конечной точкой. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию. После вызова <xref:System.Net.Sockets.Socket.Connect%2A>можно отправить данные на удаленное устройство <xref:System.Net.Sockets.Socket.Send%2A> с помощью метода или получить данные с удаленного устройства с помощью <xref:System.Net.Sockets.Socket.Receive%2A> метода.  
  
 Если используется протокол без установления соединения, например UDP, нет необходимости вызывать метод <xref:System.Net.Sockets.Socket.Connect%2A> перед отправкой и получением данных. Для синхронной <xref:System.Net.Sockets.Socket.SendTo%2A> связи <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> с удаленным узлом можно использовать и. При вызове <xref:System.Net.Sockets.Socket.Connect%2A>все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут удалены. Если вы хотите задать для <xref:System.Net.Sockets.Socket.SetSocketOption%2A> удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать метод и установить параметр сокета в <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>значение <xref:System.Net.Sockets.SocketException>, или <xref:System.Net.Sockets.Socket.Connect%2A> будет вызывать исключение. Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 Метод блокируется, если только вы не <xref:System.Net.Sockets.Socket.Blocking%2A> установили для `false` свойства значение до вызова  <xref:System.Net.Sockets.Socket.Connect%2A> .  <xref:System.Net.Sockets.Socket.Connect%2A> Если вы используете протокол, ориентированный на подключение, например TCP, и отключите блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> вызовет <xref:System.Net.Sockets.SocketException> исключение, так как ему требуется время для подключения. Протоколы без подключения не вызовут исключение, так как они просто устанавливают удаленный узел по умолчанию. Для получения конкретного <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> кода ошибки можно использовать. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки. Если ошибка вернула всаеваулдблокк, соединение с удаленным узлом было инициировано с помощью подключения <xref:System.Net.Sockets.Socket>, но еще не завершилось успешно. Используйте метод, чтобы определить, <xref:System.Net.Sockets.Socket> когда завершается соединение. <xref:System.Net.Sockets.Socket.Poll%2A>  
  
> [!NOTE]
>  Если вы используете протокол, ориентированный на подключение, и не выполнили <xref:System.Net.Sockets.Socket.Bind%2A> вызов <xref:System.Net.Sockets.Socket.Connect%2A>до вызова, базовый поставщик услуг присвоит адрес локальной сети и номер порта. Если используется протокол без подключения, поставщик услуг не будет назначать локальный сетевой адрес и номер порта, пока не завершится операция отправки или получения. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> его еще раз с нужной конечной точкой.  
  
> [!NOTE]
>  Если сокет был ранее отключен, использовать этот метод для восстановления соединения нельзя. Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методов для повторного подключения. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода подключается к удаленной конечной точке, а затем проверяет подключение.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
        <permission cref="T:System.Net.SocketPermission">для подключения к удаленному узлу. Связанное перечисление:<see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address">IP-адрес удаленного узла.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <summary>Создает подключение к удаленному узлу. Узел задается IP-адресом и номером порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если используется протокол, ориентированный на подключение, например TCP, <xref:System.Net.Sockets.Socket.Connect%2A> метод синхронно устанавливает сетевое подключение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанной удаленной конечной точкой. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию. После вызова <xref:System.Net.Sockets.Socket.Connect%2A> можно отправить данные на удаленное устройство <xref:System.Net.Sockets.Socket.Send%2A> с помощью метода или получить данные с удаленного устройства с помощью <xref:System.Net.Sockets.Socket.Receive%2A> метода.  
  
 Если используется протокол без установления соединения, например UDP, нет необходимости вызывать метод <xref:System.Net.Sockets.Socket.Connect%2A> перед отправкой и получением данных. Для синхронной <xref:System.Net.Sockets.Socket.SendTo%2A> связи <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> с удаленным узлом можно использовать и. При вызове <xref:System.Net.Sockets.Socket.Connect%2A> всех датаграмм, поступивших из адреса, отличного от указанного по умолчанию, будут удалены. Если вы хотите задать для <xref:System.Net.Sockets.Socket.SetSocketOption%2A> удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать метод и установить параметр сокета в <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>значение <xref:System.Net.Sockets.SocketException>, или <xref:System.Net.Sockets.Socket.Connect%2A> будет вызывать исключение. Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>метод будет заблокирован, если только вы не установили <xref:System.Net.Sockets.Socket.Blocking%2A> для `false` свойства значение до вызова. <xref:System.Net.Sockets.Socket.Connect%2A> Если вы используете протокол, ориентированный на подключение, например TCP, и отключите блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> вызовет <xref:System.Net.Sockets.SocketException> исключение, так как ему требуется время для подключения. Протоколы без подключения не вызовут исключение, так как они просто устанавливают удаленный узел по умолчанию. Для получения конкретного <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> кода ошибки можно использовать. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки. Если ошибка вернула всаеваулдблокк, соединение с удаленным узлом было инициировано с помощью подключения <xref:System.Net.Sockets.Socket>, но еще не завершилось успешно. Используйте метод, чтобы определить, <xref:System.Net.Sockets.Socket> когда завершается соединение. <xref:System.Net.Sockets.Socket.Poll%2A>  
  
> [!NOTE]
>  Если вы используете протокол, ориентированный на подключение, и не выполнили <xref:System.Net.Sockets.Socket.Bind%2A> вызов <xref:System.Net.Sockets.Socket.Connect%2A>до вызова, базовый поставщик услуг присвоит адрес локальной сети и номер порта. Если используется протокол без подключения, поставщик услуг не будет назначать локальный сетевой адрес и номер порта, пока не завершится операция отправки или получения. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> его еще раз с нужной конечной точкой.  
  
> [!NOTE]
>  Если сокет был ранее отключен, использовать этот метод для восстановления соединения нельзя. Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методов для повторного подключения. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода подключается к удаленной конечной точке, а затем проверяет подключение.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="address" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод применим для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="address" /> равна нулю.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="addresses">IP-адрес удаленного узла.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <summary>Устанавливает подключение к удаленному узлу. Узел задается массивом IP-адресов и номером порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обычно используется сразу после вызова <xref:System.Net.Dns.GetHostAddresses%2A>метода, который может возвращать несколько IP-адресов для одного узла. Если используется протокол, ориентированный на подключение, например TCP, <xref:System.Net.Sockets.Socket.Connect%2A> метод синхронно устанавливает сетевое подключение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанной удаленной конечной точкой. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию. После вызова <xref:System.Net.Sockets.Socket.Connect%2A> можно отправить данные на удаленное устройство <xref:System.Net.Sockets.Socket.Send%2A> с помощью метода или получить данные с удаленного устройства с помощью <xref:System.Net.Sockets.Socket.Receive%2A> метода.  
  
 Если используется протокол без установления соединения, например UDP, нет необходимости вызывать метод <xref:System.Net.Sockets.Socket.Connect%2A> перед отправкой и получением данных. Для синхронной <xref:System.Net.Sockets.Socket.SendTo%2A> связи <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> с удаленным узлом можно использовать и. При вызове <xref:System.Net.Sockets.Socket.Connect%2A> всех датаграмм, поступивших из адреса, отличного от указанного по умолчанию, будут удалены. Если вы хотите задать для <xref:System.Net.Sockets.Socket.SetSocketOption%2A> удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать метод и установить параметр сокета в <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>значение <xref:System.Net.Sockets.SocketException>, или <xref:System.Net.Sockets.Socket.Connect%2A> будет вызывать исключение. Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>метод будет заблокирован, если только вы не установили <xref:System.Net.Sockets.Socket.Blocking%2A> для `false` свойства значение до вызова. <xref:System.Net.Sockets.Socket.Connect%2A> Если вы используете протокол, ориентированный на подключение, например TCP, и отключите блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> вызовет <xref:System.Net.Sockets.SocketException> исключение, так как ему требуется время для подключения. Протоколы без подключения не вызовут исключение, так как они просто устанавливают удаленный узел по умолчанию. Для получения конкретного <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> кода ошибки можно использовать. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки. Если ошибка вернула всаеваулдблокк, соединение с удаленным узлом было инициировано с помощью подключения <xref:System.Net.Sockets.Socket>, но еще не завершилось успешно. Используйте метод, чтобы определить, <xref:System.Net.Sockets.Socket> когда завершается соединение. <xref:System.Net.Sockets.Socket.Poll%2A>  
  
> [!NOTE]
>  Если вы используете протокол, ориентированный на подключение, и не выполнили <xref:System.Net.Sockets.Socket.Bind%2A> вызов <xref:System.Net.Sockets.Socket.Connect%2A>до вызова, базовый поставщик услуг присвоит адрес локальной сети и номер порта. Если используется протокол без подключения, поставщик услуг не будет назначать локальный сетевой адрес и номер порта, пока не завершится операция отправки или получения. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> его еще раз с нужной конечной точкой.  
  
> [!NOTE]
>  Если сокет был ранее отключен, использовать этот метод для восстановления соединения нельзя. Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методов для повторного подключения. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода подключается к удаленной конечной точке, а затем проверяет подключение.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="addresses" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод применим для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">Длина параметра <paramref name="address" /> равна нулю.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="host">Имя удаленного узла.</param>
        <param name="port">Номер порта удаленного узла.</param>
        <summary>Устанавливает подключение к удаленному узлу. Узел задается именем узла и номером порта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если используется протокол, ориентированный на подключение, например TCP, <xref:System.Net.Sockets.Socket.Connect%2A> метод синхронно устанавливает сетевое подключение между <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> и указанным удаленным узлом. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.Connect%2A> устанавливает удаленный узел по умолчанию. После вызова <xref:System.Net.Sockets.Socket.Connect%2A> можно отправить данные на удаленное устройство <xref:System.Net.Sockets.Socket.Send%2A> с помощью метода или получить данные с удаленного устройства с помощью <xref:System.Net.Sockets.Socket.Receive%2A> метода.  
  
 Если используется протокол без установления соединения, например UDP, нет необходимости вызывать метод <xref:System.Net.Sockets.Socket.Connect%2A> перед отправкой и получением данных. Для синхронной <xref:System.Net.Sockets.Socket.SendTo%2A> связи <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> с удаленным узлом можно использовать и. При вызове <xref:System.Net.Sockets.Socket.Connect%2A> всех датаграмм, поступивших из адреса, отличного от указанного по умолчанию, будут удалены. Если вы хотите задать для <xref:System.Net.Sockets.Socket.SetSocketOption%2A> удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать метод и установить параметр сокета в <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>значение <xref:System.Net.Sockets.SocketException>, или <xref:System.Net.Sockets.Socket.Connect%2A> будет вызывать исключение. Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>метод будет заблокирован, если только вы не установили <xref:System.Net.Sockets.Socket.Blocking%2A> для `false` свойства значение до вызова. <xref:System.Net.Sockets.Socket.Connect%2A> Если вы используете протокол, ориентированный на подключение, например TCP, и отключите блокировку, <xref:System.Net.Sockets.Socket.Connect%2A> вызовет <xref:System.Net.Sockets.SocketException> исключение, так как ему требуется время для подключения. Протоколы без подключения не вызовут исключение, так как они просто устанавливают удаленный узел по умолчанию. Для получения конкретного <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> кода ошибки можно использовать. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки. Если ошибка вернула всаеваулдблокк, соединение с удаленным узлом было инициировано с помощью подключения <xref:System.Net.Sockets.Socket>, но еще не завершилось успешно. Используйте метод, чтобы определить, <xref:System.Net.Sockets.Socket> когда завершается соединение. <xref:System.Net.Sockets.Socket.Poll%2A>  
  
 Если включена поддержка протокола IPv6 и <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> вызывается метод для подключения к узлу, который разрешается как в IPv6, так и в IPv4-адресах, будет предпринята попытка подключения к IPv6-адресу до адреса IPv4. Это может привести к задержке времени для установления соединения, если узел не прослушивает IPv6-адрес.  
  
> [!NOTE]
>  Если вы используете протокол, ориентированный на подключение, и не выполнили <xref:System.Net.Sockets.Socket.Bind%2A> вызов <xref:System.Net.Sockets.Socket.Connect%2A>до вызова, базовый поставщик услуг присвоит адрес локальной сети и номер порта. Если используется протокол без подключения, поставщик услуг не будет назначать локальный сетевой адрес и номер порта, пока не завершится операция отправки или получения. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.Connect%2A> его еще раз с нужной конечной точкой.  
  
> [!NOTE]
>  Если сокет был ранее отключен, использовать этот метод для восстановления соединения нельзя. Используйте один из асинхронных <xref:System.Net.Sockets.Socket.BeginConnect%2A> методов для повторного подключения. Это ограничение базового поставщика.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода подключается к удаленной конечной точке, а затем проверяет подключение.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Номер порта недействителен.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод применим для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.InvalidOperationException">Сокет <see cref="T:System.Net.Sockets.Socket" /> был переведен в состояние прослушивания путем вызова <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании протокола, ориентированного на соединение, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод запускает асинхронный запрос подключения к удаленному узлу. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> устанавливает удаленный узел по умолчанию.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, реализующий\<обработчик EventHandler SocketAsyncEventArgs > делегата и присоединить <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> обратный вызов к событию.  
  
 Вызывающий объект должен задать <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> свойство <xref:System.Net.IPEndPoint> для удаленного узла, к которому необходимо подключиться.  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> для свойства любой объект пользовательского состояния, необходимый перед <xref:System.Net.Sockets.Socket.ConnectAsync%2A> вызовом метода, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 Если используется протокол без установления соединения, например UDP, нет необходимости вызывать метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> перед отправкой и получением данных. Для взаимодействия с <xref:System.Net.Sockets.Socket.SendToAsync%2A> удаленным узлом можно использовать и. <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> При вызове <xref:System.Net.Sockets.Socket.ConnectAsync%2A>все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут удалены. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод еще раз с нужной конечной точкой.  
  
 Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр Broadcast в. `true` Если это не сделано, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод вызовет <xref:System.Net.Sockets.SocketException>исключение.  
  
 Для <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> объекта требуются следующие свойства и события:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 При необходимости можно указать буфер, который будет атомарно отправлен на сокет после того, как метод завершится с <xref:System.Net.Sockets.Socket.ConnectAsync%2A> ошибкой. В этом случае <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> свойство должно быть установлено в буфер, содержащий отправляемые данные <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> , а свойство должно иметь значение, равное числу байтов данных, отправляемых из буфера. После установления соединения отправляется этот буфер данных.  
  
 Если вы используете протокол, ориентированный на подключение, и не вызываете <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, базовый поставщик услуг присвоит наиболее подходящий локальный сетевой адрес и номер порта.  
  
 Если используется протокол без установления соединения, поставщик услуг не будет назначать IP-адрес и номер порта локальной сети до тех пор, пока не <xref:System.Net.Sockets.Socket.SendAsync%2A> будут <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> вызваны методы или.  
  
 Метод вызывает исключение <xref:System.NotSupportedException> , <xref:System.Net.Sockets.Socket> Если <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  семейство адресов и не совпадает с семейством адресов. <xref:System.Net.Sockets.Socket.ConnectAsync%2A>  
  
> [!NOTE]
>  При получении сообщения <xref:System.Net.Sockets.SocketException> при вызове этого метода <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Аргумент является недопустимым. Это исключение возникает, если задано несколько буферов, свойство <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> не имеет значение "null".</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="e" /> и <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не могут иметь значение NULL.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> ведет прослушивание или работа с сокетом уже выполняется с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного параметром <paramref name="e" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях. Это исключение возникает также в том случае, если локальная конечная точка и объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не принадлежат к одному семейству адресов.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType">Одно из значений <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Одно из значений перечисления <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает выполнение асинхронного запроса для подключения к удаленному узлу.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если используется протокол, ориентированный на соединение, метод М:систем.нет.соккетс.соккет.коннектасинк (System .NET. Sockets. Соккеттипе, System .NET. Sockets. ProtocolType, System .NET. Sockets. SocketAsyncEventArgs) запускает асинхронный запрос для подключение к удаленному узлу. Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> устанавливает удаленный узел по умолчанию, заданный `socketType` параметрами и `protocolType` .  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, реализующий\<обработчик EventHandler SocketAsyncEventArgs > делегата и присоединить <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> обратный вызов к событию.  
  
 Вызывающий объект должен задать <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> свойство <xref:System.Net.IPEndPoint> для удаленного узла, к которому необходимо подключиться.  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> для свойства любой объект пользовательского состояния, необходимый перед <xref:System.Net.Sockets.Socket.ConnectAsync%2A> вызовом метода, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 Если используется протокол без установления соединения, например UDP, нет необходимости вызывать метод <xref:System.Net.Sockets.Socket.ConnectAsync%2A> перед отправкой и получением данных. Для взаимодействия с <xref:System.Net.Sockets.Socket.SendToAsync%2A> удаленным узлом можно использовать и. <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> При вызове <xref:System.Net.Sockets.Socket.ConnectAsync%2A>все датаграммы, поступающие с адреса, отличного от указанного по умолчанию, будут удалены. Если вы хотите изменить удаленный узел по умолчанию, вызовите <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод еще раз с нужной конечной точкой.  
  
 Если вы хотите задать для удаленного узла по умолчанию широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> и установить параметр Broadcast в. `true` Если это не сделано, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> метод вызовет <xref:System.Net.Sockets.SocketException>исключение.  
  
 Для <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> объекта требуются следующие свойства и события:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 При необходимости можно указать буфер, который будет атомарно отправлен на сокет после того, как метод завершится с <xref:System.Net.Sockets.Socket.ConnectAsync%2A> ошибкой. В этом случае <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> свойство должно быть установлено в буфер, содержащий отправляемые данные <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> , а свойство должно иметь значение, равное числу байтов данных, отправляемых из буфера. После установления соединения отправляется этот буфер данных.  
  
 Если вы используете протокол, ориентированный на подключение, и не вызываете <xref:System.Net.Sockets.Socket.Bind%2A> перед вызовом <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, базовый поставщик услуг присвоит наиболее подходящий локальный сетевой адрес и номер порта.  
  
 Если используется протокол без установления соединения, поставщик услуг не будет назначать IP-адрес и номер порта локальной сети до тех пор, пока не <xref:System.Net.Sockets.Socket.SendAsync%2A> будут <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> вызваны методы или.  
  
 Метод вызывает исключение <xref:System.NotSupportedException> , <xref:System.Net.Sockets.Socket> Если <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  семейство адресов и не совпадает с семейством адресов. <xref:System.Net.Sockets.Socket.ConnectAsync%2A>  
  
> [!NOTE]
>  При получении сообщения <xref:System.Net.Sockets.SocketException> при вызове этого метода <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Аргумент является недопустимым. Это исключение возникает, если задано несколько буферов, свойство <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> не имеет значение "null".</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="e" /> и <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не могут иметь значение NULL.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> ведет прослушивание или работа с сокетом уже выполняется с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного параметром <paramref name="e" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях. Это исключение возникает также в том случае, если локальная конечная точка и объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не принадлежат к одному семейству адресов.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект, находящийся выше в стеке вызовов, не имеет разрешения на запрошенную операцию.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, подключается ли объект <see cref="T:System.Net.Sockets.Socket" /> к удаленному узлу в результате последней операции <see cref="Overload:System.Net.Sockets.Socket.Send" /> или <see cref="Overload:System.Net.Sockets.Socket.Receive" />.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> в результате последней операции был подключен к удаленному ресурсу; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство возвращает состояние соединения объекта по состоянию <xref:System.Net.Sockets.Socket> последней операции ввода-вывода. `Connected` При возвращении `false` <xref:System.Net.Sockets.Socket> он никогда не был подключен или перестает быть подключенным.  
  
 Значение <xref:System.Net.Sockets.Socket.Connected%2A> свойства отражает состояние соединения в последней операции. Если необходимо определить текущее состояние соединения, сделайте неблокирующий вызов send с нулевым байтом. Если вызов завершается успешно или вызывается код ошибки ВАЕВАУЛДБЛОКК (10035), сокет все еще подключен; в противном случае сокет больше не будет подключен.  
  
 При вызове <xref:System.Net.Sockets.Socket.Connect%2A> через сокет <xref:System.Net.Sockets.Socket.Connected%2A> UDP свойство всегда возвращает `true`значение, однако это действие не изменяет характер протокола UDP без подключения.  
  
   
  
## Examples  
 В следующем примере кода выполняется подключение к удаленной конечной точке, проверяется <xref:System.Net.Sockets.Socket.Connected%2A> свойство и проверяется текущее состояние соединения.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">Значение <see langword="true" />, если этот сокет может быть повторно использован после закрытия текущего подключения; в противном случае — значение <see langword="false" />.</param>
        <summary>Закрывает подключение к сокету и позволяет повторно его использовать.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании протокола, ориентированного на подключение, этот метод можно использовать для закрытия сокета. Этот метод завершает соединение и задает <xref:System.Net.Sockets.Socket.Connected%2A> для `false`свойства значение. Однако если `reuseSocket` имеет значение `true`, можно повторно использовать сокет.  
  
 Чтобы обеспечить отправку и получение всех данных перед закрытием сокета, следует вызвать <xref:System.Net.Sockets.Socket.Shutdown%2A> <xref:System.Net.Sockets.Socket.Disconnect%2A> метод перед вызовом метода.  
  
 Если необходимо вызвать <xref:System.Net.Sockets.Socket.Disconnect%2A> без первого `false` <xref:System.Net.Sockets.SocketOptionName.DontLinger> вызова <xref:System.Net.Sockets.Socket.Shutdown%2A>, можно установить параметр в значение и указать нулевой интервал времени ожидания, чтобы гарантировать отправку данных, поставленных в очередь для исходящей передачи. <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.Disconnect%2A>затем блокируется до тех пор, пока данные не будут отправлены или пока не истечет указанное время ожидания. Если задано <xref:System.Net.Sockets.SocketOptionName.DontLinger> значение `false` и задан нулевой интервал времени ожидания, <xref:System.Net.Sockets.Socket.Close%2A> освобождает соединение и автоматически удаляет исходящие данные из очереди.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается сокет для синхронного взаимодействия и отправляются некоторые данные на удаленный узел. Затем он вызывает <xref:System.Net.Sockets.Socket.Shutdown%2A>, для завершения действия Send и Receive и <xref:System.Net.Sockets.Socket.Disconnect%2A>, чтобы закрыть подключение к сокету.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для этого метода необходима операционная система Windows 2000 или более ранняя версия или будет создано исключение.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает выполнение асинхронного запроса для отключения от удаленной конечной точки.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании протокола, ориентированного на соединение, вызов <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> метода запрашивает отключение от удаленной конечной точки. Если для <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> `true` параметра задано значение, сокет можно использовать повторно. `e`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="e" /> не может быть равен null.</exception>
        <exception cref="T:System.InvalidOperationException">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод `Dispose` по окончании использования класса <xref:System.Net.Sockets.Socket>. Метод `Dispose` оставляет класс <xref:System.Net.Sockets.Socket> в непригодном для использования состоянии. После вызова `Dispose`необходимо освободить все ссылки <xref:System.Net.Sockets.Socket> на, чтобы сборщик мусора мог освободить память, которую <xref:System.Net.Sockets.Socket> занимают.  
  
 Дополнительные сведения см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Всегда вызывайте метод `Dispose` перед освобождением последней ссылки на класс <xref:System.Net.Sockets.Socket>. В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Net.Sockets.Socket> метод `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> для освобождения управляемых и неуправляемых ресурсов; значение <see langword="false" /> для освобождения только неуправляемых ресурсов.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.Net.Sockets.Socket" />, и при необходимости освобождает также управляемые ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается открытым `Dispose()` методом <xref:System.Object.Finalize%2A> и методом. `Dispose()`вызывает защищенный `Dispose(Boolean)` метод с параметром `disposing` , для `true`которого задано значение. <xref:System.Object.Finalize%2A>вызывает метод `disposing` `false`с параметром, равным. `Dispose`  
  
 Если параметр `disposing` имеет значение `true`, то данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, на которые ссылается этот объект <xref:System.Net.Sockets.Socket>. Этот метод вызывает метод `Dispose()` каждого объекта, на который есть ссылка.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Метод 
            <see langword="Dispose" /> может вызываться несколько раз другими объектами. При переопределении метода <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами метода <see langword="Dispose" />. Дополнительные сведения о реализации <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />см. в разделе [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
<see langword="Dispose" /> Дополнительные сведения о <see cref="M:System.Object.Finalize" />и см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Переопределение метода Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, разрешает ли объект <see cref="T:System.Net.Sockets.Socket" /> выполнение фрагментации датаграмм протокола IP.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> разрешает фрагментацию датаграмм; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для датаграмм требуется фрагментация, если их размер превышает максимальную единицу передачи (MTU) носителя передачи. Датаграммы могут быть фрагментированы отправляющим узлом (все версии протокола IP) или промежуточным маршрутизатором (только для протокола IP версии 4). Если датаграмма должна быть фрагментирована, а <xref:System.Net.Sockets.Socket.DontFragment%2A> параметр установлен, датаграмма отбрасывается, а сообщение об ошибке протокола ICMP отправляется обратно отправителю датаграммы.  
  
 Установка этого свойства для сокета протокола TCP не будет действовать.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.DontFragment%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Это свойство может быть установлено только для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, является ли <see cref="T:System.Net.Sockets.Socket" /> сокетом с двойным режимом, используемым для IPv4 и IPv6.</summary>
        <value>Значение <see langword="true" />, если <see cref="T:System.Net.Sockets.Socket" /> — сокет с двойным режимом. В противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">Идентификатор конечного процесса, в котором создается дубликат ссылки сокета.</param>
        <summary>Дублирует ссылку сокета для конечного процесса и закрывает сокет для этого процесса.</summary>
        <returns>Ссылка сокета, передаваемая в конечный процесс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Целевой процесс должен использовать <xref:System.Net.Sockets.Socket.%23ctor%2A> для создания повторяющегося экземпляра сокета.  
  
 Если вы вызываете <xref:System.Net.Sockets.Socket.%23ctor%2A> конструктор несколько раз с тем же массивом байтов, что и аргумент для каждого вызова, вы создадите несколько <xref:System.Net.Sockets.Socket> управляемых экземпляров с одним и тем же базовым сокетом. Этот подход настоятельно не рекомендуется.  
  
 Если процесс создания сокета использует асинхронные методы (<xref:System.Net.Sockets.Socket.BeginReceive%2A> или <xref:System.Net.Sockets.Socket.BeginSend%2A>), то сначала необходимо установить <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> свойство в значение true. в противном случае сокет привязывается к порту завершения создания процесса, что может вызвать исключение  <xref:System.ArgumentNullException> будет выдаваться в целевом процессе.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Параметр <paramref name="targetProcessID" /> не является допустимым идентификатором процесса. 
- или - 
Дубликат ссылки сокета не создан.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, может ли объект <see cref="T:System.Net.Sockets.Socket" /> производить отправку или прием широковещательных пакетов.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> разрешает использование широковещательных пакетов; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Широковещательная рассылка ограничена определенной подсетью и должна использовать протокол UDP. Для протокола IP версии 4 можно выполнить широковещательную рассылку в локальную подсеть, отправив пакет в 255.255.255.255; также можно использовать направленный широковещательный адрес, который представляет собой сетевую часть IP-адреса со всеми битами, заданными в части узла. Например, если IP-адрес — 192.168.1.40 (адрес класса C, маска 255.255.255.0--, часть сети — первые три октета, а часть узла — последний октет), направленный широковещательный адрес 192.168.1.255.  
  
 Установка этого свойства для сокета протокола TCP не будет действовать.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Эта функция применима только для сокета датаграмм.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Асинхронно принимает попытку входящего подключения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который содержит переданные байты.</param>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии для этой асинхронной операции, а также любые данные, определенные пользователем.</param>
        <summary>Асинхронно принимает входящие попытки подключения и создает новый объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом. Этот метод возвращает буфер, который содержит начальные данные для передачи.</summary>
        <returns>Объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>завершает вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A>необходимо создать метод обратного вызова, который вызывается <xref:System.AsyncCallback> делегатом. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, <xref:System.Net.Sockets.Socket.BeginAccept%2A> как метод возвращает значение.  
  
 В методе обратного вызова вызовите <xref:System.IAsyncResult.AsyncState%2A> метод `asyncResult` параметра, чтобы получить объект <xref:System.Net.Sockets.Socket> , для которого выполняется попытка подключения. После получения <xref:System.Net.Sockets.Socket>можно <xref:System.Net.Sockets.Socket.EndAccept%2A> вызвать метод для успешного завершения попытки подключения. Параметр этой перегрузки содержит данные, полученные при <xref:System.Net.Sockets.Socket.BeginAccept%2A> вызове функции, а `bytesTransferred` параметр содержит число байтов, переданных в вызове. `buffer`  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Метод блокируется до завершения подключения в очереди входящих подключений. Метод принимает входящее соединение и возвращает новый <xref:System.Net.Sockets.Socket> объект, который может использоваться для отправки и получения данных с удаленного узла. <xref:System.Net.Sockets.Socket.EndAccept%2A>  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.Sockets.Socket.BeginAccept%2A> для создания и подключения сокета, а также для принятия начальных 10 байт данных. Делегат обратного вызова <xref:System.Net.Sockets.Socket.EndAccept%2A> вызывает метод для завершения асинхронного запроса. Число переданных байтов и данные возвращаются в `buffer` параметрах и `bytesTransferred` этого метода и отображаются в консоли.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> пуст.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был создан вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ранее был вызван метод <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к объекту <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии для этой асинхронной операции, а также любые данные, определенные пользователем.</param>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии для этой асинхронной операции, а также любые данные, определенные пользователем.</param>
        <summary>Асинхронно принимает входящие попытки подключения и создает новый объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</summary>
        <returns>Объект<see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>завершает вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A>необходимо создать метод обратного вызова, который <xref:System.AsyncCallback> реализует делегат. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, <xref:System.Net.Sockets.Socket.BeginAccept%2A> как метод возвращает значение. Он должен принять параметр `asyncResult` , возвращенный <xref:System.Net.Sockets.Socket.BeginAccept%2A> методом.  
  
 В методе обратного вызова вызовите <xref:System.IAsyncResult.AsyncState%2A> метод `asyncResult` параметра, чтобы получить объект <xref:System.Net.Sockets.Socket> , для которого выполняется попытка подключения. После получения <xref:System.Net.Sockets.Socket>можно <xref:System.Net.Sockets.Socket.EndAccept%2A> вызвать метод для успешного завершения попытки подключения.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Метод блокируется до завершения подключения в очереди входящих подключений. Метод принимает входящее соединение и возвращает новый <xref:System.Net.Sockets.Socket> объект, который может использоваться для отправки и получения данных с удаленного узла. <xref:System.Net.Sockets.Socket.EndAccept%2A>  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается асинхронный запрос и создается новый <xref:System.Net.Sockets.Socket> объект, принимающий входящий запрос на подключение. Полный пример, демонстрирующий асинхронную связь с сокетами, см. в статье [примеры кода для сокетов](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был создан вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. Дополнительные сведения см. в разделе "Примечания".</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Ранее был вызван метод <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который содержит переданные байты.</param>
        <param name="bytesTransferred">Количество переданных байтов.</param>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии для этой асинхронной операции, а также любые данные, определенные пользователем.</param>
        <summary>Асинхронно принимает входящие попытки подключения и создает новый объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом. Этот метод возвращает буфер, который содержит начальные данные и число переданных байтов.</summary>
        <returns>Объект <see cref="T:System.Net.Sockets.Socket" /> для связи с удаленным узлом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>завершает вызов <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Перед вызовом <xref:System.Net.Sockets.Socket.BeginAccept%2A>необходимо создать метод обратного вызова, который вызывается <xref:System.AsyncCallback> делегатом. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после того, <xref:System.Net.Sockets.Socket.BeginAccept%2A> как метод возвращает значение. Он должен принять параметр `asyncResult` , возвращенный <xref:System.Net.Sockets.Socket.BeginAccept%2A> методом.  
  
 В методе обратного вызова вызовите <xref:System.IAsyncResult.AsyncState%2A> метод `asyncResult` параметра, чтобы получить объект <xref:System.Net.Sockets.Socket> , для которого выполняется попытка подключения. После получения <xref:System.Net.Sockets.Socket>можно <xref:System.Net.Sockets.Socket.EndAccept%2A> вызвать метод для успешного завершения попытки подключения. Параметр этой перегрузки содержит данные, полученные при <xref:System.Net.Sockets.Socket.BeginAccept%2A> вызове функции, а `bytesTransferred` параметр содержит число байтов, переданных в вызове. `buffer`  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Метод блокируется до завершения подключения в очереди входящих подключений. Метод принимает входящее соединение и возвращает новый <xref:System.Net.Sockets.Socket> объект, который может использоваться для отправки и получения данных с удаленного узла. <xref:System.Net.Sockets.Socket.EndAccept%2A>  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.Sockets.Socket.BeginAccept%2A> для создания и подключения сокета, а также для принятия начальных 10 байт данных. Делегат обратного вызова <xref:System.Net.Sockets.Socket.EndAccept%2A> вызывает метод для завершения асинхронного запроса. Число переданных байтов и данные возвращаются в `buffer` параметрах и `bytesTransferred` этого метода и отображаются в консоли.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> пуст.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был создан вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ранее был вызван метод <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к объекту <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <summary>Завершает ожидающий асинхронный запрос на подключение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A>— Это блокирующий метод, который завершает асинхронный запрос на подключение к удаленному <xref:System.Net.Sockets.Socket.BeginConnect%2A> узлу, запущенный в методе.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginConnect%2A>необходимо создать метод обратного вызова, который <xref:System.AsyncCallback> реализует делегат. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginConnect%2A> возврата. Метод обратного вызова должен принять <xref:System.IAsyncResult> значение, возвращенное <xref:System.Net.Sockets.Socket.BeginConnect%2A> методом в качестве параметра.  
  
 В методе обратного вызова вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> параметра, чтобы получить объект <xref:System.Net.Sockets.Socket> , для которого выполняется попытка подключения. После получения <xref:System.Net.Sockets.Socket>можно <xref:System.Net.Sockets.Socket.EndConnect%2A> вызвать метод для успешного завершения попытки подключения.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается асинхронная попытки подключения. Полный пример, демонстрирующий асинхронную связь с сокетами, см. в статье [примеры кода для сокетов](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> был ранее вызван для асинхронного подключения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <summary>Завершает ожидающий асинхронный запрос на разъединение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>завершает вызов <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Метод блокируется до завершения отключения. Дополнительные сведения об асинхронных операциях см. в разделе Общие сведения о асинхронном программировании в библиотеке MSDN.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается сокет для асинхронного взаимодействия и данные отправляются на удаленный узел. При отправке <xref:System.Net.Sockets.Socket.Shutdown%2A> данных вызывается для завершения действия Send и Receive. Затем <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> вызывается для начала запроса на отключение. Делегат обратного вызова <xref:System.Net.Sockets.Socket.EndDisconnect%2A> вызывает метод для завершения асинхронного запроса. По завершении запроса <xref:System.Net.Sockets.Socket.Connected%2A> свойство запрашивается, чтобы проверить, отключен ли сокет.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Используется операционная система Windows 2000 или более ранняя версия, а для этого метода необходима операционная система Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> был ранее вызван для асинхронного подключения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.Net.WebException">Истекло время ожидания для запроса на разъединение.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Завершает отложенное асинхронное чтение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <summary>Завершает отложенное асинхронное чтение.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод завершает операцию асинхронного чтения, запущенную <xref:System.Net.Sockets.Socket.BeginReceive%2A> в методе. <xref:System.Net.Sockets.Socket.EndReceive%2A>  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceive%2A>необходимо создать метод обратного вызова, который <xref:System.AsyncCallback> реализует делегат. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginReceive%2A> возврата. Метод обратного вызова должен принять <xref:System.IAsyncResult> значение, возвращенное <xref:System.Net.Sockets.Socket.BeginReceive%2A> методом в качестве параметра.  
  
 В методе обратного вызова вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> класса, чтобы получить объект <xref:System.Net.Sockets.Socket.BeginReceive%2A> состояния, переданный в метод. Извлеките получение <xref:System.Net.Sockets.Socket> из этого объекта состояния. После получения объекта <xref:System.Net.Sockets.Socket>можно <xref:System.Net.Sockets.Socket.EndReceive%2A> вызвать метод для успешного завершения операции чтения и возврата числа считанных байтов.  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Метод будет блокироваться до тех пор, пока данные недоступны. Если используется протокол без установления соединения, будет <xref:System.Net.Sockets.Socket.EndReceive%2A> считывать первые поставленные в очередь датаграммы, доступные во входящем сетевом буфере. При использовании протокола, ориентированного на соединение, <xref:System.Net.Sockets.Socket.EndReceive%2A> метод будет считывать столько данных, сколько доступно до числа байтов, указанного `size` в параметре <xref:System.Net.Sockets.Socket.BeginReceive%2A> метода. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.EndReceive%2A> метод немедленно завершается и возвращает нулевые байты.  
  
 Чтобы получить полученные данные, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult>объекта и извлеките буфер, содержащийся в результирующем объекте состояния.  
  
 Чтобы отменить ожидание <xref:System.Net.Sockets.Socket.BeginReceive%2A>, <xref:System.Net.Sockets.Socket.Close%2A> вызовите метод.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается ожидание асинхронного чтения. Полный пример, демонстрирующий асинхронную связь с сокетами, см. в статье [примеры кода для сокетов](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> был ранее вызван для асинхронного чтения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <summary>Завершает отложенное асинхронное чтение.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод завершает операцию асинхронного чтения, запущенную <xref:System.Net.Sockets.Socket.BeginReceive%2A> в методе. <xref:System.Net.Sockets.Socket.EndReceive%2A>  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceive%2A>необходимо создать метод обратного вызова, который <xref:System.AsyncCallback> реализует делегат. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginReceive%2A> возврата. Метод обратного вызова должен принять <xref:System.IAsyncResult> значение, возвращенное <xref:System.Net.Sockets.Socket.BeginReceive%2A> методом в качестве параметра.  
  
 В методе обратного вызова вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> класса, чтобы получить объект <xref:System.Net.Sockets.Socket.BeginReceive%2A> состояния, переданный в метод. Извлеките получение <xref:System.Net.Sockets.Socket> из этого объекта состояния. После получения объекта <xref:System.Net.Sockets.Socket>можно <xref:System.Net.Sockets.Socket.EndReceive%2A> вызвать метод для успешного завершения операции чтения и возврата числа считанных байтов.  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A> Метод будет блокироваться до тех пор, пока данные недоступны. Если используется протокол без установления соединения, будет <xref:System.Net.Sockets.Socket.EndReceive%2A> считывать первые поставленные в очередь датаграммы, доступные во входящем сетевом буфере. При использовании протокола, ориентированного на соединение, <xref:System.Net.Sockets.Socket.EndReceive%2A> метод будет считывать столько данных, сколько доступно до числа байтов, указанного `size` в параметре <xref:System.Net.Sockets.Socket.BeginReceive%2A> метода. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.EndReceive%2A> метод немедленно завершается и возвращает нулевые байты.  
  
 Чтобы получить полученные данные, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult>объекта и извлеките буфер, содержащийся в результирующем объекте состояния.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> был ранее вызван для асинхронного чтения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="endPoint">Источник <see cref="T:System.Net.EndPoint" />.</param>
        <param name="end_point">Источник <see cref="T:System.Net.EndPoint" />.</param>
        <summary>Завершает отложенное асинхронное чтение с определенной конечной точки.</summary>
        <returns>Количество полученных байтов, если операция успешно выполнена. Возвращает значение 0, если операция завершилась неудачей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод завершает операцию асинхронного чтения, запущенную <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> в методе. <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>необходимо создать метод обратного вызова, который <xref:System.AsyncCallback> реализует делегат. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> возврата. Метод обратного вызова должен принять <xref:System.IAsyncResult> значение, возвращенное <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> методом в качестве параметра.  
  
 В методе обратного вызова вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> класса, чтобы получить объект <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> состояния, переданный в метод. Извлеките получение <xref:System.Net.Sockets.Socket> из этого объекта состояния. После получения объекта <xref:System.Net.Sockets.Socket>можно <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> вызвать метод для успешного завершения операции чтения и возврата числа считанных байтов.  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Метод будет блокироваться до тех пор, пока данные недоступны. Если используется протокол без установления соединения, будет <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> считывать первые поставленные в очередь датаграммы, доступные во входящем сетевом буфере. При использовании протокола, ориентированного на соединение, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> метод будет считывать столько данных, сколько доступно до числа байтов, указанного `size` в параметре <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> метода. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> метод немедленно завершается и возвращает нулевые байты. Чтобы получить полученные данные, вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> объекта и извлеките буфер, содержащийся в результирующем объекте состояния. Чтобы найти исходный узел, извлеките <xref:System.Net.EndPoint> и приведите его <xref:System.Net.IPEndPoint>к типу. Используйте метод, чтобы получить IP-адрес <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> и метод для получения номера порта. <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается ожидание асинхронного чтения из <xref:System.Net.EndPoint>указанного.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> был ранее вызван для асинхронного чтения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="socketFlags">Поразрядное сочетание значений перечисления <see cref="T:System.Net.Sockets.SocketFlags" /> для принятого пакета.</param>
        <param name="endPoint">Источник <see cref="T:System.Net.EndPoint" />.</param>
        <param name="ipPacketInformation">Объект <see cref="T:System.Net.IPAddress" /> и интерфейс полученного пакета.</param>
        <summary>Завершает отложенное асинхронное чтение с определенной конечной точки. Этот метод также показывает больше информации о пакете, чем метод <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</summary>
        <returns>Количество полученных байтов, если операция успешно выполнена. Возвращает значение 0, если операция завершилась неудачей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если операция не завершена, этот метод блокируется до тех пор, пока он не завершится.  
  
 Чтобы выполнить эту операцию синхронно, используйте <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> метод.  
  
 Проверьте `ipPacketInformation` , нужно ли узнать, была ли датаграмма отправлена с помощью одноадресного, многоадресного или широковещательного адреса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> равно <see langword="null" />  
  
-или- 
 <paramref name="endPoint" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> был ранее вызван для асинхронного чтения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Завершает отложенную операцию асинхронной передачи.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, хранящий сведения о состоянии этой асинхронной операции.</param>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, хранящий сведения о состоянии этой асинхронной операции.</param>
        <summary>Завершает отложенную операцию асинхронной передачи.</summary>
        <returns>Если операция завершилась успешно — значение количества байтов, переданных в объект <see cref="T:System.Net.Sockets.Socket" />; в противном случае — ошибка, указывающая на недопустимость объекта <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A>завершает операцию асинхронной отправки, запущенную <xref:System.Net.Sockets.Socket.BeginSend%2A>в.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>необходимо создать метод обратного вызова, который <xref:System.AsyncCallback> реализует делегат. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginSend%2A> возврата. Метод обратного вызова должен принять <xref:System.IAsyncResult> значение, возвращенное <xref:System.Net.Sockets.Socket.BeginSend%2A> методом в качестве параметра.  
  
 В методе обратного вызова вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> параметра, чтобы получить отправку <xref:System.Net.Sockets.Socket>. После получения объекта <xref:System.Net.Sockets.Socket>можно <xref:System.Net.Sockets.Socket.EndSend%2A> вызвать метод для успешного завершения операции отправки и возврата числа отправленных байтов.  
  
 Если используется протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndSend%2A> будет блокироваться до отправки датаграммы. При использовании протокола, ориентированного на соединение, <xref:System.Net.Sockets.Socket.EndSend%2A> блокируется до отправки некоторых буферов. Если возвращаемое значение из <xref:System.Net.Sockets.Socket.EndSend%2A> указывает, что буфер не был полностью отправлен, <xref:System.Net.Sockets.Socket.BeginSend%2A> вызовите метод еще раз, изменив буфер для хранения неотправленных данных.  
  
 Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.BeginSend%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается отложенная асинхронная отправка.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> был ранее вызван для асинхронной передачи.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, хранящий сведения о состоянии этой асинхронной операции.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <summary>Завершает отложенную операцию асинхронной передачи.</summary>
        <returns>Если операция завершилась успешно — значение количества байтов, переданных в объект <see cref="T:System.Net.Sockets.Socket" />; в противном случае — ошибка, указывающая на недопустимость объекта <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A>завершает операцию асинхронной отправки, запущенную <xref:System.Net.Sockets.Socket.BeginSend%2A>в.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginSend%2A>необходимо создать метод обратного вызова, который <xref:System.AsyncCallback> реализует делегат. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginSend%2A> возврата. Метод обратного вызова должен принять <xref:System.IAsyncResult> значение, возвращенное <xref:System.Net.Sockets.Socket.BeginSend%2A> методом в качестве параметра.  
  
 В методе обратного вызова вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> параметра, чтобы получить отправку <xref:System.Net.Sockets.Socket>. После получения объекта <xref:System.Net.Sockets.Socket>можно <xref:System.Net.Sockets.Socket.EndSend%2A> вызвать метод для успешного завершения операции отправки и возврата числа отправленных байтов.  
  
 Если используется протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndSend%2A> будет блокироваться до отправки датаграммы. При использовании протокола, ориентированного на соединение, <xref:System.Net.Sockets.Socket.EndSend%2A> блокируется до отправки некоторых буферов. Если возвращаемое значение из <xref:System.Net.Sockets.Socket.EndSend%2A> указывает, что буфер не был полностью отправлен, <xref:System.Net.Sockets.Socket.BeginSend%2A> вызовите метод еще раз, изменив буфер для хранения неотправленных данных.  
  
 Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.BeginSend%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Все операции ввода-вывода, инициированные данным потоком, отменяются при выходе из этого потока. Незавершенная асинхронная операция может завершиться ошибкой, если поток завершается до завершения операции.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> был ранее вызван для асинхронной передачи.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, хранящий сведения о состоянии этой асинхронной операции.</param>
        <summary>Завершает отложенную операцию асинхронной передачи файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A>завершает операцию асинхронной отправки, запущенную <xref:System.Net.Sockets.Socket.BeginSendFile%2A>в.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginSendFile%2A>необходимо создать метод обратного вызова, <xref:System.AsyncCallback> реализующий делегат. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginSendFile%2A> возврата. Метод обратного вызова должен принимать <xref:System.IAsyncResult> объект <xref:System.Net.Sockets.Socket.BeginSendFile%2A> , возвращаемый методом, в качестве параметра.  
  
 В методе обратного вызова вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> параметра, чтобы получить отправку <xref:System.Net.Sockets.Socket>. После получения <xref:System.Net.Sockets.Socket>можно <xref:System.Net.Sockets.Socket.EndSendFile%2A> вызвать метод для успешного завершения операции Send.  
  
 Если используется протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndSendFile%2A> блокируется до отправки датаграммы. Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.EndSendFile%2A> блокируется до отправки всего файла. Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.BeginSendFile%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода создает и подключает сокет для асинхронного взаимодействия и начинает асинхронно отправлять файл "Text. txt" на удаленный узел. Вызовы <xref:System.Net.Sockets.Socket.EndSendFile%2A> делегата обратного вызова для завершения передачи.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows NT.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> пуст.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> был ранее вызван для асинхронной передачи объекта <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <param name="result">Объект <see cref="T:System.IAsyncResult" />, в котором хранятся сведения о состоянии и любые данные, определенные пользователем, для этой асинхронной операции.</param>
        <summary>Завершает отложенную операцию асинхронной отправки в определенное местоположение.</summary>
        <returns>Если операция завершилась успешно — значение количества отправленных байтов; в противном случае — ошибка, указывающая на недопустимость объекта <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A>завершает операцию асинхронной отправки, запущенную <xref:System.Net.Sockets.Socket.BeginSendTo%2A>в.  
  
 Перед вызовом <xref:System.Net.Sockets.Socket.BeginSendTo%2A>необходимо создать метод обратного вызова, который <xref:System.AsyncCallback> реализует делегат. Этот метод обратного вызова выполняется в отдельном потоке и вызывается системой после <xref:System.Net.Sockets.Socket.BeginReceive%2A> возврата. Метод обратного вызова должен принять <xref:System.IAsyncResult> значение, возвращенное <xref:System.Net.Sockets.Socket.BeginSendTo%2A> методом в качестве параметра.  
  
 В методе обратного вызова вызовите <xref:System.IAsyncResult.AsyncState%2A> метод <xref:System.IAsyncResult> параметра, чтобы получить отправку <xref:System.Net.Sockets.Socket>. После получения объекта <xref:System.Net.Sockets.Socket>можно <xref:System.Net.Sockets.Socket.EndSendTo%2A> вызвать метод для успешного завершения операции отправки и возврата числа отправленных байтов.  
  
 Если используется протокол без установления соединения, <xref:System.Net.Sockets.Socket.EndSendTo%2A> будет блокироваться до отправки датаграммы. Если используется протокол, ориентированный на подключение, <xref:System.Net.Sockets.Socket.EndSendTo%2A> будет блокироваться до отправки запрошенного числа байтов. Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.BeginSendTo%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода завершается асинхронная отправка в определенное расположение.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="asyncResult" /> не был возвращен вызовом метода <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> был ранее вызван для асинхронной передачи.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, разрешает ли объект <see cref="T:System.Net.Sockets.Socket" /> привязку к порту только одного процесса.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> разрешает привязку только одного сокета к определенному порту; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" /> для Windows Server 2003 и Windows XP с пакетом обновления 2 (SP2), а <see langword="false" /> также для всех остальных версий.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> имеет `false`значение, то <xref:System.Net.Sockets.Socket.Bind%2A> несколько сокетов могут использовать метод для привязки к определенному порту, однако только один из них может выполнять операции с сетевым трафиком, отправляемым на порт. Если несколько сокетов пытаются использовать <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> метод для привязки к определенному порту, то один из них с более конкретным IP-адресом будет работать с сетевым трафиком, отправляемым на этот порт.  
  
 Если <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> имеет `true`значение <xref:System.Net.Sockets.Socket.Bind%2A> , <xref:System.Net.Sockets.Socket.Bind%2A>  то первое использование метода для попытки привязки к определенному порту, независимо от IP-адреса, будет выполняться удачно; все последующие попытки использования метода для привязки к этому порту будут сбой до уничтожения исходного привязанного сокета.  
  
 Это свойство должно быть задано <xref:System.Net.Sockets.Socket.Bind%2A> до вызова метода. <xref:System.InvalidOperationException> в противном случае будет выдано исключение.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> вызван для этого объекта <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает ресурсы, используемые классом <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Финализатор класса вызывает метод, чтобы закрыть <xref:System.Net.Sockets.Socket> и свободные ресурсы, <xref:System.Net.Sockets.Socket>связанные с. <xref:System.Net.Sockets.Socket.Close%2A> <xref:System.Net.Sockets.Socket>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-значение для экземпляра <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Целочисленное хэш-значение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Метод GetHashCode возвращает хэш-код этого экземпляра. Это значение можно использовать в качестве ключа в хэш-таблицах.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение параметра <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <summary>Возвращает значение указанного параметра <see cref="T:System.Net.Sockets.Socket" />, представленного в виде объекта.</summary>
        <returns>Объект, который представляет значение параметра. Когда для параметра <paramref name="optionName" /> установлено значение <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />, возвращаемое значение является экземпляром класса <see cref="T:System.Net.Sockets.LingerOption" />. Когда для параметра <paramref name="optionName" /> задано значение <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> или <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, возвращаемое значение является экземпляром класса <see cref="T:System.Net.Sockets.MulticastOption" />. Когда для параметра <paramref name="optionName" /> задано любое другое значение, возвращаемое значение является целым числом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>параметры определяют поведение текущего <xref:System.Net.Sockets.Socket>объекта. Используйте эту перегрузку для <xref:System.Net.Sockets.SocketOptionName.Linger>получения <xref:System.Net.Sockets.SocketOptionName.AddMembership>параметров, <xref:System.Net.Sockets.SocketOptionName.DropMembership> и <xref:System.Net.Sockets.Socket> . Для параметра используйте <xref:System.Net.Sockets.Socket> для `optionLevel` параметра. <xref:System.Net.Sockets.SocketOptionName.Linger> Для <xref:System.Net.Sockets.SocketOptionName.AddMembership> и <xref:System.Net.Sockets.SocketOptionName.DropMembership>используйте . <xref:System.Net.Sockets.SocketOptionLevel.IP> Если вы хотите задать значение любого из перечисленных выше параметров, используйте <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.Sockets.LingerOption> извлекаются <xref:System.Net.Sockets.Socket.Send%2A> значения времени ожидания и отображаются в консоли.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.  
  
- или - 
 Для параметра <paramref name="optionName" /> было установлено неподдерживаемое значение <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Массив типа <see cref="T:System.Byte" />, который используется для отправки значения параметра.</param>
        <summary>Возвращает указанное значение параметра <see cref="T:System.Net.Sockets.Socket" />, представленного в виде байтового массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>параметры определяют поведение текущего <xref:System.Net.Sockets.Socket>объекта. После успешного завершения этого метода массив, заданный `optionValue` параметром, содержит значение указанного <xref:System.Net.Sockets.Socket> параметра.  
  
 Если длина `optionValue` массива меньше, чем число байтов, необходимых для хранения значения указанного <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.SocketException>параметра, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> вызывает исключение. Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки. Используйте эту перегрузку для всех сокетов, представленных логическими значениями или целыми числами.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.Sockets.LingerOption> извлекаются <xref:System.Net.Sockets.Socket.Send%2A> значения времени ожидания и отображаются в консоли.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.  
  
-или- 
В приложениях .NET Compact Framework для размера буферного пространства Windows CE установлено по умолчанию значение 32768 байт. Можно изменить размер буферного пространства сокета, вызвав свойство <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionLength">Длина ожидаемого возвращаемого значения, указанная в байтах.</param>
        <summary>Возвращает значение указанного параметра <see cref="T:System.Net.Sockets.Socket" /> в массиве.</summary>
        <returns>Массив типа <see cref="T:System.Byte" />, который содержит значение параметра сокета.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength` Параметр задает максимальный размер возвращаемого массива байтов. Если значение параметра требует меньше байт, массив будет содержать только столько байтов. Если значение параметра требует больше байтов, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> то вызовет <xref:System.Net.Sockets.SocketException>исключение. Используйте эту перегрузку для всех сокетов, представленных логическими значениями или целыми числами.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.Sockets.LingerOption> извлекаются <xref:System.Net.Sockets.Socket.Send%2A> значения времени ожидания и отображаются в консоли.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.  
  
-или- 
В приложениях .NET Compact Framework для размера буферного пространства Windows CE установлено по умолчанию значение 32768 байт. Можно изменить размер буферного пространства сокета, вызвав свойство <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает дескриптор операционной системы для объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Объект <see cref="T:System.IntPtr" />, представляющий дескриптор операционной системы для <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает низкоуровневые операционные режимы для объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Значение <see cref="T:System.Int32" />, задающее код элемента управления для выполняемой операции.</param>
        <param name="optionInValue">Массив <see cref="T:System.Byte" />, который содержит входные данные, необходимые для операции.</param>
        <param name="optionOutValue">Массив <see cref="T:System.Byte" />, который содержит выходные данные, необходимые для операции.</param>
        <summary>Задает низкоуровневые операционные режимы для объекта <see cref="T:System.Net.Sockets.Socket" />, используя цифровые коды элементов управления.</summary>
        <returns>Число байтов в параметре <paramref name="optionOutValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод предоставляет низкоуровневый доступ к операционной системе <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket> , лежащей в основе текущего экземпляра класса. <xref:System.Net.Sockets.Socket.IOControl%2A> Дополнительные сведения см. в документации по [всаиоктл](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) .  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода сравниваются результаты ФИОНРЕАД и доступного свойства.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Была сделана попытка изменения блокирующего режима без использования свойства <see cref="P:System.Net.Sockets.Socket.Blocking" />.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для выполнения неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Значение <see cref="T:System.Net.Sockets.IOControlCode" />, задающее код элемента управления для выполняемой операции.</param>
        <param name="optionInValue">Массив типа <see cref="T:System.Byte" />, который содержит входные данные, необходимые для операции.</param>
        <param name="optionOutValue">Массив типа <see cref="T:System.Byte" />, который содержит выходные данные, возвращенные операцией.</param>
        <summary>Задает низкоуровневые операционные режимы для объекта <see cref="T:System.Net.Sockets.Socket" />, используя перечисление <see cref="T:System.Net.Sockets.IOControlCode" />, чтобы указать коды элементов управления.</summary>
        <returns>Число байтов в параметре <paramref name="optionOutValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обеспечивает низкоуровневый доступ к операционной системе <xref:System.Net.Sockets.Socket> , лежащей в основе текущего экземпляра <xref:System.Net.Sockets.Socket> класса. Дополнительные сведения см. в документации по [всаиоктл](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl) .  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода сравниваются результаты вызова метода <xref:System.Net.Sockets.Socket.IOControl%2A> с <xref:System.Net.Sockets.IOControlCode.DataToRead> и <xref:System.Net.Sockets.Socket.Available%2A> свойства.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Была сделана попытка изменения блокирующего режима без использования свойства <see cref="P:System.Net.Sockets.Socket.Blocking" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для выполнения неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, привязан ли объект <see cref="T:System.Net.Sockets.Socket" /> к конкретному локальному порту.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> привязан к локальному порту; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сокет считается привязанным к локальному порту <xref:System.Net.Sockets.Socket.Bind%2A> , если он явно привязан путем вызова метода или неявно привязан путем вызова членов, таких как <xref:System.Net.Sockets.Socket.Connect%2A>, или <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>которые используют временный локальный порт (свободный порт больше, чем 1024, выбранная операционной системой.) Серверы используют <xref:System.Net.Sockets.Socket.Bind%2A> метод для привязки к хорошо известному порту, чтобы клиенты могли подключаться к ним.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.IsBound%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли объект <see cref="T:System.Net.Sockets.Socket" /> задерживать закрытие сокета при попытке отправки всех отложенных данных.</summary>
        <value>Объект <see cref="T:System.Net.Sockets.LingerOption" />, указывающий задержку при закрытии сокета.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство изменяет способ <xref:System.Net.Sockets.Socket.Close%2A> , которым ведет себя метод. <xref:System.Net.Sockets.Socket.LingerState%2A> Это свойство задается при изменении условий, при которых подключение может быть сброшено с помощью Winsock. Сброс соединения по-прежнему может происходить в зависимости от поведения протокола IP.  
  
 Это свойство управляет длительностью времени, в течение которого соединение, ориентированное на соединение, остается открытым после вызова <xref:System.Net.Sockets.Socket.Close%2A> , когда данные остаются для отправки.  
  
 При вызове методов для отправки данных одноранговой сети эти данные помещаются в исходящий сетевой буфер. Это свойство можно использовать, чтобы убедиться, что эти данные отправляются на удаленный узел перед <xref:System.Net.Sockets.TcpClient.Close%2A> тем, как метод удалит подключение.  
  
 Чтобы включить ожидание, создайте <xref:System.Net.Sockets.LingerOption> экземпляр, содержащий нужные значения, и <xref:System.Net.Sockets.Socket.LingerState%2A> присвойте свойству значение этого экземпляра.  
  
 В следующей таблице описывается <xref:System.Net.Sockets.Socket.Close%2A> поведение метода для возможных значений <xref:System.Net.Sockets.LingerOption.Enabled%2A> свойства и <xref:System.Net.Sockets.LingerOption.LingerTime%2A> свойство, хранящееся в <xref:System.Net.Sockets.Socket.LingerState%2A> свойстве.  
  
|Линжерстате. Enabled|Линжерстате. Линжертиме|Поведение|  
|-------------------------|----------------------------|--------------|  
|`false`(отключено), значение по умолчанию|Время ожидания неприменимо (по умолчанию).|Пытается отправить ожидающие данные до истечения времени ожидания протокола IP по умолчанию.|  
|`true`доступной|Ненулевое время ожидания|Пытается отправить ожидающие данные до истечения заданного времени ожидания. Если попытка не удалась, Winsock сбрасывает подключение.|  
|`true`доступной|Нулевое время ожидания.|Отменяет все ожидающие данные. Для сокета, ориентированного на подключение (например, TCP), Winsock сбрасывает подключение.|  
  
 В стеке IP-адресов используется период ожидания протокола IP по умолчанию, используемый в зависимости от времени кругового пути соединения. В большинстве случаев время ожидания, вычисленное стеком, больше релевантно, чем определено приложением. Это поведение по умолчанию для сокета, если <xref:System.Net.Sockets.Socket.LingerState%2A> свойство не задано.  
  
 Если свойство, хранящееся в свойстве, задано больше, чем время ожидания протокола IP по умолчанию, по умолчанию время ожидания протокола IP по-прежнему будет применяться и переопределено. <xref:System.Net.Sockets.Socket.LingerState%2A> <xref:System.Net.Sockets.LingerOption.LingerTime%2A>  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.LingerState%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Максимальная длина очереди ожидающих подключений.</param>
        <summary>Устанавливает объект <see cref="T:System.Net.Sockets.Socket" /> в состояние прослушивания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A>вызывает ориентированный <xref:System.Net.Sockets.Socket> на соединение объект для прослушивания входящих попыток подключения. `backlog` Параметр указывает число входящих подключений, которые могут быть поставлены в очередь на принятие. Чтобы определить максимальное количество подключений, которое можно указать, извлеките <xref:System.Net.Sockets.SocketOptionName.MaxConnections> значение. <xref:System.Net.Sockets.Socket.Listen%2A>не блокируется.  
  
 Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки. Используйте <xref:System.Net.Sockets.Socket.Accept%2A> или <xref:System.Net.Sockets.Socket.BeginAccept%2A>  для принятия подключения из очереди.  
  
> [!NOTE]
>  Необходимо вызвать <xref:System.Net.Sockets.Socket.Bind%2A> метод перед вызовом <xref:System.Net.Sockets.Socket.Listen%2A>метода или <xref:System.Net.Sockets.Socket.Listen%2A> будет вызывать исключение <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Параметр невыполненной работы ограничен различными значениями в зависимости от операционной системы. Вы можете указать более высокое значение, но невыполненная работа будет ограничена в зависимости от операционной системы.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.Sockets.Socket> для прослушивания входящих подключений.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает локальную конечную точку.</summary>
        <value>Объект <see cref="T:System.Net.EndPoint" />, который объект <see cref="T:System.Net.Sockets.Socket" /> использует для взаимодействий.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство получает объект <xref:System.Net.EndPoint> , содержащий локальный IP-адрес и номер <xref:System.Net.Sockets.Socket> порта, к которым привязана привязка. <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Перед извлечением любой <xref:System.Net.EndPoint> информации необходимо <xref:System.Net.IPEndPoint> привести его к типу. Затем можно вызвать <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> метод, чтобы получить локальный <xref:System.Net.IPAddress>объект, и <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> метод для получения номера локального порта.  
  
 Свойство обычно задается после выполнения вызова <xref:System.Net.Sockets.Socket.Bind%2A> метода. <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Если разрешить системе назначать локальный IP-адрес сокета и номер порта, это <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> свойство будет установлено после первой операции ввода-вывода. Для протоколов, ориентированных на соединение, первая операция ввода-вывода будет вызывать <xref:System.Net.Sockets.Socket.Connect%2A> метод или. <xref:System.Net.Sockets.Socket.Accept%2A> Для протоколов без подключения первая операция ввода-вывода будет иметь любой из вызовов Send или Receive.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода извлекаются и отображаются локальные и удаленные конечные точки.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, могут ли доставляться исходящие пакеты многоадресной рассылки в передающем приложении.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> получает исходящие пакеты многоадресной рассылки; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Многоадресная рассылка — это масштабируемый метод для связи "многие ко многим" в Интернете. Процесс подписывается на адрес многоадресной рассылки; Затем все пакеты, отправленные подписанным процессом, получаются любым другим процессом, подписанным на адрес многоадресной рассылки.  
  
 Установка этого свойства для сокета протокола TCP не будет действовать.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <see cref="T:System.Boolean" />, указывающее, используется ли поток <see cref="T:System.Net.Sockets.Socket" /> в алгоритме Nagle.</summary>
        <value>Значение <see langword="false" />, если объект <see cref="T:System.Net.Sockets.Socket" /> использует алгоритм Nagle; в противном случае — значение <see langword="true" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Алгоритм Nagle предназначен для уменьшения сетевого трафика, вызывая буферизацию небольших пакетов через сокет, а затем объединять и отсылать их в одном пакете при определенных обстоятельствах. Пакет TCP состоит из 40 байт заголовка и отправляемых данных. Когда небольшие пакеты данных отправляются по протоколу TCP, накладные расходы, полученные из заголовка TCP, могут стать значительным частью сетевого трафика. В сильно загруженных сетях перегрузка, полученная в результате этой дополнительной нагрузки, может привести к потере датаграмм и повторных передач, а также к чрезмерному времени распространения, вызванному перегрузкой. Алгоритм Nagle запрещает отправку новых TCP-сегментов при поступлении новых исходящих данных от пользователя, если все ранее переданные подключения не подтверждены.  
  
 Большинство сетевых приложений должны использовать алгоритм Nagle.  
  
 Задание этого свойства для сокета UDP не будет действовать.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.NoDelay%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к объекту <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, поддерживают ли основная операционная система и сетевые адаптеры протокол IPv4.</summary>
        <value>Значение <see langword="true" />, если основная операционная система и сетевые адаптеры поддерживают протокол IPv4; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операционная система может поддерживать протоколы IPv4 и IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, поддерживают ли основная операционная система и сетевые адаптеры протокол IPv6.</summary>
        <value>Значение <see langword="true" />, если основная операционная система и сетевые адаптеры поддерживают протокол IPv6; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операционная система может поддерживать протоколы IPv4 и IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="microSeconds">Время ожидания ответа, заданное в микросекундах.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Net.Sockets.SelectMode" />.</param>
        <summary>Определяет состояние объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Состояние объекта <see cref="T:System.Net.Sockets.Socket" />, основанное на значении режима опроса, переданного в параметре <paramref name="mode" />.  
  
 <list type="table"><listheader><term> Режим 
 </term><description> Возвращаемое значение 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description>Значение <see langword="true" />, если был вызван метод <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> и подключение отложено; 
- или - 
 Значение <see langword="true" />, если данные доступны для чтения; 
- или - 
 Значение <see langword="true" />, если подключение закрыто, сброшено или завершено. 
В противном случае, возвращает значение <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description>Значение <see langword="true" />, если обработка метода <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> и подключения завершились успешно; 
-или- 
 Значение <see langword="true" />, если данные могут быть посланы; 
В противном случае, возвращает значение <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description>Значение <see langword="true" />, если не блокируется обработка метода <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> и попытка подключения завершилась неудачей; 
- или - 
 Значение <see langword="true" />, если не установлен объект <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> и доступны экстренные данные; 
В противном случае, возвращает значение <see langword="false" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод проверит состояние  <xref:System.Net.Sockets.Socket> объекта.  <xref:System.Net.Sockets.Socket.Poll%2A> Укажите <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket> для параметра, чтобы определить, является ли объект доступным для чтения. `selectMode` Укажите <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> , чтобы определить, <xref:System.Net.Sockets.Socket> является ли объект доступным для записи. Используйте <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> для обнаружения состояния ошибки. <xref:System.Net.Sockets.Socket.Poll%2A>будет блокировать выполнение до указанного периода времени, измеряемого в `microseconds`, истекает. Если вы хотите ждать ответа в течение неограниченного времени, задайте для параметра отрицательное целое число. `microSeconds` Если вы хотите проверить состояние нескольких сокетов, вы можете использовать <xref:System.Net.Sockets.Socket.Select%2A> метод.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Этот метод не может обнаружить некоторые виды проблем с подключением, например обрыв сетевого кабеля или некорректное завершение работы удаленного узла. Необходимо попытаться отправить или получить данные для обнаружения ошибок этих типов.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается сокет, подключается к серверу и используется <xref:System.Net.Sockets.Socket.Poll%2A> для проверки состояния сокета.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Параметр <paramref name="mode" /> не является одним из значений <see cref="T:System.Net.Sockets.SelectMode" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. примечания ниже.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип протокола объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Net.Sockets.ProtocolType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство задается <xref:System.Net.Sockets.Socket> при создании и указывает протокол, <xref:System.Net.Sockets.Socket>используемый этим свойством. <xref:System.Net.Sockets.Socket.ProtocolType%2A>  
  
   
  
## Examples  
 В следующем примере кода в консоль <xref:System.Net.Sockets.AddressFamily>выводятся <xref:System.Net.Sockets.ProtocolType> , <xref:System.Net.Sockets.SocketType>и.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <summary>Возвращает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Метод считывает данные в параметр buffer и возвращает число успешно считанных байтов. Вы можете вызывать <xref:System.Net.Sockets.Socket.Receive%2A> из сокетов, ориентированных на подключение, и без подключения.  
  
 Эта перегрузка требует только предоставления буфера приема. По умолчанию смещение буфера равно 0, размер по умолчанию равен длине параметра buffer, а <xref:System.Net.Sockets.SocketFlags> значение по умолчанию <xref:System.Net.Sockets.SocketFlags.None>—.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> , чтобы установить соединение с удаленным узлом, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод будет считывать только данные, поступающие с удаленного узла, <xref:System.Net.Sockets.Socket.Connect%2A> установленного в методе или. <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.Receive%2A> Если используется протокол без подключения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>позволяет принимать данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод будет блокироваться до тех пор, пока данные не будут доступны, если только значение времени ожидания не было задано с помощью. <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов <xref:System.Net.Sockets.SocketException>выдаст исключение. Если вы используете неблокирующий режим и в буфере <xref:System.Net.Sockets.Socket.Receive%2A> стека протокола нет доступных данных, метод будет завершен немедленно и <xref:System.Net.Sockets.SocketException>создаст исключение. Чтобы определить, доступны <xref:System.Net.Sockets.Socket.Available%2A> ли данные для чтения, можно использовать свойство. Если <xref:System.Net.Sockets.Socket.Available%2A> имеет ненулевое значение, повторите операцию получения.  
  
 Если используется ориентированный <xref:System.Net.Sockets.Socket>на соединение объект <xref:System.Net.Sockets.Socket.Receive%2A> , метод будет считывать столько данных, сколько доступно, вплоть до размера буфера. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.Receive%2A> метод немедленно завершается и возвращает нулевые байты.  
  
 Если используется без подключения <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> то считывает первую датаграмму в очереди из <xref:System.Net.Sockets.Socket.Connect%2A> адреса назначения, указанного в методе. Если полученная датаграмма превышает размер `buffer` параметра, `buffer` она заполняется первой частью сообщения, лишние <xref:System.Net.Sockets.SocketException> данные теряются и создается исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода получает данные на подключенном <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих полученные данные.</param>
        <summary>Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в список приемных буферов.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает данные в параметр Buffers и возвращает число успешно считанных байтов. Вы можете вызывать из сокетов, ориентированных на подключение, и без подключения.  
  
 Эта перегрузка требует предоставления одного или нескольких буферов приема.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> , чтобы установить соединение с удаленным узлом, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод будет считывать только данные, поступающие из соединения с удаленным узлом, <xref:System.Net.Sockets.Socket.Connect%2A> установленного в методе или  <xref:System.Net.Sockets.Socket.Accept%2A> . <xref:System.Net.Sockets.Socket.Receive%2A> Если используется протокол без подключения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>позволяет принимать данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод будет блокироваться до тех пор, пока данные не будут доступны, если только значение времени ожидания не было задано с помощью. <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов <xref:System.Net.Sockets.SocketException>выдаст исключение. Если вы используете неблокирующий режим и в буфере <xref:System.Net.Sockets.Socket.Receive%2A> стека протокола нет доступных данных, метод будет завершен немедленно и <xref:System.Net.Sockets.SocketException>создаст исключение. Чтобы определить, доступны <xref:System.Net.Sockets.Socket.Available%2A> ли данные для чтения, можно использовать свойство. Если <xref:System.Net.Sockets.Socket.Available%2A> имеет ненулевое значение, повторите операцию получения.  
  
 Если используется ориентированный <xref:System.Net.Sockets.Socket>на соединение объект <xref:System.Net.Sockets.Socket.Receive%2A> , метод будет считывать столько данных, сколько доступно, вплоть до размера буфера. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.Receive%2A> метод немедленно завершается и возвращает нулевые байты.  
  
 Если вы используете бесустановленное соединение <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первые поставленные в очередь датаграммы с <xref:System.Net.Sockets.Socket.Connect%2A> адреса назначения, указанного в методе. Если полученная датаграмма превышает размер `buffers` параметра, `buffers` она заполняется первой частью сообщения, лишние <xref:System.Net.Sockets.SocketException> данные теряются и создается исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
 **Примечание** . Этот элемент выводит данные трассировки при включении трассировки сети в приложении. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Метод считывает данные в параметр buffer и возвращает число успешно считанных байтов. Вы можете вызывать <xref:System.Net.Sockets.Socket.Receive%2A> из сокетов, ориентированных на подключение, и без подключения.  
  
 Эта перегрузка требует только предоставить буфер приема и необходимый <xref:System.Net.Sockets.SocketFlags>. По умолчанию смещение буфера равно 0, а размер по умолчанию равен длине параметра Byte.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> , чтобы установить соединение с удаленным узлом, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод будет считывать только данные, поступающие с удаленного узла, <xref:System.Net.Sockets.Socket.Connect%2A> установленного в методе или. <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.Receive%2A> Если используется протокол без подключения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>позволяет принимать данные, поступающие с любого узла.  
  
 Если данные для чтения недоступны, <xref:System.Net.Sockets.Socket.Receive%2A> метод блокируется до тех пор, пока данные не будут доступны. Если вы используете режим без блокировки и в буфере стека протоколов нет доступных данных, <xref:System.Net.Sockets.Socket.Receive%2A> метод будет выполнен немедленно и <xref:System.Net.Sockets.SocketException>выдаст исключение. Чтобы определить, доступны <xref:System.Net.Sockets.Socket.Available%2A> ли данные для чтения, можно использовать свойство. Если <xref:System.Net.Sockets.Socket.Available%2A> имеет ненулевое значение, повторите операцию получения.  
  
 Если используется ориентированный <xref:System.Net.Sockets.Socket>на соединение объект <xref:System.Net.Sockets.Socket.Receive%2A> , метод будет считывать столько данных, сколько доступно до размера буфера. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.Receive%2A> метод немедленно завершается и возвращает нулевые байты.  
  
 Если вы используете бесустановленное соединение <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первые поставленные в очередь датаграммы с <xref:System.Net.Sockets.Socket.Connect%2A> адреса назначения, указанного в методе. Если полученная датаграмма превышает размер `buffer` параметра, `buffer` она заполняется первой частью сообщения, лишние <xref:System.Net.Sockets.SocketException> данные теряются и создается исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода задается буфер данных и <xref:System.Net.Sockets.SocketFlags> для приема данных на подключенном <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих полученные данные.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в список приемных буферов, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает данные в `buffers` параметр и возвращает число успешно считанных байтов. Вы можете вызывать из сокетов, ориентированных на подключение, и без подключения.  
  
 Эта перегрузка требует предоставления одного или нескольких буферов приема. Значение по умолчанию  <xref:System.Net.Sockets.SocketFlags.None> —.  <xref:System.Net.Sockets.SocketFlags>  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> , чтобы установить соединение с удаленным узлом, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод будет считывать только данные, поступающие из соединения с удаленным узлом, <xref:System.Net.Sockets.Socket.Connect%2A> установленного в методе или  <xref:System.Net.Sockets.Socket.Accept%2A> . <xref:System.Net.Sockets.Socket.Receive%2A> Если используется протокол без подключения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>позволяет принимать данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод будет блокироваться до тех пор, пока данные не будут доступны, если только значение времени ожидания не было задано с помощью. <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов <xref:System.Net.Sockets.SocketException>создает исключение. Если вы используете неблокирующий режим и в буфере <xref:System.Net.Sockets.Socket.Receive%2A> стека протокола нет доступных данных, метод будет завершен немедленно и <xref:System.Net.Sockets.SocketException>создаст исключение. Чтобы определить, доступны <xref:System.Net.Sockets.Socket.Available%2A> ли данные для чтения, можно использовать свойство. Если <xref:System.Net.Sockets.Socket.Available%2A> имеет ненулевое значение, повторите операцию получения.  
  
 Если используется ориентированный <xref:System.Net.Sockets.Socket>на соединение объект <xref:System.Net.Sockets.Socket.Receive%2A> , метод будет считывать столько данных, сколько доступно, вплоть до размера буфера. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.Receive%2A> метод немедленно завершается и возвращает нулевые байты.  
  
 Если вы используете бесустановленное соединение <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> будет считывать первые поставленные в очередь датаграммы с <xref:System.Net.Sockets.Socket.Connect%2A> адреса назначения, указанного в методе. Если полученная датаграмма превышает размер `buffers` параметра, `buffers` она заполняется первой частью сообщения, лишние <xref:System.Net.Sockets.SocketException> данные теряются и создается исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как получить данные на подключенном <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffers" /> имеет значение <see langword="null" />.  
  
-или- 
 Значение <paramref name="buffers" />. Отсчет равен нулю.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Получает указанное число байтов данных из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод считывает данные `buffer` в параметр и возвращает число успешно считанных байтов. <xref:System.Net.Sockets.Socket.Receive%2A> Вы можете вызывать <xref:System.Net.Sockets.Socket.Receive%2A> из сокетов, ориентированных на подключение, и без подключения.  
  
 Эта перегрузка требует только предоставить буфер приема, число байтов, которое требуется получить, и необходимое <xref:System.Net.Sockets.SocketFlags>значение.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> , чтобы установить соединение с удаленным узлом, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод будет считывать только данные, поступающие с удаленного узла, <xref:System.Net.Sockets.Socket.Connect%2A> установленного в методе или. <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.Receive%2A> Если используется протокол без подключения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>позволяет принимать данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод будет блокироваться до тех пор, пока данные не будут доступны, если только значение времени ожидания не было задано с помощью. <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов <xref:System.Net.Sockets.SocketException>выдаст исключение. Если вы используете неблокирующий режим и в буфере <xref:System.Net.Sockets.Socket.Receive%2A> стека протокола нет доступных данных, метод будет завершен немедленно и <xref:System.Net.Sockets.SocketException>создаст исключение. Чтобы определить, доступны <xref:System.Net.Sockets.Socket.Available%2A> ли данные для чтения, можно использовать свойство. Если <xref:System.Net.Sockets.Socket.Available%2A> имеет ненулевое значение, повторите операцию получения.  
  
 Если используется ориентированный <xref:System.Net.Sockets.Socket>на соединение объект <xref:System.Net.Sockets.Socket.Receive%2A> , метод будет считывать столько данных, сколько доступно, вплоть до числа байтов, заданного `size` параметром. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.Receive%2A> метод немедленно завершается и возвращает нулевые байты.  
  
 Если используется без подключения <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> то считывает первую датаграмму в очереди из <xref:System.Net.Sockets.Socket.Connect%2A> адреса назначения, указанного в методе. Если полученная датаграмма превышает размер `buffer` параметра, `buffer` она заполняется первой частью сообщения, лишние <xref:System.Net.Sockets.SocketException> данные теряются и создается исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий объект получает данные, найденные `buffer`в, и <xref:System.Net.Sockets.SocketFlags.None> указывает <xref:System.Net.Sockets.SocketFlags>для.  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="size" /> превышает размер параметра <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих полученные данные.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <summary>Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в список приемных буферов, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает данные в `buffers` параметр и возвращает число успешно считанных байтов. Вы можете вызывать из сокетов, ориентированных на подключение, и без подключения.  
  
 Эта перегрузка требует предоставления одного или нескольких буферов приема. Значение по умолчанию  <xref:System.Net.Sockets.SocketFlags.None> —.  <xref:System.Net.Sockets.SocketFlags>  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> , чтобы установить соединение с удаленным узлом, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод будет считывать только данные, поступающие из соединения с удаленным узлом, <xref:System.Net.Sockets.Socket.Connect%2A> установленного в методе или  <xref:System.Net.Sockets.Socket.Accept%2A> . <xref:System.Net.Sockets.Socket.Receive%2A> Если используется протокол без подключения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>позволяет принимать данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод будет блокироваться до тех пор, пока данные не будут доступны, если только значение времени ожидания не было задано с помощью. <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов <xref:System.Net.Sockets.SocketException>создает исключение. Если вы используете неблокирующий режим и в буфере <xref:System.Net.Sockets.Socket.Receive%2A> стека протокола нет доступных данных, метод будет завершен немедленно и <xref:System.Net.Sockets.SocketException>создаст исключение. Чтобы определить, доступны <xref:System.Net.Sockets.Socket.Available%2A> ли данные для чтения, можно использовать свойство. Если <xref:System.Net.Sockets.Socket.Available%2A> имеет ненулевое значение, повторите операцию получения.  
  
 Если используется ориентированный <xref:System.Net.Sockets.Socket>на соединение объект <xref:System.Net.Sockets.Socket.Receive%2A> , метод будет считывать столько данных, сколько доступно, вплоть до размера буфера. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.Receive%2A> метод немедленно завершается и возвращает нулевые байты.  
  
 Если используется без подключения <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> то считывает первую датаграмму в очереди из <xref:System.Net.Sockets.Socket.Connect%2A> адреса назначения, указанного в методе. Если полученная датаграмма превышает размер `buffers` параметра, `buffers` она заполняется первой частью сообщения, лишние <xref:System.Net.Sockets.SocketException> данные теряются и создается исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> — <see langword="null" />.  
  
- или - 
 Значение <paramref name="buffers" />. Отсчет равен нулю.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</param>
        <param name="offset">Место в объекте <paramref name="buffer" />, выделенное для хранения принимаемых данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Получает указанное число байтов данных из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер с указанной позиции смещения, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Метод считывает данные в параметр buffer и возвращает число успешно считанных байтов. Вы можете вызывать <xref:System.Net.Sockets.Socket.Receive%2A> из сокетов, ориентированных на подключение, и без подключения.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> , чтобы установить соединение с удаленным узлом, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод будет считывать только данные, поступающие с удаленного узла, <xref:System.Net.Sockets.Socket.Connect%2A> установленного в методе или. <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.Receive%2A> Если используется протокол без подключения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>позволяет принимать данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод будет блокироваться до тех пор, пока данные не будут доступны, если только значение времени ожидания не было задано с помощью. <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов <xref:System.Net.Sockets.SocketException>выдаст исключение. Если вы используете неблокирующий режим и в буфере <xref:System.Net.Sockets.Socket.Receive%2A> стека протокола нет доступных данных, метод будет завершен немедленно и <xref:System.Net.Sockets.SocketException>создаст исключение. Произошла ошибка при попытке доступа к сокету. См. примечания ниже. Чтобы определить, доступны <xref:System.Net.Sockets.Socket.Available%2A> ли данные для чтения, можно использовать свойство. Если <xref:System.Net.Sockets.Socket.Available%2A> имеет ненулевое значение, повторите операцию получения.  
  
 Если используется ориентированный <xref:System.Net.Sockets.Socket>на соединение объект <xref:System.Net.Sockets.Socket.Receive%2A> , метод будет считывать столько данных, сколько доступно, вплоть до числа байтов, заданного параметром size. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.Receive%2A> метод немедленно завершается и возвращает нулевые байты.  
  
 Если используется без подключения <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> то считывает первую датаграмму в очереди из <xref:System.Net.Sockets.Socket.Connect%2A> адреса назначения, указанного в методе. Если полученная датаграмма превышает размер `buffer` параметра, `buffer` она заполняется первой частью сообщения, лишние <xref:System.Net.Sockets.SocketException> данные теряются и создается исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода задаются буфер данных, смещение, размер и флаг сокета перед получением данных на подключенном <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
- или - 
Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.  
  
- или - 
Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="offset">Позиция в параметре <paramref name="buffer" /> для хранения полученных данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <summary>Получает данные из связанного объекта <see cref="T:System.Net.Sockets.Socket" /> в приемный буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A> Метод считывает данные в параметр buffer и возвращает число успешно считанных байтов. Вы можете вызывать <xref:System.Net.Sockets.Socket.Receive%2A> из сокетов, ориентированных на подключение, и без подключения.  
  
 Если используется протокол, ориентированный на соединение, необходимо либо вызвать метод <xref:System.Net.Sockets.Socket.Connect%2A> , чтобы установить соединение с удаленным узлом, либо <xref:System.Net.Sockets.Socket.Accept%2A> принять входящее подключение перед вызовом <xref:System.Net.Sockets.Socket.Receive%2A>. Метод будет считывать только данные, поступающие с удаленного узла, <xref:System.Net.Sockets.Socket.Connect%2A> установленного в методе или. <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.Receive%2A> Если используется протокол без подключения, можно также использовать <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>позволяет принимать данные, поступающие с любого узла.  
  
 Если данные недоступны для чтения, <xref:System.Net.Sockets.Socket.Receive%2A> метод будет блокироваться до тех пор, пока данные не будут доступны, если только значение времени ожидания не было задано с помощью. <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Receive%2A> вызов <xref:System.Net.Sockets.SocketException>выдаст исключение. Если вы используете неблокирующий режим и в буфере <xref:System.Net.Sockets.Socket.Receive%2A> стека протокола нет доступных данных, метод будет завершен немедленно и <xref:System.Net.Sockets.SocketException>создаст исключение. Произошла ошибка при попытке доступа к сокету. См. примечания ниже. Чтобы определить, доступны <xref:System.Net.Sockets.Socket.Available%2A> ли данные для чтения, можно использовать свойство. Если <xref:System.Net.Sockets.Socket.Available%2A> имеет ненулевое значение, повторите операцию получения.  
  
 Если используется ориентированный <xref:System.Net.Sockets.Socket>на соединение объект <xref:System.Net.Sockets.Socket.Receive%2A> , метод будет считывать столько данных, сколько доступно, вплоть до числа байтов, заданного параметром size. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.Receive%2A> метод немедленно завершается и возвращает нулевые байты.  
  
 Если используется без подключения <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> то считывает первую датаграмму в очереди из <xref:System.Net.Sockets.Socket.Connect%2A> адреса назначения, указанного в методе. Если полученная датаграмма превышает размер `buffer` параметра, `buffer` она заполняется первой частью сообщения, лишние <xref:System.Net.Sockets.SocketException> данные теряются и создается исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
- или - 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
- или - 
Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.  
  
-или- 
Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает выполнение асинхронного запроса, чтобы получить данные из подключенного объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Метод используется на подключенных сокетах или в связанных сокетах без подключения и используется для чтения входящих данных. Локальный адрес сокета должен быть известен.  
  
 Для привязанных сокетов без подключения эта функция ограничивает адреса, из которых принимаются принимаемые сообщения. Функция возвращает только сообщения с удаленного адреса, указанного в соединении. Сообщения из других адресов отбрасываются без уведомления.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Свойство `e`  в параметре предоставляет поставщику услуг Windows Sockets дополнительные сведения о запросе на чтение. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Для успешного вызова этого метода необходимы следующие <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> свойства и события объекта:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> или <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>Если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> задано значение  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>Если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> задано значение  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> для свойства любой объект пользовательского состояния, необходимый перед <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> вызовом метода, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 Для сокетов типа Byte входящие данные помещаются в буфер до тех пор, пока буфер не будет заполнен, соединение будет закрыто или исчерпаны внутренние буферизованные данные.  
  
 Для сокетов, ориентированных на сообщения, входящее сообщение помещается в буфер вплоть до общего размера буфера, связанного с `e` параметром. Если размер сообщения превышает размер буфера, буфер заполняется первой частью сообщения.  
  
 Для сокетов, ориентированных на <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> соединение, метод может указывать на корректное завершение виртуального канала одним из двух способов, которые зависят от того, является ли сокет байтовым потоком или ориентированным на сообщения. Для потоковых потоков нулевое число прочитанных байтов указывает на корректное закрытие и на то, что больше байтов не будет считано. Для сокетов, ориентированных на сообщения, где сообщение с нулевым байтом часто разрешено <xref:System.Net.Sockets.SocketException> , для <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> указания корректного замыкания используется параметр с параметром, имеющим значение машинного кода ошибки Winsock всаедискон (10101). В любом случае, a <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> с установленным на собственный код ошибки всаеконнресет Winsock (10054) указывает на то, что произошло аварийное закрытие.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Аргумент был недопустимым. Свойства <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> или <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> на параметре <paramref name="e" /> должны ссылаться на допустимые буферы. Может быть установлено одно из этих свойств, но нельзя одновременно устанавливать оба свойства.</exception>
        <exception cref="T:System.InvalidOperationException">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, задающее размер приемного буфера объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Объект <see cref="T:System.Int32" />, который содержит значение размера приемного буфера в байтах. Значение по умолчанию — 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Больший размер буфера потенциально сокращает количество пустых подтверждений (пакетов TCP без данных), но может также отложить распознавание проблем с подключением. Если вы передаете большие файлы или используете высокоскоростное подключение с высокой задержкой (например, поставщик широкополосного подключения), попробуйте увеличить размер буфера.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное для операции установки, меньше 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает датаграмму и сохраняет конечную точку источника.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</param>
        <param name="remoteEP">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</param>
        <summary>Принимает датаграмму в буфер данных и сохраняет конечную точку.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод считывает данные `buffer` в параметр, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Этот метод полезен, если вы собираетесь принимать неподключенные датаграммы с неизвестного узла или с нескольких узлов.  
  
 Эта перегрузка требует только предоставления метода Receive `buffer` <xref:System.Net.EndPoint> и, представляющего удаленный узел. По умолчанию смещение буфера равно 0. Размер по умолчанию `buffer` `socketFlags` равен длине параметра, а значение по умолчанию <xref:System.Net.Sockets.SocketFlags.None>—.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>необходимо явным образом <xref:System.Net.Sockets.Socket> привязать к локальной конечной точке с помощью <xref:System.Net.Sockets.Socket.Bind%2A> метода. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> В <xref:System.Net.Sockets.SocketException> противном случае вызовет исключение.  
  
 При использовании протоколов без <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> подключения будет считывать первые поставленные в очередь датаграммы, полученные в буфер локальной сети. Если полученная датаграмма превышает размер `buffer` <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , метод будет заполняться `buffer` максимально возможной частью <xref:System.Net.Sockets.SocketException>сообщения и вызывать исключение. При использовании ненадежного протокола избыточные данные будут потеряны. Если используется надежный протокол, избыточные данные будут храниться в поставщике служб, и его можно будет извлечь, вызвав <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод с достаточно большим размером буфера.  
  
 Если данные для чтения недоступны, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод блокируется до тех пор, пока данные не будут доступны. Если вы используете неблокирующий режим и в буфере <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> стека протокола нет доступных данных, метод будет завершен немедленно и <xref:System.Net.Sockets.SocketException>создаст исключение. Чтобы определить, доступны <xref:System.Net.Sockets.Socket.Available%2A> ли данные для чтения, можно использовать свойство. Если <xref:System.Net.Sockets.Socket.Available%2A> имеет ненулевое значение, повторите операцию получения.  
  
 Хотя <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение. Если вы решили это сделать, необходимо сначала установить соединение с удаленным узлом, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или приняв входящее соединение с удаленным узлом, <xref:System.Net.Sockets.Socket.Accept%2A> вызвав метод. Если вы не устанавливаете или не принимаете соединение перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метода, вы <xref:System.Net.Sockets.SocketException>получите. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> вызовом метода. В любом из этих случаев <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет `remoteEP` игнорировать параметр и получить данные только с подключенного или удаленного узла по умолчанию.  
  
 При использовании сокетов, ориентированных <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> на соединение, будет считывать столько данных, сколько доступно до `buffer`размера. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод немедленно завершается и возвращает нулевые байты.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Объект <xref:System.Net.Sockets.AddressFamily> , <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.EndPoint> используемый в , <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>  должен соответствовать значению объекта, используемого в. <xref:System.Net.Sockets.AddressFamily>  <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода получает датаграмму без подключения от удаленного узла.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.  
  
- или - 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, который является местоположением памяти для полученных данных.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</param>
        <summary>Принимает датаграмму в буфер данных, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />, и сохраняет конечную точку.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод считывает данные `buffer` в параметр, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Этот метод полезен, если вы собираетесь принимать неподключенные датаграммы с неизвестного узла или с нескольких узлов.  
  
 Эта перегрузка требует только предоставить буфер приема, необходимый <xref:System.Net.Sockets.SocketFlags>объект <xref:System.Net.EndPoint> и, представляющий удаленный узел. Смещение по умолчанию равно 0, а размер по умолчанию равен длине параметра buffer.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>необходимо явным образом <xref:System.Net.Sockets.Socket> привязать к локальной конечной точке с помощью <xref:System.Net.Sockets.Socket.Bind%2A> метода. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> В <xref:System.Net.Sockets.SocketException> противном случае вызовет исключение.  
  
 При использовании протоколов без <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> подключения будет считывать первые поставленные в очередь датаграммы, полученные в буфер локальной сети. Если полученная датаграмма превышает размер `buffer` <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , метод будет заполняться `buffer` максимально возможной частью <xref:System.Net.Sockets.SocketException>сообщения и вызывать исключение. При использовании ненадежного протокола избыточные данные будут потеряны. Если используется надежный протокол, избыточные данные будут храниться в поставщике служб, и его можно будет извлечь, вызвав <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод с достаточно большим размером буфера.  
  
 Если данные для чтения недоступны, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод блокируется до тех пор, пока данные не будут доступны. Если вы используете неблокирующий режим и в буфере <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> стека протокола нет доступных данных, метод будет завершен немедленно и <xref:System.Net.Sockets.SocketException>создаст исключение. Чтобы определить, доступны <xref:System.Net.Sockets.Socket.Available%2A> ли данные для чтения, можно использовать свойство. Если <xref:System.Net.Sockets.Socket.Available%2A> имеет ненулевое значение, повторите операцию получения.  
  
 Хотя <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение. Если вы решили это сделать, необходимо сначала установить соединение с удаленным узлом, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или приняв входящее соединение с удаленным узлом, <xref:System.Net.Sockets.Socket.Accept%2A> вызвав метод. Если вы не устанавливаете или не принимаете соединение перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метода, вы <xref:System.Net.Sockets.SocketException>получите. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> вызовом метода. В любом из этих случаев <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет `remoteEP` игнорировать параметр и получить данные только с подключенного или удаленного узла по умолчанию.  
  
 При использовании сокетов, ориентированных <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> на соединение, будет считывать столько данных, сколько доступно до `buffer`размера. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод немедленно завершается и возвращает нулевые байты.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Объект <xref:System.Net.Sockets.AddressFamily> , <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.EndPoint> используемый в , <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>  должен соответствовать значению объекта, используемого в. <xref:System.Net.Sockets.AddressFamily>  <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода получает датаграмму без подключения от удаленного узла. <xref:System.Net.Sockets.SocketFlags>передаются <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> в метод.  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</param>
        <summary>Получает указанное число байтов во входной буфер, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />, и сохраняет конечную точку.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод считывает данные `buffer` в параметр, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Этот метод полезен, если вы собираетесь принимать неподключенные датаграммы с неизвестного узла или с нескольких узлов.  
  
 Эта перегрузка требует только предоставить буфер приема, число байтов, которое требуется получить, необходимое <xref:System.Net.Sockets.SocketFlags>значение и объект <xref:System.Net.EndPoint> , представляющий удаленный узел. По умолчанию смещение буфера равно 0.  
  
 При использовании протоколов без <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> подключения будет считывать первые поставленные в очередь датаграммы, полученные в буфер локальной сети. Если полученная датаграмма превышает размер `buffer` <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , метод будет заполняться `buffer` максимально возможной частью <xref:System.Net.Sockets.SocketException>сообщения и вызывать исключение. При использовании ненадежного протокола избыточные данные будут потеряны. Если используется надежный протокол, избыточные данные будут храниться в поставщике служб, и его можно будет извлечь, вызвав <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод с достаточно большим размером буфера.  
  
 Если данные для чтения недоступны, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод блокируется до тех пор, пока данные не будут доступны. Если вы используете неблокирующий режим и в буфере <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> стека протокола нет доступных данных, метод будет завершен немедленно и <xref:System.Net.Sockets.SocketException>создаст исключение. Чтобы определить, доступны <xref:System.Net.Sockets.Socket.Available%2A> ли данные для чтения, можно использовать свойство. Если <xref:System.Net.Sockets.Socket.Available%2A> имеет ненулевое значение, повторите операцию получения.  
  
 Хотя <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение. Если вы решили это сделать, необходимо сначала установить соединение с удаленным узлом, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или приняв входящее соединение с удаленным узлом, <xref:System.Net.Sockets.Socket.Accept%2A> вызвав метод. Если вы не устанавливаете или не принимаете соединение перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метода, вы <xref:System.Net.Sockets.SocketException>получите. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> вызовом метода. В любом из этих случаев <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет `remoteEP` игнорировать параметр и получить данные только с подключенного или удаленного узла по умолчанию.  
  
 При использовании сокетов, ориентированных <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> на соединение, будет считывать столько данных, сколько доступно до числа байтов `size` , заданных параметром. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод немедленно завершается и возвращает нулевые байты.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>необходимо явным образом <xref:System.Net.Sockets.Socket> привязать к локальной конечной точке с помощью <xref:System.Net.Sockets.Socket.Bind%2A> метода. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> В <xref:System.Net.Sockets.SocketException> противном случае вызовет исключение. Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Объект <xref:System.Net.Sockets.AddressFamily> , <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.EndPoint> используемый в , <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>  должен соответствовать значению объекта, используемого в. <xref:System.Net.Sockets.AddressFamily>  <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода получает датаграмму без подключения от удаленного узла. Размер буфера и <xref:System.Net.Sockets.SocketFlags> передаются <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> в метод.  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="size" /> меньше 0.  
  
- или - 
 Значение<paramref name="size" /> превышает длину <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
- или - 
Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.  
  
- или - 
Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</param>
        <param name="offset">Позиция в параметре <paramref name="buffer" /> для хранения полученных данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</param>
        <summary>Получает указанное число байтов данных в заданном расположении буфера данных с использованием определенного параметра <see cref="T:System.Net.Sockets.SocketFlags" /> и сохраняет конечную точку.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод считывает данные `buffer` в параметр, возвращает число успешно считанных байтов и фиксирует конечную точку удаленного узла, из которой были отправлены данные. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Этот метод полезен, если вы собираетесь принимать неподключенные датаграммы с неизвестного узла или с нескольких узлов.  
  
 При использовании протоколов без <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> подключения будет считывать первые поставленные в очередь датаграммы, полученные в буфер локальной сети. Если полученная датаграмма превышает размер `buffer` <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , метод будет заполняться `buffer` максимально возможной частью <xref:System.Net.Sockets.SocketException>сообщения и вызывать исключение. При использовании ненадежного протокола избыточные данные будут потеряны. Если используется надежный протокол, избыточные данные будут храниться в поставщике служб, и его можно будет извлечь, вызвав <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод с достаточно большим размером буфера.  
  
 Если данные для чтения недоступны, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод блокируется до тех пор, пока данные не будут доступны. Если вы используете неблокирующий режим и в буфере <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> стека протокола нет доступных данных, метод будет завершен немедленно и <xref:System.Net.Sockets.SocketException>создаст исключение. Чтобы определить, доступны <xref:System.Net.Sockets.Socket.Available%2A> ли данные для чтения, можно использовать свойство. Если <xref:System.Net.Sockets.Socket.Available%2A> имеет ненулевое значение, повторите операцию получения.  
  
 Хотя <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> предназначен для протоколов без подключения, также можно использовать протокол, ориентированный на соединение. Если вы решили это сделать, необходимо сначала установить соединение с удаленным узлом, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или приняв входящее соединение с удаленным узлом, <xref:System.Net.Sockets.Socket.Accept%2A> вызвав метод. Если вы не устанавливаете или не принимаете соединение перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метода, вы <xref:System.Net.Sockets.SocketException>получите. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> вызовом метода. В любом из этих случаев <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод будет `remoteEP` игнорировать параметр и получить данные только с подключенного или удаленного узла по умолчанию.  
  
 При использовании сокетов, ориентированных <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> на соединение, будет считывать столько данных, сколько доступно в байтах `size` , заданных параметром. Если удаленный узел завершает <xref:System.Net.Sockets.Socket> соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> с методом и все доступные данные получены, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> метод немедленно завершается и возвращает нулевые байты.  
  
> [!NOTE]
>  Перед вызовом <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>необходимо явным образом <xref:System.Net.Sockets.Socket> привязать к локальной конечной точке с помощью <xref:System.Net.Sockets.Socket.Bind%2A> метода. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> В <xref:System.Net.Sockets.SocketException> противном случае вызовет исключение. Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Объект <xref:System.Net.Sockets.AddressFamily> , <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.EndPoint> используемый в , <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>  должен соответствовать значению объекта, используемого в. <xref:System.Net.Sockets.AddressFamily>  <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода получает датаграмму без подключения от удаленного узла. Смещение, размер буфера и <xref:System.Net.Sockets.SocketFlags> передаются <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> в метод.  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
- или - 
 Значение параметра <paramref name="size" /> меньше 0.  
  
- или - 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра смещения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
- или - 
Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.  
  
-или- 
Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает выполнение асинхронного приема данных с указанного сетевого устройства.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> Метод используется в основном для получения данных в сокете без подключения. Локальный адрес сокета должен быть известен.  
  
 Вызывающий объект должен задать <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> свойство <xref:System.Net.IPEndPoint> для удаленного узла, от которого должны быть получены данные.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Свойство `e`  в параметре предоставляет поставщику услуг Windows Sockets дополнительные сведения о запросе на чтение. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Для успешного вызова этого метода необходимы следующие <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> свойства и события объекта:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> для свойства любой объект пользовательского состояния, необходимый перед <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> вызовом метода, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 Для сокетов, ориентированных на сообщения, входящее сообщение помещается в буфер вплоть до общего размера буфера. Свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> и <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  определяют, где в буфере размещаются данные, и объем данных.  
  
 Для сокетов типа Byte входящие данные помещаются в буфер до тех пор, пока буфер не будет заполнен, соединение будет закрыто или исчерпаны внутренние буферизованные данные. Свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> и <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  определяют, где в буфере размещаются данные, и объем данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не может иметь значение "null".</exception>
        <exception cref="T:System.InvalidOperationException">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив объекта типа <see cref="T:System.Byte" />, который является местом хранения полученных данных.</param>
        <param name="offset">Позиция в параметре <paramref name="buffer" /> для хранения полученных данных.</param>
        <param name="size">Количество байтов, которые необходимо получить.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Переданный по ссылке объект <see cref="T:System.Net.EndPoint" />, представляющий удаленный сервер.</param>
        <param name="ipPacketInformation"><see cref="T:System.Net.Sockets.IPPacketInformation" /> сохраняет адрес и сведения об интерфейсе.</param>
        <summary>Получает указанное число байтов данных в указанное расположение буфера данных с помощью заданного <see cref="T:System.Net.Sockets.SocketFlags" /> и сохраняет конечную точку и сведения о пакете.</summary>
        <returns>Количество полученных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод считывает данные `buffer` в параметр, возвращает число успешно считанных байтов и захватывает конечную точку удаленного узла, из которой были отправлены данные, а также сведения о полученных пакетах. <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Метод используется в основном для получения данных сообщений в сокете без подключения. Локальный адрес сокета должен быть известен. Этот метод может использоваться только с датаграммами и необработанными сокетами. Сокет должен быть инициализирован с типом сокета, установленным в <xref:System.Net.Sockets.SocketType.Dgram> , <xref:System.Net.Sockets.SocketType.Raw> или до вызова этого метода. Это можно сделать при создании сокета с помощью <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Для сокетов, ориентированных на сообщения, входящее сообщение помещается `buffer` в параметр вплоть до общего размера, указанного `size` в параметре. Параметр определяет место `buffer` размещения данных. `offset` Фактический объем данных, помещаемых в `buffer` , возвращается <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> методом.  
  
 Метод автоматически <xref:System.Net.Sockets.Socket>устанавливает параметр <xref:System.Net.Sockets.SocketOptionName.PacketInformation> сокета в первый раз , когда он вызывается для заданного `true` . <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Однако возвращенный <xref:System.Net.Sockets.IPPacketInformation> объект будет действителен только для пакетов, поступающих на локальный компьютер после установки параметра сокета. Значение, если сокет отправляет пакеты <xref:System.Net.Sockets.Socket.Bind%2A> между моментом привязки к локальной конечной точке (явным образом методом или неявно одним <xref:System.Net.Sockets.Socket.Connect%2A>из методов <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, или <xref:System.Net.Sockets.Socket.SendToAsync%2A> ) и первым вызовом <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> метода метод, вызовы <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> метода будут возвращать недопустимые <xref:System.Net.Sockets.IPPacketInformation> объекты для этих пакетов.  
  
 Чтобы убедиться, что <xref:System.Net.Sockets.IPPacketInformation> все объекты являются допустимыми, приложение должно <xref:System.Net.Sockets.SocketOptionName.PacketInformation> установить параметр сокета `true` в значение, прежде чем он <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> будет привязан к локальной конечной точке с помощью метода.  
  
 Приложение может проверить `ipPacketInformation` параметр, если необходимо узнать, была ли датаграмма отправлена с помощью одноадресной рассылки, многоадресной рассылки или широковещательной рассылки.  
  
> [!NOTE]
>  Объект <xref:System.Net.Sockets.AddressFamily> , <xref:System.Net.Sockets.Socket.SendTo%2A> <xref:System.Net.EndPoint> используемый в , <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>  должен соответствовать значению объекта, используемого в. <xref:System.Net.Sockets.AddressFamily>  <xref:System.Net.EndPoint>  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.  
  
\- или - 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
- или - 
 Значение параметра <paramref name="size" /> меньше 0.  
  
-или- 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра смещения.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
- или - 
Свойство <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> не задано.  
  
- или - 
Платформа .NET Framework выполняется на 64-разрядном процессоре AMD.  
  
- или - 
Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.NotSupportedException">Используется операционная система Windows 2000 или более ранняя версия, а для этого метода необходима операционная система Windows XP.</exception>
        <permission cref="T:System.Net.SocketPermission">для приема подключений из сети. Связанное перечисление: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Начинает асинхронный прием заданного числа байтов данных в указанное место буфера данных, используя заданный объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, а также сохраняет конечную точку и информацию пакета.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Метод используется в основном для получения данных сообщений в сокете без подключения. Локальный адрес сокета должен быть известен. Этот метод может использоваться только с датаграммами и необработанными сокетами. Сокет должен быть инициализирован с типом сокета, установленным в <xref:System.Net.Sockets.SocketType.Dgram> , <xref:System.Net.Sockets.SocketType.Raw> или до вызова этого метода. Это можно сделать при создании сокета с помощью <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Вызывающий объект должен задать <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> свойство <xref:System.Net.IPEndPoint> для удаленного узла, от которого должны быть получены данные.  
  
 Для успешного вызова этого метода необходимы следующие <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> свойства и события объекта:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> для свойства любой объект пользовательского состояния, необходимый перед <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> вызовом метода, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 Для сокетов, ориентированных на сообщения, входящее сообщение помещается в буфер вплоть до общего размера буфера. Свойства <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> и <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  определяют, где в буфере размещаются данные, и объем данных.  
  
 Метод автоматически <xref:System.Net.Sockets.Socket>устанавливает параметр <xref:System.Net.Sockets.SocketOptionName.PacketInformation> сокета в первый раз , когда он вызывается для заданного `true` . <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> <xref:System.Net.Sockets.IPPacketInformation> Однако объект будет действителен только для пакетов, поступающих на локальный компьютер после установки параметра сокета. Значение, если сокет отправляет пакеты между <xref:System.Net.Sockets.Socket.Bind%2A> моментом привязки сокета к локальной конечной точке (явно методом или неявно одним <xref:System.Net.Sockets.Socket.Connect%2A>из методов, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.SendTo%2A>, или <xref:System.Net.Sockets.Socket.SendToAsync%2A> ) и первым вызовом метода <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>, вызовы метода приведут к <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> недопустимым <xref:System.Net.Sockets.IPPacketInformation> объектам для этих пакетов.  
  
 Чтобы убедиться, что <xref:System.Net.Sockets.IPPacketInformation> все объекты являются допустимыми, приложение должно <xref:System.Net.Sockets.SocketOptionName.PacketInformation> установить параметр сокета`true` в значение, прежде чем он <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> будет привязан к локальной конечной точке с помощью метода.  
  
 Приложение может проверить полученные <xref:System.Net.Sockets.IPPacketInformation> объекты, если необходимо узнать, была ли датаграмма отправлена с использованием одноадресного, многоадресного или широковещательного адреса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не может иметь значение "null".</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или устанавливает значение, указывающее промежуток времени, после которого для синхронного вызова <see cref="Overload:System.Net.Sockets.Socket.Receive" /> истечет время тайм-аута.</summary>
        <value>Значение времени ожидания в миллисекундах. По умолчанию используется значение 0, указывающее на бесконечное значение интервала для тайм-аута Задание значения -1 также указывает на бесконечное значение интервала для тайм-аута.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот параметр применяется только к <xref:System.Net.Sockets.Socket.Receive%2A> синхронным вызовам. При превышении <xref:System.Net.Sockets.Socket.Receive%2A> времени ожидания метод вызовет <xref:System.Net.Sockets.SocketException>исключение.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное для операции задания, меньше –1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает удаленную конечную точку.</summary>
        <value>Объект <see cref="T:System.Net.EndPoint" />, с которым взаимодействует объект <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> свойство получает объект <xref:System.Net.EndPoint> , содержащий удаленный IP-адрес и номер порта, к которому подключен объект <xref:System.Net.Sockets.Socket> . Если используется протокол без подключения, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> содержит удаленный IP-адрес по умолчанию и номер порта, с <xref:System.Net.Sockets.Socket> которым будет взаимодействовать. Перед извлечением любой <xref:System.Net.EndPoint> информации необходимо <xref:System.Net.IPEndPoint> привести его к типу. Затем можно вызвать <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> метод, чтобы получить удаленный <xref:System.Net.IPAddress>объект, и <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> метод для получения номера удаленного порта.  
  
 Задается после вызова <xref:System.Net.Sockets.Socket.Connect%2A>либо <xref:System.Net.Sockets.Socket.Accept%2A> в, либо в. <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> Если попытаться получить доступ к этому свойству ранее <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> , <xref:System.Net.Sockets.SocketException>будет вызвано исключение. Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода извлекаются и отображаются локальные и удаленные конечные точки.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Net.Sockets.SafeSocketHandle" />, представляющий дескриптор сокета, инкапсулируемый текущим объектом <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Открытый в безопасном режиме обработчик сокета, который инкапсулирует текущий <see cref="T:System.Net.Sockets.Socket" /> объект.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!IMPORTANT]
> <xref:System.Net.Sockets.SafeSocketHandle> Использование для прямого взаимодействия с сокетом может привести к недокументированному состоянию. 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="checkRead"><see cref="T:System.Collections.IList" /> экземпляров <see cref="T:System.Net.Sockets.Socket" /> для проверки удобства чтения.</param>
        <param name="checkWrite"><see cref="T:System.Collections.IList" /> экземпляров <see cref="T:System.Net.Sockets.Socket" /> для проверки удобства ведения записи.</param>
        <param name="checkError"><see cref="T:System.Collections.IList" /> экземпляров <see cref="T:System.Net.Sockets.Socket" /> для проверки ошибок.</param>
        <param name="microSeconds">Значение времени ожидания в миллисекундах. Значение -1 указывает на бесконечное время ожидания.</param>
        <summary>Определяет состояние одного или нескольких сокетов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A>— Это статический метод, который определяет состояние одного или нескольких <xref:System.Net.Sockets.Socket> экземпляров. <xref:System.Collections.IList> Перед <xref:System.Net.Sockets.Socket.Select%2A>  использованием метода необходимо поместить один или несколько сокетов в. Проверьте наличие удобочитаемости, вызвав <xref:System.Net.Sockets.Socket.Select%2A> метод <xref:System.Collections.IList> с `checkRead` параметром. Чтобы проверить сокеты для записи, используйте `checkWrite` параметр. Для обнаружения условий ошибок используйте `checkError`. После вызова <xref:System.Net.Sockets.Socket.Select%2A>функции <xref:System.Collections.IList> будут заполнены только теми сокетами, которые соответствуют условиям.  
  
 В состоянии прослушивания удобочитаемость означает, что вызов <xref:System.Net.Sockets.Socket.Accept%2A> будет выполнен без блокировки. Если вы уже приняли подключение, удобочитаемость означает, что данные доступны для чтения. В таких случаях все операции получения будут выполняться без блокировки. Удобочитаемость также может указывать на то, <xref:System.Net.Sockets.Socket> что удаленное соединение завершилось. в этом случае <xref:System.Net.Sockets.Socket.Receive%2A> вызов будет немедленно возвращаться с нулевым количеством байт.  
  
 <xref:System.Net.Sockets.Socket.Select%2A>Возвращает, когда по крайней мере один из нужных сокетов (сокеты в `checkRead`списках `checkWrite`, и `checkError` ) соответствует заданным условиям, или превышено значение параметра в зависимости от того, что `microSeconds` происходит первым. Значение `microSeconds` параметра равно-1 указывает неограниченное время ожидания.  
  
 Если вы сделаете неблокирующий вызов <xref:System.Net.Sockets.Socket.Connect%2A>, записи означает, что соединение установлено успешно. Если соединение уже установлено, записи означает, что все операции отправки будут выполнены без блокировки.  
  
 Если вы выполнили неблокирующий вызов <xref:System.Net.Sockets.Socket.Connect%2A> `checkerror` , параметр определяет сокеты, которые не были успешно подключены.  
  
> [!NOTE]
>  Используйте метод <xref:System.Net.Sockets.Socket.Poll%2A> , если хотите определить только состояние одного <xref:System.Net.Sockets.Socket>объекта.  
  
> [!NOTE]
>  Этот метод не может обнаружить некоторые виды проблем с подключением, например обрыв сетевого кабеля или некорректное завершение работы удаленного узла. Необходимо попытаться отправить или получить данные для обнаружения ошибок этих типов.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.Sockets.Socket.Select%2A> , чтобы определить, какие сокеты прослушивания имеют запрос на соединение.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="checkRead" /> имеет значение <see langword="null" /> или является пустым.  
  
- и - 
Параметр <paramref name="checkWrite" /> имеет значение <see langword="null" /> или является пустым. 
- и - 
Параметр <paramref name="checkError" /> имеет значение <see langword="null" /> или является пустым.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Передает данные в подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <summary>Передает данные в подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>синхронно отправляет данные на удаленный узел, указанный в <xref:System.Net.Sockets.Socket.Connect%2A> методе или <xref:System.Net.Sockets.Socket.Accept%2A> , и возвращает число успешно отправленных байтов. <xref:System.Net.Sockets.Socket.Send%2A>можно использовать для протоколов, ориентированных на подключение и без подключения.  
  
 Для этой перегрузки требуется буфер, содержащий данные, которые необходимо отправить. <xref:System.Net.Sockets.SocketFlags> Значение по умолчанию равно 0, смещение буфера по умолчанию равно 0, а число байтов для отправки по умолчанию равно размеру буфера.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> метод перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызвать исключение <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на соединение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A> для установления соединения с удаленным узлом, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A> метод. Если <xref:System.Net.Sockets.Socket.SendTo%2A> метод не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>метода. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с помощью <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A> , сделав еще один <xref:System.Net.Sockets.Socket.Connect%2A>вызов.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Send%2A> вызов <xref:System.Net.Sockets.SocketException>выдаст исключение. В неблокирующем режиме может <xref:System.Net.Sockets.Socket.Send%2A> завершиться успешно, даже если число байтов в буфере меньше числа. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как отправлять данные на <xref:System.Net.Sockets.Socket>подключенном.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих данные для отправки.</param>
        <summary>Отправляет набор буферов в список на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>можно использовать для протоколов, ориентированных на подключение и без подключения.  
  
 Для этой перегрузки требуется по крайней мере один буфер, содержащий данные, которые необходимо отправить.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> метод перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызвать исключение <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на соединение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A> для установления соединения с удаленным узлом, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A> метод. Если <xref:System.Net.Sockets.Socket.SendTo%2A> метод не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>метода. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с помощью <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A> , сделав еще один <xref:System.Net.Sockets.Socket.Connect%2A>вызов.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Send%2A> вызов <xref:System.Net.Sockets.SocketException>выдаст исключение. В неблокирующем режиме может <xref:System.Net.Sockets.Socket.Send%2A> завершиться успешно, даже если число байтов в буфере меньше числа. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffers" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="buffers" /> пуст.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. См. ниже примeчания к данному разделу.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Передает данные в подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>синхронно отправляет данные на удаленный узел, установленный в <xref:System.Net.Sockets.Socket.Connect%2A> методе или <xref:System.Net.Sockets.Socket.Accept%2A> , и возвращает число успешно отправленных байтов. <xref:System.Net.Sockets.Socket.Send%2A> Метод можно использовать как для протоколов, ориентированных на подключение, так и для протокола без подключения.  
  
 Для этой перегрузки требуется буфер, содержащий данные, которые необходимо отправить, и побитовое сочетание <xref:System.Net.Sockets.SocketFlags>. По умолчанию смещение буфера равно 0, а число байтов для отправки по умолчанию равно размеру буфера. Если в <xref:System.Net.Sockets.SocketFlags.DontRoute> `socketflags` качестве значения параметра указан флаг, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> метод перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызвать исключение <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на соединение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A> для установления соединения с удаленным узлом, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A> метод. Если <xref:System.Net.Sockets.Socket.SendTo%2A> метод не используется, необходимо <xref:System.Net.Sockets.Socket.Connect%2A> вызвать <xref:System.Net.Sockets.Socket.Send%2A>метод перед каждым вызовом метода. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с помощью <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A> , сделав еще один <xref:System.Net.Sockets.Socket.Connect%2A>вызов.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Send%2A> вызов <xref:System.Net.Sockets.SocketException>выдаст исключение. В неблокирующем режиме может <xref:System.Net.Sockets.Socket.Send%2A> завершиться успешно, даже если число байтов в буфере меньше числа. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Необходимо убедиться, что размер буфера не превышает максимальный размер пакета базового поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.Send%2A> создаст <xref:System.Net.Sockets.SocketException>исключение. Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как отправлять данные на <xref:System.Net.Sockets.Socket>подключенном.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих данные для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Отправляет набор буферов в список на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя указанный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для этой перегрузки требуется по крайней мере один буфер, содержащий данные, которые необходимо отправить. <xref:System.Net.Sockets.SocketFlags> Значение по умолчанию равно 0. Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> в `socketFlags` качестве параметра флаг, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> метод перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызвать исключение <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на соединение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A> для установления соединения с удаленным узлом, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A> метод. Если <xref:System.Net.Sockets.Socket.SendTo%2A> метод не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>метода. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с помощью <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A> , сделав еще один <xref:System.Net.Sockets.Socket.Connect%2A>вызов.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Send%2A> вызов <xref:System.Net.Sockets.SocketException>выдаст исключение. В режиме без блокировки может завершиться успешно, <xref:System.Net.Sockets.Socket.Send%2A> даже если число байтов в буфере меньше числа. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffers" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="buffers" /> пуст.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Посылает указанное число байтов данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>синхронно отправляет данные на удаленный узел, установленный в <xref:System.Net.Sockets.Socket.Connect%2A> методе или <xref:System.Net.Sockets.Socket.Accept%2A> , и возвращает число успешно отправленных байтов. <xref:System.Net.Sockets.Socket.Send%2A>можно использовать для протоколов, ориентированных на подключение и без подключения.  
  
 Для этой перегрузки требуется буфер, содержащий данные, которые необходимо отправить, число байтов, которые требуется отправить, и побитовое сочетание любого из <xref:System.Net.Sockets.SocketFlags>них. Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> в `socketflags` качестве параметра флаг, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> метод перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызвать исключение <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на соединение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A> для установления соединения с удаленным узлом, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A> метод. Если <xref:System.Net.Sockets.Socket.SendTo%2A> метод не используется, то <xref:System.Net.Sockets.Socket.Send%2A> перед каждым вызовом метода придется <xref:System.Net.Sockets.Socket.Connect%2A> вызывать метод. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с помощью <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A> , сделав еще один <xref:System.Net.Sockets.Socket.Connect%2A>вызов.  
  
 При использовании протокола, ориентированного на <xref:System.Net.Sockets.Socket.Send%2A> соединение, блокируется до тех пор, пока не будет отправлено запрошенное число байтов, если не <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>было задано время ожидания с помощью. Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Send%2A> вызов <xref:System.Net.Sockets.SocketException>выдаст исключение. В неблокирующем режиме может <xref:System.Net.Sockets.Socket.Send%2A> завершиться успешно, даже если количество отправленных байтов превышает. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Необходимо убедиться, что размер не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.Send%2A> создаст <xref:System.Net.Sockets.SocketException>исключение. Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Следующий пример кода отправляет данные, найденные в буфере, и <xref:System.Net.Sockets.SocketFlags.None> указывает <xref:System.Net.Sockets.SocketFlags>для.  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="size" /> меньше 0 или превышает размер буфера.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
- или - 
Сбой операционной системы при доступе к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffers">Список объектов <see cref="T:System.ArraySegment`1" /> типа <see cref="T:System.Byte" />, содержащих данные для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <summary>Отправляет набор буферов в список на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя указанный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для этой перегрузки требуется по крайней мере один буфер, содержащий данные, которые необходимо отправить. <xref:System.Net.Sockets.SocketFlags> Значение по умолчанию равно 0. Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> в `socketFlags` качестве параметра флаг, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> метод перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызвать исключение <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на соединение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A> для установления соединения с удаленным узлом, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует использовать <xref:System.Net.Sockets.Socket.SendTo%2A> метод. Если <xref:System.Net.Sockets.Socket.SendTo%2A> метод не используется, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>метода. Вы можете использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с помощью <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A> , сделав еще один <xref:System.Net.Sockets.Socket.Connect%2A>вызов.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> будет блокироваться до тех пор, пока не будут отправлены все байты в буфере, если не было задано время ожидания с помощью. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Send%2A> вызов <xref:System.Net.Sockets.SocketException>выдаст исключение. В режиме без блокировки может завершиться успешно, <xref:System.Net.Sockets.Socket.Send%2A> даже если число байтов в буфере меньше числа. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит байты в буфере. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="buffers" /> пуст.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="offset">Положение в буфере данных, с которого начинается отправка данных.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Отправляет указанное количество байтов данных в подключенный <see cref="T:System.Net.Sockets.Socket" />, начиная с заданного смещения и используя заданный параметр <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>синхронно отправляет данные на удаленный узел, указанный в <xref:System.Net.Sockets.Socket.Connect%2A> методе или <xref:System.Net.Sockets.Socket.Accept%2A> , и возвращает число успешно отправленных байтов. <xref:System.Net.Sockets.Socket.Send%2A>можно использовать для протоколов, ориентированных на подключение и без подключения.  
  
 В этой перегрузке при указании <xref:System.Net.Sockets.SocketFlags.DontRoute> флага в `socketflags` качестве параметра отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> метод перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызвать исключение. <xref:System.Net.Sockets.SocketException> Если используется протокол, ориентированный на соединение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A> для установления соединения с удаленным узлом, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует <xref:System.Net.Sockets.Socket.SendTo%2A>использовать. Если вы не используете <xref:System.Net.Sockets.Socket.SendTo%2A>, то придется вызывать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Его можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A> , сделав еще один <xref:System.Net.Sockets.Socket.Connect%2A>вызов.  
  
 Кроме того, необходимо убедиться, что размер не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.Send%2A> создаст <xref:System.Net.Sockets.SocketException>исключение.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> блокируется до тех пор, пока не будет отправлено запрошенное число байтов, если не было задано время ожидания с помощью. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Send%2A> вызов <xref:System.Net.Sockets.SocketException>выдаст исключение. В неблокирующем режиме может <xref:System.Net.Sockets.Socket.Send%2A> завершиться успешно, даже если количество отправленных байтов превышает. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода задаются буфер данных, смещение, размер и <xref:System.Net.Sockets.SocketFlags> для отправки данных в соединение. <xref:System.Net.Sockets.Socket>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
-или- 
 Значение параметра <paramref name="size" /> меньше 0.  
  
- или - 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
-или- 
Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="offset">Положение в буфере данных, с которого начинается отправка данных.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Объект <see cref="T:System.Net.Sockets.SocketError" />, содержащий ошибку сокета.</param>
        <summary>Посылает указанное число байтов данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, начиная с указанного смещения и используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Количество байтов, отправленных в <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>синхронно отправляет данные на удаленный узел, указанный в <xref:System.Net.Sockets.Socket.Connect%2A> методе или <xref:System.Net.Sockets.Socket.Accept%2A> , и возвращает число успешно отправленных байтов. <xref:System.Net.Sockets.Socket.Send%2A>можно использовать для протоколов, ориентированных на подключение и без подключения.  
  
 В этой перегрузке при указании <xref:System.Net.Sockets.SocketFlags.DontRoute> флага в `socketflags` качестве параметра отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> метод перед вызовом этого метода или <xref:System.Net.Sockets.Socket.Send%2A> вызвать исключение. <xref:System.Net.Sockets.SocketException> Если используется протокол, ориентированный на соединение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A> для установления соединения с удаленным узлом, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если вы используете протокол без установления соединения и планируете отправку данных на несколько разных узлов, следует <xref:System.Net.Sockets.Socket.SendTo%2A>использовать. Если вы не используете <xref:System.Net.Sockets.Socket.SendTo%2A>, то придется вызывать <xref:System.Net.Sockets.Socket.Connect%2A> перед каждым вызовом <xref:System.Net.Sockets.Socket.Send%2A>. Его можно использовать <xref:System.Net.Sockets.Socket.SendTo%2A> даже после установки удаленного узла по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A>. Можно также изменить удаленный узел по умолчанию перед вызовом <xref:System.Net.Sockets.Socket.Send%2A> , сделав еще один <xref:System.Net.Sockets.Socket.Connect%2A>вызов.  
  
 Кроме того, необходимо убедиться, что размер не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.Send%2A> создаст <xref:System.Net.Sockets.SocketException>исключение.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.Send%2A> блокируется до тех пор, пока не будет отправлено запрошенное число байтов, если не было задано время ожидания с помощью. <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> Если значение времени ожидания было превышено, <xref:System.Net.Sockets.Socket.Send%2A> вызов <xref:System.Net.Sockets.SocketException>выдаст исключение. В неблокирующем режиме может <xref:System.Net.Sockets.Socket.Send%2A> завершиться успешно, даже если количество отправленных байтов превышает. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.Send%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Успешное завершение отправки не означает, что данные были успешно доставлены. Если в транспортной системе нет доступных буферных пространств для хранения данных, подходящих для передачи, отправка будет заблокирована, пока сокет не будет помещен в неблокирующий режим.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода задаются буфер данных, смещение, размер и <xref:System.Net.Sockets.SocketFlags> для отправки данных в соединение. <xref:System.Net.Sockets.Socket>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
- или - 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
- или - 
 Значение параметра <paramref name="size" /> меньше 0.  
  
- или - 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
- или - 
Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Выполняет асинхронную передачу данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> Метод используется для записи исходящих данных из одного или нескольких буферов на сокете, ориентированном на соединение. Однако этот метод можно также использовать для сокетов без подключения, которые указали удаленный узел в операции подключения.  
  
 <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.Connect%2A>Метод запускает асинхронную операцию отправки на удаленный узел, установленный в методе,, <xref:System.Net.Sockets.Socket.BeginConnect%2A>,, или. <xref:System.Net.Sockets.Socket.SendAsync%2A>  
  
 Для успешного вызова этого метода необходимы следующие <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> свойства и события объекта:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> или <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>Если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> задано значение  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>Если <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> задано значение  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> для свойства любой объект пользовательского состояния, необходимый перед <xref:System.Net.Sockets.Socket.SendAsync%2A> вызовом метода, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A>Метод вызывает исключение, если не выполняется первый вызов <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>,, или. <xref:System.Net.Sockets.Socket.SendAsync%2A>  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A> Вызов метода дает возможность отправки данных в отдельном потоке выполнения.  
  
 Для сокетов, ориентированных на сообщения, не следует превысить максимальный размер сообщения в базовом поставщике службы Windows Sockets. Если данные слишком длинны для передачи атомарным образом через базового поставщика услуг, данные не передаются, а <xref:System.Net.Sockets.Socket.SendAsync%2A> метод <xref:System.Net.Sockets.SocketException> создает исключение с <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> установленным кодом ошибки всаемсгсизе в машинном коде Winsock (10040).  
  
 Обратите внимание, что успешное <xref:System.Net.Sockets.Socket.SendAsync%2A> завершение метода не означает, что данные были успешно доставлены.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойства <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> или <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> на параметре <paramref name="e" /> должны ссылаться на допустимые буферы. Может быть установлено одно из этих свойств, но нельзя одновременно устанавливать оба свойства.</exception>
        <exception cref="T:System.InvalidOperationException">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Объект <see cref="T:System.Net.Sockets.Socket" /> уже не подключен или он был получен посредством метода <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> или <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее размер буфера передачи объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Объект <see cref="T:System.Int32" />, который содержит значение размера буфера передачи в байтах. Значение по умолчанию — 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Больший размер буфера может замедлить распознавание проблем с подключением. Если вы передаете большие файлы или используете высокоскоростное подключение с высокой задержкой (например, поставщик широкополосного подключения), попробуйте увеличить размер буфера.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.SendBufferSize%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное для операции установки, меньше 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет синхронную передачу файла и дополнительных данных на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Параметр типа <see cref="T:System.String" />, содержащий имя отправляемого файла и путь к нему. Этот параметр может иметь значение <see langword="null" />.</param>
        <summary>Отправляет файл <paramref name="fileName" /> на подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя флаг передачи <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка отправляет файл `fileName` на подключенный сокет. `preBuffer` `postBuffer` `null`Параметр по умолчанию имеет <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> значение (0), а параметры и по умолчанию имеют значение. `flags` Если `fileName` параметр находится в локальном каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла. Подстановочные знаки (".. \\\\\\\\\мифиле.ткст ") и общие имена UNC (" \шаред Directory \мифиле.ткст ") поддерживаются. \\ Если файл не найден, возникает исключение <xref:System.IO.FileNotFoundException> .  
  
 Этот метод использует функцию `TransmitFile` , обнаруженную в API Windows Sockets 2. Дополнительные сведения о `TransmitFile` функции и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A>синхронно отправляет файл на удаленный узел, указанный в <xref:System.Net.Sockets.Socket.Connect%2A> методе или. <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.SendFile%2A>можно использовать как для подключений, так и для протоколов без подключения.  
  
 Если используется протокол без установления соединения, перед вызовом этого <xref:System.Net.Sockets.Socket.Connect%2A> метода необходимо вызвать, в противном случае <xref:System.Net.Sockets.SocketException> <xref:System.Net.Sockets.Socket.SendFile%2A> вызывает исключение. Если используется протокол, ориентированный на соединение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A> для установления соединения с удаленным узлом, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.SendFile%2A> блокируется до отправки файла. В неблокирующем режиме <xref:System.Net.Sockets.Socket.SendFile%2A> может завершиться успешно перед отправкой всего файла. Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.SendFile%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается и подключается сокет, а затем файл отправляется на удаленный узел. Файл Test. txt находится в корневом каталоге локального компьютера.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Сокет не подключен к удаленному узлу.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Net.Sockets.Socket" /> не находится в режиме блокировки и не может принять этот синхронный вызов.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="fileName" /> не найден.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">Параметр типа <see cref="T:System.String" />, содержащий имя отправляемого файла и путь к нему. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="preBuffer">Массив <see cref="T:System.Byte" />, содержащий данные, отправляемые перед передачей файла. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="postBuffer">Массив <see cref="T:System.Byte" />, содержащий данные, отправляемые после передачи файла. Этот параметр может иметь значение <see langword="null" />.</param>
        <param name="flags">Одно или несколько значений <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</param>
        <summary>Отправляет файл <paramref name="fileName" /> и буферы данных в подключенный объект <see cref="T:System.Net.Sockets.Socket" />, используя указанное значение <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для этой перегрузки требуется имя файла, который необходимо отправить, и побитовое <xref:System.Net.Sockets.TransmitFileOptions> сочетание значений. `preBuffer` Параметр содержит все данные, которые должны предшествовать файлу. `postBuffer`содержит данные, которые необходимо отслеживать в файле. Если `fileName` параметр находится в текущем рабочем каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла. Подстановочные знаки (".. \\\\\\\\\мифиле.ткст ") и общие имена UNC (" \шаред Directory \мифиле.ткст ") поддерживаются. \\  
  
 `flags` Параметр предоставляет поставщику услуг Windows Sockets дополнительные сведения о переносе файлов. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Этот метод использует функцию `TransmitFile` , обнаруженную в API Windows Sockets 2. Дополнительные сведения о `TransmitFile` функции и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A>синхронно отправляет файл на удаленный узел, указанный в <xref:System.Net.Sockets.Socket.Connect%2A> методе или. <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.SendFile%2A>можно использовать как для подключений, так и для протоколов без подключения.  
  
 Если используется протокол без установления соединения, необходимо вызвать <xref:System.Net.Sockets.Socket.Connect%2A> метод перед вызовом этого метода. в противном случае <xref:System.Net.Sockets.Socket.SendFile%2A> создает исключение <xref:System.Net.Sockets.SocketException>. Если используется протокол, ориентированный на соединение, необходимо либо использовать <xref:System.Net.Sockets.Socket.Connect%2A> для установления соединения с удаленным узлом, либо использовать <xref:System.Net.Sockets.Socket.Accept%2A> для приема входящего подключения.  
  
 Если используется протокол, ориентированный на соединение, <xref:System.Net.Sockets.Socket.SendFile%2A> блокируется до отправки всего файла. В неблокирующем режиме <xref:System.Net.Sockets.Socket.SendFile%2A> может завершиться успешно перед отправкой всего файла. Нет никакой гарантии, что отправленные данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.SendFile%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода создается и подключается сокет. Файл Test. txt находится в корневом каталоге локального компьютера. В этом примере мы создадим предбуферную и буферизованную передачу данных и отправим их на удаленный узел с помощью файла. Используются значения <xref:System.Net.Sockets.TransmitFileOptions> по умолчанию.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Операционной системой не является Windows NT или более поздняя версия.  
  
-или-
  
 Сокет не подключен к удаленному узлу.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Net.Sockets.Socket" /> не находится в режиме блокировки и не может принять этот синхронный вызов.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл <paramref name="fileName" /> не найден.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Выполняет асинхронную передачу набора файла или буферов данных в памяти на подключенный объект <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Метод используется для отправки коллекции файлов или буферов данных в памяти на удаленный узел. <xref:System.Net.Sockets.Socket> Должен быть уже подключен к удаленному узлу.  
  
 Если объект <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> ссылается на файл в рабочем каталоге, он может быть идентифицирован только с именем файла; в противном случае необходимо указать полный путь и имя файла. Поддерживаются подстановочные знаки и имена общих папок в формате UNC. Если файл не найден, <xref:System.IO.FileNotFoundException> вызывается исключение.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, реализующий\<обработчик EventHandler SocketAsyncEventArgs > делегата и присоединить <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> обратный вызов к событию.  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> Свойство `e`  в параметре предоставляет поставщику услуг Windows Sockets дополнительные сведения о переносе файлов. Дополнительные сведения об использовании этого параметра см. в разделе <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Для успешного вызова этого метода необходимы следующие <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> свойства и события объекта:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> для свойства любой объект пользовательского состояния, необходимый перед <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> вызовом метода, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 Этот метод использует функцию Трансмитпаккетс, находящийся в API Windows Sockets 2. Дополнительные сведения о функции Трансмитпаккетс и ее флагах см. в документации по [сокетам Windows](/windows/desktop/WinSock/) .  
  
 Хотя этот метод предназначен для протоколов, ориентированных на соединение, он <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> также работает для протоколов без подключения, при условии, что сначала <xref:System.Net.Sockets.Socket.BeginConnect%2A>вызывается метод, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> , чтобы установить удаленный узел по умолчанию. При использовании протоколов без подключения необходимо также убедиться в том, что размер файла не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не отправляется и <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> <xref:System.Net.Sockets.SocketException> вызывает исключение.  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Метод оптимизирован в соответствии с операционной системой, в которой он используется. В выпусках Windows Server <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> этот метод оптимизирован для обеспечения высокой производительности.  
  
 В выпусках <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> клиента Windows метод оптимизирован для использования минимального объема памяти и ресурсов.  
  
 Использование флага <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> в свойстве `e` параметра может обеспечить значительное повышение производительности. <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> Если поток, инициирующий <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> вызов метода, используется для интенсивных вычислений, можно, хотя маловероятно, избежать запуска APC. Обратите внимание, что существует разница между ядром и пользовательским режимом APC. Ядро APC запуск, когда поток находится в состоянии ожидания. Пользовательский режим APC запуск, когда поток находится в состоянии ожидания с оповещением  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Файл, указанный в свойстве <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" />, не найден.</exception>
        <exception cref="T:System.InvalidOperationException">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях. Это исключение возникает также в том случае, когда объект <see cref="T:System.Net.Sockets.Socket" /> не подключен к удаленному узлу.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Используется объект <see cref="T:System.Net.Sockets.Socket" />, функционирующий без установления соединения, и размер отправляемого файла превышает максимальный размер пакета основного транспортного средства.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или устанавливает значение, указывающее промежуток времени, после которого для синхронного вызова <see cref="Overload:System.Net.Sockets.Socket.Send" /> истечет время тайм-аута.</summary>
        <value>Значение времени ожидания в миллисекундах. Если для этого свойства задать значение от 1 до 499, значение будет изменено на 500. По умолчанию используется значение 0, указывающее на бесконечное значение интервала для тайм-аута Задание значения -1 также указывает на бесконечное значение интервала для тайм-аута.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот параметр применяется только к <xref:System.Net.Sockets.Socket.Send%2A> синхронным вызовам. При превышении <xref:System.Net.Sockets.Socket.Send%2A> времени ожидания метод вызовет <xref:System.Net.Sockets.SocketException>исключение.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.SendTimeout%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное для операции задания, меньше –1.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Посылает данные на указанную конечную точку.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий пункт назначения для данных.</param>
        <summary>Посылает данные на указанную конечную точку.</summary>
        <returns>Число отправленных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этой перегрузке смещение буфера по умолчанию равно 0, число отправляемых байтов по умолчанию равно размеру `buffer` параметра, <xref:System.Net.Sockets.SocketFlags> а значение по умолчанию — 0.  
  
 Если используется протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A> методом перед вызовом. <xref:System.Net.Sockets.Socket.SendTo%2A> Это необходимо сделать только в том случае, если предполагается вызывать <xref:System.Net.Sockets.Socket.Send%2A> метод. Если <xref:System.Net.Sockets.Socket.Connect%2A> метод вызывается до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>метода, этот `remoteEP` параметр переопределит указанный удаленный узел по умолчанию только для этой операции отправки. Вам также не обязательно вызывать <xref:System.Net.Sockets.Socket.Bind%2A> метод, так как базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта. Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> свойство <xref:System.Net.Sockets.Socket.SendTo%2A> после успешного завершения метода.  
  
 Хотя и предназначен для протоколов без <xref:System.Net.Sockets.Socket.SendTo%2A> подключения, также работает с протоколами, ориентированными на подключения. Если используется протокол, ориентированный на соединение, необходимо сначала установить соединение с удаленным узлом, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или приняв входящий запрос на <xref:System.Net.Sockets.Socket.Accept%2A> соединение с помощью метода. Если не установить или принять соединение с удаленным узлом, <xref:System.Net.Sockets.Socket.SendTo%2A> будет вызвано <xref:System.Net.Sockets.SocketException>исключение. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед <xref:System.Net.Sockets.Socket.SendTo%2A> вызовом метода. В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> `remoteEP` параметр будет игнорировать параметры и отправить данные только на удаленный узел, подключенный по умолчанию.  
  
 Блокирующие сокеты блокируются до тех пор, пока не будут отправлены все байты в буфере. Поскольку неблокировка <xref:System.Net.Sockets.Socket> завершается немедленно, она может не отправить все байты `buffer`в. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит все байты в `buffer`. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.SendTo%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
 Если вы используете протокол без установления соединения в блокирующем режиме <xref:System.Net.Sockets.Socket.SendTo%2A> , будет блокироваться до отправки датаграммы. Если вы хотите отправить данные на широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод и установить параметр сокета в <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>значение. Кроме того, необходимо убедиться, что число отправленных байтов не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.SendTo%2A> создаст <xref:System.Net.Sockets.SocketException>исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода датаграмма без подключения отправляется на указанный удаленный узел.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.  
  
-или- 
 Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий пункт назначения для данных.</param>
        <summary>Передает данные на указанную конечную точку, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Число отправленных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этой перегрузке смещение буфера по умолчанию равно 0, а число байтов для отправки по умолчанию равно размеру `buffer`. Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> в `socketflags` качестве параметра флаг, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A> методом перед вызовом. <xref:System.Net.Sockets.Socket.SendTo%2A> Это необходимо сделать только в том случае, если предполагается вызывать <xref:System.Net.Sockets.Socket.Send%2A> метод. Если <xref:System.Net.Sockets.Socket.Connect%2A> метод вызывается до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>метода, этот `remoteEP` параметр переопределит указанный удаленный узел по умолчанию только для этой операции отправки. Вам также не обязательно вызывать <xref:System.Net.Sockets.Socket.Bind%2A> метод, так как базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта. Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> свойство <xref:System.Net.Sockets.Socket.SendTo%2A> после успешного завершения метода.  
  
 Хотя и предназначен для протоколов без <xref:System.Net.Sockets.Socket.SendTo%2A> подключения, также работает с протоколами, ориентированными на подключения. Если используется протокол, ориентированный на соединение, необходимо сначала установить соединение с удаленным узлом, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или приняв входящий запрос на <xref:System.Net.Sockets.Socket.Accept%2A> соединение с помощью метода. Если не установить или принять соединение с удаленным узлом, <xref:System.Net.Sockets.Socket.SendTo%2A> будет вызвано <xref:System.Net.Sockets.SocketException>исключение. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед <xref:System.Net.Sockets.Socket.SendTo%2A> вызовом метода. В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> `remoteEP` параметр будет игнорировать параметры и отправить данные только на удаленный узел, подключенный по умолчанию.  
  
 Блокирующие сокеты блокируются до тех пор, пока не будут отправлены все байты в `buffer` . Поскольку неблокировка <xref:System.Net.Sockets.Socket> завершается немедленно, она может не отправить все байты `buffer`в. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит все байты в `buffer`. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.SendTo%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
 Если вы используете протокол без установления соединения в блокирующем режиме <xref:System.Net.Sockets.Socket.SendTo%2A> , будет блокироваться до отправки датаграммы. Если вы хотите отправить данные на широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод и установить параметр сокета в <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>значение. Кроме того, необходимо убедиться, что число отправленных байтов не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.SendTo%2A> создаст <xref:System.Net.Sockets.SocketException>исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода датаграмма без подключения отправляется на указанный удаленный узел. <xref:System.Net.Sockets.SocketFlags>передаются <xref:System.Net.Sockets.Socket.SendTo%2A> в метод.  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> — <see langword="null" />.  
  
-или- 
 Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий пункт назначения для данных.</param>
        <summary>Посылает указанное число байтов данных на указанную конечную точку, используя заданный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Число отправленных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этой перегрузке смещение буфера по умолчанию равно 0. Если указать <xref:System.Net.Sockets.SocketFlags.DontRoute> в `socketflags` качестве параметра флаг, отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A> методом перед вызовом. <xref:System.Net.Sockets.Socket.SendTo%2A> Это необходимо сделать только в том случае, если предполагается вызывать <xref:System.Net.Sockets.Socket.Send%2A> метод. Если <xref:System.Net.Sockets.Socket.Connect%2A> метод вызывается до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>метода, этот `remoteEP` параметр переопределит указанный удаленный узел по умолчанию только для этой операции отправки. Вам также не обязательно вызывать <xref:System.Net.Sockets.Socket.Bind%2A> метод, так как базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта. Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> свойство <xref:System.Net.Sockets.Socket.SendTo%2A> после успешного завершения метода.  
  
 Хотя и предназначен для протоколов без <xref:System.Net.Sockets.Socket.SendTo%2A> подключения, также работает с протоколами, ориентированными на подключения. Если используется протокол, ориентированный на соединение, необходимо сначала установить соединение с удаленным узлом, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или приняв входящий запрос на <xref:System.Net.Sockets.Socket.Accept%2A> соединение с помощью метода. Если не установить или принять соединение с удаленным узлом, <xref:System.Net.Sockets.Socket.SendTo%2A> будет вызвано <xref:System.Net.Sockets.SocketException>исключение. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед <xref:System.Net.Sockets.Socket.SendTo%2A> вызовом метода. В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> `remoteEP` параметр будет игнорировать параметры и отправить данные только на удаленный узел, подключенный по умолчанию.  
  
 Блокирующие сокеты блокируются до тех пор, пока не будет отправлено запрошенное число байтов. Поскольку неблокировка <xref:System.Net.Sockets.Socket> завершается немедленно, она может не отправить все запрошенные байты в одной операции. Ответственность за отслеживание числа отправленных байтов и повтор операции до тех пор, пока приложение не отправит запрошенное число байтов. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.SendTo%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
 Если вы используете протокол без установления соединения в блокирующем режиме <xref:System.Net.Sockets.Socket.SendTo%2A> , будет блокироваться до отправки датаграммы. Если вы хотите отправить данные на широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод и установить параметр сокета в <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>значение. Кроме того, необходимо убедиться, что число отправленных байтов не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.SendTo%2A> создаст <xref:System.Net.Sockets.SocketException>исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода датаграмма без подключения отправляется на указанный удаленный узел. Размер и <xref:System.Net.Sockets.SocketFlags> передаются <xref:System.Net.Sockets.Socket.SendTo%2A> в метод.  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.  
  
- или - 
 <paramref name="remoteEP" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Заданное значение <paramref name="size" /> превышает размер параметра <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив типа <see cref="T:System.Byte" />, содержащий данные для отправки.</param>
        <param name="offset">Положение в буфере данных, с которого начинается отправка данных.</param>
        <param name="size">Количество байтов для отправки.</param>
        <param name="socketFlags">Поразрядное сочетание значений <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Объект <see cref="T:System.Net.EndPoint" />, представляющий пункт назначения для данных.</param>
        <summary>Посылает указанное число байтов данных на указанную конечную точку, начиная с заданной позиции буфера и используя указанный объект <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Число отправленных байтов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этой перегрузке при указании <xref:System.Net.Sockets.SocketFlags.DontRoute> флага в `socketflags` качестве параметра отправляемые данные не будут маршрутизироваться.  
  
 Если используется протокол без установления соединения, не нужно устанавливать удаленный узел по умолчанию с <xref:System.Net.Sockets.Socket.Connect%2A> методом перед вызовом. <xref:System.Net.Sockets.Socket.SendTo%2A> Это необходимо сделать только в том случае, если предполагается вызывать <xref:System.Net.Sockets.Socket.Send%2A> метод. Если <xref:System.Net.Sockets.Socket.Connect%2A> метод вызывается до вызова <xref:System.Net.Sockets.Socket.SendTo%2A>метода, этот `remoteEP` параметр переопределит указанный удаленный узел по умолчанию только для этой операции отправки. Вам также не обязательно вызывать <xref:System.Net.Sockets.Socket.Bind%2A> метод, так как базовый поставщик услуг будет назначать наиболее подходящий адрес локальной сети и номер порта. Если необходимо указать назначенный локальный сетевой адрес и номер порта, можно использовать <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> свойство <xref:System.Net.Sockets.Socket.SendTo%2A> после успешного завершения метода.  
  
 Хотя и предназначен для протоколов без <xref:System.Net.Sockets.Socket.SendTo%2A> подключения, также работает с протоколами, ориентированными на подключения. Если используется протокол, ориентированный на соединение, необходимо сначала установить соединение с удаленным узлом, вызвав <xref:System.Net.Sockets.Socket.Connect%2A> метод или приняв входящий запрос на <xref:System.Net.Sockets.Socket.Accept%2A> соединение с помощью метода. Если не установить или принять соединение с удаленным узлом, <xref:System.Net.Sockets.Socket.SendTo%2A> будет вызвано <xref:System.Net.Sockets.SocketException>исключение. Кроме того, можно установить удаленный узел по умолчанию для протокола без установления соединения перед <xref:System.Net.Sockets.Socket.SendTo%2A> вызовом метода. В любом из этих случаев <xref:System.Net.Sockets.Socket.SendTo%2A> `remoteEP` параметр будет игнорировать параметры и отправить данные только на удаленный узел, подключенный по умолчанию.  
  
 Блокирующие сокеты блокируются до тех пор, пока не будет отправлено запрошенное число байтов. Так как неблокировка <xref:System.Net.Sockets.Socket> завершается немедленно, она может не отправить все запрошенные байты в одной операции. Мы обязаны следить за количеством отправленных байтов и повторить операцию до тех пор, пока приложение не отправит запрошенное число байтов. Кроме того, не гарантируется, что отправляемые данные будут немедленно отображаться в сети. Чтобы повысить эффективность работы сети, базовая система может отложить передачу данных до тех пор, пока не будет собрано значительное количество исходящих. Успешное завершение <xref:System.Net.Sockets.Socket.SendTo%2A> метода означает, что базовая система имела место для буферизации данных для отправки в сеть.  
  
 Если вы используете протокол без установления соединения в блокирующем режиме <xref:System.Net.Sockets.Socket.SendTo%2A> , будет блокироваться до отправки датаграммы. Если вы хотите отправить данные на широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод и установить параметр сокета в <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>значение. Кроме того, необходимо убедиться, что размер не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.SendTo%2A> создаст <xref:System.Net.Sockets.SocketException>исключение.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода датаграмма без подключения отправляется на указанный удаленный узел. Смещение, размер и <xref:System.Net.Sockets.SocketFlags> передаются <xref:System.Net.Sockets.Socket.SendTo%2A> в метод.  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.  
  
- или - 
 Свойство <paramref name="remoteEP" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="offset" /> меньше 0.  
  
-или- 
 Значение <paramref name="offset" /> превышает длину <paramref name="buffer" />.  
  
- или - 
 Значение параметра <paramref name="size" /> меньше 0.  
  
- или - 
 Значение <paramref name="size" /> превышает значение, полученное, если отнять от длины <paramref name="buffer" /> значение параметра <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> — недопустимое сочетание значений.  
  
- или - 
Произошла ошибка операционной системы при доступе к <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Security.SecurityException">Вызывающий оператор в стеке вызовов не имеет необходимых разрешений.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> для использования в данной асинхронной операции сокета.</param>
        <summary>Асинхронно передает данные на конкретный удаленный узел.</summary>
        <returns><see langword="true" />, если операция ввода-вывода находится в состоянии ожидания. По завершении операции создается событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> в параметре <paramref name="e" />.  
  
 <see langword="false" />, если операция ввода-вывода завершена синхронно. В данном случае событие <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> на параметре <paramref name="e" /> не будет создано и объект <paramref name="e" />, передаваемый как параметр, можно изучить сразу после получения результатов вызова метода для извлечения результатов операции.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод запускает асинхронную операцию отправки на удаленный узел, указанный <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> в свойстве `e` параметра. <xref:System.Net.Sockets.Socket.SendToAsync%2A> <xref:System.Net.Sockets.Socket.SendToAsync%2A> Вызов метода дает возможность отправки данных в отдельном потоке выполнения. Несмотря на то, что этот метод предназначен для протоколов без подключения, работает с протоколами, <xref:System.Net.Sockets.Socket.SendToAsync%2A> ориентированными на подключения и без них.  
  
 Чтобы получать уведомления о завершении, необходимо создать метод обратного вызова, реализующий\<обработчик EventHandler SocketAsyncEventArgs > делегата и присоединить <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> обратный вызов к событию.  
  
 Для успешного вызова этого метода необходимы следующие <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> свойства и события объекта:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Вызывающая сторона может задать <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> для свойства любой объект пользовательского состояния, необходимый перед <xref:System.Net.Sockets.Socket.SendToAsync%2A> вызовом метода, чтобы информация была извлечена в методе обратного вызова. Если для обратного вызова требуется больше сведений, чем для одного объекта, можно создать небольшой класс для хранения других требуемых сведений о состоянии в качестве членов.  
  
 При использовании <xref:System.Net.Sockets.Socket.Accept%2A>протокола, ориентированного на соединение, необходимо сначала вызвать метод, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>,, или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> . В <xref:System.Net.Sockets.Socket.SendToAsync%2A> противном случае <xref:System.Net.Sockets.SocketException>будет вызвано исключение. При использовании протокола, ориентированного на соединение, <xref:System.Net.Sockets.Socket.SendToAsync%2A> метод <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> игнорирует свойство и отправляет данные в объект <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.EndPoint?displayProperty=nameWithType> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.Accept%2A>, установленный в, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>,,, <xref:System.Net.Sockets.Socket.Connect%2A> метод или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> .  
  
 Если используется протокол без установления соединения, не <xref:System.Net.Sockets.Socket.BeginConnect%2A>нужно устанавливать удаленный узел по умолчанию с методом, <xref:System.Net.Sockets.Socket.Connect%2A>или <xref:System.Net.Sockets.Socket.ConnectAsync%2A> до вызова <xref:System.Net.Sockets.Socket.SendToAsync%2A>метода. Это необходимо сделать только в том случае, если предполагается вызывать <xref:System.Net.Sockets.Socket.BeginSend%2A> методы <xref:System.Net.Sockets.Socket.SendAsync%2A> или. При <xref:System.Net.Sockets.Socket.BeginConnect%2A>вызове метода, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.Connect%2A>или перед вызовом <xref:System.Net.Sockets.Socket.SendToAsync%2A> <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> свойство переопределит указанный удаленный узел по умолчанию только для этой операции отправки. Также не требуется вызывать <xref:System.Net.Sockets.Socket.Bind%2A> метод. В этом случае базовый поставщик услуг будет назначать наиболее подходящий IP-адрес локальной сети и номер порта. Если необходимо, чтобы базовый поставщик услуг выберет свободный порт, используйте нуль-порт. Если необходимо указать назначенный локальный сетевой IP-адрес и номер порта, можно использовать <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> свойство <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> после получения сигнала о событии и вызова связанных делегатов.  
  
 Если вы хотите отправить данные на широковещательный адрес, необходимо сначала вызвать <xref:System.Net.Sockets.Socket.SetSocketOption%2A> метод и установить <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> параметр сокета в значение true. Кроме того, необходимо убедиться, что размер буфера не превышает максимальный размер пакета для базового поставщика услуг. Если это так, датаграмма не будет отправлена и <xref:System.Net.Sockets.Socket.SendToAsync%2A> создаст <xref:System.Net.Sockets.SocketException>исключение.  
  
 Если в <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> свойстве указан флаг донтрауте, отправляемые данные не будут маршрутизироваться.  
  
 Для сокетов, ориентированных на сообщения, необходимо не превышать максимальный размер сообщения базового транспорта. Если размер буфера превышает максимальный размер пакета основного поставщика услуг, датаграмма не отправляется и <xref:System.Net.Sockets.Socket.SendToAsync%2A> вызывает <xref:System.Net.Sockets.SocketException>исключение. Успешное завершение <xref:System.Net.Sockets.Socket.SendToAsync%2A> метода не означает, что данные были успешно доставлены.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Объект <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> не может иметь значение "null".</exception>
        <exception cref="T:System.InvalidOperationException">Операция сокета уже выполнялась с использованием объекта <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />, указанного в параметре <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот метод доступен только в Windows XP и более поздних версиях.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Указанный протокол работает с установлением соединения, но объект <see cref="T:System.Net.Sockets.Socket" /> еще не подключен.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="level">Уровень защиты IP, который надо установить для сокета.</param>
        <summary>Задается стандартный уровень защиты IP для сокета.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Метод позволяет ограничить сокеты IPv6 или IP для прослушивания указанной области, например адресов с одинаковой локальной ссылкой или локальным префиксом сайта. Этот параметр сокета позволяет приложениям размещать ограничения доступа к сокетам IPv6 или IP. Такие ограничения позволяют приложению, работающему в частной локальной сети, просто и надежно защититься от внешних атак. Этот параметр сокета также можно использовать для удаления ограничений доступа, `level` если параметр имеет <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>значение. Этот параметр сокета расширяет или сужает диапазон прослушивающего сокета, обеспечивая при необходимости неограниченный доступ со стороны открытых и закрытых пользователей или ограничивая доступ только тем же сайтом.  
  
 Определенные уровни защиты этого параметра сокета указаны в перечислении <xref:System.Net.Sockets.IPProtectionLevel>.  
  
 Метод используется для включения или отключения обхода сетевых адресов (NAT) <xref:System.Net.Sockets.Socket> для экземпляра. <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Обход NAT может быть предоставлен с помощью Teredo, 6to4 или туннеля ISATAP.  
  
 Если параметр имеет <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>значение или <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, то <xref:System.Net.Sockets.Socket> он явно отключает обход NAT для экземпляра. `level`  
  
 Если параметр имеет <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>значение, это может разрешить обход NAT для, <xref:System.Net.Sockets.Socket> в зависимости от правил брандмауэра, установленных в системе. `level`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="level" /> не может иметь значение <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />. Уровень защиты IP не может быть неопределенным.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Sockets.AddressFamily" /> сокета должен быть либо <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />, либо <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Устанавливает параметр <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Значение параметра, представленное в виде объекта <see cref="T:System.Boolean" />.</param>
        <summary>Устанавливает для заданного параметра <see cref="T:System.Net.Sockets.Socket" /> указанное значение <see cref="T:System.Boolean" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>параметры определяют поведение текущего <xref:System.Net.Sockets.Socket>объекта. Задайте для значение `optionValue` , чтобы включить параметр, или `false` для отключения параметра. `true`  
  
 <xref:System.Net.Sockets.Socket>Параметры группируются по уровню поддержки протокола.  
  
 Ниже приведены различные <xref:System.Net.Sockets.Socket> параметры, которые можно задать с помощью этой перегрузки. Эти параметры группируются по соответствующему <xref:System.Net.Sockets.SocketOptionLevel> значению. Если вы собираетесь задать любой из этих параметров, обязательно используйте соответствующее <xref:System.Net.Sockets.SocketOptionLevel> значение `optionLevel` для параметра. Параметр, выбранный для установки, должен быть указан в `optionName` параметре. Если вы хотите получить текущее значение любого из перечисленных параметров, используйте <xref:System.Net.Sockets.Socket.GetSocketOption%2A> метод.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType>параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType>параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType>параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType>параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 Дополнительные сведения об этих параметрах см. в <xref:System.Net.Sockets.SocketOptionName> описании перечисления.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException> исключение, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
   
  
## Examples  
 В следующем примере кода открывается сокет и включаются `DontLinger` параметры `OutOfBandInline` и сокета.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Net.Sockets.Socket" /> закрыт.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Массив типа <see cref="T:System.Byte" />, который представляет значение параметра.</param>
        <summary>Устанавливает для указанного параметра <see cref="T:System.Net.Sockets.Socket" /> заданное значение, представленное в виде байтового массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>параметры определяют поведение текущего <xref:System.Net.Sockets.Socket>объекта. Используйте эту перегрузку для <xref:System.Net.Sockets.Socket> задания этих параметров, для которых в качестве значения параметра требуется массив байтов.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.Sockets.LingerOption> задаются <xref:System.Net.Sockets.Socket.Send%2A> значения времени ожидания и.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Значение параметра.</param>
        <summary>Устанавливает заданное целое значение для указанного параметра <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>параметры определяют поведение текущего <xref:System.Net.Sockets.Socket>объекта. Для параметра с <xref:System.Boolean> типом данных укажите ненулевое значение, чтобы включить параметр, и нулевое значение для отключения параметра. Для параметра с целочисленным типом данных укажите соответствующее значение. <xref:System.Net.Sockets.Socket>Параметры группируются по уровню поддержки протокола.  
  
 Ниже приведены различные <xref:System.Net.Sockets.Socket> параметры, которые можно задать с помощью этой перегрузки. Эти параметры группируются по соответствующему <xref:System.Net.Sockets.SocketOptionLevel>параметру. Если вы собираетесь задать любой из этих параметров, обязательно используйте соответствующий <xref:System.Net.Sockets.SocketOptionLevel> `optionLevel` параметр. Параметр, выбранный для установки, должен быть указан в `optionName` параметре. Если вы хотите получить текущее значение любого из перечисленных параметров, используйте <xref:System.Net.Sockets.Socket.GetSocketOption%2A> метод.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType>параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType>параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType>параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType>параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType>параметры, которые можно задать с помощью этой перегрузки.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 Дополнительные сведения об этих параметрах см. в <xref:System.Net.Sockets.SocketOptionName> описании перечисления.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.Sockets.LingerOption> задаются <xref:System.Net.Sockets.Socket.Send%2A> значения времени ожидания и.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Объект <see cref="T:System.Net.Sockets.LingerOption" /> или <see cref="T:System.Net.Sockets.MulticastOption" />, содержащий значение параметра.</param>
        <summary>Устанавливает для указанного параметра <see cref="T:System.Net.Sockets.Socket" /> заданное значение, представленное в виде объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>параметры определяют поведение текущего <xref:System.Net.Sockets.Socket>объекта. Используйте эту перегрузку для <xref:System.Net.Sockets.SocketOptionName.Linger>установки <xref:System.Net.Sockets.SocketOptionName.AddMembership>параметров, <xref:System.Net.Sockets.SocketOptionName.DropMembership> и <xref:System.Net.Sockets.Socket> . Для параметра используйте <xref:System.Net.Sockets.Socket> для `optionLevel` параметра. <xref:System.Net.Sockets.SocketOptionName.Linger> Для <xref:System.Net.Sockets.SocketOptionName.AddMembership> и <xref:System.Net.Sockets.SocketOptionName.DropMembership>используйте . <xref:System.Net.Sockets.SocketOptionLevel.IP> Если вы хотите получить текущее значение любого из перечисленных выше параметров, используйте <xref:System.Net.Sockets.Socket.GetSocketOption%2A> метод.  
  
> [!NOTE]
>  Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
   
  
## Examples  
 В следующем примере кода <xref:System.Net.Sockets.LingerOption> задаются <xref:System.Net.Sockets.Socket.Send%2A> значения и времени ожидания.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">Одно из значений <see cref="T:System.Net.Sockets.SocketShutdown" />, указывающее на то, что операция более не разрешена.</param>
        <summary>Блокирует передачу и получение данных для объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании ориентированного <xref:System.Net.Sockets.Socket>на соединение <xref:System.Net.Sockets.Socket.Shutdown%2A> метода всегда вызывайте метод перед закрытием <xref:System.Net.Sockets.Socket>. Это гарантирует, что все данные отправляются и получаются на подключенном сокете до его закрытия.  
  
 Вызовите <xref:System.Net.Sockets.Socket>метод, чтобы освободить все управляемые и неуправляемые ресурсы, связанные с. <xref:System.Net.Sockets.Socket.Close%2A> Не пытайтесь повторно использовать <xref:System.Net.Sockets.Socket> после закрытия.  
  
 В следующей таблице приведены <xref:System.Net.Sockets.SocketShutdown> значения перечисления, которые являются допустимыми `how` для параметра.  
  
|Значение|Описание|  
|-----------|-----------------|  
|Отправить|Отключите отправку <xref:System.Net.Sockets.Socket>на этом.|  
|Получить|Отключите получение на этом <xref:System.Net.Sockets.Socket>.|  
|Оба|Отключите отправку и получение для <xref:System.Net.Sockets.Socket>этого.|  
  
 Значение  `how` , указывающее, что последующие вызовы не разрешены. <xref:System.Net.Sockets.SocketShutdown.Send>  <xref:System.Net.Sockets.Socket.Send%2A> Если используется соединение без подключения <xref:System.Net.Sockets.Socket>, то указание <xref:System.Net.Sockets.SocketShutdown.Send> не будет действовать.  
  
 Значение  `how` , указывающее, что последующие вызовы не разрешены. <xref:System.Net.Sockets.SocketShutdown.Receive>  <xref:System.Net.Sockets.Socket.Receive%2A> Это не влияет на более низкие уровни протокола. Если используется протокол, ориентированный на соединение, соединение будет разорвано, если после вызова метода выполнить <xref:System.Net.Sockets.Socket.Shutdown%2A> одно из следующих условий.  
  
-   Данные находятся в входящем сетевом буфере, ожидающем получения.  
  
-   Получены дополнительные данные.  
  
 Если используется протокол без установления соединения, датаграммы принимаются и ставятся в очередь. Однако если для дополнительных входящих датаграмм нет буферного пространства, они будут удалены, а отправителю не будет возвращено сообщение об ошибке. Использовать <xref:System.Net.Sockets.Socket.Shutdown%2A> для <xref:System.Net.Sockets.Socket>  подключения не рекомендуется.  
  
 Параметр `how` для <xref:System.Net.Sockets.SocketShutdown.Both>  отключения обеих операций отправки и получения, как описано выше.  
  
> [!NOTE]
>  При получении сообщения <xref:System.Net.Sockets.SocketException> при <xref:System.Net.Sockets.Socket.Shutdown%2A> вызове метода используйте <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
> [!NOTE]
>  Данный член генерирует сведения трассировки, если в приложении включена трассировка сети. Дополнительные сведения см. [в разделе Сетевая трассировка в .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Net.Sockets.Socket.Shutdown%2A> для <xref:System.Net.Sockets.Socket>отключения.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип объекта <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Net.Sockets.SocketType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A>параметр доступен только для чтения и задается <xref:System.Net.Sockets.Socket> при создании.  
  
   
  
## Examples  
 В следующем примере кода в консоль <xref:System.Net.Sockets.AddressFamily>выводятся <xref:System.Net.Sockets.ProtocolType> , <xref:System.Net.Sockets.SocketType>и.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, доступна ли на текущем узле поддержка протокола IPv4 и включена ли эта функция.</summary>
        <value>Значение <see langword="true" />, если текущий узел поддерживает протокол IPv4; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операционная система может поддерживать протоколы IPv4 и IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, поддерживает ли Framework протокол IPv6 для определенных устаревших членов <see cref="T:System.Net.Dns" />.</summary>
        <value>Значение <see langword="true" />, если Framework поддерживает протокол IPv6 для определенных устаревших методов <see cref="T:System.Net.Dns" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операционная система может поддерживать протоколы IPv4 и IPv6.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, занятые модулем <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Вызовите IDisposable. Dispose по завершении использования <xref:System.Net.Sockets.Socket>. Метод IDisposable. Dispose оставляет в непригодном для <xref:System.Net.Sockets.Socket> использования состоянии. После вызова IDisposable. Dispose необходимо освободить все ссылки на, <xref:System.Net.Sockets.Socket> чтобы сборщик мусора мог высвободить память, занимаемую заданной. <xref:System.Net.Sockets.Socket> Дополнительные сведения см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE] 
> Всегда вызывайте IDisposable. Dispose перед освобождением последней ссылки <xref:System.Net.Sockets.Socket>на. В противном случае используемые им ресурсы не будут освобождены до тех пор, пока сборщик мусора не вызовет для объекта <xref:System.Net.Sockets.Socket> метод `Finalize`.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, задающее время существования (TTL) IP-пакетов, отправленных объектом <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Значение времени существования TTL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение TTL указывает максимальное число маршрутизаторов, которые может пройти пакет, прежде чем маршрутизатор отклоняет пакет и сообщение об ошибке TTL (ICMP), полученное по истечении срока жизни, возвращается отправителю.  
  
 Для значения TTL можно задать значение от 0 до 255. Если это свойство не задано, значение TTL по умолчанию для сокета равно 32.  
  
 Установка этого свойства для сокета TCP/IP пропускается стеком TCP/SSL, если установлено успешное соединение с помощью сокета.  
  
 Если вы получаете <xref:System.Net.Sockets.SocketException>, <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> используйте свойство для получения конкретного кода ошибки. После получения этого кода обратитесь к документации по [коду ошибки API Windows Sockets версии 2](/windows/desktop/winsock/windows-sockets-error-codes-2) для получения подробного описания ошибки.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Net.Sockets.Socket.Ttl%2A> свойство.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">В качестве величины срока жизни нельзя задать отрицательное число.</exception>
        <exception cref="T:System.NotSupportedException">Это свойство может быть установлено только для сокетов в семействах <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> или <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Произошла ошибка при попытке доступа к сокету. Эта ошибка также возвращается при попытке задать срок жизни больше, чем 255.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> был закрыт.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, должен ли сокет использовать только режим ввода-вывода Overlapped.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Net.Sockets.Socket" /> использует только режим перекрывающего ввода-вывода; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задайте для этого свойства `true` значение, <xref:System.Net.Sockets.Socket> которое нужно вызвать <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. В противном случае платформа может назначить порту завершения сокету, что запрещает использование <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сокет привязан к порту завершения.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
