<Type Name="Binder" FullName="System.Reflection.Binder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="11240fb9c050851d65c9500083ac17afd2802967" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70490460" /></Metadata><TypeSignature Language="C#" Value="public abstract class Binder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Binder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Binder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Binder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Binder abstract" />
  <TypeSignature Language="F#" Value="type Binder = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Выбирает член из списка кандидатов и выполняет преобразование типов из действительного типа аргумента к формальному типу аргумента.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализации класса используются такими методами, как <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>, который выбирает из набора возможных элементов для выполнения на основе набора типов параметров и значений аргументов. <xref:System.Reflection.Binder> <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, который выбирает метод на основе типов параметров и т. д.  
  
 Реализация <xref:System.Reflection.Binder> по умолчанию класса предоставляется <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> свойством.  
  
   
  
## Examples  
 В следующем примере реализуются и демонстрируются все члены `Binder` класса. Метод `CanConvertFrom` Private находит совместимые типы для заданного типа.  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>При наследовании из <see cref="T:System.Reflection.Binder" />необходимо переопределить следующие члены: <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, <see cref="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />, <see cref="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" /> <see cref="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />, и <see cref="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Binder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Binder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Reflection.Binder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор вызывается конструкторами производных классов для инициализации состояния в этом типе.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindToField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo BindToField (System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo BindToField(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.FieldInfo[] match, object value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function BindToField (bindingAttr As BindingFlags, match As FieldInfo(), value As Object, culture As CultureInfo) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ BindToField(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ match, System::Object ^ value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member BindToField : System.Reflection.BindingFlags * System.Reflection.FieldInfo[] * obj * System.Globalization.CultureInfo -&gt; System.Reflection.FieldInfo" Usage="binder.BindToField (bindingAttr, match, value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.FieldInfo[]" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="match">Набор полей, которые являются кандидатами для сопоставления. Например, если объект <see cref="T:System.Reflection.Binder" /> используется методом <see cref="Overload:System.Type.InvokeMember" />, этот параметр указывает набор полей, определенных в отражении как возможные соответствия, как правило в связи с тем, что они имеют правильное имя члена. Реализация по умолчанию, предоставленная свойством <see cref="P:System.Type.DefaultBinder" />, изменяет порядок этого массива.</param>
        <param name="value">Значение поля, используемое для нахождения соответствующего поля.</param>
        <param name="culture">Экземпляр класса <see cref="T:System.Globalization.CultureInfo" />, который используется для управления приведения типов данных в реализациях связывателя, выполняющих приведение типов. Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.  
  
Примечание.   Например, если в реализации связывателя допускается приведение строкового типа к числовому, этот параметр необходим для преобразования значения типа <see langword="String" />, представляющего число 1000, в значение типа <see langword="Double" />, поскольку в разных языках и региональных параметрах значение 1000 представляется по-разному. Связыватель по умолчанию не выполняет подобного преобразования строковых типов.</param>
        <summary>Выбирает поле из заданного набора полей с учетом заданных критериев.</summary>
        <returns>Соответствующее поле.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `bindingAttr` не включает <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, реализация связывателя <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> по умолчанию, предоставляемая, просто возвращает первый `match`элемент. Выбор не выполняется.  
  
 Этот метод управляет привязкой, <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>предоставляемой.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">В связывателе по умолчанию параметр <paramref name="bindingAttr" /> содержит флаг <see cref="F:System.Reflection.BindingFlags.SetField" />, а параметр <paramref name="match" /> — несколько полей, в равной мере соответствующих параметру <paramref name="value" />. Например, параметр <paramref name="value" /> содержит объект <c>MyClass</c>, который реализует интерфейс <c>IMyClass</c>, а объект <paramref name="match" /> содержит поле типа <c>MyClass</c> и поле типа <c>IMyClass</c>.</exception>
        <exception cref="T:System.MissingFieldException">В связывателе по умолчанию параметр <paramref name="bindingAttr" /> содержит флаг <see cref="F:System.Reflection.BindingFlags.SetField" />, а параметр <paramref name="match" /> не содержит полей, которые могут принимать значение <paramref name="value" />.</exception>
        <exception cref="T:System.NullReferenceException">В связывателе по умолчанию параметр <paramref name="bindingAttr" /> содержит флаг <see cref="F:System.Reflection.BindingFlags.SetField" />, а параметр <paramref name="match" /> имеет значение <see langword="null" /> или является пустым массивом.  
  
-или- 
 Параметр <paramref name="bindingAttr" /> содержит флаг <see cref="F:System.Reflection.BindingFlags.SetField" />, а параметр <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
      </Docs>
    </Member>
    <Member MemberName="BindToMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase BindToMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, out object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase BindToMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, object[]&amp; args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] names, [out] object&amp; state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function BindToMethod (bindingAttr As BindingFlags, match As MethodBase(), ByRef args As Object(), modifiers As ParameterModifier(), culture As CultureInfo, names As String(), ByRef state As Object) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodBase ^ BindToMethod(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::MethodBase ^&gt; ^ match, cli::array &lt;System::Object ^&gt; ^ % args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ names, [Runtime::InteropServices::Out] System::Object ^ % state);" />
      <MemberSignature Language="F#" Value="abstract member BindToMethod : System.Reflection.BindingFlags * System.Reflection.MethodBase[] *  * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] *  -&gt; System.Reflection.MethodBase" Usage="binder.BindToMethod (bindingAttr, match, args, modifiers, culture, names, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="args" Type="System.Object[]" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="names" Type="System.String[]" />
        <Parameter Name="state" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="match">Набор методов, являющихся кандидатами для сопоставления. Например, если объект <see cref="T:System.Reflection.Binder" /> используется методом <see cref="Overload:System.Type.InvokeMember" />, этот параметр указывает набор методов, определенных в отражении как возможные соответствия, как правило в связи с тем, что они имеют правильное имя члена. Реализация по умолчанию, предоставленная свойством <see cref="P:System.Type.DefaultBinder" />, изменяет порядок этого массива.</param>
        <param name="args">Переданные аргументы. Связыватель может изменить порядок аргументов в этом массиве, например связыватель по умолчанию изменяет порядок аргументов в том случае, если этот порядок отличается от порядка по позиции аргументов и определяется параметром <paramref name="names" />. Если в реализации связывателя выполняется приведение типов аргументов, могут также изменяться типы и значения аргументов.</param>
        <param name="modifiers">Массив модификаторов параметров, позволяющий привязке работать с сигнатурами параметров, в которых были изменены типы. В реализации по умолчанию для связывателя этот параметр не используется.</param>
        <param name="culture">Экземпляр класса <see cref="T:System.Globalization.CultureInfo" />, который используется для управления приведения типов данных в реализациях связывателя, выполняющих приведение типов. Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.  
  
Примечание.   Например, если в реализации связывателя допускается приведение строкового типа к числовому, этот параметр необходим для преобразования значения типа <see langword="String" />, представляющего число 1000, в значение типа <see langword="Double" />, поскольку в разных языках и региональных параметрах значение 1000 представляется по-разному. Связыватель по умолчанию не выполняет подобного преобразования строковых типов.</param>
        <param name="names">Имена параметров, если они должны учитываться при сопоставлении, либо значение <see langword="null" />, если аргументы должны считаться чисто позиционными. Например, необходимо использовать имена параметров в том случае, если аргументы не передаются в порядке по их позиции.</param>
        <param name="state">После возврата из этого метода параметр <paramref name="state" /> содержит предоставленный связывателем объект, который отслеживает изменение порядка аргументов. Связыватель создает этот объект и является его единственным объектом-получателем. Если параметр <paramref name="state" /> не равен <see langword="null" /> в результате возврата из метода <see langword="BindToMethod" />, необходимо передать параметр <paramref name="state" /> в метод <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />, чтобы восстановить исходный порядок параметра <paramref name="args" />, например, с целью получить возможность извлекать значения параметров <see langword="ref" /> (в Visual Basic — параметров <see langword="ByRef" />).</param>
        <summary>Выбирает вызываемый метод из данного набора методов в зависимости от переданных аргументов.</summary>
        <returns>Соответствующий метод.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Связыватель по умолчанию учитывает оба параметра, значения и `params` массивы (`ParamArray` массивы в Visual Basic). Поэтому совпадение можно найти в случаях, когда `args` и `match` не содержат одинаковое число элементов.  
  
 Связыватель позволяет клиенту сопоставлять массив аргументов обратно к его исходной форме, если массив аргументов был обработан с помощью <xref:System.Reflection.Binder.BindToMethod%2A>. Используйте эту возможность повторного сопоставления, чтобы получить аргументы по ссылке при наличии таких аргументов. При передаче аргументов по имени связыватель переупорядочивает массив аргументов. Параметр отслеживает изменение порядка аргументов, тем самым позволяя <xref:System.Reflection.Binder.ReorderArgumentArray%2A> методу связывателя переупорядочивать массив аргументов в исходную форму. `state`  
  
 <xref:System.Reflection.Binder.BindToMethod%2A> Метод используется <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>  методом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">В связывателе по умолчанию параметр <paramref name="match" /> содержит несколько методов, которые являются соответствующими значениям параметра <paramref name="args" /> с одинаковой степенью соответствия. Например, параметр <paramref name="args" /> содержит объект <c>MyClass</c>, который реализует интерфейс <c>IMyClass</c>, а объект <paramref name="match" /> содержит метод, который принимает объект <c>MyClass</c> и метод, который принимает объект <c>IMyClass</c>.</exception>
        <exception cref="T:System.MissingMethodException">В связывателе по умолчанию параметр <paramref name="match" /> не содержит методов, которые могут принимать аргументы, переданные в параметре <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentException">В связывателе по умолчанию параметр <paramref name="match" /> имеет значение <see langword="null" /> или является пустым массивом.</exception>
        <altmember cref="T:System.Reflection.MethodBase" />
      </Docs>
    </Member>
    <Member MemberName="CanChangeType">
      <MemberSignature Language="C#" Value="public virtual bool CanChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.CanChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanChangeType(System::Object ^ value, Type ^ type, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member CanChangeType : obj * Type * System.Globalization.CultureInfo -&gt; bool&#xA;override this.CanChangeType : obj * Type * System.Globalization.CultureInfo -&gt; bool" Usage="binder.CanChangeType (value, type, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="xamarinios-10.8" />
        <Parameter Name="type" Type="System.Type" Index="1" FrameworkAlternate="xamarinios-10.8" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="xamarinios-10.8" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="type">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeType">
      <MemberSignature Language="C#" Value="public abstract object ChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ ChangeType(System::Object ^ value, Type ^ type, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member ChangeType : obj * Type * System.Globalization.CultureInfo -&gt; obj" Usage="binder.ChangeType (value, type, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Объект, для которого должен быть изменен параметр <see langword="Type" />.</param>
        <param name="type">Новый параметр <see langword="Type" />, к которому будет приведен параметр <paramref name="value" />.</param>
        <param name="culture">Экземпляр объекта <see cref="T:System.Globalization.CultureInfo" />, используемый для управления приведением типов данных. Если параметр <paramref name="culture" /> имеет значение <see langword="null" />, для текущего потока используется объект <see cref="T:System.Globalization.CultureInfo" />.  
  
Примечание.  Например, этот параметр необходим для преобразования значения типа <see langword="String" />, представляющего число 1000, в значение типа <see langword="Double" />, поскольку в разных языках и региональных параметрах значение 1000 представляется по-разному.</param>
        <summary>Меняет тип заданного <see langword="Object" /> на заданный <see langword="Type" />.</summary>
        <returns>Объект, содержащий заданное значение в качестве нового типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Отражение моделирует правила специальных возможностей системы общих типов. Например, если вызывающий объект находится в той же сборке, вызывающему объекту не требуются специальные разрешения для внутренних членов. В противном случае вызывающему объекту требуется <xref:System.Security.Permissions.ReflectionPermission>. Это согласуется с поиском защищенных, закрытых и других элементов.  
  
 Основным принципом является то `ChangeType` , что следует выполнять только расширяющее преобразование, которое никогда не теряет данные. Примером расширяющего приведения является приведение значения, которое является 32-битным целым числом со знаком, к значению, которое является 64-битным целым числом со знаком. Это отличается от сужающего приведения, что может привести к потере данных. Примером сужающего приведения является преобразование 64-битового целого числа со знаком в 32-разрядное целое число со знаком.  
  
 В следующей таблице перечислены преобразования, выполняемые по умолчанию `ChangeType`.  
  
|Тип исходного значения|Тип результирующего значения|  
|-----------------|-----------------|  
|Любой тип|Его базовый тип.|  
|Любой тип|Интерфейс, который он реализует.|  
|Char|UInt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Не является ссылкой|По ссылке.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReorderArgumentArray">
      <MemberSignature Language="C#" Value="public abstract void ReorderArgumentArray (ref object[] args, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReorderArgumentArray(object[]&amp; args, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ReorderArgumentArray (ByRef args As Object(), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ReorderArgumentArray(cli::array &lt;System::Object ^&gt; ^ % args, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member ReorderArgumentArray :  * obj -&gt; unit" Usage="binder.ReorderArgumentArray (args, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" RefType="ref" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="args">Фактически переданные аргументы. Допускается изменение как типов, так и значений этих аргументов.</param>
        <param name="state">Объект, предоставленный связывателем и отслеживающий изменение порядка аргументов.</param>
        <summary>При возвращении из <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" /> приводит аргумент <paramref name="args" /> к виду, в котором он был передан из <see langword="BindToMethod" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда CLR вызывает этот метод, если `state` не `null` после возврата из `BindToMethod`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase SelectMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase SelectMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SelectMethod (bindingAttr As BindingFlags, match As MethodBase(), types As Type(), modifiers As ParameterModifier()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodBase ^ SelectMethod(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::MethodBase ^&gt; ^ match, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member SelectMethod : System.Reflection.BindingFlags * System.Reflection.MethodBase[] * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodBase" Usage="binder.SelectMethod (bindingAttr, match, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="match">Набор методов, являющихся кандидатами для сопоставления. Например, если объект <see cref="T:System.Reflection.Binder" /> используется методом <see cref="Overload:System.Type.InvokeMember" />, этот параметр указывает набор методов, определенных в отражении как возможные соответствия, как правило в связи с тем, что они имеют правильное имя члена. Реализация по умолчанию, предоставленная свойством <see cref="P:System.Type.DefaultBinder" />, изменяет порядок этого массива.</param>
        <param name="types">Типы параметров, используемые для нахождения соответствующего метода.</param>
        <param name="modifiers">Массив модификаторов параметров, позволяющий привязке работать с сигнатурами параметров, в которых были изменены типы.</param>
        <summary>В зависимости от типа аргумента выбирает вызываемый метод из данного набора методов.</summary>
        <returns>Соответствующий метод, если таковой обнаружен; в обратном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен возвращать `null` значение, если ни один из методов не соответствует критериям. Этот метод управляет выбором, предоставленным `GetConstructor` методами и `GetMethod` в `Type`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">В связывателе по умолчанию параметр <paramref name="match" /> содержит несколько методов, которые являются соответствующими значениям типов параметров, определенных параметром <paramref name="types" />, с одинаковой степенью соответствия. Например, массив в параметре <paramref name="types" /> содержит объект <see cref="T:System.Type" /> для <c>MyClass</c>, а массив в параметре <paramref name="match" /> содержит метод, который принимает базовый класс объектов <c>MyClass</c>, а также метод, который принимает интерфейс, реализуемый классом <c>MyClass</c>.</exception>
        <exception cref="T:System.ArgumentException">В связывателе по умолчанию параметр <paramref name="match" /> имеет значение <see langword="null" /> или является пустым массивом.  
  
- или - 
Тип элемента параметра <paramref name="types" /> является производным от типа <see cref="T:System.Type" />, но не типом <see langword="RuntimeType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectProperty">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo SelectProperty (System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, Type returnType, Type[] indexes, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo SelectProperty(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.PropertyInfo[] match, class System.Type returnType, class System.Type[] indexes, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SelectProperty (bindingAttr As BindingFlags, match As PropertyInfo(), returnType As Type, indexes As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::PropertyInfo ^ SelectProperty(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ match, Type ^ returnType, cli::array &lt;Type ^&gt; ^ indexes, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member SelectProperty : System.Reflection.BindingFlags * System.Reflection.PropertyInfo[] * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="binder.SelectProperty (bindingAttr, match, returnType, indexes, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.PropertyInfo[]" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="indexes" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Побитовое сочетание значений <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="match">Набор свойств, являющихся кандидатами для сопоставления. Например, если объект <see cref="T:System.Reflection.Binder" /> используется методом <see cref="Overload:System.Type.InvokeMember" />, этот параметр указывает набор свойств, определенных в отражении как возможные соответствия, как правило в связи с тем, что они имеют правильное имя члена. Реализация по умолчанию, предоставленная свойством <see cref="P:System.Type.DefaultBinder" />, изменяет порядок этого массива.</param>
        <param name="returnType">Возвращаемое значение, которым должно обладать соответствующее свойство.</param>
        <param name="indexes">Типы индексов свойства, поиск которого выполняется. Используется для свойств индекса, например указателя для класса.</param>
        <param name="modifiers">Массив модификаторов параметров, позволяющий привязке работать с сигнатурами параметров, в которых были изменены типы.</param>
        <summary>Выбирает свойство из заданного набора свойств в зависимости от заданных критериев.</summary>
        <returns>Соответствующее свойство.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод управляет выбором, предоставленным `GetProperty` методом для. `Type`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">В связывателе по умолчанию параметр <paramref name="match" /> содержит несколько свойств, которые одинаково хорошо соответствуют значениям параметров <paramref name="returnType" /> и <paramref name="indexes" />.</exception>
        <exception cref="T:System.ArgumentException">В связывателе по умолчанию параметр <paramref name="match" /> имеет значение <see langword="null" /> или является пустым массивом.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
      </Docs>
    </Member>
  </Members>
</Type>
