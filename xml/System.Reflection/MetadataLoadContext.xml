<Type Name="MetadataLoadContext" FullName="System.Reflection.MetadataLoadContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="77275d03e2060384e5f1475e3cfde6631b035839" /><Meta Name="ms.sourcegitcommit" Value="f6fc130f7b9399b2b130a137d6b0b2b73c1d17b3" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/18/2019" /><Meta Name="ms.locfileid" Value="74154603" /></Metadata><TypeSignature Language="C#" Value="public sealed class MetadataLoadContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MetadataLoadContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MetadataLoadContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MetadataLoadContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MetadataLoadContext sealed : IDisposable" />
  <TypeSignature Language="F#" Value="type MetadataLoadContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a closed universe of Type objects loaded for inspection-only purposes. Each MetadataLoadContext can have its own binding rules and is isolated from all other MetadataLoadContexts.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

## Remarks

`MetadataLoadContext` выступает в качестве словаря, который привязывает имена сборок к <xref:System.Reflection.Assembly> экземплярам, которые ранее загружались в контекст или должны быть загружены.

Сборки обрабатываются строго как метаданные. Нет никаких ограничений на загрузку сборок на основе целевой платформы, архитектуры ЦП или размера указателя. Нет ограничений на сборку, обозначенную как основная сборка (**mscorlib**).

]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MetadataLoadContext (System.Reflection.MetadataAssemblyResolver resolver, string coreAssemblyName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.MetadataAssemblyResolver resolver, string coreAssemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.#ctor(System.Reflection.MetadataAssemblyResolver,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resolver As MetadataAssemblyResolver, Optional coreAssemblyName As String = null)" />
      <MemberSignature Language="F#" Value="new System.Reflection.MetadataLoadContext : System.Reflection.MetadataAssemblyResolver * string -&gt; System.Reflection.MetadataLoadContext" Usage="new System.Reflection.MetadataLoadContext (resolver, coreAssemblyName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="resolver" Type="System.Reflection.MetadataAssemblyResolver" />
        <Parameter Name="coreAssemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resolver">A <see cref="T:System.Reflection.MetadataAssemblyResolver" /> instance.</param>
        <param name="coreAssemblyName">The name of the assembly that contains the core types such as <see cref="T:System.Object" />. Typically, this would be "mscorlib".</param>
        <summary>Creates a new <see cref="T:System.Reflection.MetadataLoadContext" /> object.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CoreAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly CoreAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly CoreAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MetadataLoadContext.CoreAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CoreAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Assembly ^ CoreAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CoreAssembly : System.Reflection.Assembly" Usage="System.Reflection.MetadataLoadContext.CoreAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the assembly that denotes the "system assembly" that houses the well-known types such as <see cref="T:System.Int32" />.</summary>
        <value>Экземпляр <see cref="T:System.Reflection.Assembly" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Основная сборка обрабатывается иначе, чем другие сборки, так как ссылки на эти хорошо известные типы не включают ссылку на сборку, в отличие от обычных типов.
            
Как правило, эта сборка называется mscorlib или netstandard. Если основная сборка не найдена, значение будет `null`и многие другие методы отражения, включая те, которые анализируют подписи методов, вызовут исключение.
            
`CoreAssembly` определяется путем передачи параметра `coreAssemblyName`, переданного в конструктор <xref:System.Reflection.MetadataAssemblyResolver>, в метод <xref:System.Reflection.MetadataAssemblyResolver.Resolve%2A?displayProperty=nameWithType>.

Если в конструкторе <xref:System.Reflection.MetadataLoadContext>не указан `coreAssemblyName` аргумент, используются значения по умолчанию, включая mscorlib, System. Runtime и netstandard.
            
Назначенная основная сборка не обязана напрямую содержать основные типы. Он может ввести пересылку в другие сборки. Таким образом, вполне допустимо использовать mscorlib фасадной в качестве назначенной основной сборки.
            
Обратите внимание, что <xref:System.Runtime> не является идеальной основной сборкой, так как она исключает некоторые типы псевдо-настраиваемых атрибутов взаимодействия, такие как <xref:System.Runtime.InteropServices.DllImportAttribute>. Однако он может быть в том случае, если в этих атрибутах нет интереса. API CustomAttributes пропустит эти атрибуты, если основная сборка не включает необходимые типы.
            
Основная сборка не загружается, пока это не потребуется. Следующие API не активируют поиск основной сборки:

* <xref:System.Reflection.MetadataLoadContext.LoadFromStream%2A?displayProperty=nameWithType>
* <xref:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath%2A?displayProperty=nameWithType>
* <xref:System.Reflection.MetadataLoadContext.LoadFromByteArray%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetName%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.FullName?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.DefinedTypes?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetForwardedTypes%2A?displayProperty=nameWithType>
* <xref:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)?displayProperty=nameWithType>
* <xref:System.Type.Name?displayProperty=nameWithType>
* <xref:System.Type.FullName?displayProperty=nameWithType>
* <xref:System.Type.AssemblyQualifiedName?displayProperty=nameWithType>
            
Если не удается найти основную сборку или если у основной сборки отсутствуют типы, это повлияет на поведение <xref:System.Reflection.MetadataLoadContext> следующим образом.
            
* API-интерфейсы, которым необходимо проанализировать сигнатуры или TypeSpec и возвращать результаты в виде <xref:System.Type> объекты, будут вызывать исключение. Например:

  * <xref:System.Reflection.MethodInfo.ReturnType?displayProperty=nameWithType>
  * <xref:System.Reflection.MethodBase.GetParameters%2A?displayProperty=nameWithType>
  * <xref:System.Type.BaseType?displayProperty-nameWithType>
  * <xref:System.Type.GetInterfaces%2A?displayProperty=nameWithType>

* API-интерфейсы, которые должны сравнивать типы с хорошо известными основными типами, не будут вызывать исключение, а сравнение будет вычисляться как `false`. Например, если не указать основную сборку, <xref:System.Type.IsPrimitive> будет возвращать `false` для всех, даже типы с именем <xref:System.Int32>. Аналогичным образом <xref:System.Type.GetTypeCode%2A?displayProperty=nameWithType> будет возвращать <xref:System.TypeCode.Object> для всех.
            
* Если сущность метаданных устанавливает флаги, которые являются псевдо-настраиваемым атрибутом, а базовая сборка не содержит тип атрибута псевдо-Custom, необходимый конструктор или любой тип параметров конструктора, <xref:System.Reflection.MetadataLoadContext> не будет вызывать исключение. Атрибут псевдо-Custom будет пропущен из списка возвращаемых атрибутов.
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="metadataLoadContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases any native resources (such as file locks on assembly files).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

После реализации необязательно использовать <xref:System.Reflection.Assembly> объекты, выданные <xref:System.Reflection.MetadataLoadContext>, или любые объекты отражения, выданные этими <xref:System.Reflection.Assembly>ными объектами.

Хотя объекты, предоставляемые <xref:System.Reflection.MetadataLoadContext>, стремится выдавать <xref:System.ObjectDisposedException>, это не гарантируется.

Некоторые API-интерфейсы могут возвращать фиксированные или ранее кэшированные данные. Доступ к объектам *во время* вызова метода <xref:System.Reflection.MetadataLoadContext.Dispose%2A> может привести к неуправляемому нарушению прав доступа и FailFast.
         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As IEnumerable(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.GetAssemblies : unit -&gt; seq&lt;System.Reflection.Assembly&gt;" Usage="metadataLoadContext.GetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Return an atomic snapshot of the assemblies that have been loaded into the <see cref="T:System.Reflection.MetadataLoadContext" />.</summary>
        <returns>An enumerable collection of <see xref="T:System.Reflection.Assembly" /> objects.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName">An <see cref="T:System.Reflection.AssemblyName" /> instance.</param>
        <summary>Resolves the supplied assembly name to an assembly. If an assembly was previously bound to this name, that assembly is returned. Otherwise, the <see cref="T:System.Reflection.MetadataLoadContext" /> calls the specified <see cref="T:System.Reflection.MetadataAssemblyResolver" />.</summary>
        <returns>An <see cref="T:System.Reflection.Assembly" /> instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
Обратите внимание, что поведение этого метода соответствует поведению события <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A?displayProperty=nameWithType> Resolve, но не соответствует поведению <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>. (Последнее позволяет избежать возникновения события разрешения.)
          ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">The resolver returns <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyName (assemblyName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : string -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">A <see cref="T:System.String" /> representing the assembly name.</param>
        <summary>Resolves the supplied assembly name to an assembly. If an assembly was previously bound to this name, that assembly is returned. Otherwise, the <see cref="T:System.Reflection.MetadataLoadContext" /> calls the specified <see cref="T:System.Reflection.MetadataAssemblyResolver" />.</summary>
        <returns>An <see cref="T:System.Reflection.Assembly" /> instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

Обратите внимание, что поведение этого метода соответствует поведению события <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A?displayProperty=nameWithType> Resolve, но не соответствует поведению <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>. (Последнее позволяет избежать возникновения события разрешения.)

]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">The resolver returns <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyPath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyPath (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyPath(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyPath (assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyPath(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyPath : string -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromAssemblyPath assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath">A <see cref="T:System.String" /> representing the path to the assembly.</param>
        <summary>Loads an assembly from a specific path on the disk and binds its assembly name to it in the <see cref="T:System.Reflection.MetadataLoadContext" />. If a prior assembly with the same name was already loaded into the <see cref="T:System.Reflection.MetadataLoadContext" />, the prior assembly will be returned.</summary>
        <returns>An <see cref="T:System.Reflection.Assembly" /> instance.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.FileLoadException">The two assemblies do not have the same Mvid.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromByteArray">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromByteArray (byte[] assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromByteArray(unsigned int8[] assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromByteArray(System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromByteArray(cli::array &lt;System::Byte&gt; ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromByteArray : byte[] -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromByteArray assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="assembly">A byte array holding an assembly.</param>
        <summary>Loads an assembly from a byte array and binds its assembly name to it in the <see cref="T:System.Reflection.MetadataLoadContext" />. If a prior assembly with the same name was already loaded into the <see cref="T:System.Reflection.MetadataLoadContext" />, the prior assembly will be returned.</summary>
        <returns>An <see cref="T:System.Reflection.Assembly" /> instance.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.FileLoadException">The two assemblies do not have the same Mvid.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MetadataLoadContext.LoadFromStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream -&gt; System.Reflection.Assembly" Usage="metadataLoadContext.LoadFromStream assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.MetadataLoadContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly">A <see cref="T:System.IO.Stream" /> holding an assembly.</param>
        <summary>Loads an assembly from a stream and binds its assembly name to it in the <see cref="T:System.Reflection.MetadataLoadContext" />. If a prior assembly with the same name was already loaded into the <see cref="T:System.Reflection.MetadataLoadContext" />, the prior assembly will be returned.</summary>
        <returns>The loaded assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!IMPORTANT]
> <xref:System.Reflection.MetadataLoadContext> принимает владение <xref:System.IO.Stream>, переданным в этот метод. Исходный владелец не должен изменять его положение, ликвидировать <xref:System.IO.Stream>или предположить, что его положение останется неизменным.

]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">The two assemblies do not have the same Mvid.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
