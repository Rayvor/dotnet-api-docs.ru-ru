<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata><Meta Name="ms.openlocfilehash" Value="db72d34b5a4c159399029932c6bc75949e8c9313" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69356452" /></Metadata><TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type Package = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет контейнер, в котором может храниться несколько объектов данных.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package>— Это абстрактный класс, который можно использовать для организации объектов в единую сущность определенного физического формата для обеспечения переносимости и эффективного доступа.  
  
 ZIP-файл является основным физическим форматом для <xref:System.IO.Packaging.Package>.  Другие <xref:System.IO.Packaging.Package> реализации могут использовать другие физические форматы, такие как XML-документ, база данных или веб-служба.  
  
 Как и в файловой системе, элементы, содержащиеся в <xref:System.IO.Packaging.Package> , указываются в иерархической структуре папок и файлов.  
  
 Хотя <xref:System.IO.Packaging.Package> сам по себе является абстрактным классом <xref:System.IO.Packaging.ZipPackage> , производный класс по умолчанию <xref:System.IO.Packaging.Package.Open%2A> используется методом.  
  
 ("Часть") является абстрактным классом, который представляет объект, хранящийся <xref:System.IO.Packaging.Package>в. <xref:System.IO.Packaging.PackagePart>  
  
 Объект <xref:System.IO.Packaging.PackageRelationship> ("связь") определяет связь между источником <xref:System.IO.Packaging.Package> или <xref:System.IO.Packaging.PackagePart> целевым объектом.  <xref:System.IO.Packaging.PackageRelationship> Может быть одним из двух типов, каждый из которых может быть одной из двух форм:  
  
-   Связь уровня пакета (созданная <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> методом) связывается с одним из <xref:System.IO.Packaging.Package> следующих способов:  
  
    -   Целевой элемент в пакете.  
  
    -   Целевой ресурс за пределами пакета.  
  
-   Отношение уровня части (созданное <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> методом) связывает источник <xref:System.IO.Packaging.PackagePart> с одним из следующих способов:  
  
    -   Другая Целевая часть в пакете.  
  
    -   Целевой ресурс за пределами пакета.  
  
 Источник <xref:System.IO.Packaging.Package> или источник <xref:System.IO.Packaging.PackagePart> связи считается "владельцем" связи.  При удалении исходного объекта все связи, принадлежащие исходному объекту, также удаляются.  Процесс создания или удаления связи физически не изменяет исходные или целевые объекты каким-либо образом.  
  
 A <xref:System.IO.Packaging.PackageDigitalSignature> ("Цифровая подпись") представляет собой композицию частей и связей, представляющих цифровую подпись, <xref:System.IO.Packaging.Package>включенную в.  Цифровая подпись идентифицирует инициатора и проверяет, что подписанные части и связи, содержащиеся в, <xref:System.IO.Packaging.Package> не были изменены.  
  
 Пакеты также поддерживают цифровые Rights Management (DRM), что позволяет шифровать элементы содержимого <xref:System.IO.Packaging.Package> в для шифрования с определенными правами доступа, предоставленными полномочным пользователям.  
  
 Основываясь на <xref:System.IO.Packaging.Package> архитектуре <xref:System.Windows.Xps.Packaging.XpsDocument> , — это тип пакета, предназначенный для хранения документов на основе [формата XPS](https://go.microsoft.com/fwlink/?LinkID=65761).  
  
 .NET Framework использует пакеты для хранения содержимого, ресурсов и связей страниц и документов с помощью стандартного ZIP-файла по умолчанию. Как и в случае с любым ZIP-файлом, приложение <xref:System.IO.Packaging> может использовать классы для хранения и, при необходимости, защиты любого типа или числа файлов данных в одном контейнере эффективного доступа.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показаны основные шаги для создания <xref:System.IO.Packaging.Package>.  В этом примере создается пакет, содержащий документ вместе с графическим изображением, которое отображается как часть документа.  (Это похоже на случай, когда HTML-файл имеет \<тег img >, который ссылается на внешний файл изображения.)  В <xref:System.IO.Packaging.PackageRelationship> пакет также включены два элемента.  Первый объект, связь уровня пакета, определяет часть документа как корневой элемент пакета.  Вторая связь "уровень части" определяет связь между частью документа ("источником" связи уровня части) и ее использованием части изображения ("цель" отношения уровня части).  Полный пример см. в разделе [запись примера пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Спецификация Open Packaging Conventions (OPC)</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=74494">Платформа цифровых подписей в соглашениях Open Packaging</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Packaging.Package" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package openFileAccess" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Разрешения файлового ввода-вывода для пакета.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Packaging.Package" />, использующий заданный режим <see cref="T:System.IO.FileAccess" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A>является защищенным конструктором <xref:System.IO.Packaging.Package> абстрактного базового класса. При вызове в производном классе <xref:System.IO.Packaging.Package.%23ctor%2A> конструктор инициализирует новый экземпляр производного класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="openFileAccess" /> является недопустимым.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess * bool -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package (openFileAccess, streaming)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="streaming" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Разрешения файлового ввода-вывода для пакета.</param>
        <param name="streaming"><see langword="true" />, если требуется открыть пакет для работы в потоке, в противном случае — <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.IO.Packaging.Package" />, использующий заданный режим <see cref="T:System.IO.FileAccess" /> и режим потока.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A>является защищенным конструктором <xref:System.IO.Packaging.Package> абстрактного базового абстрактного базового класса. При вызове в производном классе <xref:System.IO.Packaging.Package.%23ctor%2A> конструктор инициализирует новый экземпляр производного класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="openFileAccess" /> является недопустимым.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="package.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сохраняет и закрывает пакет, а также все базовые потоки частей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Close%2A> <xref:System.IO.Packaging.Package.Dispose%2A> Для класса и<xref:System.IO.Packaging.Package.Close%2A> выполнения<xref:System.IO.Packaging.Package.Dispose%2A> той же операции нет необходимости вызывать метод, если вы вызываете или наоборот. <xref:System.IO.Packaging.Package>  
  
 <xref:System.IO.Packaging.Package.Close%2A>и <xref:System.IO.Packaging.Package.Dispose%2A> внутренне вызов <xref:System.IO.Packaging.Package.Flush%2A>.  
  
> [!NOTE]
>  Оператор (отличный `using` от директивы Namespace) <xref:System.IO.Packaging.Package.Close%2A> является рекомендуемым способом и <xref:System.IO.Packaging.Package.Dispose%2A> пакетом. `using`  [Пример написания пакета](https://go.microsoft.com/fwlink/?LinkID=160055) и [Чтение примера пакета](https://go.microsoft.com/fwlink/?LinkID=160034) показывают, как закрыть и ликвидировать пакет с помощью `using` инструкции.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новую часть пакета.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A>Инициализирует пустое <xref:System.IO.Stream> значение для новой части.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Метод можно использовать для получения ссылки на экземпляр потока, связанный с частью.  
  
 Дополнительные сведения о частях пакета см. в разделе 1,1 спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показано, как создать новый <xref:System.IO.Packaging.PackagePart> объект, а затем сохранить данные в части.  Полный пример см. в разделе [запись примера пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" />внутренне вызывает производный метод <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> класса для фактического создания части на основе физического формата, реализованного в производном классе.</para></block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] новой части.</param>
        <param name="contentType">Тип содержимого потока данных.</param>
        <summary>Создает новую несжатую часть с заданным URI и типом содержимого.</summary>
        <returns>Новая созданная часть.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A>Инициализирует пустое <xref:System.IO.Stream> значение для новой части.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Метод можно использовать для получения ссылки на экземпляр потока, связанный с частью.  
  
 Часть <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> — .<xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>  
  
 Дополнительные сведения о частях пакета см. в разделе 1,1 спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показано, как создать новый <xref:System.IO.Packaging.PackagePart> объект, а затем сохранить данные в части.  Полный пример см. в разделе [запись примера пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="partUri" /> или <paramref name="contentType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> не является допустимым <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Часть с указанным <paramref name="partUri" /> уже имеется в пакете.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения (добавление новой части невозможно).</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />внутренне вызывает <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> метод производного класса для фактического создания части на основе физического формата, реализованного в производном классе.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] новой части.</param>
        <param name="contentType">Тип содержимого потока данных.</param>
        <param name="compressionOption">Режим сжатия потока данных — <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> или <see cref="F:System.IO.Packaging.CompressionOption.Normal" />.</param>
        <summary>Создает новую часть с заданными значениями URI, типа содержимого и режима сжатия.</summary>
        <returns>Новая созданная часть.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для производного <xref:System.IO.Packaging.ZipPackage> класса <xref:System.IO.Packaging.Package.CreatePart%2A> по умолчанию метод поддерживает только два `compressionOption` значения ( <xref:System.IO.Packaging.CompressionOption.NotCompressed> или <xref:System.IO.Packaging.CompressionOption.Normal> сжатие).  Другие <xref:System.IO.Packaging.CompressionOption> значения<xref:System.IO.Packaging.CompressionOption.Fast>, или Используйте<xref:System.IO.Packaging.CompressionOption.SuperFast> сжатие. <xref:System.IO.Packaging.CompressionOption.Maximum> <xref:System.IO.Packaging.CompressionOption.Normal>  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A>Создает пустое <xref:System.IO.Stream> значение для новой части.  <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Метод можно использовать для получения ссылки на экземпляр потока, связанный с частью.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показано, как создать новый <xref:System.IO.Packaging.PackagePart> объект, а затем сохранить данные в части.  Полный пример см. в разделе [запись примера пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="partUri" /> или <paramref name="contentType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> не является допустимым <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Часть с указанным <paramref name="partUri" /> уже имеется в пакете.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="compressionOption" /> является недопустимым.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения (добавление новой части невозможно).</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />внутренне вызывает <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> метод производного класса для фактического создания части на основе физического формата, реализованного в производном классе.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="abstract member CreatePartCore : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePartCore (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] создаваемой части.</param>
        <param name="contentType">Тип содержимого потока данных.</param>
        <param name="compressionOption">Параметр сжатия потока данных.</param>
        <summary>При переопределении в производном классе создает новую часть в пакете.</summary>
        <returns>Созданная часть.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производный <xref:System.IO.Packaging.Package.CreatePartCore%2A> метод вызывается <xref:System.IO.Packaging.Package.CreatePart%2A> методом для создания части на основе физического формата, реализованного в производном классе.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> предоставляется и используется реализация производного класса <xref:System.IO.Packaging.Package> для абстрактного класса.  В операции <xref:System.IO.Packaging.Package.CreatePart%2A> по умолчанию внутренний вызов <xref:System.IO.Packaging.Package.CreatePartCore%2A> <xref:System.IO.Packaging.ZipPackage> класса для создания новой части в ZIP-файле.  
  
 Для производного <xref:System.IO.Packaging.ZipPackage> класса <xref:System.IO.Packaging.Package.CreatePartCore%2A> по умолчанию метод поддерживает только два `compressionOption` значения ( <xref:System.IO.Packaging.CompressionOption.NotCompressed> или <xref:System.IO.Packaging.CompressionOption.Normal> сжатие).  Другие <xref:System.IO.Packaging.CompressionOption> значения<xref:System.IO.Packaging.CompressionOption.Fast>, или Используйте<xref:System.IO.Packaging.CompressionOption.SuperFast> сжатие. <xref:System.IO.Packaging.CompressionOption.Maximum> <xref:System.IO.Packaging.CompressionOption.Normal>  
  
 Дополнительные сведения о модели пакета и частях пакета см. в главе 1 спецификации Open Packaging Conventions (OPC), доступной для загрузки по <https://go.microsoft.com/fwlink/?LinkID=71255>адресу.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Производная <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> реализация не должна делать никаких предположений о заказе или операциях, <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> выполняемых методом, который его вызывает.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает связь с заданной частью на уровне пакета.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Связь уровня пакета определяет связь между пакетом и связанным целевым элементом или ресурсом.  Отношение уровня пакета может быть одной из двух форм.  
  
-   <xref:System.IO.Packaging.PackagePart> Между объектом <xref:System.IO.Packaging.Package> и целевым объектом внутри пакета.  
  
-   Между объектом <xref:System.IO.Packaging.Package> и целевым ресурсом за пределами пакета.  
  
 В связи с пакетом пакет считается "владельцем" связи.  При удалении пакета также удаляются все связи, принадлежащие пакету.  Процесс создания или удаления связи физически не изменяет целевую часть или ресурс каким бы то ни было.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показано создание <xref:System.IO.Packaging.PackageRelationship> <xref:System.IO.Packaging.Package> между и корневым элементом документа.  Полный пример см. в разделе [запись примера пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] целевой части.</param>
        <param name="targetMode">Показывает, является ли целевая часть внутренней (<see cref="F:System.IO.Packaging.TargetMode.Internal" />) или внешней (<see cref="F:System.IO.Packaging.TargetMode.External" />) по отношению к пакету.</param>
        <param name="relationshipType">Код URI, однозначно определяющий роль связи.</param>
        <summary>Создает связь с частью на уровне пакета по заданным значениям URI, вида целевой части и типа связи.</summary>
        <returns>Связь с указанной частью на уровне пакета.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Связь уровня пакета определяет связь между пакетом и связанным целевым элементом или ресурсом.  Отношение уровня пакета может быть одной из двух форм.  
  
-   Между объектом <xref:System.IO.Packaging.Package> и целевым элементом в пакете.  
  
-   Между объектом <xref:System.IO.Packaging.Package> и целевым ресурсом за пределами пакета.  
  
 В связи с пакетом пакет считается "владельцем" связи.  При удалении пакета также удаляются все связи, принадлежащие пакету.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A>не изменяет физически целевую часть или ресурс каким бы то ни было.  
  
 Целевой объект связи не может быть другой связью.  
  
 Если `targetMode` параметр имеет значение <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` то параметр должен быть относительным URI, сформированным в соответствии с универсальной спецификацией синтаксиса в стандарте URI [RFC 3986](https://tools.ietf.org/html/rfc3986) .  Внутренний относительный URI может быть либо абсолютным путем, который начинается с косой черты ("/"), например "/Page1.XAML", либо "/images/picture4.jpg", либо относительным путем, таким как ".. /imagespicture1.jpg ", который разрешается в корневую папку пакета ("/") как базовый URI.  
  
 Если `targetMode` параметр имеет значение <xref:System.IO.Packaging.TargetMode.External>, `targetUri` то параметр может быть абсолютным или относительным URI, сформированным в соответствии со спецификацией общего синтаксиса универсального кода ресурса (URI) [RFC 3986](https://tools.ietf.org/html/rfc3986) . `http://www.microsoft.com/page2.xml`пример абсолютного URI, который ссылается на внешний целевой ресурс "Page2. XML".  "images/picture1. jpg" — это пример относительного URI, который также ссылается на внешний целевой ресурс "1. jpg", но он разрешается в URI самого пакета.  
  
 `relationshipType`параметр должен иметь [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] значение, сформированное в соответствии с универсальной спецификацией синтаксиса в стандарте URI [RFC 3986](https://tools.ietf.org/html/rfc3986) .  В следующей таблице показаны URI уровня `relationshipType` пакета, определенные в спецификации Open Packaging Conventions (OPC).  
  
|Отношение уровня пакета|URI типа отношения|  
|---------------------------------|---------------------------|  
|Основные свойства|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Цифровая подпись|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Сертификат цифровой подписи|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Источник цифровой подписи|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Эскиз|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Дополнительные сведения о взаимосвязи пакетов и пакетов см. в разделе 1,3 спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.IO.Packaging.Package.CreateRelationship%2A> для <xref:System.IO.Packaging.PackageRelationship> создания между <xref:System.IO.Packaging.Package> и корневым элементом документа.  Полный пример см. в разделе [запись примера пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="targetUri" /> или <paramref name="relationshipType" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Часть <paramref name="targetUri" /> представляет собой <see cref="T:System.IO.Packaging.PackageRelationship" />, или в качестве <paramref name="targetMode" /> задано <see cref="F:System.IO.Packaging.TargetMode.Internal" /> и <paramref name="targetUri" /> является абсолютным URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="targetMode" /> является недопустимым.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения.</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] целевой части.</param>
        <param name="targetMode">Показывает, является ли целевая часть внутренней (<see cref="F:System.IO.Packaging.TargetMode.Internal" />) или внешней (<see cref="F:System.IO.Packaging.TargetMode.External" />) по отношению к пакету.</param>
        <param name="relationshipType">Код URI, однозначно определяющий роль связи.</param>
        <param name="id">Уникальный идентификатор XML.</param>
        <summary>Создает связь с частью на уровне пакета по заданным значениям URI, вида целевой части, типа связи и [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</summary>
        <returns>Связь с указанной частью на уровне пакета.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Связь уровня пакета определяет связь между пакетом и связанным целевым элементом или ресурсом.  Отношение уровня пакета может быть одной из двух форм.  
  
-   Между объектом <xref:System.IO.Packaging.Package> и целевым элементом в пакете.  
  
-   Между объектом <xref:System.IO.Packaging.Package> и целевым ресурсом за пределами пакета.  
  
 В связи с пакетом пакет считается "владельцем" связи.  При удалении пакета также удаляются все связи, принадлежащие пакету.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A>не изменяет физически целевую часть или ресурс каким бы то ни было.  
  
 Целевой объект связи не может быть другой связью.  
  
 `id`должен быть допустимым идентификатором XML.  `id` Тип — XSD: ID. он должен соответствовать соглашениям об именовании, указанным в схеме XML, части 2: Спецификация типов (см [https://www.w3.org/TR/xmlschema-2/#ID](https://www.w3.org/TR/xmlschema-2/#ID).).  
  
 `id` Если`null` задано значение, то автоматически создается уникальный идентификатор.  Параметр `id` , заданный пустой строкой, является недопустимым.  
  
 Если `targetMode` параметр имеет значение <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` то параметр должен быть относительным URI, сформированным в соответствии с универсальной спецификацией синтаксиса в стандарте URI [RFC 3986](https://tools.ietf.org/html/rfc3986) .  Внутренний относительный URI может быть либо абсолютным путем, который начинается с косой черты ("/"), например "/Page1.XAML", либо "/images/picture4.jpg", либо относительным путем, таким как ".. /imagespicture1.jpg ", который разрешается в корневую папку пакета ("/") как базовый URI.  
  
 Если `targetMode` параметр имеет значение <xref:System.IO.Packaging.TargetMode.External>, `targetUri` то параметр может быть абсолютным или относительным URI, сформированным в соответствии со спецификацией общего синтаксиса универсального кода ресурса (URI) [RFC 3986](https://tools.ietf.org/html/rfc3986) . `http://www.microsoft.com/page2.xml`пример абсолютного URI, который ссылается на внешний целевой ресурс "Page2. XML".  "images/picture1. jpg" — это пример относительного URI, который также ссылается на внешний целевой ресурс "1. jpg", но он разрешается в URI самого пакета.  
  
 `relationshipType`должен быть URI, сформированным согласно спецификации универсального синтаксиса URI [RFC 3986](https://tools.ietf.org/html/rfc3986) .  В следующей таблице показаны URI уровня `relationshipType` пакета, определенные в спецификации Open Packaging Conventions (OPC).  
  
|Отношение уровня пакета|URI типа отношения|  
|---------------------------------|---------------------------|  
|Основные свойства|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Цифровая подпись|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Сертификат цифровой подписи|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Источник цифровой подписи|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Эскиз|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Дополнительные сведения о взаимосвязи пакетов и пакетов см. в разделе 1,3 спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.IO.Packaging.Package.CreateRelationship%2A> для <xref:System.IO.Packaging.PackageRelationship> создания между <xref:System.IO.Packaging.Package> и корневым элементом документа.  Полный пример см. в разделе [запись примера пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="targetUri" /> или <paramref name="relationshipType" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Часть <paramref name="targetUri" /> представляет собой <see cref="T:System.IO.Packaging.PackageRelationship" />, или в качестве <paramref name="targetMode" /> задано <see cref="F:System.IO.Packaging.TargetMode.Internal" /> и <paramref name="targetUri" /> является абсолютным URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="targetMode" /> является недопустимым.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> не является допустимым идентификатором XML; или часть с указанным <paramref name="id" /> уже имеется в пакете.</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.DeletePart : Uri -&gt; unit" Usage="package.DeletePart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] удаляемой части.</param>
        <summary>Удаляет из пакета часть с заданным URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri`должен быть относительным URI, состоящим из абсолютного пути, который начинается с символа косой черты ("/").  Абсолютный путь задается относительно корня пакета и формируется в соответствии с универсальной спецификацией синтаксиса в стандарте URI [RFC 3986](https://tools.ietf.org/html/rfc3986) .  "/Page1.XAML" и "/images/picture4.jpg" являются примерами допустимых URI частей.  
  
 Исключение не возникает, если часть с указанным `partUri` параметром не находится в пакете.  (С помощью <xref:System.IO.Packaging.Package.PartExists%2A> метода можно определить, находится ли часть с указанным `partUri` в пакете.)  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="partUri" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> не является допустимым <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />внутренне вызывает <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> метод производного класса для фактического удаления части на основе физического формата, реализованного в производном классе.</para></block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member DeletePartCore : Uri -&gt; unit" Usage="package.DeletePartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Свойство <see cref="P:System.IO.Packaging.PackagePart.Uri" /> удаляемого объекта <see cref="T:System.IO.Packaging.PackagePart" />.</param>
        <summary>При переопределении в производном классе удаляет часть с заданным URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> предоставляется и используется реализация производного класса <xref:System.IO.Packaging.Package> для абстрактного класса.  В операции <xref:System.IO.Packaging.Package.DeletePart%2A> по умолчанию внутренние вызовы <xref:System.IO.Packaging.Package.DeletePartCore%2A> <xref:System.IO.Packaging.ZipPackage> класса выполняют фактическую операцию удаления на основе физического формата, реализованного в производном классе.  
  
 Дополнительные сведения о модели пакета и частях пакета см. в главе 1 спецификации Open Packaging Conventions (OPC), доступной для загрузки по <https://go.microsoft.com/fwlink/?LinkID=71255>адресу.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализация производного <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> класса вызывается <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> методом в указанную часть на основе физического формата, реализованного в производном классе.  
  
Производная <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> реализация не должна делать никаких предположений о заказе или операциях, <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> выполняемых методом, который его вызывает.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="package.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> удаляемого объекта <see cref="T:System.IO.Packaging.PackageRelationship" />.</param>
        <summary>Удаляет связь уровня пакета.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Связь уровня пакета определяет связь между пакетом и связанным целевым элементом или ресурсом.  Отношение уровня пакета может быть одной из двух форм.  
  
-   Между объектом <xref:System.IO.Packaging.Package> и целевым элементом в пакете.  
  
-   Между объектом <xref:System.IO.Packaging.Package> и целевым ресурсом за пределами пакета.  
  
 В связи с пакетом пакет считается "владельцем" связи.  При удалении пакета также удаляются все связи, принадлежащие пакету.  
  
 Если связь с указанным `id` параметром отсутствует в пакете, исключение не возникает.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A>физически не изменяет целевую часть.  
  
 Дополнительные сведения о связях между пакетами см. в разделе 1,3 спецификации Open Packaging Conventions (OPC), доступной <https://go.microsoft.com/fwlink/?LinkID=71255>для загрузки по адресу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения.</exception>
        <exception cref="T:System.Xml.XmlException">Параметр <paramref name="id" /> не является допустимым идентификатором XML.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="package.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Очищает и сохраняет содержимое всех частей и связей, закрывает пакет и освобождает все ресурсы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы убедиться, что все изменения правильно сохранены, <xref:System.IO.Packaging.Package.Dispose%2A> также завершает, очищает и закрывает все части и отношения, содержащиеся в пакете.  
  
 <xref:System.IO.Packaging.Package.Dispose%2A> <xref:System.IO.Packaging.Package.Close%2A>Для классаи<xref:System.IO.Packaging.Package.Close%2A> выполнения той же операции нет необходимости вызывать метод, если вы вызываете, или наоборот. <xref:System.IO.Packaging.Package.Dispose%2A> <xref:System.IO.Packaging.Package>  
  
 <xref:System.IO.Packaging.Package.Close%2A>и <xref:System.IO.Packaging.Package.Dispose%2A> внутренне вызов <xref:System.IO.Packaging.Package.Flush%2A>.  
  
 Производные классы, которые распределяют ресурсы, не связанные с памятью и управляют ими, должны <xref:System.IO.Packaging.Package.Dispose%2A> переопределять этот метод для освобождения ресурсов при вызове метода. Переопределения производного класса также должны вызывать <xref:System.IO.Packaging.Package.Flush%2A> и метод базового класса <xref:System.IO.Packaging.Package.Dispose%2A> , чтобы гарантировать, что очистка базового класса выполняется всегда.  
  
> [!NOTE]
>  Оператор (отличный `using` от директивы Namespace) <xref:System.IO.Packaging.Package.Close%2A> является рекомендуемым способом и <xref:System.IO.Packaging.Package.Dispose%2A> пакетом. `using` В [примере написания пакета](https://go.microsoft.com/fwlink/?LinkID=160055) показано, как закрыть и ликвидировать пакет с помощью `using` инструкции.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberSignature Language="F#" Value="member this.FileOpenAccess : System.IO.FileAccess" Usage="System.IO.Packaging.Package.FileOpenAccess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение режима доступа к файлу для пакета.</summary>
        <value>Одно из значений <see cref="T:System.IO.FileAccess" />: <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" /> или <see cref="F:System.IO.FileAccess.ReadWrite" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.IO.Packaging.Package.FileOpenAccess%2A> не имеет значения по умолчанию.  Параметр доступа к файлу указывается в <xref:System.IO.Packaging.Package.%23ctor%2A> вызове конструктора при создании нового пакета или <xref:System.IO.Packaging.Package.Open%2A> в вызове при открытии существующего пакета.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="package.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сохраняет содержимое всех частей и связей, имеющихся в пакете.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A>внутренне вызывает <xref:System.IO.Packaging.Package.FlushCore%2A> реализацию производного класса для выполнения фактической операции очистки, относящейся к конкретному формату.  <xref:System.IO.Packaging.Package.FlushCore%2A> Метод производного класса отвечает за фактическое сохранение части и содержимого отношений в конкретную реализацию физического производного класса.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> предоставляется и используется производная реализация <xref:System.IO.Packaging.Package> абстрактного базового класса. В операции <xref:System.IO.Packaging.Package.Flush%2A> по умолчанию внутренние вызовы <xref:System.IO.Packaging.Package.FlushCore%2A> сохраняют части и связи в пакете ZIP-файла.  
  
 <xref:System.IO.Packaging.Package.Flush%2A>вызывается автоматически <xref:System.IO.Packaging.Package.Close%2A> методами и <xref:System.IO.Packaging.Package.Dispose%2A> .  Когда <xref:System.IO.Packaging.Package.Close%2A> вызывается или <xref:System.IO.Packaging.Package.Dispose%2A> , нет необходимости вызывать <xref:System.IO.Packaging.Package.Flush%2A> отдельно.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для чтения и не может быть изменен.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.Flush" />внутренне вызывает <see cref="M:System.IO.Packaging.Package.FlushCore" /> метод производного класса для фактической очистки части на основе физического формата, реализованного в производном классе.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberSignature Language="F#" Value="abstract member FlushCore : unit -&gt; unit" Usage="package.FlushCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе сохраняет содержимое всех частей и связей в хранилище производного класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A><xref:System.IO.Packaging.Package.Flush%2A> метод вызывается методом для выполнения фактической операции записи на диск в зависимости от физического формата, реализованного в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Производная <see cref="M:System.IO.Packaging.Package.FlushCore" /> реализация не должна делать никаких предположений о заказе или операциях, выполняемых <see cref="M:System.IO.Packaging.Package.Flush" /> методом, который его вызывает.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.GetPart : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] части, которую требуется возвратить.</param>
        <summary>Возвращает часть с заданным URI.</summary>
        <returns>Часть с указанным <paramref name="partUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если часть с указанным `partUri` параметром не существует, создается исключение. <xref:System.InvalidOperationException>  
  
 Метод можно использовать, чтобы определить, ссылается `partUri` ли ссылка на существующую часть. <xref:System.IO.Packaging.Package.PartExists%2A>  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> предоставляется и используется производная реализация <xref:System.IO.Packaging.Package> абстрактного базового класса.  В операции <xref:System.IO.Packaging.Package.GetPart%2A> по умолчанию внутренние вызовы <xref:System.IO.Packaging.Package.GetPartCore%2A> <xref:System.IO.Packaging.ZipPackage> класса возвращают запрошенную часть из ZIP-файла.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показано, как найти, извлечь и прочитать части, содержащиеся в пакете.  Полный пример см. в разделе [Чтение примера пакета](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> не является допустимым <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Часть с указанным <paramref name="partUri" /> не содержится в пакете.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />внутренне вызывает производный метод <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> класса для фактической очистки части на основе физического формата, реализованного в производном классе.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member GetPartCore : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] части, которую требуется извлечь.</param>
        <summary>При переопределении в производном классе возвращает часть, адресованную заданным URI.</summary>
        <returns>Запрошенная часть или <see langword="null" />, если часть с указанным <paramref name="partUri" /> отсутствует в пакете.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> предоставляется и используется производная реализация <xref:System.IO.Packaging.Package> абстрактного класса.  В операции <xref:System.IO.Packaging.Package.GetPart%2A> по умолчанию внутренние вызовы <xref:System.IO.Packaging.Package.GetPartCore%2A> <xref:System.IO.Packaging.ZipPackage> класса для получения части из ZIP-файла.  
  
 Дополнительные сведения о модели пакета и частях пакета см. в главе 1 спецификации Open Packaging Conventions (OPC), доступной для загрузки по <https://go.microsoft.com/fwlink/?LinkID=71255>адресу.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Реализация производного <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> класса вызывается <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> методом для доступа к указанной части и возвращения ее на основе физического формата, реализованного в производном классе.  
  
Производная <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> реализация не должна делать никаких предположений о заказе или операциях, <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> выполняемых методом, который его вызывает.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberSignature Language="F#" Value="member this.GetParts : unit -&gt; System.IO.Packaging.PackagePartCollection" Usage="package.GetParts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию, состоящую из всех частей пакета.</summary>
        <returns>Коллекция всех элементов <see cref="T:System.IO.Packaging.PackagePart" />, содержащихся в пакете.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A>Возвращает коллекцию всех частей, содержащихся в пакете, включая <xref:System.IO.Packaging.PackageRelationship> части.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A>никогда не возвращает `null`, но возвращаемая коллекция будет содержать нуль элементов, если пакет не содержит частей.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> предоставляется и используется производная реализация <xref:System.IO.Packaging.Package> абстрактного базового класса.  В операции <xref:System.IO.Packaging.Package.GetParts%2A> по умолчанию <xref:System.IO.Packaging.Package.GetPartsCore%2A> вызывает метод <xref:System.IO.Packaging.ZipPackage> класса для возврата частей из ZIP-файла.  
  
 Дополнительные сведения о пакетах и частях пакета см. в разделе 1,1 спецификации Open Packaging Conventions (OPC), доступной для <https://go.microsoft.com/fwlink/?LinkID=71255>загрузки по адресу.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.IO.Packaging.Package.GetParts%2A> метод для получения коллекции частей, содержащихся <xref:System.IO.Packaging.Package>в.  Полный исходный код программы см. в разделе [Создание пакета с примером цифровой подписи](https://go.microsoft.com/fwlink/?LinkID=159966).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetParts" />внутренне вызывает производный метод <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> класса для фактической очистки части на основе физического формата, реализованного в производном классе.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberSignature Language="F#" Value="abstract member GetPartsCore : unit -&gt; System.IO.Packaging.PackagePart[]" Usage="package.GetPartsCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает массив, состоящий из всех частей пакета.</summary>
        <returns>Массив всех частей, содержащихся в пакете.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация производного <xref:System.IO.Packaging.Package.GetPartsCore%2A> класса вызывается <xref:System.IO.Packaging.Package.GetParts%2A> методом для доступа к массиву частей и возвращения его в зависимости от физического формата, реализованного в производном классе.  
  
 По умолчанию <xref:System.IO.Packaging.ZipPackage> предоставляется и используется производная реализация <xref:System.IO.Packaging.Package> абстрактного класса.  В операции <xref:System.IO.Packaging.Package.GetParts%2A> по умолчанию внутренние вызовы <xref:System.IO.Packaging.Package.GetPartCore%2A> <xref:System.IO.Packaging.ZipPackage> класса для получения частей из ZIP-файла.  
  
 Дополнительные сведения о модели пакета и частях пакета см. в главе 1 спецификации Open Packaging Conventions (OPC), доступной для загрузки по <https://go.microsoft.com/fwlink/?LinkID=71255>адресу.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Производная <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> реализация не должна делать никаких предположений о заказе или операциях, <see cref="M:System.IO.Packaging.Package.GetParts" /> выполняемых методом, который его вызывает.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> связи, которую требуется возвратить.</param>
        <summary>Возвращает связь уровня пакета с заданным идентификатором.</summary>
        <returns>Связь уровня пакета с указанным <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id`должен быть допустимым идентификатором XML. Тип — XSD: ID. он должен соответствовать соглашениям об именовании, указанным [в разделе 3.3.8 схемы XML, части 2: `id` Спецификация](https://www.w3.org/TR/xmlschema-2/#ID)типов.  
  
 Дополнительные сведения о взаимосвязи пакетов и пакетов см. в разделе 1,3 спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">Параметр <paramref name="id" /> не является допустимым идентификатором XML.</exception>
        <exception cref="T:System.InvalidOperationException">Связь с указанным <paramref name="id" /> отсутствует в пакете.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию, состоящую из всех связей уровня пакета.</summary>
        <returns>Коллекция всех связей уровня пакета, содержащихся в данном пакете.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A>никогда не возвращает `null`, однако возвращаемая коллекция может содержать нулевые элементы, если пакет не содержит связей на уровне пакета.  
  
 Связь уровня пакета определяет связь между пакетом и связанным целевым элементом или ресурсом.  Отношение уровня пакета может быть одной из двух форм.  
  
-   Между объектом <xref:System.IO.Packaging.Package> и целевым элементом в пакете.  
  
-   Между объектом <xref:System.IO.Packaging.Package> и целевым ресурсом за пределами пакета.  
  
 В связи с пакетом пакет считается "владельцем" связи.  При удалении пакета также удаляются все связи, принадлежащие пакету.  Процесс создания или удаления связи физически не изменяет целевую часть или ресурс каким бы то ни было.  
  
 Дополнительные сведения о взаимосвязи пакетов и пакетов см. в разделе 1,3 спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">Свойство <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> для сопоставления и возврата в коллекцию.</param>
        <summary>Возвращает коллекцию, состоящую из всех связей уровня пакета с заданным типом <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />.</summary>
        <returns>Коллекция связей уровня пакета, соответствующих указанному типу <paramref name="relationshipType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A>никогда не возвращает `null`, однако возвращаемая коллекция может содержать нулевые элементы, если нет связей уровня пакета, соответствующих указанному. `relationshipType`  
  
 В следующей таблице показаны URI уровня `relationshipType` пакета, определенные в спецификации Open Packaging Conventions (OPC).  
  
|Отношение уровня пакета|URI типа отношения|  
|---------------------------------|---------------------------|  
|Основные свойства|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Цифровая подпись|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Сертификат цифровой подписи|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Источник цифровой подписи|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Эскиз|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показано, как получить связи, определенные для пакета.  Полный пример см. в разделе [Чтение примера пакета](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="relationshipType" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="relationshipType" /> равен пустой строке.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает пакет.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>тип пакета по умолчанию, используемый <xref:System.IO.Packaging.Package.Open%2A> методом.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показано, как создать новый <xref:System.IO.Packaging.Package> элемент, <xref:System.IO.Packaging.PackageRelationship> включающий элементы и <xref:System.IO.Packaging.PackagePart> , вместе с хранимыми данными.  Полный пример см. в разделе [запись примера пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Поток ввода-вывода, в котором требуется открыть пакет.</param>
        <summary>Открывает пакет в заданном потоке ввода-вывода.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>тип пакета по умолчанию, используемый <xref:System.IO.Packaging.Package.Open%2A> методом.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Для открываемого пакета требуются разрешения на чтение или чтение/запись, а указанный поток <paramref name="stream" /> доступен только для записи, или для открываемого пакета требуются разрешения на запись или чтение/запись, а указанный поток <paramref name="stream" /> доступен только для чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь и имя файла пакета.</param>
        <summary>Открывает пакет с указанным путем и именем файла.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>тип пакета по умолчанию, используемый <xref:System.IO.Packaging.Package.Open%2A> методом.  
  
 Этот <xref:System.IO.Packaging.Package.Open%2A> метод открывает пакет с атрибутами <xref:System.IO.FileMode.OpenOrCreate>по умолчанию, <xref:System.IO.FileShare.None> <xref:System.IO.FileAccess.ReadWrite>и (чтобы указать другие атрибуты, используйте одну из других перегрузок открытого метода).  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показано, как создать новый <xref:System.IO.Packaging.Package> элемент, <xref:System.IO.Packaging.PackageRelationship> включающий элементы и <xref:System.IO.Packaging.PackagePart> , вместе с хранимыми данными.  Полный пример см. в разделе [запись примера пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">Поток ввода-вывода, в котором требуется открыть пакет.</param>
        <param name="packageMode">Файловый режим, в котором следует открыть пакет.</param>
        <summary>Открывает пакет в заданном потоке ввода-вывода в указанном файловом режиме.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>тип пакета по умолчанию, используемый <xref:System.IO.Packaging.Package.Open%2A> методом.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="stream" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Недопустимое значение параметра <paramref name="packageMode" />.</exception>
        <exception cref="T:System.IO.IOException">Для открываемого пакета требуются разрешения на чтение или чтение/запись, а указанный поток <paramref name="stream" /> доступен только для записи, или для открываемого пакета требуются разрешения на запись или чтение/запись, а указанный поток <paramref name="stream" /> доступен только для чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Путь и имя файла пакета.</param>
        <param name="packageMode">Файловый режим, в котором следует открыть пакет.</param>
        <summary>Открывает пакет на заданном пути в указанном файловом режиме.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>тип пакета по умолчанию, используемый <xref:System.IO.Packaging.Package.Open%2A> методом.  
  
 Этот <xref:System.IO.Packaging.Package.Open%2A> метод открывает пакет с атрибутами <xref:System.IO.FileAccess.ReadWrite> по умолчанию и <xref:System.IO.FileShare.None> (для указания различных атрибутов используйте одну из других перегрузок открытого метода).  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показано, как создать новый <xref:System.IO.Packaging.Package> элемент, <xref:System.IO.Packaging.PackageRelationship> включающий элементы и <xref:System.IO.Packaging.PackagePart> , вместе с хранимыми данными.  Полный пример см. в разделе [запись примера пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="packageMode" /> является недопустимым.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">Поток ввода-вывода, в котором требуется открыть пакет.</param>
        <param name="packageMode">Файловый режим, в котором следует открыть пакет.</param>
        <param name="packageAccess">Режим доступа к файлу, в котором следует открыть пакет.</param>
        <summary>Открывает пакет в заданном потоке ввода-вывода с указанными значениями файлового режима и режима доступа к файлу.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>тип пакета по умолчанию, используемый <xref:System.IO.Packaging.Package.Open%2A> методом.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="packageMode" /> или <paramref name="packageAccess" /> является недопустимым.</exception>
        <exception cref="T:System.IO.IOException">Для открываемого пакета требуются разрешения на чтение или чтение/запись, а указанный поток <paramref name="stream" /> доступен только для записи, или для открываемого пакета требуются разрешения на запись или чтение/запись, а указанный поток <paramref name="stream" /> доступен только для чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Путь и имя файла пакета.</param>
        <param name="packageMode">Файловый режим, в котором следует открыть пакет.</param>
        <param name="packageAccess">Режим доступа к файлу, в котором следует открыть пакет.</param>
        <summary>Открывает пакет на заданном пути с указанными значениями файлового режима и режима доступа к файлу.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>тип пакета по умолчанию, используемый <xref:System.IO.Packaging.Package.Open%2A> методом.  
  
 Этот <xref:System.IO.Packaging.Package.Open%2A> метод открывает пакет с атрибутом по <xref:System.IO.FileShare.None> умолчанию (для указания другого атрибута используйте <xref:System.IO.Packaging.Package.Open%2A> перегрузку метода).  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показано, как открыть и прочитать объект <xref:System.IO.Packaging.Package> , содержащий <xref:System.IO.Packaging.PackageRelationship> элементы <xref:System.IO.Packaging.PackagePart> и вместе с хранимыми данными.  Полный пример см. в разделе [Чтение примера пакета](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="packageMode" /> или <paramref name="packageAccess" /> является недопустимым.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess, packageShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Путь и имя файла пакета.</param>
        <param name="packageMode">Файловый режим, в котором следует открыть пакет.</param>
        <param name="packageAccess">Режим доступа к файлу, в котором следует открыть пакет.</param>
        <param name="packageShare">Режим общего доступа, в котором следует открыть пакет.</param>
        <summary>Открывает пакет на заданном пути с указанными значениями файлового режима, режима доступа к файлу и режима общего доступа.</summary>
        <returns>Открытый пакет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>тип пакета по умолчанию, используемый <xref:System.IO.Packaging.Package.Open%2A> методом.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
   
  
## Examples  
 В следующем примере показано, как создать новый <xref:System.IO.Packaging.Package> элемент, <xref:System.IO.Packaging.PackageRelationship> включающий элементы и <xref:System.IO.Packaging.PackagePart> , вместе с хранимыми данными.  Полный пример см. в разделе [запись примера пакета](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="packageMode" />, <paramref name="packageAccess" /> или <paramref name="packageShare" /> является недопустимым.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PackageProperties : System.IO.Packaging.PackageProperties" Usage="System.IO.Packaging.Package.PackageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает основные свойства пакета.</summary>
        <value>Основные свойства пакета.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о основных свойствах пакета см. в разделе 3,1 спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member PartExists : Uri -&gt; bool&#xA;override this.PartExists : Uri -&gt; bool" Usage="package.PartExists partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri"><see cref="T:System.Uri" /> проверяемой части.</param>
        <summary>Показывает, содержится ли часть с заданным URI в пакете.</summary>
        <returns><see langword="true" />, если часть с указанным <paramref name="partUri" /> находится в пакете, в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` Должен начинаться с символа прямой косой черты "/" и быть абсолютным от корня пакета.  
  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="partUri" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> не является допустимым <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи (чтение информации невозможно).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="package.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><see cref="P:System.IO.Packaging.PackageRelationship.Id" /> проверяемой связи.</param>
        <summary>Показывается, содержится ли в пакете связь уровня пакета с заданным идентификатором.</summary>
        <returns><see langword="true" />, если связь уровня пакета с указанным <paramref name="id" /> находится в пакете, в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в спецификации Open Packaging Conventions (OPC), доступной для загрузки <https://go.microsoft.com/fwlink/?LinkID=71255>по адресу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">Параметр <paramref name="id" /> не является допустимым идентификатором XML.</exception>
        <exception cref="T:System.ObjectDisposedException">Пакет не открыт (вызван метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> или <see cref="M:System.IO.Packaging.Package.Close" />).</exception>
        <exception cref="T:System.IO.IOException">Пакет доступен только для записи.</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Данный член поддерживает инфраструктуру [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] и не предназначен для использования в приложениях.  Использовать вместо этого типобезопасный метод <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
