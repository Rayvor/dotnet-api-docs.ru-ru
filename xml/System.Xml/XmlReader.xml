<Type Name="XmlReader" FullName="System.Xml.XmlReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0968dfbc799960aa7a290f7bb19497bffa4812e5" /><Meta Name="ms.sourcegitcommit" Value="385ff23cc00fe9aa1c93460c62603b45c2041d0b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/22/2019" /><Meta Name="ms.locfileid" Value="74385229" /></Metadata><TypeSignature Language="C#" Value="public abstract class XmlReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlReader abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type XmlReader = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет средство чтения, обеспечивающее быстрый прямой доступ (без кэширования) к данным XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader> предоставляет доступ к XML-данным в документе или потоке только для чтения вперед. Этот класс соответствует стандартам W3C [язык XML (XML) 1,0 (Четвертый выпуск)](https://www.w3.org/TR/2006/REC-xml-20060816/) и [пространствам имен в рекомендациях по XML 1,0 (третий выпуск)](https://www.w3.org/TR/REC-xml-names/) .  
  
 <xref:System.Xml.XmlReader> методы позволяют перемещаться по XML-данным и читать содержимое узла. Свойства класса отражать значение текущего узла, где расположен модуль чтения. Значение свойства <xref:System.Xml.XmlReader.ReadState%2A> указывает текущее состояние модуля чтения XML. Например, свойство устанавливается в <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType> методом <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> и <xref:System.Xml.ReadState.Closed?displayProperty=nameWithType>ся методом <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType>. <xref:System.Xml.XmlReader> также обеспечивает проверку согласованности данных и проверку DTD или схемы.  
  
 <xref:System.Xml.XmlReader> использует модель извлечения для получения данных. Эта модель:  
  
-   Упрощает управление состоянием с помощью естественного уточнения процедур сверху вниз.  
  
-   Поддерживает несколько входных потоков и уровней.  
  
-   Позволяет клиенту предоставить средству синтаксического анализа буфер, в который непосредственно записывается строка, и таким образом избежать необходимости в дополнительной копии строки.  
  
-   Поддерживает выборочную обработку. Клиент может пропускать элементы и обрабатывать те, которые представляют интерес для приложения. Вы также можете заранее задать свойства, чтобы управлять обработкой XML-потока (например, нормализацией).  
  
 Содержание  
  
 [Создание  модуля чтения XML](#xmlreader_create)  
 [Проверка  данных XML](#xmlreader_validate)  
 [Соответствие данных](#xmlreader_data)   
 [Навигация по узлам](#xmlreader_nodes)   
 [Чтение XML-элементов](#xmlreader_elements)   
 [Чтение АТРИБУТОВ XML](#xmlreader_attributes)   
 [Чтение XML-содержимого](#xmlreader_content)   
 [Преобразование в типы CLR](#xmlreader_clr)   
 [Асинхронное программирование](#xmlreader_async)   
 [Вопросы безопасности](#xmlreader_security)  
  
<a name="xmlreader_create"></a>   
## <a name="creating-an-xml-reader"></a>Создание средства чтения XML  
 Для создания экземпляра <xref:System.Xml.XmlReader> используйте метод <xref:System.Xml.XmlReader.Create%2A>.  
  
 Хотя .NET Framework предоставляет конкретные реализации класса <xref:System.Xml.XmlReader>, такие как <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>и классы <xref:System.Xml.XmlValidatingReader>, рекомендуется использовать специализированные классы только в следующих сценариях:  
  
-   Если необходимо считать поддерево XML DOM из объекта <xref:System.Xml.XmlNode>, используйте класс <xref:System.Xml.XmlNodeReader>. (Однако этот класс не поддерживает проверку DTD или схемы.)  
  
-   Если необходимо развернуть сущности по запросу, вы не хотите нормализовать содержимое текста или не хотите, чтобы атрибуты по умолчанию возвращались, используйте класс <xref:System.Xml.XmlTextReader>.  
  
 Чтобы указать набор компонентов, которые необходимо включить в модуле чтения XML, передайте объект <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> в метод <xref:System.Xml.XmlReader.Create%2A>. Вы можете использовать один объект <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>, чтобы создать несколько модулей чтения с одинаковыми функциональными возможностями или изменить объект <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>, чтобы создать новое средство чтения с другим набором компонентов. Можно также легко добавить компоненты в существующий модуль чтения.  
  
 Если объект <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> не используется, используются параметры по умолчанию. Дополнительные сведения см. на странице справочника по <xref:System.Xml.XmlReader.Create%2A>.  
  
 <xref:System.Xml.XmlReader> создает <xref:System.Xml.XmlException> при ошибках синтаксического анализа XML. После возникновения исключения состояние модуля чтения не может быть предсказуемым. Например, тип сообщаемого узла может отличаться от фактического типа узла текущего узла. Используйте свойство <xref:System.Xml.XmlReader.ReadState%2A>, чтобы проверить, находится ли модуль чтения в состоянии ошибки.  
  
<a name="xmlreader_validate"></a>   
## <a name="validating-xml-data"></a>Проверка XML-данных  
 Для определения структуры XML-документа и его связей, типов данных и ограничений содержимого используется определение типа документа (DTD) или схема языка определения схемы XML (XSD). XML-документ считается правильным форматом, если он соответствует всем синтаксическим требованиям, определенным в [рекомендациях консорциума W3C по XML 1,0](https://www.w3.org/TR/2006/REC-xml-20060816/). Он считается допустимым, если он правильно сформирован, а также соответствует ограничениям, определенным в DTD или схеме. (См. раздел [Схема W3C XML, часть 1: структуры](https://www.w3.org/TR/xmlschema-1/) и [Схема W3C XML, часть 2:](https://www.w3.org/TR/xmlschema-2/) рекомендации по типам.) Таким образом, несмотря на то, что все допустимые XML-документы имеют правильный формат, не все XML-документы правильного формата являются допустимыми.  
  
 Можно проверить данные по DTD, встроенной XSD-схеме или схеме XSD, хранящейся в объекте <xref:System.Xml.Schema.XmlSchemaSet> (кэше). Эти сценарии описаны на странице справки <xref:System.Xml.XmlReader.Create%2A>. <xref:System.Xml.XmlReader> не поддерживает проверку схемы XML-Data Reduceed (XDR).  
  
 Чтобы указать тип проверки, поддерживаемый экземпляром <xref:System.Xml.XmlReader>, используйте следующие параметры класса <xref:System.Xml.XmlReaderSettings>.  
  
|Использовать этот <xref:System.Xml.XmlReaderSettings> элемент|Чтобы указать|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|  
|Свойство<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|Следует ли разрешить обработку DTD. По умолчанию обработка определения DTD не разрешается.|  
|Свойство<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|Должен ли модуль чтения проверять данные, а также тип выполняемой проверки (DTD или Schema). По умолчанию проверка данных не выполняется.|  
|Событие<xref:System.Xml.XmlReaderSettings.ValidationEventHandler>|Обработчик событий для получения сведений о событиях проверки. Если обработчик события не предоставлен, при первой ошибке проверки вызывается исключение <xref:System.Xml.XmlException>.|  
|Свойство<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|Дополнительные параметры проверки с помощью членов перечисления <xref:System.Xml.Schema.XmlSchemaValidationFlags>:<br /><br /> -   `AllowXmlAttributes`--разрешить XML-атрибуты (`xml:*`) в документах экземпляров, даже если они не определены в схеме. Атрибуты проверяются на основе их типов данных. Сведения о параметрах, используемых в конкретных сценариях, см. на странице справочника по <xref:System.Xml.Schema.XmlSchemaValidationFlags>. (По умолчанию отключено.)<br />-   `ProcessIdentityConstraints`--Обработка ограничений идентификации (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, `xs:unique`), обнаруженных во время проверки. (Включено по умолчанию.)<br />-   `ProcessSchemaLocation`--обрабатывать схемы, заданные атрибутом `xsi:schemaLocation` или `xsi:noNamespaceSchemaLocation`. (Включено по умолчанию.)<br />-   `ProcessInlineSchema`--обрабатывать встроенные XML-схемы во время проверки. (По умолчанию отключено.)<br />-   `ReportValidationWarnings`— сообщать о событиях, если происходит предупреждение проверки. Предупреждение обычно формируется при отсутствии определения DTD или схемы XML для проверки конкретного элемента или атрибута. Параметр <xref:System.Xml.XmlReaderSettings.ValidationEventHandler> используется для уведомления. (По умолчанию отключено.)|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|<xref:System.Xml.Schema.XmlSchemaSet>, используемый при проверке данных.|  
|Свойство<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|<xref:System.Xml.XmlResolver> для разрешения и доступа к внешним ресурсам. Это могут быть внешние сущности, такие как DTD и схемы, а также любые `xs:include` или `xs:import` элементы, содержащиеся в схеме XML. Если не указать <xref:System.Xml.XmlResolver>, <xref:System.Xml.XmlReader> использует <xref:System.Xml.XmlUrlResolver> по умолчанию без учетных данных пользователя.|  
  
<a name="xmlreader_data"></a>   
## <a name="data-conformance"></a>Соответствие данных  
 Средства чтения XML, созданным <xref:System.Xml.XmlReader.Create%2A> метод следующие предварительные требования соответствия по умолчанию:  
  
-   Новые строки и значения атрибутов нормализованы согласно рекомендациям консорциума W3C по [XML 1,0](https://www.w3.org/TR/2006/REC-xml-20060816/).  
  
-   Все сущности разворачиваются автоматически.  
  
-   Атрибуты по умолчанию, объявленные в определении типа документа, всегда добавляются, даже если средство чтения не проверяется.  
  
-   Допускается объявление префикса XML, сопоставленного с правильным URI пространства имен XML.  
  
-   Имена нотаций в одном `NotationType` объявление атрибута и `NmTokens` в одном `Enumeration` объявление атрибута отличаются.  
  
 Используйте следующие свойства <xref:System.Xml.XmlReaderSettings>, чтобы указать тип проверки соответствия, которую необходимо включить.  
  
|Используйте это <xref:System.Xml.XmlReaderSettings> свойство|Кому|Значение по умолчанию|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|-------------|  
|Свойство<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|Включить или отключить проверки для следующих:<br /><br /> -Символы находятся в диапазоне допустимых символов XML, как определено в разделе [2,2 символов](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets) статьи рекомендации консорциума W3C XML 1,0.<br />— Все имена XML являются допустимыми, как определено в разделе [Общие синтаксические конструкции 2,3](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name) рекомендации консорциума W3C XML 1,0.<br /><br /> Если это свойство имеет значение `true` (по умолчанию), исключение <xref:System.Xml.XmlException> возникает, если XML-файл содержит недопустимые символы или недопустимые имена XML (например, имя элемента начинается с цифры).|Проверка символов и имен включена.<br /><br /> Задание свойству <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> значения `false` отключает проверку символов для ссылок на сущности символов. Если модуль чтения обрабатывает текстовые данные, он всегда проверяет допустимость имен XML независимо от этого параметра. **Примечание.**  Рекомендации по XML 1,0 требуют соответствия уровня документа при наличии DTD. Таким образом, если средство чтения настроено для поддержки <xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>, но XML-данные содержат определение типа документа (DTD), выдается <xref:System.Xml.XmlException>.|  
|Свойство<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|Выберите уровень соответствия для принудительного применения:<br /><br /> -   <xref:System.Xml.ConformanceLevel.Document>. Соответствует правилам для [XML-документа с правильным форматом 1,0](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed).<br />-   <xref:System.Xml.ConformanceLevel.Fragment>. Соответствует правилам для фрагмента документа правильного формата, который можно использовать как [внешнюю анализируемую сущность](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities).<br />-   <xref:System.Xml.ConformanceLevel.Auto>. Соответствует уровню, принятому модулем чтения.<br /><br /> Если данные не согласованы, возникает исключение <xref:System.Xml.XmlException>.|<xref:System.Xml.ConformanceLevel.Document>|  
  
<a name="xmlreader_nodes"></a>   
## <a name="navigating-through-nodes"></a>Навигация по узлам  
 Текущий узел — это XML-узел, на котором в настоящий момент размещается модуль чтения XML. Все методы <xref:System.Xml.XmlReader> выполняют операции в связи с этим узлом, а все свойства <xref:System.Xml.XmlReader> соответствуют значению текущего узла.  
  
 Следующие методы упрощают навигацию по узлам и анализу данных.  
  
|Используйте этот метод <xref:System.Xml.XmlReaderSettings>|Кому|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Read%2A>|Прочтите первый узел и прокрутите поток по одному узлу за раз. Такие вызовы обычно выполняются в цикле `while`.<br /><br /> Используйте свойство <xref:System.Xml.XmlReader.NodeType%2A>, чтобы получить тип (например, атрибут, комментарий, элемент и т. д.) текущего узла.|  
|<xref:System.Xml.XmlReader.Skip%2A>|Пропустите дочерние элементы текущего узла и перейдите к следующему узлу.|  
|<xref:System.Xml.XmlReader.MoveToContent%2A> и <xref:System.Xml.XmlReader.MoveToContentAsync%2A>|Пропускать узлы, не являющиеся узлами содержимого, и переходить к следующему узлу содержимого или к концу файла.<br /><br /> Узлы без содержимого включают <xref:System.Xml.XmlNodeType.ProcessingInstruction>, <xref:System.Xml.XmlNodeType.DocumentType>, <xref:System.Xml.XmlNodeType.Comment>, <xref:System.Xml.XmlNodeType.Whitespace>и <xref:System.Xml.XmlNodeType.SignificantWhitespace>.<br /><br /> Узлы содержимого содержат текст, не являющийся пробелом, <xref:System.Xml.XmlNodeType.CDATA>, <xref:System.Xml.XmlNodeType.EntityReference> и <xref:System.Xml.XmlNodeType.EndEntity>.|  
|<xref:System.Xml.XmlReader.ReadSubtree%2A>|Считывает элемент и все его дочерние элементы и возвращает новый экземпляр <xref:System.Xml.XmlReader>, для которого задано значение <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>.<br /><br /> Этот метод полезен для создания границ вокруг XML-элементов. Например, если требуется передать данные в другой компонент для обработки и требуется ограничить объем данных, доступ к которым может получить компонент.|  
  
 Пример перемещения по текстовому потоку по одному узлу за раз и отображения типа каждого узла см. на странице справки <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>.  
  
 В следующих разделах описывается, как можно читать определенные типы данных, такие как элементы, атрибуты и типизированные данные.  
  
<a name="xmlreader_elements"></a>   
## <a name="reading-xml-elements"></a>Чтение XML-элементов  
 В следующей таблице перечислены методы и свойства, предоставляемые классом <xref:System.Xml.XmlReader> для обработки элементов. После того, как объект <xref:System.Xml.XmlReader> позиционируется на элементе, свойства узла, например <xref:System.Xml.XmlReader.Name%2A>, отражают значения этого элемента. Кроме описанных ниже членов для обработки элементов процесса могут также использоваться любые методы и свойства класса <xref:System.Xml.XmlReader>. Например, для чтения содержимого элемента используется метод <xref:System.Xml.XmlReader.ReadInnerXml%2A>.  
  
> [!NOTE]
>  Определения открывающих тегов, закрывающих тегов и пустых тегов элементов см. в разделе 3,1 [рекомендации консорциума W3C по XML 1,0](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags) .  
  
|Использовать этот <xref:System.Xml.XmlReader> элемент|Кому|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Метод <xref:System.Xml.XmlReader.IsStartElement%2A>|Проверьте, является ли текущий узел открывающим тегом или пустым тегом элемента.|  
|Метод <xref:System.Xml.XmlReader.ReadStartElement%2A>|Убедитесь, что текущий узел является элементом, и перейдите к следующему узлу (вызывается <xref:System.Xml.XmlReader.IsStartElement%2A>, за которым следует <xref:System.Xml.XmlReader.Read%2A>).|  
|Метод <xref:System.Xml.XmlReader.ReadEndElement%2A>|Убедитесь, что текущий узел является закрывающим тегом и переместит читателя на следующий узел.|  
|Метод <xref:System.Xml.XmlReader.ReadElementString%2A>|Чтение элемента, доступного только для текста.|  
|Метод <xref:System.Xml.XmlReader.ReadToDescendant%2A>|Передвиньте модуль чтения XML к следующему элементу-потомку (дочернему), имеющему указанное имя.|  
|Метод <xref:System.Xml.XmlReader.ReadToNextSibling%2A>|Переместить модуль чтения XML к следующему родственному элементу с указанным именем.|  
|Свойство<xref:System.Xml.XmlReader.IsEmptyElement%2A>|Проверьте, содержит ли текущий элемент тег конечного элемента. Например:<br /><br /> `<item num="123"/>` -   (<xref:System.Xml.XmlReader.IsEmptyElement%2A> `true`.)<br />-   `<item num="123"> </item>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> `false`, хотя содержимое элемента пусто.)|  
  
 Пример чтения текстового содержимого элементов см. в описании метода <xref:System.Xml.XmlReader.ReadString%2A>. В следующем примере элементы обрабатываются с помощью цикла `while`.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
<a name="xmlreader_attributes"></a>   
## <a name="reading-xml-attributes"></a>Чтение атрибутов XML  
 Атрибуты XML чаще всего встречаются в элементах, но они также разрешены для XML-декларации и узлов типов документов.  
  
 При позиционировании на узле элемента метод <xref:System.Xml.XmlReader.MoveToAttribute%2A> позволяет перемещаться по списку атрибутов элемента. Обратите внимание, что после вызова <xref:System.Xml.XmlReader.MoveToAttribute%2A> свойства узла, такие как <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>и <xref:System.Xml.XmlReader.Prefix%2A>, отражать свойства этого атрибута, а не свойства элемента, к которому принадлежит атрибут.  
  
 Класс <xref:System.Xml.XmlReader> предоставляет эти методы и свойства для чтения и обработки атрибутов элементов.  
  
|Использовать этот <xref:System.Xml.XmlReader> элемент|Кому|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Свойство<xref:System.Xml.XmlReader.HasAttributes%2A>|Проверьте, имеются ли у текущего узла какие либо атрибуты.|  
|Свойство<xref:System.Xml.XmlReader.AttributeCount%2A>|Возвращает количество атрибутов текущего элемента.|  
|Метод <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>|Перейти к первому атрибуту в элементе.|  
|Метод <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>|Переход к следующему атрибуту в элементе.|  
|Метод <xref:System.Xml.XmlReader.MoveToAttribute%2A>|Перейти к указанному атрибуту.|  
|метод <xref:System.Xml.XmlReader.GetAttribute%2A> или свойство <xref:System.Xml.XmlReader.Item%2A>|Получение значения указанного атрибута.|  
|Свойство<xref:System.Xml.XmlReader.IsDefault%2A>|Проверьте, является ли текущий узел атрибутом, созданным из значения по умолчанию, определенного в DTD или схеме.|  
|Метод <xref:System.Xml.XmlReader.MoveToElement%2A>|Переход к элементу, владеющему текущим атрибутом. Используйте этот метод, чтобы вернуться к элементу после перехода по его атрибутам.|  
|Метод <xref:System.Xml.XmlReader.ReadAttributeValue%2A>|Проанализируйте значение атрибута в одном или нескольких `Text`, `EntityReference`или узлах `EndEntity`.|  
  
 Для обработки атрибутов можно использовать и любые обычные методы и свойства объекта <xref:System.Xml.XmlReader>. Например, если объект <xref:System.Xml.XmlReader> расположен на атрибуте, свойства <xref:System.Xml.XmlReader.Name%2A> и <xref:System.Xml.XmlReader.Value%2A> будут отражать значения этого атрибута. Также можно использовать любые методы `Read` содержимого, чтобы получить значение атрибута.  
  
 В этом примере используется свойство <xref:System.Xml.XmlReader.AttributeCount%2A> для навигации по всем атрибутам элемента.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 В этом примере используется метод <xref:System.Xml.XmlReader.MoveToNextAttribute%2A> в цикле `while` для перемещения по атрибутам.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 **Чтение атрибутов на узлах объявления XML**  
  
 Когда модуль чтения XML располагается на узле объявления XML, свойство <xref:System.Xml.XmlReader.Value%2A> возвращает сведения о версии, автономной и кодировке в виде одной строки. <xref:System.Xml.XmlReader> объекты, созданные методом <xref:System.Xml.XmlReader.Create%2A>, классом <xref:System.Xml.XmlTextReader> и классом <xref:System.Xml.XmlValidatingReader> предоставляют версию, автономную и кодировку элементов в качестве атрибутов.  
  
 **Чтение атрибутов на узлах типов документов**  
  
 Когда модуль чтения XML располагается на узле типа документа, для получения значений для системы и открытых литералов можно использовать метод <xref:System.Xml.XmlReader.GetAttribute%2A> и свойство <xref:System.Xml.XmlReader.Item%2A>. Например, вызов метода `reader.GetAttribute("PUBLIC")` возвращает значение PUBLIC.  
  
 **Чтение атрибутов на узлах инструкции по обработке**  
  
 Если <xref:System.Xml.XmlReader> расположен на узле инструкций по обработке, свойство <xref:System.Xml.XmlReader.Value%2A> возвращает текстовое содержимое целиком. Элементы в узле инструкции по обработке не рассматриваются как атрибуты. Их невозможно прочитать с помощью метода <xref:System.Xml.XmlReader.GetAttribute%2A> или <xref:System.Xml.XmlReader.MoveToAttribute%2A>.  
  
<a name="xmlreader_content"></a>   
## <a name="reading-xml-content"></a>Чтение XML-содержимого  
 Класс XMLReader включает следующие члены, которые считывают содержимое из XML-файла и возвращают содержимое в виде строковых значений. (Чтобы получить типы CLR, см. [следующий раздел](#xmlreader_clr).)  
  
|Использовать этот <xref:System.Xml.XmlReader> элемент|Кому|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Свойство<xref:System.Xml.XmlReader.Value%2A>|Возвращает текстовое содержимое текущего узла. Возвращаемое значение зависит от типа узла. Дополнительные сведения см. на странице справочника по <xref:System.Xml.XmlReader.Value%2A>.|  
|Метод <xref:System.Xml.XmlReader.ReadString%2A>|Получение содержимого элемента или текстового узла в виде строки. Этот метод прекращает работу в инструкциях по обработке и комментариях.<br /><br /> Дополнительные сведения о том, как этот метод обрабатывает определенные типы узлов, см. на странице справочника по <xref:System.Xml.XmlReader.ReadString%2A>.|  
|Методы <xref:System.Xml.XmlReader.ReadInnerXml%2A> и <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>|Возвращает все содержимое текущего узла, включая разметку, но не исключая начальный и конечный теги. Например, для:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadInnerXml%2A> возвращает:<br /><br /> `this<child id="123"/>`|  
|Методы <xref:System.Xml.XmlReader.ReadOuterXml%2A> и <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>|Получение всего содержимого текущего узла и его дочерних элементов, включая разметку и теги начала и окончания. Например, для:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadOuterXml%2A> возвращает:<br /><br /> `<node>this<child id="123"/></node>`|  
  
<a name="xmlreader_clr"></a>   
## <a name="converting-to-clr-types"></a>Преобразование в типы CLR  
 Члены класса <xref:System.Xml.XmlReader> (перечисленные в следующей таблице) можно использовать для считывания XML-данных и возвращаемых значений в качестве типов среды CLR вместо строк. Эти члены позволяют получать в представлении значения, наиболее подходящие для задачи кода, без необходимости вручную анализировать или преобразовывать строковые значения.  
  
-   Методы **ReadElementContentAs** могут вызываться только для типов узлов элементов. Их нельзя использовать для элементов, содержащих дочерние элементы или смешанное содержимое. Объект <xref:System.Xml.XmlReader> при вызове считывает открывающий тег, читает содержимое элемента и перемещается за закрывающий тег элемента. Инструкции по обработке и комментарии пропускаются, а сущности раскрываются.  
  
-   Методы **реадконтентас** считывают текстовое содержимое в текущей позиции модуля чтения, и если с данными XML не связаны какие-либо схемы или сведения о типах данных, преобразуйте текстовое содержимое в запрошенный тип возвращаемого значения. Текст, пробелы, значимые пробелы и разделы CDATA объединяются. Комментарии и инструкции по обработке пропускаются, и ссылки на сущности разрешаются автоматически.  
  
 Класс <xref:System.Xml.XmlReader> использует правила, определенные в рекомендации [консорциума W3C по XML-схеме, часть 2: типы](https://www.w3.org/TR/xmlschema-2/) данных.  
  
|Используйте этот метод <xref:System.Xml.XmlReader>|Возврат этого типа CLR|  
|--------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> и <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A>|<xref:System.Boolean>|  
|<xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> и <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>|<xref:System.DateTime>|  
|<xref:System.Xml.XmlReader.ReadContentAsDouble%2A> и <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A>|<xref:System.Double>|  
|<xref:System.Xml.XmlReader.ReadContentAsLong%2A> и <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>|<xref:System.Int64>|  
|<xref:System.Xml.XmlReader.ReadContentAsInt%2A> и <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A>|<xref:System.Int32>|  
|<xref:System.Xml.XmlReader.ReadContentAsString%2A> и <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>|<xref:System.String>|  
|<xref:System.Xml.XmlReader.ReadContentAs%2A> и <xref:System.Xml.XmlReader.ReadElementContentAs%2A>|Тип, указанный с помощью параметра `returnType`|  
|<xref:System.Xml.XmlReader.ReadContentAsObject%2A> и <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>|Наиболее подходящий тип, как указано в свойстве <xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType>. Сведения о сопоставлении см. [в разделе Поддержка типов в классах System. XML](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) .|  
  
 Если элемент невозможно легко преобразовать в тип CLR из-за его формата, можно использовать сопоставление схемы для успешного преобразования. В следующем примере используется XSD-файл для преобразования элемента `hire-date` в тип `xs:date`, а затем используется метод <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> для возврата элемента в виде объекта <xref:System.DateTime>.  
  
 **Ввод (hireDate. XML):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#9](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xml#9)]  
  
 **Схема (hireDate. xsd):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#10](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xsd#10)]  
  
 **Приведен**  
  
 [!code-csharp[XmlReader.ReadElementContentAs#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#13)]
 [!code-vb[XmlReader.ReadElementContentAs#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#13)]  
  
 **Выходные данные:**  
  
```  
Six Month Review Date:  7/8/2003 12:00:00 AM  
```  
  
<a name="xmlreader_async"></a>   
## <a name="asynchronous-programming"></a>Асинхронное программирование  
 Большинство методов <xref:System.Xml.XmlReader> имеют асинхронные аналоги, имеющие "Async" в конце имен методов. Например, асинхронный эквивалент <xref:System.Xml.XmlReader.ReadContentAsObject%2A> <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 С асинхронными вызовами методов можно использовать следующие методы:  
  
-   <xref:System.Xml.XmlReader.GetAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToElement%2A>  
  
-   <xref:System.Xml.XmlReader.ReadAttributeValue%2A>  
  
-   <xref:System.Xml.XmlReader.ReadSubtree%2A>  
  
-   <xref:System.Xml.XmlReader.ResolveEntity%2A>  
  
 В следующих разделах описывается асинхронное использование для методов, которые не имеют асинхронных аналогов.  
  
 **Метод Реадстартелемент**  
  
 [!code-csharp[System.Xml.XmlReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#1)]
 [!code-vb[System.Xml.XmlReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#1)]  
  
 **Метод Реаденделемент**  
  
 [!code-csharp[System.Xml.XmlReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#2)]
 [!code-vb[System.Xml.XmlReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#2)]  
  
 **Метод Реадтонекстсиблинг**  
  
 [!code-csharp[System.Xml.XmlReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#3)]
 [!code-vb[System.Xml.XmlReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#3)]  
  
 **Метод Реадтофолловинг**  
  
 [!code-csharp[System.Xml.XmlReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#4)]
 [!code-vb[System.Xml.XmlReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#4)]  
  
 **Метод Реадтодесцендант**  
  
 [!code-csharp[System.Xml.XmlReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#5)]
 [!code-vb[System.Xml.XmlReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#5)]  
  
<a name="xmlreader_security"></a>   
## <a name="security-considerations"></a>Замечания по безопасности  
 При работе с классом <xref:System.Xml.XmlReader> учитывайте следующее.  
  
-   Исключения, вызываемые из <xref:System.Xml.XmlReader>, могут раскрывать сведения о пути, которые не должны быть собраны в приложение. Приложение должно перехватывать исключения и обрабатывать их соответствующим образом.  
  
-   Не включайте обработку DTD, если у вас возникли проблемы отказа в обслуживании или если вы работаете с ненадежными источниками. Обработка DTD отключена по умолчанию для объектов <xref:System.Xml.XmlReader>, созданных методом <xref:System.Xml.XmlReader.Create%2A>.  
  
     Если обработка DTD включена, то с помощью класса <xref:System.Xml.XmlSecureResolver> можно ограничить ресурсы, доступные для объекта <xref:System.Xml.XmlReader>. Можно также спроектировать приложение таким образом, чтобы обработка XML была ограничена памятью и временем. Например, можно настроить ограничения времени ожидания в приложении ASP.NET.  
  
-   XML-данные могут содержать ссылки на внешние ресурсы, например файл схемы. По умолчанию внешние ресурсы разрешаются с помощью объекта <xref:System.Xml.XmlUrlResolver> без учетных данных пользователя. Это можно сделать еще более безопасным, выполнив одно из следующих действий.  
  
    -   Ограничить ресурсы, к которым имеет доступ <xref:System.Xml.XmlReader>, установив в качестве значения свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> объект <xref:System.Xml.XmlSecureResolver>.  
  
    -   Не разрешать <xref:System.Xml.XmlReader> открывать какие-либо внешние ресурсы, установив для свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> значение `null`.  
  
-   Флаги проверки <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> и <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> объекта <xref:System.Xml.XmlReaderSettings> не устанавливаются по умолчанию. Это позволяет защитить объект <xref:System.Xml.XmlReader> от атак на основе схем при обработке XML-данных из ненадежного источника. Если эти флаги установлены, для разрешения расположения схем, обнаруженных в экземпляре документа в объекте <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>, используется арбитр <xref:System.Xml.XmlReaderSettings> объекта <xref:System.Xml.XmlReader>. Если свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> имеет значение `null`, расположение схемы не разрешается, даже если установлены флаги проверки <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> и <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>.  
  
     Схемы, добавленные во время проверки, добавляют новые типы и могут изменить результат проверки документа. Поэтому следует разрешать только внешние схемы из доверенных источников.  
  
     Рекомендуется отключить флаг <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> при проверке ненадежных, больших XML-документов в сценариях с высоким уровнем доступности в отношении схемы, имеющей ограничения идентификации, в большой части документа. Этот флаг включен по умолчанию.  
  
-   XML-данные могут содержать большое количество атрибутов, деклараций пространств имен, вложенных элементов и так далее, на обработку которых требуется значительное время. Чтобы ограничить размер входных данных, отправляемых в <xref:System.Xml.XmlReader>, можно:  
  
    -   Ограничьте размер документа, задав свойство <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A>.  
  
    -   Ограничьте число символов, появляющихся в результате расширения сущностей, установив свойство <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A>.  
  
    -   Создайте пользовательскую реализацию `IStream` для <xref:System.Xml.XmlReader>.  
  
-   Метод <xref:System.Xml.XmlReader.ReadValueChunk%2A> можно использовать для управления большими потоками данных. Этот метод за раз считывает небольшое число символов, а не выделяет одну строку для всего значения.  
  
-   При чтении XML-документа с большим количеством уникальных локальных имен, пространств имен или префиксов может возникнуть проблема. Если вы используете класс, производный от <xref:System.Xml.XmlReader>, и вызываете свойство <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A>или <xref:System.Xml.XmlReader.NamespaceURI%2A> для каждого элемента, возвращаемая строка добавляется в <xref:System.Xml.NameTable>. Коллекция, удерживаемая <xref:System.Xml.NameTable>, никогда не уменьшается в размере, создавая утечку виртуальной памяти дескрипторов строк. Одним из способов устранения этой проблемы является наследование от класса <xref:System.Xml.NameTable> и принудительная квота максимального размера. (Не существует способа предотвратить использование <xref:System.Xml.NameTable>или переключить <xref:System.Xml.NameTable> при заполнении). Еще один способ устранения проблемы заключается в предотвращении использования упомянутых свойств, вместо этого используйте метод <xref:System.Xml.XmlReader.MoveToAttribute%2A> с методом <xref:System.Xml.XmlReader.IsStartElement%2A>, где это возможно. Эти методы не возвращают строки и, таким же, избегают проблемы переполнения коллекции <xref:System.Xml.NameTable>.  
  
-   Объекты <xref:System.Xml.XmlReaderSettings> могут содержать конфиденциальные сведения, например учетные данные пользователей. Ненадежный компонент может использовать объект <xref:System.Xml.XmlReaderSettings> и его учетные данные пользователя, чтобы создавать объекты <xref:System.Xml.XmlReader> для считывания данных. Будьте внимательны при кэшировании <xref:System.Xml.XmlReaderSettings> объектов или при передаче объекта <xref:System.Xml.XmlReaderSettings> из одного компонента в другой.  
  
-   Не следует принимать вспомогательные компоненты, например объекты <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager> и <xref:System.Xml.XmlResolver>, из ненадежных источников.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать асинхронный API для анализа XML.  
  
 [!code-csharp[System.Xml.XmlReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#6)]
 [!code-vb[System.Xml.XmlReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#6)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/data/xml/index.md">XML-документы и данные</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see langword="XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор вызывается конструкторами производного класса для инициализации состояния в этом типе.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public abstract int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int AttributeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeCount : int" Usage="System.Xml.XmlReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Когда переопределено в производном классе, возвращает количество атрибутов текущего узла.</summary>
        <value>Количество атрибутов текущего узла.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство относится только к `Element`, `DocumentType` и `XmlDeclaration` узлам. (Другие типы узлов не имеют атрибутов.)  
  
   
  
## Examples  
 В следующем примере отображаются все атрибуты текущего узла.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public abstract string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает базовый URI текущего узла.</summary>
        <value>Базовый URI текущего узла.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сетевой XML-документ состоит из фрагментов данных, агрегированных с помощью различных механизмов включения стандарта W3C и, следовательно, содержит узлы, полученные из разных мест. Сущности DTD являются примером этого, но это не ограничивается DTD. Базовый URI указывает, откуда получены эти узлы. Если для возвращаемых узлов не существует базового URI (например, они были проанализированы из строки в памяти), возвращается `String.Empty`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public virtual bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadBinaryContent : bool" Usage="System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, реализует ли объект <see cref="T:System.Xml.XmlReader" /> методы чтения двоичного содержимого.</summary>
        <value>Значение <see langword="true" />, если реализуются методы чтения двоичного содержимого; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы чтения двоичного содержимого включают в себя методы <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>и <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>. Если это свойство возвращает значение, `false` при вызове любого двоичного метода Read возвращается <xref:System.NotSupportedException>.  
  
 Все реализации Microsoft .NET Framework класса <xref:System.Xml.XmlReader> возвращают `true` для этого свойства.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadValueChunk : bool" Usage="System.Xml.XmlReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, реализует ли объект <see cref="T:System.Xml.XmlReader" /> метод <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Xml.XmlReader" /> реализует метод <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Синтаксический анализ текста <xref:System.Xml.XmlReader> объекты, созданные из статического метода <xref:System.Xml.XmlReader.Create%2A>, всегда возвращают `true`. Все остальные реализации Microsoft .NET Framework класса <xref:System.Xml.XmlReader>, включая класс <xref:System.Xml.XmlTextReader>, возвращают `false`.  
  
 Если это свойство возвращает значение, `false` при вызове метода <xref:System.Xml.XmlReader.ReadValueChunk%2A> возвращается <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public virtual bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResolveEntity : bool" Usage="System.Xml.XmlReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, способно ли данное средство чтения выполнять синтаксический анализ и разрешение сущностей.</summary>
        <value>Значение <see langword="true" />, если средство чтения позволяет анализировать и разрешать сущности; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство всегда возвращает `false` для реализаций <xref:System.Xml.XmlReader>, которые не поддерживают сведения о DTD. В этом случае вызов <xref:System.Xml.XmlReader.ResolveEntity%2A> создает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="xmlReader.Close " FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public abstract void Close ();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Close ()" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Close();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit" Usage="xmlReader.Close " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе изменяет значение свойства <see cref="P:System.Xml.XmlReader.ReadState" /> на <see cref="F:System.Xml.ReadState.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод также освобождает все ресурсы, удерживаемые во время чтения. Если <xref:System.Xml.XmlReader.Close%2A> уже вызван, никакие действия не выполняются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Большая часть <xref:System.Xml.XmlReader.Create%2A> перегрузок включает параметр `settings`, который принимает объект <xref:System.Xml.XmlReaderSettings>. Этот объект можно использовать для следующих действий:  
  
-   Укажите, какие функции должны поддерживаться для объекта <xref:System.Xml.XmlReader>.  
  
-   Повторное использование объекта <xref:System.Xml.XmlReaderSettings> для создания нескольких модулей чтения. Можно использовать те же настройки для создания нескольких объектов средства чтения с одинаковой функциональностью. Или можно изменить параметры на экземпляре <xref:System.Xml.XmlReaderSettings> и создать новое средство чтения с другим набором компонентов.  
  
-   Добавление компонентов к существующему модулю чтения XML. Метод <xref:System.Xml.XmlReader.Create%2A> может принимать другой объект <xref:System.Xml.XmlReader>. Базовым объектом <xref:System.Xml.XmlReader> может быть определяемый пользователем модуль чтения, объект <xref:System.Xml.XmlTextReader> или другой экземпляр <xref:System.Xml.XmlReader>, к которому требуется добавить дополнительные функции.  
  
-   Воспользуйтесь всеми преимуществами таких функций, как улучшенная проверка соответствия и соответствие рекомендациям для [XML 1,0 (четвертого выпуска)](https://www.w3.org/TR/2006/REC-xml-20060816/) , которые доступны только для <xref:System.Xml.XmlReader> объектов, созданных статическим методом <xref:System.Xml.XmlReader.Create%2A>.  
  
> [!NOTE]
>  Хотя .NET Framework включает конкретные реализации класса <xref:System.Xml.XmlReader>, такие как <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>и классы <xref:System.Xml.XmlValidatingReader>, рекомендуется создавать экземпляры <xref:System.Xml.XmlReader> с помощью метода <xref:System.Xml.XmlReader.Create%2A>.  
  
## <a name="default-settings"></a>Параметры по умолчанию  
 При использовании перегрузки <xref:System.Xml.XmlReader.Create%2A>, которая не принимает объект <xref:System.Xml.XmlReaderSettings>, используются следующие параметры модуля чтения по умолчанию:  
  
|Параметр|Значение по умолчанию|  
|-------------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|Пустой объект <xref:System.Xml.Schema.XmlSchemaSet>|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> включено|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|Новый объект <xref:System.Xml.XmlUrlResolver>.  Начиная с .NET Framework 4.5.2, этот параметр имеет значение по умолчанию `null`.|  
  
## <a name="settings-for-common-scenarios"></a>Параметры для распространенных сценариев  
 Ниже приведены свойства <xref:System.Xml.XmlReaderSettings>, которые следует задать для некоторых типовых сценариев средства чтения XML.  
  
|Требование|Задать|  
|-----------------|---------|  
|Данные должны представлять собой XML-документ правильного формата.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> <xref:System.Xml.ConformanceLevel.Document>.|  
|Данные должны быть правильно сформированными XML-проанализированными сущностями.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> <xref:System.Xml.ConformanceLevel.Fragment>.|  
|Данные должны быть проверены по DTD.|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> — <xref:System.Xml.DtdProcessing.Parse><br /><xref:System.Xml.XmlReaderSettings.ValidationType%2A> <xref:System.Xml.ValidationType.DTD>.|  
|Данные должны быть проверены по схеме XML.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> — <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> <xref:System.Xml.Schema.XmlSchemaSet>, используемый для проверки. Обратите внимание, что <xref:System.Xml.XmlReader> не поддерживает проверку схемы XML-Data Reduceed (XDR).|  
|Данные должны быть проверены по встроенной схеме XML.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> — <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>.|  
|Поддержка типов.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> — <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> <xref:System.Xml.Schema.XmlSchemaSet> для использования.|  
  
 <xref:System.Xml.XmlReader> не поддерживает проверку схемы XML-Data Reduceed (XDR).  
  
## <a name="asynchronous-programming"></a>Асинхронное программирование  
 В синхронном режиме метод <xref:System.Xml.XmlReader.Create%2A> считывает первый фрагмент данных из буфера чтения файла, потока или средства считывания текста. Это может вызвать исключение в случае сбоя операции ввода-вывода. В асинхронном режиме первая операция ввода-вывода выполняется с операцией чтения, поэтому возникающие исключения будут выдаваться при выполнении операции чтения.  
  
## <a name="security-considerations"></a>Замечания по безопасности  
 По умолчанию <xref:System.Xml.XmlReader> использует объект <xref:System.Xml.XmlUrlResolver> без учетных данных пользователя для открытия ресурсов. Это означает, что по умолчанию модуль чтения XML может получить доступ к любому расположению, которое не требует учетных данных. Используйте свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> для управления доступом к ресурсам.  
  
-   Задайте <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> объекту <xref:System.Xml.XmlSecureResolver>, чтобы ограничить ресурсы, к которым может обращаться модуль чтения XML.  
  
 - или -  
  
-   Задайте для параметра <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> значение `null`, чтобы модуль чтения XML не открывал какие-либо внешние ресурсы.  
  
   
  
## Examples  
 В этом примере создается модуль чтения XML, который удаляет незначащие пробелы, пробельные комментарии и выполняет проверку соответствия на уровне фрагментов.  
  
 [!code-csharp[XmlReader.Create#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#11)]
 [!code-vb[XmlReader.Create#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#11)]  
  
 В следующем примере используется <xref:System.Xml.XmlUrlResolver> с учетными данными по умолчанию для доступа к файлу.  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 [!code-cpp[XmlReaderSettings.cctor#2](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#2)]
 [!code-csharp[XmlReaderSettings.cctor#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#2)]
 [!code-vb[XmlReaderSettings.cctor#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#2)]  
  
 Следующий код создает оболочку для экземпляра модуля чтения в другом модуле чтения.  
  
 [!code-csharp[XmlReader.Create#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#13)]
 [!code-vb[XmlReader.Create#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#13)]  
  
 В этом примере читатели привязывает средства чтения для добавления проверки DTD и схемы XML.  
  
 [!code-csharp[XmlReader.Create#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#12)]
 [!code-vb[XmlReader.Create#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Поток, содержащий XML-данные.  
  
<see cref="T:System.Xml.XmlReader" /> просматривает первые байты потока в поисках метки порядка следования байтов или другого признака кодировки. Эта кодировка после определения используется в последующем считывании потока, а процедура обработки продолжает анализировать входные данные как поток символов Юникода.</param>
        <summary>Создает новый экземпляр <see cref="T:System.Xml.XmlReader" />, используя заданный поток с параметрами по умолчанию.</summary>
        <returns>Объект, используемый для чтения данных XML в потоке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания модуля чтения используется объект <xref:System.Xml.XmlReaderSettings> с параметрами по умолчанию. Если вы хотите указать функции для поддержки в созданном модуле чтения, используйте перегрузку, которая принимает объект <xref:System.Xml.XmlReaderSettings> как один из своих аргументов, и передает объект <xref:System.Xml.XmlReaderSettings> с правильными параметрами.  
  
 <xref:System.Xml.XmlUrlResolver> по умолчанию без учетных данных используется для доступа ко всем внешним ресурсам, таким как определение типа документа (DTD), сущности, схемы и т. д.  
  
> [!IMPORTANT]
>  Начиная с .NET Framework 4.5.2, <xref:System.Xml.XmlUrlResolver> по умолчанию не предоставляется. Если решение предназначено для .NET Framework 4.5.2 или более поздних версий, укажите <xref:System.Xml.XmlResolver> с помощью свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Если внешний ресурс находится в сетевом ресурсе, требующем проверки подлинности, укажите <xref:System.Xml.XmlResolver> с необходимыми учетными данными, используя свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Созданный объект <xref:System.Xml.XmlReader> расширяет ссылки на сущности и выполняет нормализацию XML символов новой строки.  
  
   
  
## Examples  
 В следующем примере создается объект <xref:System.Xml.XmlReader>, который считывает из <xref:System.IO.FileStream>.  
  
 [!code-csharp[XmlReader.Create#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#8)]
 [!code-vb[XmlReader.Create#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="input" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Тип <see cref="T:System.Xml.XmlReader" /> не имеет достаточных разрешений для доступа к расположению XML-данных.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Средство считывания текста, из которого следует считывать данные XML. Средство считывания текста возвращает поток символов Юникода, и указанная в объявлении XML кодировка не используется средством считывания XML для раскодирования потока данных.</param>
        <summary>Создает экземпляр <see cref="T:System.Xml.XmlReader" /> с использованием указанного средства чтения текста.</summary>
        <returns>Объект, используемый для чтения данных XML в потоке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания модуля чтения используется объект <xref:System.Xml.XmlReaderSettings> с параметрами по умолчанию. Если вы хотите указать функции для поддержки в созданном модуле чтения, используйте перегрузку, которая принимает объект <xref:System.Xml.XmlReaderSettings> как один из своих аргументов, и передает объект <xref:System.Xml.XmlReaderSettings> с правильными параметрами.  
  
 <xref:System.Xml.XmlUrlResolver> по умолчанию без учетных данных используется для доступа ко всем внешним ресурсам, таким как определение типа документа (DTD), сущности, схемы и т. д.  
  
> [!IMPORTANT]
>  Начиная с .NET Framework 4.5.2, <xref:System.Xml.XmlUrlResolver> по умолчанию не предоставляется. Если решение предназначено для .NET Framework 4.5.2 или более поздних версий, укажите <xref:System.Xml.XmlResolver> с помощью свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Если внешний ресурс находится в сетевом ресурсе, требующем проверки подлинности, укажите <xref:System.Xml.XmlResolver> с необходимыми учетными данными, используя свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Созданный объект <xref:System.Xml.XmlReader> расширяет ссылки на сущности и выполняет нормализацию XML символов новой строки.  
  
   
  
## Examples  
 В следующем примере класс <xref:System.IO.StringReader> используется для чтения XML-строки.  
  
 [!code-csharp[XmlReader.Create#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#7)]
 [!code-vb[XmlReader.Create#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="input" /> равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create inputUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inputUri">URI файла с XML-данными. Класс <see cref="T:System.Xml.XmlUrlResolver" /> используется для преобразования пути к классическому представлению данных.</param>
        <summary>Создает новый экземпляр <see cref="T:System.Xml.XmlReader" /> с указанным URI.</summary>
        <returns>Объект, используемый для чтения данных XML в потоке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания модуля чтения используется объект <xref:System.Xml.XmlReaderSettings> с параметрами по умолчанию. Если вы хотите указать функции для поддержки в созданном модуле чтения, используйте перегрузку, которая принимает объект <xref:System.Xml.XmlReaderSettings> как один из своих аргументов, и передает объект <xref:System.Xml.XmlReaderSettings> с правильными параметрами.  
  
 <xref:System.Xml.XmlUrlResolver> по умолчанию без учетных данных используется для доступа ко всем внешним ресурсам, таким как определение типа документа (DTD), сущности, схемы и т. д.  
  
> [!IMPORTANT]
>  Начиная с .NET Framework 4.5.2, <xref:System.Xml.XmlUrlResolver> по умолчанию не предоставляется. Если решение предназначено для .NET Framework 4.5.2 или более поздних версий, укажите <xref:System.Xml.XmlResolver> с помощью свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Если внешний ресурс находится в сетевом ресурсе, требующем проверки подлинности, укажите <xref:System.Xml.XmlResolver> с необходимыми учетными данными, используя свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Созданный объект <xref:System.Xml.XmlReader> расширяет ссылки на сущности и выполняет нормализацию XML символов новой строки.  
  
   
  
## Examples  
 В следующем примере создается объект <xref:System.Xml.XmlReader>, который считывает файл данных XML, заданный с помощью URI.  
  
 [!code-csharp[XmlReader.Create#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#6)]
 [!code-vb[XmlReader.Create#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="inputUri" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Тип <see cref="T:System.Xml.XmlReader" /> не имеет достаточных разрешений для доступа к расположению XML-данных.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Файл, указанный в URI, не существует.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>  
 Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.  
  
</para>
          </block>  
  
 Неправильный формат URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Поток, содержащий XML-данные.  
  
<see cref="T:System.Xml.XmlReader" /> просматривает первые байты потока в поисках метки порядка следования байтов или другого признака кодировки. Эта кодировка после определения используется в последующем считывании потока, а процедура обработки продолжает анализировать входные данные как поток символов Юникода.</param>
        <param name="settings">Параметры нового экземпляра <see cref="T:System.Xml.XmlReader" />. Это значение может быть равно <see langword="null" />.</param>
        <summary>Создает экземпляр <see cref="T:System.Xml.XmlReader" /> с указанными потоком и параметрами.</summary>
        <returns>Объект, используемый для чтения данных XML в потоке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Xml.XmlUrlResolver> без учетных данных используется для доступа ко всем внешним ресурсам, таким как определение типа документа (DTD), сущности, схемы и т. д.  
  
> [!IMPORTANT]
>  Начиная с .NET Framework 4.5.2, <xref:System.Xml.XmlUrlResolver> по умолчанию не предоставляется. Если решение предназначено для .NET Framework 4.5.2 или более поздних версий, укажите <xref:System.Xml.XmlResolver> с помощью свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Если внешний ресурс находится в сетевом ресурсе, требующем проверки подлинности, используйте свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>, чтобы указать <xref:System.Xml.XmlResolver> с необходимыми учетными данными.  
  
> [!IMPORTANT]
>  Для управления ресурсами, к которым <xref:System.Xml.XmlReader> может быть доступ, можно использовать один из следующих методов.  
>   
>  -   Ограничить ресурсы, к которым имеет доступ <xref:System.Xml.XmlReader>, установив в качестве значения свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> объект <xref:System.Xml.XmlSecureResolver>.  
>   
>  - или -  
>   
>  -   Не разрешать <xref:System.Xml.XmlReader> открывать какие-либо внешние ресурсы, установив для свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> значение `null`.  
  
 Созданный объект <xref:System.Xml.XmlReader> расширяет ссылки на сущности и выполняет нормализацию XML символов новой строки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="input" /> равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Средство считывания текста, из которого следует считывать данные XML. Средство считывания текста возвращает поток символов Юникода, и указанная в объявлении XML кодировка не используется средством считывания XML для раскодирования потока данных.</param>
        <param name="settings">Параметры для нового <see cref="T:System.Xml.XmlReader" />. Это значение может быть равно <see langword="null" />.</param>
        <summary>Создает новый экземпляр <see cref="T:System.Xml.XmlReader" /> с использованием указанного модуля чтения текста и параметров.</summary>
        <returns>Объект, используемый для чтения данных XML в потоке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Xml.XmlUrlResolver> без учетных данных используется для доступа ко всем внешним ресурсам, таким как определение типа документа (DTD), сущности, схемы и т. д.  
  
> [!IMPORTANT]
>  Начиная с .NET Framework 4.5.2, <xref:System.Xml.XmlUrlResolver> по умолчанию не предоставляется. Если решение предназначено для .NET Framework 4.5.2 или более поздних версий, укажите <xref:System.Xml.XmlResolver> с помощью свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Если внешний ресурс находится в сетевом ресурсе, требующем проверки подлинности, используйте свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>, чтобы указать <xref:System.Xml.XmlResolver> с необходимыми учетными данными.  
  
> [!IMPORTANT]
>  Для управления ресурсами, к которым <xref:System.Xml.XmlReader> может быть доступ, можно использовать один из следующих методов.  
>   
>  -   Ограничить ресурсы, к которым имеет доступ <xref:System.Xml.XmlReader>, установив в качестве значения свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> объект <xref:System.Xml.XmlSecureResolver>.  
>   
>  - или -  
>   
>  -   Не разрешать <xref:System.Xml.XmlReader> открывать какие-либо внешние ресурсы, установив для свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> значение `null`.  
  
 Созданный объект <xref:System.Xml.XmlReader> расширяет ссылки на сущности и выполняет нормализацию XML символов новой строки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="input" /> равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inputUri">URI файла с XML-данными. Объект <see cref="T:System.Xml.XmlResolver" /> в объекте <see cref="T:System.Xml.XmlReaderSettings" /> используется для преобразования пути в каноническое представление данных. Если <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> равно <see langword="null" />, используется новый объект <see cref="T:System.Xml.XmlUrlResolver" />.</param>
        <param name="settings">Параметры нового экземпляра <see cref="T:System.Xml.XmlReader" />. Это значение может быть равно <see langword="null" />.</param>
        <summary>Создает новый экземпляр <see cref="T:System.Xml.XmlReader" /> с использованием указанного URI и параметров.</summary>
        <returns>Объект, используемый для чтения данных XML в потоке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Xml.XmlUrlResolver> без учетных данных используется для доступа ко всем внешним ресурсам, таким как определение типа документа (DTD), сущности, схемы и т. д.  
  
> [!IMPORTANT]
>  Начиная с .NET Framework 4.5.2, <xref:System.Xml.XmlUrlResolver> по умолчанию не предоставляется. Если решение предназначено для .NET Framework 4.5.2 или более поздних версий, укажите <xref:System.Xml.XmlResolver> с помощью свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Это означает, что <xref:System.Xml.XmlReader> может получить доступ к любому расположению, которое не требует проверки подлинности. Если внешний ресурс находится в сетевом ресурсе, требующем проверки подлинности, используйте свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>, чтобы указать <xref:System.Xml.XmlResolver> с необходимыми учетными данными.  
  
> [!IMPORTANT]
>  Можно ограничить ресурсы, к которым может получить доступ <xref:System.Xml.XmlReader>, задав для свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> объект <xref:System.Xml.XmlSecureResolver>.  
  
 Созданный объект <xref:System.Xml.XmlReader> расширяет ссылки на сущности и выполняет нормализацию XML символов новой строки.  
  
   
  
## Examples  
 В следующем примере создается объект <xref:System.Xml.XmlReader>, поддерживающий проверку определения типа документа (DTD).  
  
 [!code-csharp[XmlReader.Create#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#3)]
 [!code-vb[XmlReader.Create#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="inputUri" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл, заданный с помощью URI.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>  
 Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.FormatException" />.  
  
</para>
          </block>  
  
 Неправильный формат URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.Xml.XmlReader reader, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.Xml.XmlReader reader, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.Xml.XmlReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (reader As XmlReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::Xml::XmlReader ^ reader, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (reader, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reader">Объект, который следует использовать в качестве базового средства чтения XML.</param>
        <param name="settings">Параметры нового экземпляра <see cref="T:System.Xml.XmlReader" />.  
  
Уровень согласованности объекта <see cref="T:System.Xml.XmlReaderSettings" /> должен быть равным уровню согласованности базового средства чтения или иметь значение <see cref="F:System.Xml.ConformanceLevel.Auto" />.</param>
        <summary>Создает новый экземпляр <see cref="T:System.Xml.XmlReader" />, используя заданное средство чтения XML и параметры.</summary>
        <returns>Объект, являющийся оболочкой для объекта <see cref="T:System.Xml.XmlReader" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет добавлять дополнительные функции к базовому объекту <xref:System.Xml.XmlReader>. Базовый объект <xref:System.Xml.XmlReader> может быть другим <xref:System.Xml.XmlReader>ным объектом, созданным методом <xref:System.Xml.XmlReader.Create%2A>, или объектом <xref:System.Xml.XmlReader>, созданным с помощью одной из реализаций конкретного <xref:System.Xml.XmlReader>.  
  
 Для доступа ко всем внешним ресурсам, таким как схема, используется <xref:System.Xml.XmlUrlResolver> по умолчанию без учетных данных.  
  
> [!IMPORTANT]
>  Начиная с .NET Framework 4.5.2, <xref:System.Xml.XmlUrlResolver> по умолчанию не предоставляется. Если решение предназначено для .NET Framework 4.5.2 или более поздних версий, укажите <xref:System.Xml.XmlResolver> с помощью свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Если внешний ресурс находится в сетевом ресурсе, требующем проверки подлинности, укажите <xref:System.Xml.XmlResolver> с необходимыми учетными данными, используя свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Для управления ресурсами, к которым <xref:System.Xml.XmlReader> может быть доступ, можно использовать один из следующих методов.  
>   
>  -   Ограничить ресурсы, к которым имеет доступ <xref:System.Xml.XmlReader>, установив в качестве значения свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> объект <xref:System.Xml.XmlSecureResolver>.  
>   
>  - или -  
>   
>  -   Не разрешать <xref:System.Xml.XmlReader> открывать какие-либо внешние ресурсы, установив для свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> значение `null`.  
  
 Созданный объект <xref:System.Xml.XmlReader> расширяет ссылки на сущности и выполняет нормализацию XML символов новой строки.  
  
   
  
## Examples  
 В следующем примере создается объект проверки <xref:System.Xml.XmlReader>, упакованный вокруг объекта <xref:System.Xml.XmlNodeReader>.  
  
 [!code-csharp[XmlReader.Create#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#5)]
 [!code-vb[XmlReader.Create#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="reader" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Если объект <see cref="T:System.Xml.XmlReaderSettings" /> задает уровень согласованности, который не соответствует уровню согласованности базового средства чтения.  
  
- или - 
Базовый <see cref="T:System.Xml.XmlReader" /> находится в состоянии <see cref="F:System.Xml.ReadState.Error" /> или <see cref="F:System.Xml.ReadState.Closed" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="baseUri" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="input">Поток, содержащий XML-данные.  
  
<see cref="T:System.Xml.XmlReader" /> просматривает первые байты потока в поисках метки порядка следования байтов или другого признака кодировки. Эта кодировка после определения используется в последующем считывании потока, а процедура обработки продолжает анализировать входные данные как поток символов Юникода.</param>
        <param name="settings">Параметры нового экземпляра <see cref="T:System.Xml.XmlReader" />. Это значение может быть равно <see langword="null" />.</param>
        <param name="baseUri">Базовый URI считываемой сущности или документа. Это значение может быть равно <see langword="null" />.  
  
 **Примечание по безопасности.** Базовый универсальный код ресурса (URI) используется для разрешения относительного URI XML-документа. Не используйте базовый URI из непроверенного источника.</param>
        <summary>Создает новый экземпляр <see cref="T:System.Xml.XmlReader" /> с использованием указанного потока, базового URI и параметров.</summary>
        <returns>Объект, используемый для чтения данных XML в потоке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Xml.XmlUrlResolver> без учетных данных используется для доступа ко всем внешним ресурсам, таким как определение типа документа (DTD), сущности, схемы и т. д.  
  
> [!IMPORTANT]
>  Начиная с .NET Framework 4.5.2, <xref:System.Xml.XmlUrlResolver> по умолчанию не предоставляется. Если решение предназначено для .NET Framework 4.5.2 или более поздних версий, укажите <xref:System.Xml.XmlResolver> с помощью свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Если внешний ресурс находится в сетевом ресурсе, требующем проверки подлинности, используйте свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>, чтобы указать <xref:System.Xml.XmlResolver> с необходимыми учетными данными.  
  
> [!IMPORTANT]
>  Для управления ресурсами, к которым <xref:System.Xml.XmlReader> может быть доступ, можно использовать один из следующих методов.  
>   
>  -   Ограничить ресурсы, к которым имеет доступ <xref:System.Xml.XmlReader>, установив в качестве значения свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> объект <xref:System.Xml.XmlSecureResolver>.  
>   
>  - или -  
>   
>  -   Не разрешать <xref:System.Xml.XmlReader> открывать какие-либо внешние ресурсы, установив для свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> значение `null`.  
  
 Созданный объект <xref:System.Xml.XmlReader> расширяет ссылки на сущности и выполняет нормализацию XML символов новой строки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="input" /> равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Поток, содержащий XML-данные.  
  
<see cref="T:System.Xml.XmlReader" /> просматривает первые байты потока в поисках метки порядка следования байтов или другого признака кодировки. Эта кодировка после определения используется в последующем считывании потока, а процедура обработки продолжает анализировать входные данные как поток символов Юникода.</param>
        <param name="settings">Параметры нового экземпляра <see cref="T:System.Xml.XmlReader" />. Это значение может быть равно <see langword="null" />.</param>
        <param name="inputContext">Для синтаксического анализа фрагмента XML необходимы контекстные сведения. Контекстные сведения могут содержать используемый класс <see cref="T:System.Xml.XmlNameTable" />, кодировку, область пространства имен, текущие области <c>xml:lang</c> и <c>xml:space</c>, базовый код URI и определение типа документа.  
  
Это значение может быть равно <see langword="null" />.</param>
        <summary>Создает новый экземпляр <see cref="T:System.Xml.XmlReader" />, используя заданный поток, параметры и контекстную информацию для анализа.</summary>
        <returns>Объект, используемый для чтения данных XML в потоке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Xml.XmlUrlResolver> без учетных данных используется для доступа ко всем внешним ресурсам, таким как определение типа документа (DTD), сущности, схемы и т. д.  
  
> [!IMPORTANT]
>  Начиная с .NET Framework 4.5.2, <xref:System.Xml.XmlUrlResolver> по умолчанию не предоставляется. Если решение предназначено для .NET Framework 4.5.2 или более поздних версий, укажите <xref:System.Xml.XmlResolver> с помощью свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Если внешний ресурс находится в сетевом ресурсе, требующем проверки подлинности, используйте свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>, чтобы указать <xref:System.Xml.XmlResolver> с необходимыми учетными данными.  
  
> [!IMPORTANT]
>  Для управления ресурсами, к которым <xref:System.Xml.XmlReader> может быть доступ, можно использовать один из следующих методов.  
>   
>  -   Ограничить ресурсы, к которым имеет доступ <xref:System.Xml.XmlReader>, установив в качестве значения свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> объект <xref:System.Xml.XmlSecureResolver>.  
>   
>  - или -  
>   
>  -   Не разрешать <xref:System.Xml.XmlReader> открывать какие-либо внешние ресурсы, установив для свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> значение `null`.  
  
 Созданный объект <xref:System.Xml.XmlReader> расширяет ссылки на сущности и выполняет нормализацию XML символов новой строки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="input" /> равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="baseUri" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="input">Средство считывания текста, из которого следует считывать данные XML. Средство считывания текста возвращает поток символов Юникода, и указанная в объявлении XML кодировка не используется <see cref="T:System.Xml.XmlReader" /> для декодирования потока данных.</param>
        <param name="settings">Параметры нового экземпляра <see cref="T:System.Xml.XmlReader" />. Это значение может быть равно <see langword="null" />.</param>
        <param name="baseUri">Базовый URI считываемой сущности или документа. Это значение может быть равно <see langword="null" />.  
  
 **Примечание по безопасности.** Базовый универсальный код ресурса (URI) используется для разрешения относительного URI XML-документа. Не используйте базовый URI из непроверенного источника.</param>
        <summary>Создает экземпляр <see cref="T:System.Xml.XmlReader" /> с использованием указанного средства чтения текста, параметров и базового кода URI.</summary>
        <returns>Объект, используемый для чтения данных XML в потоке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Xml.XmlUrlResolver> без учетных данных используется для доступа ко всем внешним ресурсам, таким как определение типа документа (DTD), сущности, схемы и т. д.  
  
> [!IMPORTANT]
>  Начиная с .NET Framework 4.5.2, <xref:System.Xml.XmlUrlResolver> по умолчанию не предоставляется. Если решение предназначено для .NET Framework 4.5.2 или более поздних версий, укажите <xref:System.Xml.XmlResolver> с помощью свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Если внешний ресурс находится в сетевом ресурсе, требующем проверки подлинности, используйте свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>, чтобы указать <xref:System.Xml.XmlResolver> с необходимыми учетными данными.  
  
> [!IMPORTANT]
>  Для управления ресурсами, к которым <xref:System.Xml.XmlReader> может быть доступ, можно использовать один из следующих методов.  
>   
>  -   Ограничить ресурсы, к которым имеет доступ <xref:System.Xml.XmlReader>, установив в качестве значения свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> объект <xref:System.Xml.XmlSecureResolver>.  
>   
>  - или -  
>   
>  -   Не разрешать <xref:System.Xml.XmlReader> открывать какие-либо внешние ресурсы, установив для свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> значение `null`.  
  
 Созданный объект <xref:System.Xml.XmlReader> расширяет ссылки на сущности и выполняет нормализацию XML символов новой строки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="input" /> равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Средство считывания текста, из которого следует считывать данные XML. Средство считывания текста возвращает поток символов Юникода, и указанная в объявлении XML кодировка не используется средством считывания XML для раскодирования потока данных.</param>
        <param name="settings">Параметры нового экземпляра <see cref="T:System.Xml.XmlReader" />. Это значение может быть равно <see langword="null" />.</param>
        <param name="inputContext">Для синтаксического анализа фрагмента XML необходимы контекстные сведения. Контекстные сведения могут содержать используемый класс <see cref="T:System.Xml.XmlNameTable" />, кодировку, область пространства имен, текущие области <c>xml:lang</c> и <c>xml:space</c>, базовый код URI и определение типа документа.  
  
Это значение может быть равно <see langword="null" />.</param>
        <summary>Создает новый экземпляр <see cref="T:System.Xml.XmlReader" /> с использованием указанного средства чтения текста, параметров и сведений о контексте для анализа.</summary>
        <returns>Объект, используемый для чтения данных XML в потоке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Xml.XmlUrlResolver> без учетных данных используется для доступа ко всем внешним ресурсам, таким как определение типа документа (DTD), сущности, схемы и т. д.  
  
> [!IMPORTANT]
>  Начиная с .NET Framework 4.5.2, <xref:System.Xml.XmlUrlResolver> по умолчанию не предоставляется. Если решение предназначено для .NET Framework 4.5.2 или более поздних версий, укажите <xref:System.Xml.XmlResolver> с помощью свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Если внешний ресурс находится в сетевом ресурсе, требующем проверки подлинности, используйте свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>, чтобы указать <xref:System.Xml.XmlResolver> с необходимыми учетными данными.  
  
> [!IMPORTANT]
>  Для управления ресурсами, к которым <xref:System.Xml.XmlReader> может быть доступ, можно использовать один из следующих методов.  
>   
>  -   Ограничить ресурсы, к которым имеет доступ <xref:System.Xml.XmlReader>, установив в качестве значения свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> объект <xref:System.Xml.XmlSecureResolver>.  
>   
>  - или -  
>   
>  -   Не разрешать <xref:System.Xml.XmlReader> открывать какие-либо внешние ресурсы, установив для свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> значение `null`.  
  
 Созданный объект <xref:System.Xml.XmlReader> расширяет ссылки на сущности и выполняет нормализацию XML символов новой строки.  
  
   
  
## Examples  
 В следующем примере создается объект <xref:System.Xml.XmlReader>, который считывает фрагмент XML.  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="input" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значения присвоены как свойству <see cref="P:System.Xml.XmlReaderSettings.NameTable" />, так и свойству <see cref="P:System.Xml.XmlParserContext.NameTable" />. (Только для одного из этих свойств <see langword="NameTable" /> можно задать значение и использовать это свойство).</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inputUri">URI файла с XML-данными. Объект <see cref="T:System.Xml.XmlResolver" /> в объекте <see cref="T:System.Xml.XmlReaderSettings" /> используется для преобразования пути в каноническое представление данных. Если <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> равно <see langword="null" />, используется новый объект <see cref="T:System.Xml.XmlUrlResolver" />.</param>
        <param name="settings">Параметры нового экземпляра <see cref="T:System.Xml.XmlReader" />. Это значение может быть равно <see langword="null" />.</param>
        <param name="inputContext">Для синтаксического анализа фрагмента XML необходимы контекстные сведения. Контекстные сведения могут содержать используемый класс <see cref="T:System.Xml.XmlNameTable" />, кодировку, область пространства имен, текущие области <c>xml:lang</c> и <c>xml:space</c>, базовый код URI и определение типа документа.  
  
Это значение может быть равно <see langword="null" />.</param>
        <summary>Создает новый экземпляр <see cref="T:System.Xml.XmlReader" /> с помощью указанного URI, параметров и сведений о контексте для анализа.</summary>
        <returns>Объект, используемый для чтения данных XML в потоке.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Xml.XmlUrlResolver> без учетных данных используется для доступа ко всем внешним ресурсам, таким как определение типа документа (DTD), сущности, схемы и т. д.  
  
> [!IMPORTANT]
>  Начиная с .NET Framework 4.5.2, <xref:System.Xml.XmlUrlResolver> по умолчанию не предоставляется. Если решение предназначено для .NET Framework 4.5.2 или более поздних версий, укажите <xref:System.Xml.XmlResolver> с помощью свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>.  
  
 Это означает, что <xref:System.Xml.XmlReader> может получить доступ к любому расположению, которое не требует проверки подлинности. Если внешний ресурс находится в сетевом ресурсе, требующем проверки подлинности, используйте свойство <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>, чтобы указать <xref:System.Xml.XmlResolver> с необходимыми учетными данными.  
  
> [!IMPORTANT]
>  Можно ограничить ресурсы, к которым может получить доступ <xref:System.Xml.XmlReader>, задав для свойства <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> объект <xref:System.Xml.XmlSecureResolver>.  
  
 Созданный объект <xref:System.Xml.XmlReader> расширяет ссылки на сущности и выполняет нормализацию XML символов новой строки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <see langword="inputUri" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Тип <see cref="T:System.Xml.XmlReader" /> не имеет достаточных разрешений для доступа к расположению XML-данных.</exception>
        <exception cref="T:System.ArgumentException">Значения присвоены как свойству <see cref="P:System.Xml.XmlReaderSettings.NameTable" />, так и свойству <see cref="P:System.Xml.XmlParserContext.NameTable" />. (Только для одного из этих свойств <see langword="NameTable" /> можно задать значение и использовать это свойство).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти файл, заданный с помощью URI.</exception>
        <exception cref="T:System.UriFormatException">Неправильный формат URI.</exception>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public abstract int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Xml.XmlReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает глубину текущего узла в XML-документе.</summary>
        <value>Глубина текущего узла в XML-документе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Пример использования этого свойства см. в разделе <xref:System.Xml.XmlTextReader.Depth%2A> (в классе `XmlTextReader`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Освобождение ресурсов, используемых классом <see cref="T:System.Xml.XmlReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="xmlReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="xmlReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.Xml.XmlReader" />, а при необходимости освобождает также управляемые ресурсы.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public abstract bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool EOF { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EOF : bool" Usage="System.Xml.XmlReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Когда переопределено в производном классе, возвращает значение, показывающее, позиционировано ли средство чтения в конец потока.</summary>
        <value>Значение <see langword="true" />, если средство чтения установлено в конец потока; в противном случае — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>При переопределении в производном классе получает значение атрибута.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : int -&gt; string" Usage="xmlReader.GetAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Индекс атрибута. Индексация начинается с нуля. (Индекс первого атрибута равен нулю.)</param>
        <summary>При переопределении в производном классе получает значение атрибута по указанному индексу.</summary>
        <returns>Значение указанного атрибута. Этот метод не изменяет позицию средства чтения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере возвращается значение третьего атрибута.  
  
 [!code-csharp[XmlReaderBasic#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#2)]
 [!code-vb[XmlReaderBasic#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="i" /> выходит за пределы диапазона. Оно должно быть неотрицательным и меньшим, чем размер коллекции атрибутов.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string -&gt; string" Usage="xmlReader.GetAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Полное имя атрибута.</param>
        <summary>При переопределении в производном классе получает значение атрибута с указанным свойством <see cref="P:System.Xml.XmlReader.Name" />.</summary>
        <returns>Значение указанного атрибута. Если атрибут не найден или значение равно <see langword="String.Empty" />, возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не изменяет позицию средства чтения.  
  
 Если средство чтения находится на `DocumentType` узле, этот метод можно использовать для получения открытых и СИСТЕМНЫХ литералов, например `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 В следующем примере возвращается значение атрибута ISBN.  
  
 [!code-csharp[XmlReaderBasic#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#3)]
 [!code-vb[XmlReaderBasic#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string * string -&gt; string" Usage="xmlReader.GetAttribute (name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Локальное имя атрибута.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен атрибута.</param>
        <summary>При переопределении в производном классе получает значение атрибута с указанными свойствами <see cref="P:System.Xml.XmlReader.LocalName" /> и <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</summary>
        <returns>Значение указанного атрибута. Если атрибут не найден или значение равно <see langword="String.Empty" />, возвращается значение <see langword="null" />. Этот метод не изменяет позицию средства чтения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следующий XML-код содержит атрибут в определенном пространстве имен:  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Можно выполнить поиск `dt:type` атрибута, используя один аргумент (префикс и локальное имя) или два аргумента (локальное имя и URI пространства имен):  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 Чтобы найти `xmlns:dt` атрибут, используйте один из следующих аргументов:  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 Эти сведения также можно получить с помощью свойства <xref:System.Xml.XmlReader.Prefix%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; GetValueAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; GetValueAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetValueAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ GetValueAsync();" />
      <MemberSignature Language="F#" Value="abstract member GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.GetValueAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно получает значение текущего узла.</summary>
        <returns>Значение текущего узла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public virtual bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasAttributes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasAttributes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAttributes : bool" Usage="System.Xml.XmlReader.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, имеются ли атрибуты у текущего узла.</summary>
        <value>Значение <see langword="true" />, если текущий узел содержит атрибуты; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере отображаются все атрибуты текущего узла.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public virtual bool HasValue { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasValue As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.HasValue : bool" Usage="System.Xml.XmlReader.HasValue" />
      <MemberSignature Language="C#" Value="public abstract bool HasValue { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property HasValue As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool HasValue { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, показывающее, имеет ли текущий узел свойство <see cref="P:System.Xml.XmlReader.Value" />.</summary>
        <value>Значение <see langword="true" />, если узел, на котором расположено средство чтения, может иметь значение <see langword="Value" />; в противном случае — <see langword="false" />. Если значение равно <see langword="false" />, узел принимает значение <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице представлен список возвращаемых типов узлов со значениями.  
  
|Тип узла|Значение|  
|---------------|-----------|  
|`Attribute`|Значение атрибута.|  
|`CDATA`|Содержимое раздела CDATA.|  
|`Comment`|Содержимое комментария.|  
|`DocumentType`|Внутреннее подмножество.|  
|`ProcessingInstruction`|Все содержимое, за исключением цели.|  
|`SignificantWhitespace`|Пустое пространство в разметке модели со смешанным содержимым.|  
|`Text`|Содержимое текстового узла.|  
|`Whitespace`|Пробелы между разметкой.|  
|`XmlDeclaration`|Содержимое декларации.|  
  
   
  
## Examples  
 Пример использования этого метода см. в разделе <xref:System.Xml.XmlTextReader.HasValue%2A> (в классе `XmlTextReader`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public virtual bool IsDefault { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDefault As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool" Usage="System.Xml.XmlReader.IsDefault" />
      <MemberSignature Language="C#" Value="public abstract bool IsDefault { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsDefault As Boolean" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsDefault { bool get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Когда переопределено в производном классе, возвращает значение, определяющее, является ли текущий узел атрибутом, созданным из значения по умолчанию, определенного в DTD или схеме.</summary>
        <value>Значение <see langword="true" />, если текущий узел является атрибутом, значение которого было создано из значения по умолчанию, определенного в DTD или схеме; значение <see langword="false" />, если значение атрибута было задано явно.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsDefault` всегда возвращает `false` для реализаций `XmlReader`, которые не поддерживают схему или сведения о DTD. Это свойство применяется только к узлу атрибута.  
  
   
  
## Examples  
 В следующем примере отображаются все атрибуты в корневом элементе.  
  
```csharp  
using System;  
using System.IO;  
using System.Xml;  
  
public class Sample   
{  
  public static void Main(){  
  
    // Create the reader.  
    XmlReader reader = XmlReader.Create("book4.xml");  
  
    reader.MoveToContent();  
  
    // Display each of the attribute nodes, including default attributes.  
    while (reader.MoveToNextAttribute()){  
        if (reader.IsDefault)  
          Console.Write("(default attribute) ");  
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);    
    }             
  
    //Close the reader.  
    reader.Close();       
  
  }  
} // End class  
```  
  
 В этом примере в качестве входных данных используются следующие файлы.  
  
 `book4.xml`  
  
```xml  
<!DOCTYPE book SYSTEM 'book.dtd'>  
<book ISBN = '1-861001-57-5'>  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
</book>  
```  
  
 `book.dtd`  
  
```  
<!ELEMENT book (title,price)>   
<!ATTLIST book   
   genre CDATA "novel"  
   ISBN CDATA #REQUIRED>  
<!ELEMENT title (#PCDATA)>  
<!ELEMENT price (#PCDATA)>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public abstract bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsEmptyElement { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmptyElement : bool" Usage="System.Xml.XmlReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает значение, указывающее, является ли текущий узел пустым элементом (например, <c>&lt;MyElement/&gt;</c>).</summary>
        <value><see langword="true" />, если текущий узел является элементом (<see cref="P:System.Xml.XmlReader.NodeType" /> равно <see langword="XmlNodeType.Element" />), который заканчивается <c>/&gt;</c>; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство позволяет определить разницу между:  
  
 `<item num="123"/>` (`IsEmptyElement` `true`).  
  
 `<item num="123"></item>` (`IsEmptyElement` `false`, хотя содержимое элемента пусто).  
  
 Для пустых элементов не создается соответствующий узел `EndElement`.  
  
 Если содержимое по умолчанию было добавлено в элемент из-за проверки схемы, `IsEmptyElement` по-прежнему возвращает `true`. Он не влияет на то, имеет ли элемент значение по умолчанию. Иными словами, `IsEmptyElement` просто сообщает, содержит ли элемент в исходном документе тег конечного элемента.  
  
   
  
## Examples  
 В следующем примере выводится текстовое содержимое каждого элемента.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 В этом примере в качестве входных данных используется файл `elems.xml`.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="IsName">
      <MemberSignature Language="C#" Value="public static bool IsName (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsName(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsName (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsName(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsName : string -&gt; bool" Usage="System.Xml.XmlReader.IsName str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Имя для проверки.</param>
        <summary>Возвращает значение, определяющее, является ли строковый аргумент допустимым именем XML.</summary>
        <returns>Значение <see langword="true" />, если имя является допустимым; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [рекомендацию консорциума W3C по XML 1,0](https://go.microsoft.com/fwlink/?LinkId=49863) , чтобы определить, является ли имя допустимым.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="str" /> равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNameToken">
      <MemberSignature Language="C#" Value="public static bool IsNameToken (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNameToken(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsNameToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNameToken (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNameToken(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsNameToken : string -&gt; bool" Usage="System.Xml.XmlReader.IsNameToken str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Лексема имени для проверки.</param>
        <summary>Возвращает значение, определяющее, является ли строковый аргумент допустимым токеном имени XML.</summary>
        <returns>Значение <see langword="true" />, если аргумент является допустимой лексемой имени; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [рекомендацию консорциума W3C по XML 1,0](https://go.microsoft.com/fwlink/?LinkId=49863) , чтобы определить, является ли маркер имени допустимым.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="str" /> равно <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Проверяет, является ли текущий узел содержимого открывающим тегом.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement();" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : unit -&gt; bool&#xA;override this.IsStartElement : unit -&gt; bool" Usage="xmlReader.IsStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает метод <see cref="M:System.Xml.XmlReader.MoveToContent" /> и проверяет, является ли текущий узел содержимого открывающим тегом или пустым тегом элемента.</summary>
        <returns>Значение <see langword="true" />, если метод <see cref="M:System.Xml.XmlReader.MoveToContent" /> находит открывающий тег или пустой тег элемента; значение <see langword="false" />, если тип найденного узла отличается от <see langword="XmlNodeType.Element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод пропускает пробелы, комментарии и инструкции по обработке, пока модуль чтения не будет размещен на узле содержимого. Затем метод проверяет, является ли текущий узел элементом.  
  
   
  
## Examples  
 В следующем примере выводится текстовое содержимое каждого элемента.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 В этом примере в качестве входных данных используется файл `elems.xml`.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Во входном потоке обнаружен неправильный XML-код.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string -&gt; bool&#xA;override this.IsStartElement : string -&gt; bool" Usage="xmlReader.IsStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Строка противопоставляется значению свойства <see langword="Name" /> найденного элемента.</param>
        <summary>Вызывает метод <see cref="M:System.Xml.XmlReader.MoveToContent" /> и проверяет, является ли текущий узел содержимого открывающим тегом или пустым тегом элемента, а также соответствует ли значение свойства <see cref="P:System.Xml.XmlReader.Name" /> элемента заданному аргументу.</summary>
        <returns>Значение <see langword="true" />, если полученный в результате узел является элементом, а свойство <see langword="Name" /> совпадает с указанной строкой. Значение <see langword="false" />, если обнаружен узел с типом, отличным от <see langword="XmlNodeType.Element" />, или если свойство <see langword="Name" /> элемента не совпадает с указанной строкой.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод пропускает пробелы, комментарии и инструкции по обработке, пока модуль чтения не будет размещен на узле содержимого. Затем метод проверяет, является ли текущий узел элементом.  
  
   
  
## Examples  
 В следующем примере отображается каждый элемент price.  
  
 [!code-csharp[XmlReaderBasic#17](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#17)]
 [!code-vb[XmlReaderBasic#17](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Во входном потоке обнаружен неправильный XML-код.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (localname As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string * string -&gt; bool&#xA;override this.IsStartElement : string * string -&gt; bool" Usage="xmlReader.IsStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Строка, которая противопоставляется значению свойства <see langword="LocalName" /> найденного элемента.</param>
        <param name="ns">Строка, которая противопоставляется значению свойства <see langword="NamespaceURI" /> найденного элемента.</param>
        <summary>Вызывает метод <see cref="M:System.Xml.XmlReader.MoveToContent" /> и проверяет, является ли текущий узел содержимого открывающим тегом или пустым тегом элемента, а также соответствуют ли значения свойств <see cref="P:System.Xml.XmlReader.LocalName" /> и <see cref="P:System.Xml.XmlReader.NamespaceURI" /> элемента заданным строкам.</summary>
        <returns>Значение <see langword="true" />, если полученный в результате узел является элементом. Значение <see langword="false" />, если обнаружен узел с типом, отличным от <see langword="XmlNodeType.Element" />, или если свойства <see langword="LocalName" /> и <see langword="NamespaceURI" /> элемента не совпадают с указанными строками.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод пропускает пробелы, комментарии и инструкции по обработке, пока модуль чтения не будет размещен на узле содержимого. Затем метод проверяет, является ли текущий узел элементом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Во входном потоке обнаружен неправильный XML-код.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>При переопределении в производном классе получает значение атрибута.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[int i] { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(i As Integer) As String" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[int] { System::String ^ get(int i); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Item(int) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberSignature Language="C#" Value="public abstract string this[int i] { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride ReadOnly Property Item(i As Integer) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ default[int] { System::String ^ get(int i); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Индекс атрибута.</param>
        <summary>Когда переопределено в производном классе, возвращает значение атрибута по указанному индексу.</summary>
        <value>Значение указанного атрибута.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство не перемещает средство чтения.  
  
   
  
## Examples  
 В следующем примере отображаются все атрибуты текущего узла.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name] { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String) As String" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ name); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberSignature Language="C#" Value="public abstract string this[string name] { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride ReadOnly Property Item(name As String) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ name); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Полное имя атрибута.</param>
        <summary>При переопределении в производном классе получает значение атрибута с указанным свойством <see cref="P:System.Xml.XmlReader.Name" />.</summary>
        <value>Значение указанного атрибута. Если атрибут не найден, возвращается значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство не перемещает средство чтения.  
  
 Если средство чтения находится на `DocumentType` узле, этот метод можно использовать для получения открытых и СИСТЕМНЫХ литералов, например `reader["PUBLIC"]`  
  
   
  
## Examples  
 В следующем примере возвращается значение атрибута ISBN.  
  
 [!code-csharp[XmlReaderBasic#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#7)]
 [!code-vb[XmlReaderBasic#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name, string namespaceURI] { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String, namespaceURI As String) As String" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberSignature Language="C#" Value="public abstract string this[string name, string namespaceURI] { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride ReadOnly Property Item(name As String, namespaceURI As String) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Локальное имя атрибута.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен атрибута.</param>
        <summary>При переопределении в производном классе получает значение атрибута с указанными свойствами <see cref="P:System.Xml.XmlReader.LocalName" /> и <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</summary>
        <value>Значение указанного атрибута. Если атрибут не найден, возвращается значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство не перемещает средство чтения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает локальное имя текущего узла.</summary>
        <value>Имя текущего узла с удаленным префиксом. Например, <see langword="LocalName" /> <see langword="book" /> для элемента <c>&lt;BK: book&gt;</c>.  
  
Для безымянных типов узлов (например, <see langword="Text" />, <see langword="Comment" /> и т. д.) данное свойство возвращает <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере отображается локальное имя каждого узла и, если они существуют, префикс и URI пространства имен.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 В качестве входных данных в примере используется файл book2. XML.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="P:System.Xml.XmlReader.Name" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public abstract string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member LookupNamespace : string -&gt; string" Usage="xmlReader.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Префикс, для которого требуется разрешить URI пространства имен. Чтобы сопоставить пространство имен по умолчанию, необходимо передать пустую строку.</param>
        <summary>При переопределении в производном классе разрешает префикс пространства имен в ограниченной области действия текущего элемента.</summary>
        <returns>URI пространства имен, которое отображает префикс, или значение <see langword="null" />, если соответствующий префикс не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей XML-строке, если модуль чтения расположен на атрибуте `href`, префикс `a` разрешается путем вызова `reader.LookupNamespace("a")`. Возвращаемая строка — `urn:456`.  
  
```xml  
<root xmlns:a="urn:456">  
  <item>  
  <ref href="a:b"/>  
  </item>  
 </root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>При переопределении в производном классе перемещает к указанному атрибуту.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public virtual void MoveToAttribute (int i);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MoveToAttribute (i As Integer)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveToAttribute(int i);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : int -&gt; unit&#xA;override this.MoveToAttribute : int -&gt; unit" Usage="xmlReader.MoveToAttribute i" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public abstract void MoveToAttribute (int i);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub MoveToAttribute (i As Integer)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void MoveToAttribute(int i);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : int -&gt; unit" Usage="xmlReader.MoveToAttribute i" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Индекс атрибута.</param>
        <summary>Когда переопределено в производном классе, переходит к атрибуту с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере отображаются все атрибуты текущего узла.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр имеет отрицательное значение.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string -&gt; bool" Usage="xmlReader.MoveToAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Полное имя атрибута.</param>
        <summary>При переопределении в производном классе перемещает к атрибуту с указанным <see cref="P:System.Xml.XmlReader.Name" />.</summary>
        <returns>Значение <see langword="true" />, если атрибут найден; в противном случае — <see langword="false" />. Если значение <see langword="false" />, позиция средства чтения не изменяется.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После вызова `MoveToAttribute`свойства <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>и <xref:System.Xml.XmlReader.Prefix%2A> соответствуют свойствам этого атрибута.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentException">Параметр является пустой строкой.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string * string -&gt; bool" Usage="xmlReader.MoveToAttribute (name, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Локальное имя атрибута.</param>
        <param name="ns">Универсальный код ресурса (URI) пространства имен атрибута.</param>
        <summary>При переопределении в производном классе перемещает к атрибуту с указанными <see cref="P:System.Xml.XmlReader.LocalName" /> и <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</summary>
        <returns>Значение <see langword="true" />, если атрибут найден; в противном случае — <see langword="false" />. Если значение <see langword="false" />, позиция средства чтения не изменяется.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После вызова `MoveToAttribute`свойства <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>и <xref:System.Xml.XmlReader.Prefix%2A> соответствуют свойствам этого атрибута.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentNullException">Оба параметра имеют значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContent">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeType MoveToContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Xml.XmlNodeType MoveToContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContent () As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeType MoveToContent();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContent : unit -&gt; System.Xml.XmlNodeType&#xA;override this.MoveToContent : unit -&gt; System.Xml.XmlNodeType" Usage="xmlReader.MoveToContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Проверяет, является ли текущий узел узлом содержимого (текст без пустого пространства, <see langword="CDATA" />, <see langword="Element" />, <see langword="EndElement" />, <see langword="EntityReference" /> или <see langword="EndEntity" />). Если узел не является узлом содержимого, средство чтения пропускает этот узел и переходит к следующему узлу содержимого или в конец файла. Пропускаются узлы следующих типов: <see langword="ProcessingInstruction" />, <see langword="DocumentType" />, <see langword="Comment" />, <see langword="Whitespace" /> и <see langword="SignificantWhitespace" />.</summary>
        <returns>Значение <see cref="P:System.Xml.XmlReader.NodeType" /> для текущего узла, найденного с помощью метода, или значение <see langword="XmlNodeType.None" />, если средство чтения достигло конца потока входных данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий узел является узлом атрибута, этот метод перемещает модуль чтения обратно в элемент, владеющий атрибутом.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.MoveToContentAsync%2A>.  
  
   
  
## Examples  
 Это полезно, если требуется написать код, который может пропускать случайную XML-разметку без нарушения. Например, предположим, что у вас есть следующий код:  
  
 [!code-cpp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/VB/source.vb#1)]  
  
 Этот код может выполнять следующие входы без нарушения:  
  
```xml  
<price>123.4</price>  
```  
  
 and  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM  
  "abc"><price>123.4</price>  
```  
  
 and  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM "abc"  
  [<!ENTITY p  
  "123.4">]><price>&p;</price>  
```  
  
 and  
  
```xml  
<!-- some test comment --><?processing  
  instruction?><price>123.4</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">В входном потоке обнаружен неправильный XML.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt; MoveToContentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;valuetype System.Xml.XmlNodeType&gt; MoveToContentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContentAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContentAsync () As Task(Of XmlNodeType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Xml::XmlNodeType&gt; ^ MoveToContentAsync();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;&#xA;override this.MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;" Usage="xmlReader.MoveToContentAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>В асинхронном режиме проверяет, является ли текущий узел узлом содержимого. Если узел не является узлом содержимого, средство чтения пропускает этот узел и переходит к следующему узлу содержимого или в конец файла.</summary>
        <returns>Значение <see cref="P:System.Xml.XmlReader.NodeType" /> для текущего узла, найденного с помощью метода, или значение <see langword="XmlNodeType.None" />, если средство чтения достигло конца потока входных данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.MoveToContent%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public abstract bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToElement();" />
      <MemberSignature Language="F#" Value="abstract member MoveToElement : unit -&gt; bool" Usage="xmlReader.MoveToElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Когда переопределено в производном классе, переходит к элементу, содержащему текущий узел атрибута.</summary>
        <returns>Значение <see langword="true" />, если средство чтения находится на атрибуте (средство чтения перемещается к элементу с этим атрибутом); в противном случае — <see langword="false" /> (позиция средства чтения не изменяется).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы вернуться к элементу после перехода по его атрибутам. Этот метод перемещает модуль чтения на один из следующих типов узлов: `Element`, `DocumentType`или `XmlDeclaration`.  
  
   
  
## Examples  
 В следующем примере отображаются все атрибуты текущего узла.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToFirstAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToFirstAttribute : unit -&gt; bool" Usage="xmlReader.MoveToFirstAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Когда переопределено в производном классе, переходит к первому атрибуту.</summary>
        <returns>Значение <see langword="true" />, если атрибут существует (средство чтения перемещается к первому атрибуту); в противном случае — <see langword="false" /> (позиция средства чтения не изменяется).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере возвращается значение первого атрибута.  
  
 [!code-csharp[XmlReaderBasic#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#5)]
 [!code-vb[XmlReaderBasic#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToNextAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToNextAttribute : unit -&gt; bool" Usage="xmlReader.MoveToNextAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Когда переопределено в производном классе, переходит к следующему атрибуту.</summary>
        <returns>Значение <see langword="true" />, если присутствует следующий атрибут; значение <see langword="false" />, если другие атрибуты отсутствуют.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий узел является узлом элемента, этот метод эквивалентен <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>. Если `MoveToNextAttribute` возвращает `true`, средство чтения перемещается к следующему атрибуту. в противном случае расположение модуля чтения не изменяется.  
  
   
  
## Examples  
 В следующем примере отображаются все атрибуты текущего узла.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlReader.Name" />
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Когда переопределено в производном классе, возвращает полное имя текущего узла.</summary>
        <value>Полное имя текущего узла. Например, <see langword="Name" /> <see langword="bk:book" /> для элемента <c>&lt;BK: book&gt;</c>.  
  
Возвращаемое имя зависит от значения свойства <see cref="P:System.Xml.XmlReader.NodeType" /> узла. Значения возвращаются для представленных ниже типов узлов. Для других типов узлов возвращается пустая строка.  
  
 <list type="table"><listheader><term> Тип узла 
 </term><description> name 
 </description></listheader><item><term><see langword="Attribute" /></term><description> Имя атрибута.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Имя типа документа.  
  
 </description></item><item><term><see langword="Element" /></term><description> Имя тега.  
  
 </description></item><item><term><see langword="EntityReference" /></term><description> Имя сущности, на которую существует ссылка.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Цель инструкции по обработке.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Строка символов <see langword="xml" />.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере считывается XML-файл и отображается каждый из узлов.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 В примере используется файл `items.xml`.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="P:System.Xml.XmlReader.LocalName" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public abstract string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает URI пространства имен (определенное в спецификации W3C Namespace) узла, на котором расположено средство чтения.</summary>
        <value>URI пространства имен текущего узла; в противном случае — пустая строка.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство относится только к `Element` и `Attribute` узлам.  
  
   
  
## Examples  
 В следующем примере отображается локальное имя каждого узла и, если они существуют, префикс и URI пространства имен.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 В качестве входных данных в примере используется файл book2. XML.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает класс <see cref="T:System.Xml.XmlNameTable" />, связанный с данной реализацией.</summary>
        <value><see langword="XmlNameTable" />, позволяющий получать в узле разделенную версию строки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все имена узлов и атрибутов, возвращаемые из <xref:System.Xml.XmlReader>, размещаются с помощью `NameTable`. Если одно и то же имя возвращается несколько раз (например, `Customer`), то для этого имени будет возвращен тот же `String` объект. Это позволяет написать эффективный код, выполняющий сравнения объектов в этих строках вместо дорогостоящих сравнений строк.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Когда переопределено в производном классе, возвращает тип текущего узла.</summary>
        <value>Одно из значений перечисления, задающее тип текущего узла.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере считывается XML-файл и отображается каждый из узлов.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 В примере используется файл `items.xml`.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public abstract string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string" Usage="System.Xml.XmlReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Когда переопределено в производном классе, возвращает префикс пространства имен, связанный с текущим узлом.</summary>
        <value>Префикс пространства имен, связанный с текущим узлом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере отображается локальное имя каждого узла и, если они существуют, префикс и URI пространства имен.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 В качестве входных данных в примере используется файл book2. XML.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public virtual char QuoteChar { get; }" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property QuoteChar As Char" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.QuoteChar : char" Usage="System.Xml.XmlReader.QuoteChar" />
      <MemberSignature Language="C#" Value="public abstract char QuoteChar { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property QuoteChar As Char" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property char QuoteChar { char get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает знак кавычек для выделения значения узла атрибута.</summary>
        <value>Знак кавычек (" или ') для выделения значения узла атрибута.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство применяется только к узлу атрибута.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Read();" />
      <MemberSignature Language="F#" Value="abstract member Read : unit -&gt; bool" Usage="xmlReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Когда переопределено в производном классе, считывает из потока следующий узел.</summary>
        <returns><see langword="true" />, если считывание узла прошло успешно. В противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При первоначальном создании и инициализации <xref:System.Xml.XmlReader> сведения недоступны. Для чтения первого узла необходимо вызвать <xref:System.Xml.XmlReader.Read%2A>. Метод <xref:System.Xml.XmlReader.Read%2A> задает состояние запуска модуля чтения XML <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType> и последовательно перемещает XML-файл, пока не достигнет конца файла, после чего метод возвращает значение `false`.  
  
 Для начала синтаксического анализа этому методу требуется по крайней мере четыре байта из потока данных. Если возвращается менее четырех байтов и в потоке больше нет данных, метод возвращает `false`. Если в потоке больше данных, метод будет блокировать анализ до получения четвертого байта.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadAsync%2A>.  
  
   
  
## Examples  
 В следующем примере считывается XML-файл и отображаются все узлы:
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 В примере используется файл `items.xml`.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 **Выходные данные:**  

 [!INCLUDE [xmlreader-read-sample-output](~/includes/xmlreader-read-sample-output.md)] 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Произошла ошибка при синтаксическом анализе XML.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; ReadAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; ReadAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync () As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;bool&gt; ^ ReadAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;&#xA;override this.ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="xmlReader.ReadAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно считывает следующий узел из потока.</summary>
        <returns>Значение <see langword="true" />, если чтение прошло успешно; значение <see langword="false" />, если отсутствуют узлы для чтения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.Read%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public abstract bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ReadAttributeValue();" />
      <MemberSignature Language="F#" Value="abstract member ReadAttributeValue : unit -&gt; bool" Usage="xmlReader.ReadAttributeValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе разбирает значение атрибута в один или более узлов <see langword="Text" />, <see langword="EntityReference" /> или <see langword="EndEntity" />.</summary>
        <returns>Значение <see langword="true" />, если присутствуют возвращаемые узлы.  
  
 Значение <see langword="false" />, если средство чтения не расположено на узле атрибута при первом вызове или все значения атрибута считаны.  
  
Пустой атрибут (например, <c>misc=""</c>) возвращает значение <see langword="true" /> с отдельным узлом, имеющим значение <see langword="String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод после вызова <xref:System.Xml.XmlReader.MoveToAttribute%2A>, чтобы прочесть текст или узлы ссылки на сущность, которые составляют значение атрибута. <xref:System.Xml.XmlReader.Depth%2A> узлов значений атрибутов — это один плюс Глубина узла атрибута; он увеличивается и уменьшается на единицу при пошаговом выполнении и выходе из общих ссылок на сущности.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">Тип возвращаемого значения.  
  
 **Примечание**. С выпуском платформы .NET Framework 3.5 значение параметра <paramref name="returnType" /> может иметь тип <see cref="T:System.DateTimeOffset" />.</param>
        <param name="namespaceResolver">Объект <see cref="T:System.Xml.IXmlNamespaceResolver" />, используемый для разрешения любых префиксов пространств имен, имеющих отношение к преобразованию типов. Например, этот объект можно использовать при преобразовании объекта <see cref="T:System.Xml.XmlQualifiedName" /> в <c>xs:string</c>.  
  
Это значение может быть равно <see langword="null" />.</param>
        <summary>Прочитывает содержимое объекта указанного типа.</summary>
        <returns>Объединенное текстовое содержимое или значение атрибута, преобразованное в требуемый тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает текстовое содержимое в текущей позиции модуля чтения и преобразует его в запрошенный тип возвращаемого значения. Текст, пробелы, значимые пробелы и разделы CDATA объединяются. Комментарии и инструкции по обработке пропускаются, автоматически разрешаются ссылки на сущности.  
  
 Этот метод используется для чтения, преобразования при необходимости и возврата элементов атомарных значений из содержимого текущего узла. Если входной тип является допустимым сопоставлением для типа текущего узла, возвращается экземпляр целевого типа, содержащий значение текущего узла. Список сопоставлений по умолчанию см. в разделе "Примечания" на странице справочника по <xref:System.Xml.XmlReader>.  
  
 Например, если у вас есть следующий XML-текст:  
  
```xml  
<elem>123 <!-- comment --> <?pi my_text?> 456 <?pi another_pi?></elem>  
```  
  
 Если данные типизированы и в вызове метода <xref:System.Xml.XmlReader.ReadContentAs%2A> предоставлен массив строк, то целочисленные значения преобразуются из строк в соответствии со списком допустимых сопоставлений типов CLR.  
  
 Если данные не типизированы и в вызове метода <xref:System.Xml.XmlReader.ReadContentAs%2A> передается массив строк, содержимое разбивается на отдельные строки. Массив, содержащий две строки, возвращается со значениями "123" и "456". Пробелы не сохраняются в содержимом.  
  
 Как правило, при чтении нетипизированных данных содержимое анализируется в соответствии с предоставленным типом. Например, если для вызова метода <xref:System.Xml.XmlReader.ReadContentAs%2A> предоставляется целочисленный массив, строка разбивается в массив целых чисел {123,456}.  
  
 В следующем примере текст XML не отделяется пробелами.  
  
```xml  
<elem>123<!-- comment --><?pi my_text?>456789<?pi another_pi?></elem>  
```  
  
 Если содержимое не типизировано и в вызове метода <xref:System.Xml.XmlReader.ReadContentAs%2A> передается массив строк, то возвращается массив, содержащий одну объединенную строку со значением "123456789".  
  
 В следующей таблице описано, как этот метод обрабатывает каждый тип узла.  
  
|Тип узла XML|Возвращаемое значение|Поведение модуля чтения|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Объединенное содержимое узлов текста, CDATA, пробелов и значимых пробелов, преобразованное в необходимый тип.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`Attribute`|Аналогично вызову `XmlConvert.ToXxx` для значения атрибута.|Средство чтения остается в текущей позиции.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Пропускает инструкцию по обработке или комментарий и считывает объединенное текстовое содержимое, следующее за инструкцией по обработке или комментарием.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`EndElement`|Пустая строка.|Средство чтения остается в текущей позиции.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Возникает исключение <xref:System.InvalidOperationException>.|Не определено, хотя обычно модуль чтения остается в текущей позиции.|  
  
 Дополнительные сведения см. в подразделе "Примечания" на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadContentAsAsync%2A>.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Xml.XmlReader.ReadContentAs%2A> для возврата содержимого элемента Colors в массив строковых объектов.  
  
 [!code-csharp[XmlReader.ReadContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#2)]
 [!code-vb[XmlReader.ReadContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#2)]  
  
 В примере в качестве входных данных используется файл `dataFile_2.xml`.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Содержимое имеет неверный формат для типа целевого объекта.</exception>
        <exception cref="T:System.InvalidCastException">Недопустимая попытка приведения.</exception>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="returnType" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий узел не принадлежит к поддерживаемому типу узлов. Дополнительные сведения приведены в таблице ниже.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.OverflowException">Чтение значения <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">Тип возвращаемого значения.</param>
        <param name="namespaceResolver">Объект <see cref="T:System.Xml.IXmlNamespaceResolver" />, используемый для разрешения любых префиксов пространств имен, имеющих отношение к преобразованию типов.</param>
        <summary>Асинхронно считывает содержимое как объект указанного типа.</summary>
        <returns>Объединенное текстовое содержимое или значение атрибута, преобразованное в требуемый тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.ReadContentAs%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, в который копируется полученный текст. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, с которого следует начать копировать результат.</param>
        <param name="count">Максимальное количество копируемых в буфер байтов. Этот метод возвращает фактическое количество скопированных байтов.</param>
        <summary>Считывает содержимое и возвращает раскодированные двоичные байты Base64.</summary>
        <returns>Количество байтов, записанных в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет потоковую передачу содержимого, декодирует содержимое `Base64` и возвращает раскодированные двоичные байты (например, встроенный `Base64` закодированный рисунок в формате GIF) в буфер. Этот метод можно последовательно вызывать для чтения больших потоков внедренного текста. Дополнительные сведения см. в статьях RFC 1521, "MIME (многоцелевые расширения электронной почты Интернета): механизмы указания и описания формата текста Интернет-сообщений". RFC можно получить на [веб-сайте Request for Comments](https://go.microsoft.com/fwlink/?LinkId=37119).  
  
> [!NOTE]
>  Не следует обращаться к свойствам средства чтения между вызовами метода <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, пока метод не вернет значение `0`.  
  
 Этот метод имеет следующие особенности.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> возвращает значение `0` при достижении конца потока байтов, на котором он был запущен. Модуль чтения размещается на первом узле, не являющемся содержимым.  
  
-   Если вы запрашиваете меньшее или точное число байтов, чем осталось в потоке, модуль чтения остается в текущем положении.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> не поддерживается для следующих типов узлов XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="buffer" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" /> не поддерживается на текущем узле.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение индекса в буфере или сумма значений индекса и счетчика больше, чем выделенный размер буфера.</exception>
        <exception cref="T:System.NotSupportedException">Реализация <see cref="T:System.Xml.XmlReader" /> не поддерживает данный метод.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, в который копируется полученный текст. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, с которого следует начать копировать результат.</param>
        <param name="count">Максимальное количество копируемых в буфер байтов. Этот метод возвращает фактическое количество скопированных байтов.</param>
        <summary>Асинхронно считывает содержимое и возвращает раскодированные двоичные байты Base64.</summary>
        <returns>Количество байтов, записанных в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, в который копируется полученный текст. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, с которого следует начать копировать результат.</param>
        <param name="count">Максимальное количество копируемых в буфер байтов. Этот метод возвращает фактическое количество скопированных байтов.</param>
        <summary>Считывает содержимое и возвращает раскодированные двоичные байты <see langword="BinHex" />.</summary>
        <returns>Количество байтов, записанных в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет потоковую передачу содержимого, декодирует содержимое `BinHex` и возвращает раскодированные двоичные байты (например, встроенный `BinHex` закодированный рисунок в формате GIF) в буфер. Этот метод можно последовательно вызывать для чтения больших потоков внедренного текста.  
  
> [!NOTE]
>  Не следует обращаться к свойствам средства чтения между вызовами метода <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, пока метод не вернет значение `0`.  
  
 Этот метод имеет следующие особенности.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> возвращает значение `0` при достижении конца потока байтов, на котором он был запущен. Модуль чтения размещается на первом узле, не являющемся содержимым.  
  
-   Если вы запрашиваете меньшее или точное число байтов, чем осталось в потоке, модуль чтения остается в текущем положении.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> не поддерживается для следующих типов узлов XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation, Entity`, `DocumentFragment`.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="buffer" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" /> не поддерживается на текущем узле.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение индекса в буфере или сумма значений индекса и счетчика больше, чем выделенный размер буфера.</exception>
        <exception cref="T:System.NotSupportedException">Реализация <see cref="T:System.Xml.XmlReader" /> не поддерживает данный метод.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, в который копируется полученный текст. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, с которого следует начать копировать результат.</param>
        <param name="count">Максимальное количество копируемых в буфер байтов. Этот метод возвращает фактическое количество скопированных байтов.</param>
        <summary>Асинхронно считывает содержимое и возвращает раскодированные двоичные байты <see langword="BinHex" />.</summary>
        <returns>Количество байтов, записанных в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBoolean : unit -&gt; bool&#xA;override this.ReadContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает содержимое текста в текущей позиции как значение <see langword="Boolean" />.</summary>
        <returns>Текстовое содержимое в виде объекта <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет текст, пробел, значащий пробел и разделы CDATA и пропускает все комментарии и инструкции по обработке. Ссылки на сущности разрешаются автоматически.  
  
 Если содержимое введено `xsd:boolean`, средство чтения возвращает неупакованный <xref:System.Boolean> объект. Если содержимое не типизировано `xsd:boolean`, модуль чтения пытается преобразовать его в объект <xref:System.Boolean> в соответствии с правилами, определенными в рекомендациях [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 В следующей таблице описано, как этот метод обрабатывает каждый тип узла.  
  
|Тип узла XML|Возвращаемое значение|Поведение модуля чтения|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Объединенное содержимое узлов текста, CDATA, пробелов и значимых пробелов, преобразованное в необходимый тип.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`Attribute`|Аналогично вызову `XmlConvert.ToXxx` для значения атрибута.|Средство чтения остается в текущей позиции.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Пропускает инструкцию по обработке или комментарий и считывает объединенное текстовое содержимое, следующее за инструкцией по обработке или комментарием.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`EndElement`|Пустая строка.|Средство чтения остается в текущей позиции.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Возникает исключение <xref:System.InvalidOperationException>.|Не определено, хотя обычно модуль чтения остается в текущей позиции.|  
  
 Дополнительные сведения см. на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по XML-схеме часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> для чтения атрибута как значения `Boolean`.  
  
 [!code-csharp[XmlReader.ReadContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#1)]
 [!code-vb[XmlReader.ReadContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#1)]  
  
 В примере в качестве входных данных используется файл `dataFile_2.xml`.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Недопустимая попытка приведения.</exception>
        <exception cref="T:System.FormatException">Недопустимый формат строки.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает содержимое текста в текущем положении как объект <see cref="T:System.DateTime" />.</summary>
        <returns>Текстовое содержимое в виде объекта <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет текст, пробел, значащий пробел и разделы CDATA и пропускает все комментарии и инструкции по обработке. Ссылки на сущности разрешаются автоматически.  
  
 Если содержимое введено `xsd:dateTime`, средство чтения возвращает неупакованный <xref:System.DateTime> объект. Если содержимое не типизировано `xsd:dateTime`, модуль чтения пытается преобразовать его в объект <xref:System.DateTime> в соответствии с правилами, определенными в рекомендациях [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
> [!NOTE]
>  Не следует полагаться на значение свойства <xref:System.DateTime.Year%2A?displayProperty=nameWithType>, когда содержимое типизируется как `xsd:gMonthDay`. <xref:System.Xml.XmlReader> всегда задает <xref:System.DateTime.Year%2A?displayProperty=nameWithType> значение 1904 в этом случае.  
  
 В следующей таблице описано, как этот метод обрабатывает каждый тип узла.  
  
|Тип узла XML|Возвращаемое значение|Поведение модуля чтения|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Объединенное содержимое узлов текста, CDATA, пробелов и значимых пробелов, преобразованное в необходимый тип.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`Attribute`|Аналогично вызову `XmlConvert.ToXxx` для значения атрибута.|Средство чтения остается в текущей позиции.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Пропускает инструкцию по обработке или комментарий и считывает объединенное текстовое содержимое, следующее за инструкцией по обработке или комментарием.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`EndElement`|Пустая строка.|Средство чтения остается в текущей позиции.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Возникает исключение <xref:System.InvalidOperationException>.|Не определено, хотя обычно модуль чтения остается в текущей позиции.|  
  
 Дополнительные сведения см. на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по XML-схеме часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Недопустимая попытка приведения.</exception>
        <exception cref="T:System.FormatException">Недопустимый формат строки.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTimeOffset">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ReadContentAsDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTimeOffset ReadContentAsDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTimeOffset ReadContentAsDateTimeOffset();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset&#xA;override this.ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset" Usage="xmlReader.ReadContentAsDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает содержимое текста в текущем положении как объект <see cref="T:System.DateTimeOffset" />.</summary>
        <returns>Текстовое содержимое в виде объекта <see cref="T:System.DateTimeOffset" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает содержимое текста в текущем положении как объект <see cref="T:System.Decimal" />.</summary>
        <returns>Содержимое текста в текущей позиции как объект <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет текст, пробел, значащий пробел и разделы CDATA и пропускает все комментарии и инструкции по обработке. Ссылки на сущности разрешаются автоматически.  
  
 Если содержимое введено `xsd:decimal`, средство чтения возвращает неупакованный <xref:System.Decimal> объект. Если содержимое не типизировано `xsd:decimal`, модуль чтения пытается преобразовать его в объект <xref:System.Decimal> в соответствии с правилами, определенными в рекомендациях [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 В следующей таблице описано, как этот метод обрабатывает каждый тип узла.  
  
|Тип узла XML|Возвращаемое значение|Поведение модуля чтения|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Объединенное содержимое узлов текста, CDATA, пробелов и значимых пробелов, преобразованное в необходимый тип.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`Attribute`|Аналогично вызову `XmlConvert.ToXxx` для значения атрибута.|Средство чтения остается в текущей позиции.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Пропускает инструкцию по обработке или комментарий и считывает объединенное текстовое содержимое, следующее за инструкцией по обработке или комментарием.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`EndElement`|Пустая строка.|Средство чтения остается в текущей позиции.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Возникает исключение <xref:System.InvalidOperationException>.|Не определено, хотя обычно модуль чтения остается в текущей позиции.|  
  
 Дополнительные сведения см. на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по XML-схеме часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Недопустимая попытка приведения.</exception>
        <exception cref="T:System.FormatException">Недопустимый формат строки.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDouble : unit -&gt; double&#xA;override this.ReadContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает содержимое текста в текущей позиции как число с плавающей запятой двойной точности.</summary>
        <returns>Текстовое содержимое в виде числа с плавающей запятой двойной точности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет текст, пробел, значащий пробел и разделы CDATA и пропускает все комментарии и инструкции по обработке. Ссылки на сущности разрешаются автоматически.  
  
 Если содержимое введено `xsd:double`, средство чтения возвращает число двойной точности с плавающей запятой. Если содержимое не типизировано `xsd:double`, модуль чтения пытается преобразовать его в число двойной точности с плавающей запятой в соответствии с правилами, определенными в рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 В следующей таблице описано, как этот метод обрабатывает каждый тип узла.  
  
|Тип узла XML|Возвращаемое значение|Поведение модуля чтения|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Объединенное содержимое узлов текста, CDATA, пробелов и значимых пробелов, преобразованное в необходимый тип.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`Attribute`|Аналогично вызову `XmlConvert.ToXxx` для значения атрибута.|Средство чтения остается в текущей позиции.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Пропускает инструкцию по обработке или комментарий и считывает объединенное текстовое содержимое, следующее за инструкцией по обработке или комментарием.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`EndElement`|Пустая строка.|Средство чтения остается в текущей позиции.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Возникает исключение <xref:System.InvalidOperationException>.|Не определено, хотя обычно модуль чтения остается в текущей позиции.|  
  
 Дополнительные сведения см. на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по XML-схеме часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Недопустимая попытка приведения.</exception>
        <exception cref="T:System.FormatException">Недопустимый формат строки.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsFloat : unit -&gt; single&#xA;override this.ReadContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает содержимое текста в текущей позиции как число с плавающей запятой одинарной точности.</summary>
        <returns>Содержимое текста в текущей позиции как число с плавающей запятой одиночной точности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет текст, пробел, значащий пробел и разделы CDATA и пропускает все комментарии и инструкции по обработке. Ссылки на сущности разрешаются автоматически.  
  
 Если содержимое введено `xsd:float`, средство чтения возвращает неупакованное число с плавающей запятой одиночной точности. Если содержимое не типизировано `xsd:float`, модуль чтения пытается преобразовать его в число с плавающей запятой одиночной точности в соответствии с правилами, определенными в рекомендациях [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 В следующей таблице описано, как этот метод обрабатывает каждый тип узла.  
  
|Тип узла XML|Возвращаемое значение|Поведение модуля чтения|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Объединенное содержимое узлов текста, CDATA, пробелов и значимых пробелов, преобразованное в необходимый тип.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`Attribute`|Аналогично вызову `XmlConvert.ToXxx` для значения атрибута.|Средство чтения остается в текущей позиции.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Пропускает инструкцию по обработке или комментарий и считывает объединенное текстовое содержимое, следующее за инструкцией по обработке или комментарием.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`EndElement`|Пустая строка.|Средство чтения остается в текущей позиции.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Возникает исключение <xref:System.InvalidOperationException>.|Не определено, хотя обычно модуль чтения остается в текущей позиции.|  
  
 Дополнительные сведения см. в подразделе "Примечания" на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Недопустимая попытка приведения.</exception>
        <exception cref="T:System.FormatException">Недопустимый формат строки.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsInt : unit -&gt; int&#xA;override this.ReadContentAsInt : unit -&gt; int" Usage="xmlReader.ReadContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает содержимое текста в текущем положении как 32-разрядное знаковое целое число.</summary>
        <returns>Содержимое как 32-разрядное целое число со знаком.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет текст, пробел, значащий пробел и разделы CDATA и пропускает все комментарии и инструкции по обработке. Ссылки на сущности разрешаются автоматически.  
  
 Если содержимое введено `xsd:integer`, средство чтения возвращает неупакованное 32-разрядное целое число со знаком. Если содержимое не типизировано `xsd:integer`, модуль чтения пытается преобразовать его в 32-разрядное целое число со знаком в соответствии с правилами, определенными в рекомендациях по [XML-схеме W3C, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 В следующей таблице описано, как этот метод обрабатывает каждый тип узла.  
  
|Тип узла XML|Возвращаемое значение|Поведение модуля чтения|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Объединенное содержимое узлов текста, CDATA, пробелов и значимых пробелов, преобразованное в необходимый тип.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`Attribute`|Аналогично вызову `XmlConvert.ToXxx` для значения атрибута.|Средство чтения остается в текущей позиции.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Пропускает инструкцию по обработке или комментарий и считывает объединенное текстовое содержимое, следующее за инструкцией по обработке или комментарием.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`EndElement`|Пустая строка.|Средство чтения остается в текущей позиции.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Возникает исключение <xref:System.InvalidOperationException>.|Не определено, хотя обычно модуль чтения остается в текущей позиции.|  
  
 Дополнительные сведения см. в подразделе "Примечания" на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Недопустимая попытка приведения.</exception>
        <exception cref="T:System.FormatException">Недопустимый формат строки.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsLong : unit -&gt; int64&#xA;override this.ReadContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает текстовое содержимое в текущей позиции как 64-разрядное целое число со знаком.</summary>
        <returns>Текстовое содержимое как 64-разрядное целое число со знаком.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет текст, пробел, значащий пробел и разделы CDATA и пропускает все комментарии и инструкции по обработке. Ссылки на сущности разрешаются автоматически.  
  
 Если содержимое введено `xsd:long`, средство чтения возвращает неупакованное 64-разрядное целое число со знаком. Если содержимое не типизировано `xsd:long`, модуль чтения пытается преобразовать его в 64-разрядное целое число со знаком в соответствии с правилами, определенными в рекомендациях по [XML-схеме W3C, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 В следующей таблице описывается, как этот метод обрабатывает каждый тип узла.  
  
|Тип узла XML|Возвращаемое значение|Поведение модуля чтения|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Объединенное содержимое узлов текста, CDATA, пробелов и значимых пробелов, преобразованное в необходимый тип.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`Attribute`|То же, что и `XmlConvert.ToXxx` значения атрибута.|Модуль чтения остается в текущей должности|  
|`Comment`<br /><br /> `ProcessingInstruction`|Пропускает инструкцию по обработке или комментарий и считывает объединенное текстовое содержимое, следующее за инструкцией по обработке или комментарием.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`EndElement`|Пустая строка.|Средство чтения остается в текущей позиции.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Возникает исключение <xref:System.InvalidOperationException>.|Не определено, хотя обычно модуль чтения остается в текущей позиции.|  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Недопустимая попытка приведения.</exception>
        <exception cref="T:System.FormatException">Недопустимый формат строки.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObject : unit -&gt; obj&#xA;override this.ReadContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает содержимое текста в текущей позиции как значение <see cref="T:System.Object" />.</summary>
        <returns>Текстовое содержимое как самый подходящий объект CLR.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет текст, пробел, значащий пробел и разделы CDATA и пропускает все комментарии и инструкции по обработке. Ссылки на сущности разрешаются автоматически.  
  
 Если содержимое типизировано, средство чтения возвращает среду CLR с наиболее подходящим типом, заданную свойством <xref:System.Xml.XmlReader.ValueType%2A>. Если содержимое является типом списка, средство чтения возвращает массив упакованных объектов соответствующего типа.  
  
> [!NOTE]
>  Если при синтаксическом анализе содержимого возникает ошибка проверки, а средство чтения является объектом <xref:System.Xml.XmlReader>, созданным методом <xref:System.Xml.XmlReader.Create%2A>, средство чтения возвращает содержимое в виде строки. Иными словами, при возникновении ошибки или предупреждения проверки содержимое считается нетипизированным.  
  
 Если содержимое не типизировано, средство чтения возвращает его в виде строки.  
  
 В следующей таблице описано, как этот метод обрабатывает каждый тип узла.  
  
|Тип узла XML|Возвращаемое значение|Поведение модуля чтения|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Объединенное содержимое узлов текста, CDATA, пробелов и значимых пробелов, преобразованное в необходимый тип.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`Attribute`|Аналогично вызову `XmlConvert.ToXxx` для значения атрибута.|Модуль чтения остается в текущей должности|  
|`Comment`<br /><br /> `ProcessingInstruction`|Пропускает инструкцию по обработке или комментарий и считывает объединенное текстовое содержимое, следующее за инструкцией по обработке или комментарием.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`EndElement`|Значение элемента, если читатель является модулем чтения для проверки схемы (<xref:System.Xml.XmlReaderSettings.ValidationType%2A> имеет значение <xref:System.Xml.ValidationType.Schema>); в противном случае — пустая строка.|Средство чтения остается в текущей позиции.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Возникает исключение <xref:System.InvalidOperationException>.|Не определено, хотя обычно модуль чтения остается в текущей позиции.|  
  
 Дополнительные сведения см. в подразделе "Примечания" на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Недопустимая попытка приведения.</exception>
        <exception cref="T:System.FormatException">Недопустимый формат строки.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно считывает содержимое текста в текущем положении как объект <see cref="T:System.Object" />.</summary>
        <returns>Текстовое содержимое как самый подходящий объект CLR.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.ReadContentAsObject%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsString : unit -&gt; string&#xA;override this.ReadContentAsString : unit -&gt; string" Usage="xmlReader.ReadContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает содержимое текста в текущем положении как объект <see cref="T:System.String" />.</summary>
        <returns>Текстовое содержимое в виде объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод объединяет текст, пробел, значащий пробел и разделы CDATA и пропускает все комментарии и инструкции по обработке. Ссылки на сущности разрешаются автоматически.  
  
 Этот метод может использоваться для преобразования типизированных значений в строку или для чтения текстового содержимого при пропуске комментариев и инструкций по обработке.  
  
 В следующей таблице описано, как этот метод обрабатывает каждый тип узла.  
  
|Тип узла XML|Возвращаемое значение|Поведение модуля чтения|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Объединенное содержимое узлов текста, CDATA, пробелов и значимых пробелов, преобразованное в необходимый тип.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`Attribute`|Аналогично вызову `XmlConvert.ToXxx` для значения атрибута.|Средство чтения остается в текущей позиции.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Пропускает инструкцию по обработке или комментарий и считывает объединенное текстовое содержимое, следующее за инструкцией по обработке или комментарием.|Перемещается к следующему тегу начального или конечного элемента. Ссылки на сущности автоматически раскрываются.|  
|`EndElement`|Пустая строка.|Средство чтения остается в текущей позиции.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Возникает исключение <xref:System.InvalidOperationException>.|Не определено, хотя обычно модуль чтения остается в текущей позиции.|  
  
 Дополнительные сведения см. в подразделе "Примечания" на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Недопустимая попытка приведения.</exception>
        <exception cref="T:System.FormatException">Недопустимый формат строки.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно считывает содержимое текста в текущем положении как объект <see cref="T:System.String" />.</summary>
        <returns>Текстовое содержимое в виде объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.ReadContentAsString%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAs">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Прочитывает текущий элемент и возвращает содержимое объекта указанного типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">Тип возвращаемого значения.  
  
 **Примечание**. С выпуском платформы .NET Framework 3.5 значение параметра <paramref name="returnType" /> может иметь тип <see cref="T:System.DateTimeOffset" />.</param>
        <param name="namespaceResolver">Объект <see cref="T:System.Xml.IXmlNamespaceResolver" />, используемый для разрешения любых префиксов пространств имен, имеющих отношение к преобразованию типов.</param>
        <summary>Считывает содержимое элемента в качестве требуемого типа.</summary>
        <returns>Содержимое элемента, преобразованное в требуемый типизированный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Дополнительные сведения см. в подразделе "Примечания" на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Xml.XmlReader.ReadElementContentAs%2A> для чтения содержимого `date` узла.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#5)]
 [!code-vb[XmlReader.ReadElementContentAs#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#5)]  
  
 В примере в качестве входных данных используется файл `dataFile.xml`.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Не удается преобразовать содержимое элемента в запрошенный тип.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Чтение значения <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver, localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="localName" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">Тип возвращаемого значения.  
  
 **Примечание**. С выпуском платформы .NET Framework 3.5 значение параметра <paramref name="returnType" /> может иметь тип <see cref="T:System.DateTimeOffset" />.</param>
        <param name="namespaceResolver">Объект <see cref="T:System.Xml.IXmlNamespaceResolver" />, используемый для разрешения любых префиксов пространств имен, имеющих отношение к преобразованию типов.</param>
        <param name="localName">Локальное имя элемента.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен элемента.</param>
        <summary>Проверяет, сопоставлен ли URI локального имени и пространства имен с URI текущего элемента, затем считывает содержимое элемента требуемого типа.</summary>
        <returns>Содержимое элемента, преобразованное в требуемый типизированный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Дополнительные сведения см. в подразделе "Примечания" на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Не удается преобразовать содержимое элемента в запрошенный тип.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Указанное локальное имя и URI пространства имен не совпадают с аналогичными параметрами текущего считываемого элемента.</exception>
        <exception cref="T:System.OverflowException">Чтение значения <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">Тип возвращаемого значения.</param>
        <param name="namespaceResolver">Объект <see cref="T:System.Xml.IXmlNamespaceResolver" />, используемый для разрешения любых префиксов пространств имен, имеющих отношение к преобразованию типов.</param>
        <summary>Асинхронно считывает содержимое элемента как запрашиваемый тип.</summary>
        <returns>Содержимое элемента, преобразованное в требуемый типизированный объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.ReadElementContentAs%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".
- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, в который копируется полученный текст. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, с которого следует начать копировать результат.</param>
        <param name="count">Максимальное количество копируемых в буфер байтов. Этот метод возвращает фактическое количество скопированных байтов.</param>
        <summary>Считывает элемент и декодирует содержимое <see langword="Base64" />.</summary>
        <returns>Количество байтов, записанных в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает содержимое элемента, декодирует его с помощью `Base64` кодирования и возвращает раскодированные двоичные байты (например, встроенный `Base64`закодированный рисунок в формате GIF) в буфер. Дополнительные сведения см. в статьях RFC 1521, "MIME (многоцелевые расширения электронной почты Интернета): механизмы указания и описания формата текста Интернет-сообщений". RFC можно получить на [веб-сайте Request for Comments](https://go.microsoft.com/fwlink/?LinkId=37119).  
  
 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A> может читать только элементы с простым содержимым. Элемент может содержать текст, пробелы, значащие пробелы, разделы CDATA, комментарии и инструкции по обработке. Он также может содержать ссылки на сущности, которые автоматически развертываются. Элемент не может иметь дочерние элементы.  
  
 Этот метод очень похож на метод <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, за исключением того, что он может вызываться только для типов узлов элементов.  
  
 Если значение `count` больше числа байтов в документе или равно числу байтов в документе, <xref:System.Xml.XmlReader> считывает все оставшиеся байты в документе и возвращает число считанных байтов. Следующий вызов метода <xref:System.Xml.XmlReader> возвращает ноль и перемещает модуль чтения на узел после `EndElement`.  
  
 При вызове <xref:System.Xml.XmlReader.Read%2A> до того, как будет использовано все содержимое элемента, читатель может вести себя так, как если бы первое содержимое было использовано, а затем был вызван метод <xref:System.Xml.XmlReader.Read%2A>. Это означает, что читатель считывает весь текст до тех пор, пока не будет обнаружен элемент End. Затем он считывает конечный узел тега, считывает следующий узел, а затем позиционирует себя на следующем следующем узле.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>.  
  
   
  
## Examples  
 В следующем примере считывается встроенное `Base64` кодированное изображение. `Base64` данные внедряются в элемент `<image>`. Для создания нового двоичного файла данных используется <xref:System.IO.BinaryWriter>.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#4)]
 [!code-vb[XmlReader_Read_Write_Binary#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="buffer" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий узел не является узлом элемента.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение индекса в буфере или сумма значений индекса и счетчика больше, чем выделенный размер буфера.</exception>
        <exception cref="T:System.NotSupportedException">Реализация <see cref="T:System.Xml.XmlReader" /> не поддерживает данный метод.</exception>
        <exception cref="T:System.Xml.XmlException">Элемент содержит смешанное содержимое.</exception>
        <exception cref="T:System.FormatException">Не удается преобразовать содержимое в требуемый тип.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, в который копируется полученный текст. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, с которого следует начать копировать результат.</param>
        <param name="count">Максимальное количество копируемых в буфер байтов. Этот метод возвращает фактическое количество скопированных байтов.</param>
        <summary>Асинхронно считывает элемент и расшифровывает содержимое <see langword="Base64" />.</summary>
        <returns>Количество байтов, записанных в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, в который копируется полученный текст. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, с которого следует начать копировать результат.</param>
        <param name="count">Максимальное количество копируемых в буфер байтов. Этот метод возвращает фактическое количество скопированных байтов.</param>
        <summary>Считывает элемент и декодирует содержимое <see langword="BinHex" />.</summary>
        <returns>Количество байтов, записанных в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает содержимое элемента, декодирует его с помощью `BinHex` кодирования и возвращает раскодированные двоичные байты (например, встроенный `BinHex`закодированный рисунок в формате GIF) в буфер.  
  
 Этот метод может читать только элементы с простым содержимым. Элемент может содержать текст, пробелы, значащие пробелы, разделы CDATA, комментарии и инструкции по обработке. Он также может содержать ссылки на сущности, которые автоматически развертываются. Элемент не может иметь дочерние элементы.  
  
 Этот метод очень похож на метод <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, за исключением того, что он может вызываться только для типов узлов элементов.  
  
 Если значение `count` больше числа байтов в документе или равно числу байтов в документе, <xref:System.Xml.XmlReader> считывает все оставшиеся байты в документе и возвращает число считанных байтов. Следующий вызов метода <xref:System.Xml.XmlReader> возвращает ноль и перемещает модуль чтения на узел после `EndElement`.  
  
 При вызове <xref:System.Xml.XmlReader.Read%2A> до того, как будет использовано все содержимое элемента, читатель может вести себя так, как если бы первое содержимое было использовано, а затем был вызван метод <xref:System.Xml.XmlReader.Read%2A>. Это означает, что читатель считывает весь текст до тех пор, пока не будет обнаружен элемент End. Затем он считывает конечный узел тега, считывает следующий узел, а затем позиционирует себя на следующем следующем узле.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>.  
  
   
  
## Examples  
 В следующем примере считывается встроенное `BinHex` кодированное изображение. `BinHex` данные внедряются в элемент `<image>`. Для создания нового двоичного файла данных используется <xref:System.IO.BinaryWriter>.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#2)]
 [!code-vb[XmlReader_Read_Write_Binary#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="buffer" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий узел не является узлом элемента.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение индекса в буфере или сумма значений индекса и счетчика больше, чем выделенный размер буфера.</exception>
        <exception cref="T:System.NotSupportedException">Реализация <see cref="T:System.Xml.XmlReader" /> не поддерживает данный метод.</exception>
        <exception cref="T:System.Xml.XmlException">Элемент содержит смешанное содержимое.</exception>
        <exception cref="T:System.FormatException">Не удается преобразовать содержимое в требуемый тип.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, в который копируется полученный текст. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, с которого следует начать копировать результат.</param>
        <param name="count">Максимальное количество копируемых в буфер байтов. Этот метод возвращает фактическое количество скопированных байтов.</param>
        <summary>Асинхронно считывает элемент и расшифровывает содержимое <see langword="BinHex" />.</summary>
        <returns>Количество байтов, записанных в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsBoolean">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Считывает текущее значение элемента в качестве объекта <see cref="T:System.Boolean" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : unit -&gt; bool&#xA;override this.ReadElementContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает текущий элемент и возвращает содержимое объекта <see cref="T:System.Boolean" />.</summary>
        <returns>Содержимое элемента в виде объекта <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Если содержимое элемента введено `xsd:boolean`, средство чтения возвращает неупакованный <xref:System.Boolean> объект. Если содержимое не типизировано `xsd:boolean`, модуль чтения пытается преобразовать его в объект <xref:System.Boolean> в соответствии с правилами, определенными в рекомендациях [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
- или - 
Содержимое элемента нельзя преобразовать в объект <see cref="T:System.Boolean" />.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : string * string -&gt; bool&#xA;override this.ReadElementContentAsBoolean : string * string -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя элемента.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен элемента.</param>
        <summary>Проверяет соответствие указанного URI локального имени и пространства имен с URI текущего элемента, затем считывает текущий элемент и возвращает содержимое как объект <see cref="T:System.Boolean" />.</summary>
        <returns>Содержимое элемента в виде объекта <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Если содержимое введено `xsd:boolean`, средство чтения возвращает неупакованный <xref:System.Boolean> объект. Если содержимое не типизировано `xsd:boolean`, модуль чтения пытается преобразовать его в объект <xref:System.Boolean> в соответствии с правилами, определенными в рекомендациях [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Не удается преобразовать содержимое элемента в запрошенный тип.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Указанное локальное имя и URI пространства имен не совпадают с аналогичными параметрами текущего считываемого элемента.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDateTime">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Считывает текущий элемент и возвращает содержимое объекта <see cref="T:System.DateTime" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает текущий элемент и возвращает содержимое объекта <see cref="T:System.DateTime" />.</summary>
        <returns>Содержимое элемента в виде объекта <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Если содержимое введено `xsd:dateTime`, средство чтения возвращает неупакованный <xref:System.DateTime> объект. Если содержимое не типизировано `xsd:dateTime`, модуль чтения пытается преобразовать его в объект <xref:System.DateTime> в соответствии с правилами, определенными в рекомендациях [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
> [!NOTE]
>  Не следует полагаться на значение свойства <xref:System.DateTime.Year%2A?displayProperty=nameWithType>, когда содержимое типизируется как `xsd:gMonthDay`. <xref:System.Xml.XmlReader> всегда задает <xref:System.DateTime.Year%2A?displayProperty=nameWithType> значение 1904 в этом случае.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> для чтения содержимого элемента `date`.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#4)]
 [!code-vb[XmlReader.ReadElementContentAs#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#4)]  
  
 В примере в качестве входных данных используется файл `dataFile.xml`.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
- или - 
Содержимое элемента нельзя преобразовать в объект <see cref="T:System.DateTime" />.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime (localName As String, namespaceURI As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : string * string -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : string * string -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя элемента.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен элемента.</param>
        <summary>Проверяет соответствие указанного URI локального имени и пространства имен с URI текущего элемента, затем считывает текущий элемент и возвращает содержимое как объект <see cref="T:System.DateTime" />.</summary>
        <returns>Содержимое элемента в виде объекта <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Если содержимое введено `xsd:dateTime`, средство чтения возвращает неупакованный <xref:System.DateTime> объект. Если содержимое не типизировано `xsd:dateTime`, модуль чтения пытается преобразовать его в объект <xref:System.DateTime> в соответствии с правилами, определенными в рекомендациях [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
> [!NOTE]
>  Не следует полагаться на значение свойства <xref:System.DateTime.Year%2A?displayProperty=nameWithType>, когда содержимое типизируется как `xsd:gMonthDay`. <xref:System.Xml.XmlReader> всегда задает <xref:System.DateTime.Year%2A?displayProperty=nameWithType> значение 1904 в этом случае.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Не удается преобразовать содержимое элемента в запрошенный тип.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Указанное локальное имя и URI пространства имен не совпадают с аналогичными параметрами текущего считываемого элемента.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDecimal">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Считывает текущее значение элемента в качестве объекта <see cref="T:System.Decimal" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает текущий элемент и возвращает содержимое объекта <see cref="T:System.Decimal" />.</summary>
        <returns>Содержимое элемента в виде объекта <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Модуль чтения пытается преобразовать содержимое элемента в <xref:System.Decimal> объект в соответствии с правилами, определенными в рекомендациях [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
- или - 
Содержимое элемента нельзя преобразовать в объект типа <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal (localName As String, namespaceURI As String) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : string * string -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : string * string -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя элемента.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен элемента.</param>
        <summary>Проверяет соответствие указанного URI локального имени и пространства имен с URI текущего элемента, затем считывает текущий элемент и возвращает содержимое как объект <see cref="T:System.Decimal" />.</summary>
        <returns>Содержимое элемента в виде объекта <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Модуль чтения пытается преобразовать содержимое элемента в <xref:System.Decimal> объект в соответствии с правилами, определенными в рекомендациях [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
- или - 
Содержимое элемента нельзя преобразовать в объект типа <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Указанное локальное имя и URI пространства имен не совпадают с аналогичными параметрами текущего считываемого элемента.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDouble">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Считывает текущий элемент и возвращает содержимое как число с плавающей запятой двойной точности.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : unit -&gt; double&#xA;override this.ReadElementContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadElementContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает текущий элемент и возвращает содержимое как число с плавающей запятой двойной точности.</summary>
        <returns>Содержимое элемента в виде числа с плавающей запятой двойной точности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Если содержимое введено `xsd:double`, средство чтения возвращает число двойной точности с плавающей запятой. Если содержимое не типизировано `xsd:double`, модуль чтения пытается преобразовать его в число двойной точности с плавающей запятой в соответствии с правилами, определенными в рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 В следующем примере используется метод для возврата содержимого элемента в виде числа с плавающей запятой двойной точности.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#7)]
 [!code-vb[XmlReader.ReadElementContentAs#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#7)]  
  
 В примере в качестве входных данных используется файл `dataFile.xml`.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Содержимое элемента нельзя преобразовать в число с плавающей запятой двойной точности.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble (localName As String, namespaceURI As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : string * string -&gt; double&#xA;override this.ReadElementContentAsDouble : string * string -&gt; double" Usage="xmlReader.ReadElementContentAsDouble (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя элемента.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен элемента.</param>
        <summary>Проверяет соответствие указанного URI локального имени и пространства имен с URI текущего элемента, затем считывает текущий элемент и возвращает содержимое как число с плавающей запятой двойной точности.</summary>
        <returns>Содержимое элемента в виде числа с плавающей запятой двойной точности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Если содержимое введено `xsd:double`, средство чтения возвращает число двойной точности с плавающей запятой. Если содержимое не типизировано `xsd:double`, модуль чтения пытается преобразовать его в число двойной точности с плавающей запятой в соответствии с правилами, определенными в рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Не удается преобразовать содержимое элемента в запрошенный тип.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Указанное локальное имя и URI пространства имен не совпадают с аналогичными параметрами текущего считываемого элемента.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsFloat">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Считывает текущее значение элемента как число с плавающей запятой одинарной точности.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : unit -&gt; single&#xA;override this.ReadElementContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadElementContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает текущий элемент и возвращает содержимое как число с плавающей запятой одинарной точности.</summary>
        <returns>Содержимое элемента в виде числа с плавающей запятой одиночной точности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Модуль чтения пытается преобразовать содержимое элемента в число с плавающей запятой одиночной точности в соответствии с правилами, определенными в рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Содержимое элемента нельзя преобразовать в число с плавающей запятой одиночной точности.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat (localName As String, namespaceURI As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : string * string -&gt; single&#xA;override this.ReadElementContentAsFloat : string * string -&gt; single" Usage="xmlReader.ReadElementContentAsFloat (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя элемента.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен элемента.</param>
        <summary>Проверяет соответствие указанного URI локального имени и пространства имен с URI текущего элемента, затем считывает текущий элемент и возвращает содержимое как число с плавающей запятой одинарной точности.</summary>
        <returns>Содержимое элемента в виде числа с плавающей запятой одиночной точности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Модуль чтения пытается преобразовать содержимое элемента в число с плавающей запятой одиночной точности в соответствии с правилами, определенными в рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или - 
Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Содержимое элемента нельзя преобразовать в число с плавающей запятой одиночной точности.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Указанное локальное имя и URI пространства имен не совпадают с аналогичными параметрами текущего считываемого элемента.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsInt">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Считывает текущий элемент и возвращает содержимое в виде 32-разрядного знакового целого числа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : unit -&gt; int&#xA;override this.ReadElementContentAsInt : unit -&gt; int" Usage="xmlReader.ReadElementContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает текущий элемент и возвращает содержимое в виде 32-разрядного целого числа со знаком.</summary>
        <returns>Содержимое элемента как целое 32-разрядное целое число со знаком.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Если содержимое введено `xsd:integer`, средство чтения возвращает неупакованное 32-разрядное целое число со знаком. Если содержимое не типизировано `xsd:integer`, модуль чтения пытается преобразовать его в 32-разрядное целое число со знаком в соответствии с правилами, определенными в рекомендациях по [XML-схеме W3C, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или - 
Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Содержимое элемента не может быть преобразовано в 32-разрядное знаковое целое число.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt (localName As String, namespaceURI As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : string * string -&gt; int&#xA;override this.ReadElementContentAsInt : string * string -&gt; int" Usage="xmlReader.ReadElementContentAsInt (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя элемента.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен элемента.</param>
        <summary>Проверяет соответствие указанного URI локального имени и пространства имен с URI текущего элемента, затем считывает текущий элемент и возвращает содержимое как 32-разрядное целое число со знаком.</summary>
        <returns>Содержимое элемента как целое 32-разрядное целое число со знаком.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Если содержимое введено `xsd:integer`, средство чтения возвращает неупакованное 32-разрядное целое число со знаком. Если содержимое не типизировано `xsd:integer`, модуль чтения пытается преобразовать его в 32-разрядное целое число со знаком в соответствии с правилами, определенными в рекомендациях по [XML-схеме W3C, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или - 
Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Содержимое элемента не может быть преобразовано в 32-разрядное знаковое целое число.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Указанное локальное имя и URI пространства имен не совпадают с аналогичными параметрами текущего считываемого элемента.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsLong">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Считывает текущий элемент и возвращает содержимое в виде 64-разрядного целого числа со знаком.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : unit -&gt; int64&#xA;override this.ReadElementContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadElementContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает текущий элемент и возвращает содержимое в виде 64-разрядного целого числа со знаком.</summary>
        <returns>Содержимое элемента как целое 64-разрядное целое число со знаком.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Если содержимое введено `xsd:long`, средство чтения возвращает неупакованное 64-разрядное целое число со знаком. Если содержимое не типизировано `xsd:long`, модуль чтения пытается преобразовать его в 64-разрядное целое число со знаком в соответствии с правилами, определенными в рекомендациях по [XML-схеме W3C, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A> для чтения содержимого элемента `longValue`.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#3)]
 [!code-vb[XmlReader.ReadElementContentAs#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#3)]  
  
 В примере в качестве входных данных используется файл `dataFile.xml`.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или - 
Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Содержимое элемента не может быть преобразовано в 64-разрядное целое число со знаком.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong (localName As String, namespaceURI As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : string * string -&gt; int64&#xA;override this.ReadElementContentAsLong : string * string -&gt; int64" Usage="xmlReader.ReadElementContentAsLong (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя элемента.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен элемента.</param>
        <summary>Проверяет, совпадают ли указанные локальное имя и URI пространства имен с таковыми для текущего элемента, затем считывает текущий элемент и возвращает содержимое как 64-разрядное целое число со знаком.</summary>
        <returns>Содержимое элемента как целое 64-разрядное целое число со знаком.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Если содержимое введено `xsd:long`, средство чтения возвращает неупакованное 64-разрядное целое число со знаком. Если содержимое не типизировано `xsd:long`, модуль чтения пытается преобразовать его в 64-разрядное целое число со знаком в соответствии с правилами, определенными в рекомендациях по [XML-схеме W3C, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Дополнительные сведения см. в подразделе "Примечания" на справочной странице <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или - 
Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Содержимое элемента не может быть преобразовано в 64-разрядное целое число со знаком.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Указанное локальное имя и URI пространства имен не совпадают с аналогичными параметрами текущего считываемого элемента.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsObject">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Прочитывает текущий элемент и возвращает содержимое в качестве объекта <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : unit -&gt; obj&#xA;override this.ReadElementContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadElementContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Прочитывает текущий элемент и возвращает содержимое в качестве объекта <see cref="T:System.Object" />.</summary>
        <returns>Упакованный объект CLR наиболее подходящего типа. Свойство <see cref="P:System.Xml.XmlReader.ValueType" /> служит для определения подходящего типа CLR. Если содержимое типизировано как тип списка, этот метод возвращает массив упакованных объектов соответствующего типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Дополнительные сведения см. в подразделе "Примечания" на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>.  
  
   
  
## Examples  
 В следующем примере метод используется для чтения содержимого узла `price`. Средство чтения использует сведения в схеме для преобразования содержимого в правильный тип данных.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#6)]
 [!code-vb[XmlReader.ReadElementContentAs#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#6)]  
  
 В этом примере в качестве входных данных используются следующие два файла.  
  
 `item.xml`  
  
 [!code-xml[XmlReader.ReadElementContentAs#11](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xml#11)]  
  
 `item.xsd`  
  
 [!code-xml[XmlReader.ReadElementContentAs#12](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xsd#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или - 
Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Содержимое элемента невозможно преобразовать в запрошенный тип.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject (localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : string * string -&gt; obj&#xA;override this.ReadElementContentAsObject : string * string -&gt; obj" Usage="xmlReader.ReadElementContentAsObject (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя элемента.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен элемента.</param>
        <summary>Проверяет соответствие указанного URI локального имени и пространства имен с URI текущего элемента, затем считывает текущий элемент и возвращает содержимое как объект <see cref="T:System.Object" />.</summary>
        <returns>Упакованный объект CLR наиболее подходящего типа. Свойство <see cref="P:System.Xml.XmlReader.ValueType" /> служит для определения подходящего типа CLR. Если содержимое типизировано как тип списка, этот метод возвращает массив упакованных объектов соответствующего типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Дополнительные сведения см. в подразделе "Примечания" на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или - 
Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
 - или -  
  
 Не удается преобразовать содержимое элемента в запрошенный тип.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Указанное локальное имя и URI пространства имен не совпадают с аналогичными параметрами текущего считываемого элемента.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно считывает текущий элемент и возвращает содержимое как объект <see cref="T:System.Object" />.</summary>
        <returns>Упакованный объект CLR наиболее подходящего типа. Свойство <see cref="P:System.Xml.XmlReader.ValueType" /> служит для определения подходящего типа CLR. Если содержимое типизировано как тип списка, этот метод возвращает массив упакованных объектов соответствующего типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Считывает текущий элемент и возвращает содержимое объекта <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : unit -&gt; string&#xA;override this.ReadElementContentAsString : unit -&gt; string" Usage="xmlReader.ReadElementContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает текущий элемент и возвращает содержимое объекта <see cref="T:System.String" />.</summary>
        <returns>Содержимое элемента в виде объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Дополнительные сведения см. в подразделе "Примечания" на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>.  
  
   
  
## Examples  
 В следующем примере считывается элемент `stringValue` и возвращается текстовое содержимое (без учета комментария и инструкции по обработке).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#1)]
 [!code-vb[XmlReader.ReadElementContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#1)]  
  
 В примере в качестве входных данных используется файл `dataFile.xml`.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
- или - 
Содержимое элемента нельзя преобразовать в объект <see cref="T:System.String" />.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : string * string -&gt; string&#xA;override this.ReadElementContentAsString : string * string -&gt; string" Usage="xmlReader.ReadElementContentAsString (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя элемента.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен элемента.</param>
        <summary>Проверяет соответствие указанного URI локального имени и пространства имен с URI текущего элемента, затем считывает текущий элемент и возвращает содержимое как объект <see cref="T:System.String" />.</summary>
        <returns>Содержимое элемента в виде объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод считывает начальный тег, содержимое элемента и перемещает модуль чтения после тега конечного элемента. Он расширяет сущности и игнорирует инструкции по обработке и комментарии. Элемент может содержать только простое содержимое. То есть у него не может быть дочерних элементов.  
  
 Дополнительные сведения см. в подразделе "Примечания" на странице справочника по <xref:System.Xml.XmlReader> и рекомендации [консорциума W3C по схеме XML, часть 2: типы](https://go.microsoft.com/fwlink/?LinkId=4871) данных.  
  
   
  
## Examples  
 В следующем примере считывается элемент `stringValue` и возвращается текстовое содержимое (без учета комментария и инструкции по обработке).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#2)]
 [!code-vb[XmlReader.ReadElementContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#2)]  
  
 В примере в качестве входных данных используется файл `dataFile.xml`.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Xml.XmlReader" /> не расположен на элементе.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.Xml.XmlException">Текущий элемент содержит дочерние элементы.  
  
- или - 
Содержимое элемента нельзя преобразовать в объект <see cref="T:System.String" />.</exception>
        <exception cref="T:System.ArgumentNullException">Метод вызван с аргументами <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Указанное локальное имя и URI пространства имен не совпадают с аналогичными параметрами текущего считываемого элемента.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadElementContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadElementContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadElementContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadElementContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно считывает текущий элемент и возвращает содержимое как объект <see cref="T:System.String" />.</summary>
        <returns>Содержимое элемента в виде объекта <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Считывает простые текстовые элементы. Однако рекомендуем использовать вместо этого метод <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" />, предполагающий более простой способ обработки данной операции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для чтения текстового элемента рекомендуется использовать метод <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : unit -&gt; string&#xA;override this.ReadElementString : unit -&gt; string" Usage="xmlReader.ReadElementString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает элемент, предназначенный только для чтения. Однако рекомендуем использовать вместо этого метод <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />, предполагающий более простой способ обработки данной операции.</summary>
        <returns>Текст, содержащийся в считываемом элементе. Пустая строка, если элемент пуст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для чтения текстового элемента рекомендуется использовать метод <xref:System.Xml.XmlReader.ReadElementContentAsString>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Следующий узел содержимого не является открывающим тегом или найденный элемент не содержит простого текстового значения.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string -&gt; string&#xA;override this.ReadElementString : string -&gt; string" Usage="xmlReader.ReadElementString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Имя для проверки.</param>
        <summary>Проверяет перед чтением текстового элемента соответствие значения свойства <see cref="P:System.Xml.XmlReader.Name" /> найденного элемента и заданной строки. Однако рекомендуем использовать вместо этого метод <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />, предполагающий более простой способ обработки данной операции.</summary>
        <returns>Текст, содержащийся в считываемом элементе. Пустая строка, если элемент пуст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для чтения текстового элемента рекомендуется использовать метод <xref:System.Xml.XmlReader.ReadElementContentAsString>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Если следующий узел содержимого не является открывающим тегом, элемент <see langword="Name" /> не соответствует заданному аргументу или найденный элемент не содержит простого текстового значения.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (localname As String, ns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string * string -&gt; string&#xA;override this.ReadElementString : string * string -&gt; string" Usage="xmlReader.ReadElementString (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ns" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="localname">Локальное имя для проверки.</param>
        <param name="ns">URI пространства имен для проверки.</param>
        <summary>Проверяет перед чтением текстового элемента соответствие значений свойств <see cref="P:System.Xml.XmlReader.LocalName" /> и <see cref="P:System.Xml.XmlReader.NamespaceURI" /> найденного элемента и заданных строк. Однако рекомендуем использовать вместо этого метод <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />, предполагающий более простой способ обработки данной операции.</summary>
        <returns>Текст, содержащийся в считываемом элементе. Пустая строка, если элемент пуст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для чтения текстового элемента рекомендуется использовать метод <xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Если следующий узел содержимого не является открывающим тегом, элемент <see langword="LocalName" /> или <see langword="NamespaceURI" /> не соответствует заданным аргументам или найденный элемент не содержит простого текстового значения.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEndElement">
      <MemberSignature Language="C#" Value="public virtual void ReadEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadEndElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadEndElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadEndElement : unit -&gt; unit&#xA;override this.ReadEndElement : unit -&gt; unit" Usage="xmlReader.ReadEndElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Проверяет, является ли текущий узел содержимого закрывающим тегом, и позиционирует средство чтения на следующий узел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере выводится текстовое содержимое каждого элемента.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 В примере используется файл `book3.xml`.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Текущий узел не является закрывающим тегом или если во входном потоке обнаружен неверный XML.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadStartElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXml">
      <MemberSignature Language="C#" Value="public virtual string ReadInnerXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadInnerXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadInnerXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXml : unit -&gt; string&#xA;override this.ReadInnerXml : unit -&gt; string" Usage="xmlReader.ReadInnerXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе считывает все содержимое, включая разметку, как строку.</summary>
        <returns>Все содержимое XML-кода в текущем узле, включая разметку. Если текущий узел не имеет дочерних узлов, возвращается пустая строка.  
  
 Если текущий узел не является элементом или атрибутом, возвращается пустая строка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает все содержимое текущего узла, включая разметку. Текущий узел (открывающий тег) и соответствующий ему конечный узел (закрывающий тег) не возвращаются. Например, если у вас есть следующее:  
  
```xml  
<node>  
 this <child id="123"/>  
</node>  
```  
  
 `ReadInnerXml` возвращает `this <child id="123"/>`  
  
 Этот метод обрабатывает узлы элементов и атрибутов следующим образом:  
  
|Тип узла|Расположение перед вызовом|XML-фрагмент|Возвращаемое значение|Расположение после вызова|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|В открывающем теге `item1`.|\<Item1 > Текст1\</Item1 >\<Item2 > Текст2\</Item2 >|text1|В открывающем теге `item2`.|  
|`Attribute`|В узле атрибута `attr1`.|\<Item attr1 = "val1" attr2 = "val2" > Text\</Item >|val1|Остается в узле атрибута `attr1`.|  
  
 Если модуль чтения располагается в конечном узле, вызов метода `ReadInnerXml` будет равносилен вызову метода <xref:System.Xml.XmlReader.Read%2A>. Метод возвращает `String.Empty` (за исключением узлов атрибутов, в этом случае возвращается значение атрибута).  
  
 Этот метод проверяет правильность XML-кода. Если `ReadInnerXml` вызывается из <xref:System.Xml.XmlValidatingReader>, этот метод также проверяет возвращаемое содержимое.  
  
 Как реализовано в классах <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> и `XmlValidatingReader`, метод `ReadOuterXml` учитывает пространство имен.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>.  
  
   
  
## Examples  
 В следующем примере сравниваются методы `ReadInnerXml` и <xref:System.Xml.XmlReader.ReadOuterXml%2A>.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 В примере используется `2books.xml` File в качестве входных данных.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Неправильный формат XML, или при синтаксическом анализе XML произошла ошибка.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadInnerXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadInnerXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadInnerXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadInnerXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно считывает все содержимое, включая разметку, в виде строки.</summary>
        <returns>Все содержимое XML-кода в текущем узле, включая разметку. Если текущий узел не имеет дочерних узлов, возвращается пустая строка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.ReadInnerXml%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXml">
      <MemberSignature Language="C#" Value="public virtual string ReadOuterXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadOuterXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadOuterXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXml : unit -&gt; string&#xA;override this.ReadOuterXml : unit -&gt; string" Usage="xmlReader.ReadOuterXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе считывает содержимое в виде строки, включая разметку, предоставляющую этот узел и все его дочерние узлы.</summary>
        <returns>Если средство чтения позиционировано на узел элемента или атрибута, данный метод возвращает все содержимое XML текущего узла и всех его дочерних узлов, включая разметку; в противном случае возвращается пустая строка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод аналогичен <xref:System.Xml.XmlReader.ReadInnerXml%2A>, за исключением того, что он также возвращает начальный и конечный теги.  
  
 Этот метод обрабатывает узлы элементов и атрибутов следующим образом:  
  
|Тип узла|Расположение перед вызовом|XML-фрагмент|Возвращаемое значение|Расположение после вызова|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|В открывающем теге `item1`.|\<Item1 > Текст1\</Item1 >\<Item2 > Текст2\</Item2 >|\<Item1 > Текст1\</Item1 >|В открывающем теге `item2`.|  
|`Attribute`|В узле атрибута `attr1`.|\<Item attr1 = "val1" attr2 = "val2" > Text\</Item >|attr1 = "val1"|Остается в узле атрибута `attr1`.|  
  
 Если модуль чтения располагается в конечном узле, вызов метода `ReadOuterXml` будет равносилен вызову метода <xref:System.Xml.XmlReader.Read%2A>. Метод возвращает `String.Empty` (за исключением узлов атрибутов, в этом случае возвращается разметка атрибута).  
  
 Этот метод проверяет правильность XML-кода. Если `ReadOuterXml` вызывается из <xref:System.Xml.XmlValidatingReader>, этот метод также проверяет возвращаемое содержимое.  
  
 Как реализовано в классах <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> и `XmlValidatingReader`, метод `ReadOuterXml` учитывает пространство имен. При указании следующего XML-текста `<A xmlns:S="urn:1"><S:B>hello</S:B></A>`, если средство чтения было размещено в `S:B` открывающем теге, `ReadOuterXml` возвращает `<S:B xmlns:S="urn:1">hello<S:B/>`.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>.  
  
   
  
## Examples  
 В следующем примере сравниваются методы `ReadInnerXml` и `ReadOuterXml`.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 В примере используется `2books.xml` File в качестве входных данных.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Неправильный формат XML, или при синтаксическом анализе XML произошла ошибка.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadOuterXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadOuterXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadOuterXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadOuterXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно считывает содержимое в виде строки, включая разметку, предоставляющую этот узел и все его дочерние узлы.</summary>
        <returns>Если средство чтения позиционировано на узел элемента или атрибута, данный метод возвращает все содержимое XML текущего узла и всех его дочерних узлов, включая разметку; в противном случае возвращается пустая строка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.ReadOuterXml%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Проверяет, является ли текущий узел элементом и перемещает средство чтения на следующий узел.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : unit -&gt; unit&#xA;override this.ReadStartElement : unit -&gt; unit" Usage="xmlReader.ReadStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Проверяет, является ли текущий узел элементом и перемещает модуль чтения к следующему узлу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает <xref:System.Xml.XmlReader.IsStartElement%2A>, за которым следует <xref:System.Xml.XmlReader.Read%2A>, чтобы расположить вас на содержимом этого элемента, найденного во входном потоке.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">В входном потоке обнаружен неправильный XML.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string -&gt; unit&#xA;override this.ReadStartElement : string -&gt; unit" Usage="xmlReader.ReadStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Полное имя элемента.</param>
        <summary>Проверяет, является ли текущий узел элементом с заданным <see cref="P:System.Xml.XmlReader.Name" />, и перемещает средство чтения на следующий узел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода соответствует вызову <xref:System.Xml.XmlReader.IsStartElement%2A>, за которым следует вызов <xref:System.Xml.XmlReader.Read%2A>.  
  
   
  
## Examples  
 В следующем примере выводится текстовое содержимое каждого элемента.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 В примере используется файл `book3.xml`.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">В входном потоке обнаружен неправильный XML.  
  
- или - 
<see cref="P:System.Xml.XmlReader.Name" /> элемента не соответствует заданному <paramref name="name" />.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (localname As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string * string -&gt; unit&#xA;override this.ReadStartElement : string * string -&gt; unit" Usage="xmlReader.ReadStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Локальное имя элемента.</param>
        <param name="ns">Универсальный код ресурса (URI) пространства имен элемента.</param>
        <summary>Проверяет, является ли текущий узел элементом с заданным <see cref="P:System.Xml.XmlReader.LocalName" /> и <see cref="P:System.Xml.XmlReader.NamespaceURI" />, и перемещает средство чтения на следующий узел.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода соответствует вызову <xref:System.Xml.XmlReader.IsStartElement%2A>, за которым следует вызов <xref:System.Xml.XmlReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">В входном потоке обнаружен неправильный XML.  
  
- или - 
Свойства <see cref="P:System.Xml.XmlReader.LocalName" /> и <see cref="P:System.Xml.XmlReader.NamespaceURI" /> найденного элемента не совпадают с предоставленными аргументами.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadState : System.Xml.ReadState" Usage="System.Xml.XmlReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Когда переопределено в производном классе, возвращает состояние средства чтения.</summary>
        <value>Одно из значений перечисления, определяющее состояние средства чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Xml.XmlReader.ReadState%2A> имеет одно из следующих значений:  
  
-   <xref:System.Xml.ReadState.Initial>, при вызове метода <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>.  
  
-   <xref:System.Xml.ReadState.Interactive>, при вызове метода <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>, а также в модуле чтения могут вызываться дополнительные методы.  
  
-   <xref:System.Xml.ReadState.EndOfFile>, когда конец XML-документа был успешно достигнут.  
  
-   <xref:System.Xml.ReadState.Closed>, при вызове метода <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType>.  
  
-   <xref:System.Xml.ReadState.Error>, когда ошибка препятствует продолжению операции чтения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="abstract member ReadString : unit -&gt; string&#xA;override this.ReadString : unit -&gt; string" Usage="xmlReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе считывает содержимое узла элемента или текстового узла в виде строки. Однако рекомендуем использовать вместо этого метод <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" />, предполагающий более простой способ обработки данной операции.</summary>
        <returns>Содержимое элемента или пустая строка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Рекомендуется использовать метод <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> для чтения содержимого элемента или текстового узла в виде строки.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Произошла ошибка при синтаксическом анализе XML.</exception>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSubtree">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReader ReadSubtree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlReader ReadSubtree() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadSubtree" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSubtree () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlReader ^ ReadSubtree();" />
      <MemberSignature Language="F#" Value="abstract member ReadSubtree : unit -&gt; System.Xml.XmlReader&#xA;override this.ReadSubtree : unit -&gt; System.Xml.XmlReader" Usage="xmlReader.ReadSubtree " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает новый экземпляр <see langword="XmlReader" />, который может использоваться для считывания текущего узла и всех его потомков.</summary>
        <returns>Новый экземпляр средства чтения XML задается как <see cref="F:System.Xml.ReadState.Initial" />. Вызов метода <see cref="M:System.Xml.XmlReader.Read" /> приводит к позиционированию нового средства чтения на узле, который являлся текущим до вызова метода <see cref="M:System.Xml.XmlReader.ReadSubtree" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadSubtree%2A> можно вызывать только для узлов элементов. При считывании всего поддерева вызовы метода <xref:System.Xml.XmlReader.Read%2A> возвращают `false`. После закрытия нового модуля чтения XML исходный модуль чтения размещается на `EndElement` узле вложенного дерева. Таким способом, если вы вызывали метод <xref:System.Xml.XmlReader.ReadSubtree%2A> в открывающем теге элемента Book, после того, как поддерево было считано и было закрыто новое средство чтения XML, исходное средство чтения XML позиционируется в конце тега элемента Book.  
  
 Пока не будет закрыт новый модуль чтения, не следует выполнять никаких операций с первоначальным модулем. Такие действия не поддерживаются и могут привести к непредсказуемым эффектам.  
  
> [!NOTE]
>  Метод <xref:System.Xml.XmlReader.ReadSubtree%2A> не предназначен для создания копий XML-данных, с которыми можно работать независимо. Он предназначен для создания границы вокруг элемента XML. Это полезно, если требуется передать данные в другой компонент для обработки и ограничить объем данных, к которым компонент может получить доступ. При передаче средства чтения XML, возвращенного методом <xref:System.Xml.XmlReader.ReadSubtree%2A>, в другое приложение приложение может получить доступ только к этому XML-элементу, а не ко всему XML-документу.  
  
   
  
## Examples  
 В следующем примере показано, как использовать метод <xref:System.Xml.XmlReader.ReadSubtree%2A>.  
  
 [!code-csharp[XmlReaderBasic#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#13)]
 [!code-vb[XmlReaderBasic#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#13)]  
  
 Используйте следующие XML-данные для выполнения примеров в этом разделе:  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<Books>  
  <Book>  
    <Title>A Brief History of Time</Title>  
  </Book>  
  <Book>  
    <Title>Principle Of Relativity</Title>  
  </Book>  
  <Book>  
    <Title>Victory of Reason</Title>  
  </Book>  
  <Book>  
    <Title>The Unicorn that did not Fail</Title>  
  </Book>  
  <Book>  
    <Title>Rational Ontology</Title>  
  </Book>  
  <Book>  
    <Title>The Meaning of Pizza</Title>  
  </Book>  
</Books>  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Средство чтения XML не расположено на элементе при вызове этого метода.

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToDescendant">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Переводит <see cref="T:System.Xml.XmlReader" /> к следующему сопоставленному элементу-потомку.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string -&gt; bool&#xA;override this.ReadToDescendant : string -&gt; bool" Usage="xmlReader.ReadToDescendant name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Проверенное имя элемента, на который следует переместиться.</param>
        <summary>Переводит <see cref="T:System.Xml.XmlReader" /> к следующему сопоставленному элементу-потомку с указанным проверенным именем.</summary>
        <returns><see langword="true" />, если найден сопоставленный элемент-потомок; в противном случае — <see langword="false" />. Если сопоставленный дочерний элемент не найден, средство чтения <see cref="T:System.Xml.XmlReader" /> позиционируется на закрывающем теге (<see cref="P:System.Xml.XmlReader.NodeType" /> является <see langword="XmlNodeType.EndElement" />) родительского элемента.  
  
Если средство чтения <see cref="T:System.Xml.XmlReader" /> не размещено на элементе при вызове метода <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />, последний возвращает значение <see langword="false" /> и положение <see cref="T:System.Xml.XmlReader" /> не изменяется.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере выполняется анализ второго узла книги.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 В этом примере в качестве входных данных используется файл `2books.xml`.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentException">Параметр является пустой строкой.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string * string -&gt; bool&#xA;override this.ReadToDescendant : string * string -&gt; bool" Usage="xmlReader.ReadToDescendant (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя элемента, на который следует переместиться.</param>
        <param name="namespaceURI">URI пространства имен элемента, на который следует переместиться.</param>
        <summary>Переводит <see cref="T:System.Xml.XmlReader" /> к следующему элементу-потомку с указанным локальным именем и URI пространства имен.</summary>
        <returns><see langword="true" />, если найден сопоставленный элемент-потомок; в противном случае — <see langword="false" />. Если сопоставленный дочерний элемент не найден, средство чтения <see cref="T:System.Xml.XmlReader" /> позиционируется на закрывающем теге (<see cref="P:System.Xml.XmlReader.NodeType" /> является <see langword="XmlNodeType.EndElement" />) родительского элемента.  
  
Если средство чтения <see cref="T:System.Xml.XmlReader" /> не размещено на элементе при вызове метода <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />, последний возвращает значение <see langword="false" /> и положение <see cref="T:System.Xml.XmlReader" /> не изменяется.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentNullException">Оба параметра имеют значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToFollowing">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Выполняет чтение до обнаружения именованного элемента.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string -&gt; bool&#xA;override this.ReadToFollowing : string -&gt; bool" Usage="xmlReader.ReadToFollowing name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Полное имя элемента.</param>
        <summary>Выполняет чтение до обнаружения элемента с указанным полным именем.</summary>
        <returns>Значение <see langword="true" />, если найден соответствующий элемент; в противном случае —<see langword="false" /> и перемещение <see cref="T:System.Xml.XmlReader" /> в конец файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод функционально эквивалентен выполнению `following::name` выражения XPath из текущего узла. Он обеспечивает быстрый способ поиска именованного элемента в XML-документе. Он перемещает средство чтения к следующему следующему элементу, который соответствует заданному имени, и возвращает `true`, если найден соответствующий элемент. Используя приведенный ниже пример, читатель считывает данные в первый экземпляр указанного элемента при чтении вперед.  
  
```xml  
<!--"sample.xml"-->  
<?xml version="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item");  
  
```  
  
 Этот метод может быть вызван для всех типов узлов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentException">Параметр является пустой строкой.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string * string -&gt; bool&#xA;override this.ReadToFollowing : string * string -&gt; bool" Usage="xmlReader.ReadToFollowing (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя элемента.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен элемента.</param>
        <summary>Выполняет чтение до обнаружения указанных локального имени и URI пространства имен.</summary>
        <returns>Значение <see langword="true" />, если найден соответствующий элемент; в противном случае —<see langword="false" /> и перемещение <see cref="T:System.Xml.XmlReader" /> в конец файла.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод функционально эквивалентен выполнению `following::name` выражения XPath из текущего узла. Он обеспечивает быстрый способ поиска именованного элемента в XML-документе. Он перемещает средство чтения к следующему следующему элементу, который соответствует заданному имени, и возвращает `true`, если найден соответствующий элемент.  
  
```xml  
<!--"sample.xml"-->  
<?xml version="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item", "urn:1");  
  
```  
  
 Этот метод может быть вызван для всех типов узлов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentNullException">Оба параметра имеют значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToNextSibling">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <summary>Переводит <see langword="XmlReader" /> к следующему сопоставленному родственному элементу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string -&gt; bool&#xA;override this.ReadToNextSibling : string -&gt; bool" Usage="xmlReader.ReadToNextSibling name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Проверенное имя родственного элемента, на который следует переместиться.</param>
        <summary>Переводит <see langword="XmlReader" /> к следующему сопоставленному родственному элементу с указанным проверенным именем.</summary>
        <returns><see langword="true" />, если найден сопоставленный родственный элемент; в противном случае — <see langword="false" />. Если такой элемент не найден, средство чтения <see langword="XmlReader" /> позиционируется на закрывающем теге (<see cref="P:System.Xml.XmlReader.NodeType" /> является <see langword="XmlNodeType.EndElement" />) родительского элемента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Не вызывайте <xref:System.Xml.XmlReader.ReadToNextSibling%2A>, если `XmlReader` является начальным состоянием (<xref:System.Xml.XmlReader.ReadState%2A> <xref:System.Xml.ReadState.Initial>). Можно вызвать <xref:System.Xml.XmlReader.Read%2A>, чтобы переместить `XmlReader`, а затем вызвать метод <xref:System.Xml.XmlReader.ReadToNextSibling%2A>.  
  
   
  
## Examples  
 В следующем примере считывается атрибут ISBN для каждого узла книги.  
  
 [!code-csharp[XmlReaderBasic#15](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#15)]
 [!code-vb[XmlReaderBasic#15](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentException">Параметр является пустой строкой.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string * string -&gt; bool&#xA;override this.ReadToNextSibling : string * string -&gt; bool" Usage="xmlReader.ReadToNextSibling (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя элемента того же уровня, на который следует переместиться.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен элемента того же уровня, на который следует переместиться.</param>
        <summary>Переводит <see langword="XmlReader" /> к следующему элементу того же уровня с указанным локальным именем и URI пространства имен.</summary>
        <returns>Значение <see langword="true" />, если найден сопоставленный элемент с тем же родительским элементом. В противном случае — значение <see langword="false" />. Если такой элемент не найден, средство чтения <see langword="XmlReader" /> позиционируется на закрывающем теге (<see cref="P:System.Xml.XmlReader.NodeType" /> является <see langword="XmlNodeType.EndElement" />) родительского элемента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Не вызывайте <xref:System.Xml.XmlReader.ReadToNextSibling%2A>, если `XmlReader` является начальным состоянием (<xref:System.Xml.XmlReader.ReadState%2A> <xref:System.Xml.ReadState.Initial>). Можно вызвать <xref:System.Xml.XmlReader.Read%2A>, чтобы переместить `XmlReader`, а затем вызвать метод <xref:System.Xml.XmlReader.ReadToNextSibling%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentNullException">Оба параметра имеют значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual int ReadValueChunk (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadValueChunk(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunk (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadValueChunk(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunk : char[] * int * int -&gt; int&#xA;override this.ReadValueChunk : char[] * int * int -&gt; int" Usage="xmlReader.ReadValueChunk (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив символов, выполняющий функции буфера, в который записывается текстовое содержимое. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, где <see cref="T:System.Xml.XmlReader" /> может начать копировать результаты.</param>
        <param name="count">Максимальное число копируемых в буфер символов. Этот метод возвращает фактическое количество скопированных символов.</param>
        <summary>Считывает большие потоки текста, внедренного в XML-документ.</summary>
        <returns>Количество символов, считанных в буфер. По окончании текстового содержимого возвращается нуль.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет считывать очень большие потоки текста, внедренные в XML-документ в потоковой манере, то есть небольшое количество символов за раз, вместо того чтобы выделять одну строку для всего значения. Этот метод может быть вызван для любого узла, имеющего значение (<xref:System.Xml.XmlReader.HasValue%2A> `true`), однако фактическая потоковая передача значения узла происходит только при вызове на узлах текста, пробелов и значащих пробелов. Другие значения типа узла кэшируются, включая атрибуты и узлы CDATA.  
  
 Этот метод возвращает только содержимое свойства <xref:System.Xml.XmlReader.Value%2A> и не перемещает <xref:System.Xml.XmlReader>.  
  
 Этот метод считывает указанное число символов (`count`) значения узла в символьный буфер (`buffer`) с указанным смещением (`index`) и возвращает число символов, записанных в буфер. Он возвращает `0` по достижении конца значения. Его невозможно перезапустить для повторного считывания значения.  
  
 В между вызовами <xref:System.Xml.XmlReader.ReadValueChunk%2A> свойства <xref:System.Xml.XmlReader> не изменяются, за исключением свойства <xref:System.Xml.XmlReader.Value%2A>. При доступе к свойству <xref:System.Xml.XmlReader.Value%2A> оно может возвращать частичное значение (с символами, которые еще не возвращены <xref:System.Xml.XmlReader.ReadValueChunk%2A>) или полным значением в зависимости от реализации. Все реализации <xref:System.Xml.XmlReader> в пространстве имен <xref:System.Xml> возвращают частичное значение для реализации свойства <xref:System.Xml.XmlReader.Value%2A>.  
  
 Любой метод Read может быть вызван между вызовами <xref:System.Xml.XmlReader.ReadValueChunk%2A>. В этом случае <xref:System.Xml.XmlReader> переходит к следующему <xref:System.Xml.XmlNodeType> в потоке, и все невозвращенные символы пропускаются.  
  
 Может возникнуть ситуация, когда <xref:System.Xml.XmlReader.ReadValueChunk%2A> возвращает меньше запрошенного количества символов. Например, если имеется 200-символьное длинное значение с суррогатной парой в позициях 127 и 128, и вы вызывали <xref:System.Xml.XmlReader.ReadValueChunk%2A> с помощью буфера 128-character, вызов метода будет возвращать не более 127 символов вместо запрошенных 128. Суррогатная пара затем будет возвращена при следующем вызове <xref:System.Xml.XmlReader.ReadValueChunk%2A>. В этом случае <xref:System.Xml.XmlReader.ReadValueChunk%2A> не вернула запрошенные 128 символов, так как это привело бы к тому, что в конце буфера будет обнаружена неполная суррогатная пара.  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">У текущего узла нет значения (значение свойства <see cref="P:System.Xml.XmlReader.HasValue" /> — <see langword="false" />).

- или - 
Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="buffer" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение индекса в буфере или сумма значений индекса и счетчика больше, чем выделенный размер буфера.</exception>
        <exception cref="T:System.NotSupportedException">Реализация <see cref="T:System.Xml.XmlReader" /> не поддерживает данный метод.</exception>
        <exception cref="T:System.Xml.XmlException">Данные XML имеют неправильный формат.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunkAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadValueChunkAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadValueChunkAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunkAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunkAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadValueChunkAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadValueChunkAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив символов, выполняющий функции буфера, в который записывается текстовое содержимое. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, где <see cref="T:System.Xml.XmlReader" /> может начать копировать результаты.</param>
        <param name="count">Максимальное число копируемых в буфер символов. Этим методом возвращается фактическое количество скопированных символов.</param>
        <summary>Асинхронно считывает большие потоки текста, внедренного в XML-документ.</summary>
        <returns>Количество символов, считанных в буфер. По окончании текстового содержимого возвращается нуль.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.ReadValueChunk%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".
- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public abstract void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResolveEntity();" />
      <MemberSignature Language="F#" Value="abstract member ResolveEntity : unit -&gt; unit" Usage="xmlReader.ResolveEntity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе разрешает ссылки для сущностей для узлов <see langword="EntityReference" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если модуль чтения находится на `EntityReference` узле (`XmlNodeType.EntityReference`), то при вызове <xref:System.Xml.XmlReader.Read%2A> после вызова этого метода выполняется синтаксический анализ замещающего текста сущности. Когда замещающий текст сущности закончится, возвращается узел `EndEntity`, чтобы закрыть область ссылки на сущность.  
  
> [!NOTE]
>  Если после вызова этого метода сущность является частью значения атрибута, необходимо вызвать метод <xref:System.Xml.XmlReader.ReadAttributeValue%2A>, чтобы выполнить шаг с заходом в сущность.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Средство чтения не расположено на узле <see langword="EntityReference" />; эта реализация средства чтения не может разрешить сущности (свойство <see cref="P:System.Xml.XmlReader.CanResolveEntity" /> возвращает значение <see langword="false" />).

- или -

Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="P:System.Xml.XmlReader.CanResolveEntity" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlReader.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает сведения схемы, которые были назначены текущему узлу в результате проверки схемы.</summary>
        <value><see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> содержит сведения схемы для текущего узла. Сведения схемы могут быть заданы для элементов, атрибутов или текстовых узлов со значением <see cref="P:System.Xml.XmlReader.ValueType" />, не являющимся нулевым (типизированные значения).  
  
Если текущий узел не является одним из приведенных выше типов узлов или если экземпляр <see langword="XmlReader" /> не указывает сведений схемы, это свойство возвращает <see langword="null" />.  
  
Если это свойство вызывается из объекта <see cref="T:System.Xml.XmlTextReader" /> или <see cref="T:System.Xml.XmlValidatingReader" />, это свойство всегда возвращает <see langword="null" />. Эти реализации <see langword="XmlReader" /> не раскрывают сведений схемы посредством свойства <see langword="SchemaInfo" />.  
  
 <block subset="none" type="note"><para>  
 Если требуется получить набор сведений PSVI (Post-Schema-Validation Information) для элемента, поместите объект чтения на конечный тег элемента, а не на его начальный элемент. Сведения PSVI доступны через свойство <see langword="SchemaInfo" /> объекта чтения. Проверяющий объект чтения, который создается с помощью метода <see cref="Overload:System.Xml.XmlReader.Create" />, и свойство <see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> которого имеет значение <see cref="F:System.Xml.ValidationType.Schema" />, содержит полные сведения PSVI для элемента только в том случае, если объект чтения помещается на конечный тег элемента.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Интерфейс <xref:System.Xml.Schema.IXmlSchemaInfo> предоставляет подмножество набора сведений после проверки схемы (PSVI), связанного с XML-узлом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Settings As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlReaderSettings ^ Settings { System::Xml::XmlReaderSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Xml.XmlReaderSettings" Usage="System.Xml.XmlReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Xml.XmlReaderSettings" />, используемый для создания данного экземпляра <see cref="T:System.Xml.XmlReader" />.</summary>
        <value>Объект <see cref="T:System.Xml.XmlReaderSettings" />, использованный для создания этого экземпляра средства чтения. Если это средство чтения не было создано с помощью метода <see cref="Overload:System.Xml.XmlReader.Create" />, это свойство возвращает <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Объект <xref:System.Xml.XmlReaderSettings> может содержать конфиденциальные сведения, такие как учетные данные пользователя. Приложения должны быть внимательны при кэшировании этого объекта или передаче его другому компоненту.  
  
 Класс <xref:System.Xml.XmlReaderSettings> используется для указания набора компонентов, которые должны поддерживаться в созданном экземпляре модуля чтения. Объект <xref:System.Xml.XmlReaderSettings>, возвращаемый этим свойством, нельзя изменить. Любая попытка изменить отдельные параметры приведет к возникновению исключения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public virtual void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Skip();" />
      <MemberSignature Language="F#" Value="abstract member Skip : unit -&gt; unit&#xA;override this.Skip : unit -&gt; unit" Usage="xmlReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пропускает дочерний узел текущего узла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующих входных данных XML, если средство чтения расположено на `<a>` узле или любом из его атрибутов, вызов `Skip` помещает модуль чтения на узел `<b>`.  
  
 Если модуль чтения уже расположен на конечном узле (например, `<x>` узле или текстовом узле `abc`), вызов `Skip` аналогичен вызову <xref:System.Xml.XmlReader.Read%2A>.  
  
```xml  
<a name="bob" age="123">  
 <x/>abc<y/>  
</a>  
<b>  
...  
</b>  
```  
  
 Этот метод проверяет правильность XML-кода.  
  
 Если модуль чтения является <xref:System.Xml.XmlValidatingReader>, этот метод также проверяет пропущенное содержимое.  
  
 Реализация `XmlReader` определяет, будет ли метод `Skip` расширять внешние сущности. В следующей таблице описано, разворачиваются ли внешние сущности для различных типов объектов `XmlReader`.  
  
|Тип XmlReader|Развертывает внешние сущности|  
|-----------------------|-------------------------------|  
|<xref:System.Xml.XmlTextReader>|Нет.|  
|<xref:System.Xml.XmlReader> экземпляр, созданный методом <xref:System.Xml.XmlReader.Create%2A>, считывающим текстовые данные.|Нет.|  
|<xref:System.Xml.XmlReader> экземпляр, созданный методом <xref:System.Xml.XmlReader.Create%2A>, который считывает двоичные данные.|Неприменимо.|  
|Проверка схемы <xref:System.Xml.XmlReader> экземпляра, созданного методом <xref:System.Xml.XmlReader.Create%2A>.|Да.|  
|<xref:System.Xml.XmlValidatingReader>|Да.|  
|<xref:System.Xml.XmlReader> экземпляр, возвращаемый объектом <xref:System.Xml.XPath.XPathNavigator>.|Неприменимо.|  
|<xref:System.Xml.XmlNodeReader>|Нет.|  
|<xref:System.Xml.XmlReader> экземпляр, заключенный в оболочку другого экземпляра <xref:System.Xml.XmlReader>.|Зависит от реализации базового <xref:System.Xml.XmlReader>. (Вызывается метод `Skip` в базовом <xref:System.Xml.XmlReader>).|  
  
 Асинхронную версию этого метода см. в разделе <xref:System.Xml.XmlReader.SkipAsync%2A>.  
  
   
  
## Examples  
 В следующем примере выполняется синтаксический анализ XML-файла, начиная с второго узла книги.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 В этом примере в качестве входных данных используется файл `2books.xml`.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SkipAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SkipAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.SkipAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SkipAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ SkipAsync();" />
      <MemberSignature Language="F#" Value="abstract member SkipAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.SkipAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlReader.SkipAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно пропускает дочерний узел текущего узла.</summary>
        <returns>Текущий узел.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это асинхронная версия <xref:System.Xml.XmlReader.Skip%2A>с теми же функциональными возможностями. Чтобы использовать этот метод, необходимо задать для флага <xref:System.Xml.XmlReaderSettings.Async%2A> значение `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".

- или -

Асинхронный метод <see cref="T:System.Xml.XmlReader" /> вызван без присваивания флагу <see cref="P:System.Xml.XmlReaderSettings.Async" /> значения <see langword="true" />. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Задайте параметру XmlReaderSettings.Async значение true, если хотите использовать асинхронные методы Async Methods".</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Асинхронное программирование с использованием ключевых слов Async и Await (C# и Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IDisposable.Dispose" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Xml.XmlReader> приведен к типу интерфейса <xref:System.IDisposable>.

Этот элемент может вести себя по-разному, если он используется в проекте [переносимой библиотеки классов](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) . Дополнительные сведения см. [в разделе различия в API в переносимой библиотеке классов](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/gg597392(v=vs.100)).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Xml.XmlReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Когда переопределено в производном классе, возвращает текстовое значение текущего узла.</summary>
        <value>Возвращаемое значение зависит от значения свойства <see cref="P:System.Xml.XmlReader.NodeType" /> узла. В следующей таблице представлен список возвращаемых типов узлов со значениями. Все прочие типы узлов возвращают значение <see langword="String.Empty" />.  
  
 <list type="table"><listheader><term> Тип узла 
 </term><description> Значение 
 </description></listheader><item><term><see langword="Attribute" /></term><description> Значение атрибута.  
  
 </description></item><item><term><see langword="CDATA" /></term><description> Содержимое раздела CDATA.  
  
 </description></item><item><term><see langword="Comment" /></term><description> Содержимое комментария.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Внутреннее подмножество.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Все содержимое, за исключением цели.  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description> Пустое пространство в разметке модели со смешанным содержимым.  
  
 </description></item><item><term><see langword="Text" /></term><description> Содержимое текстового узла.  
  
 </description></item><item><term><see langword="Whitespace" /></term><description> Пробелы между разметкой.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Содержимое декларации.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Асинхронную версию этого свойства см. в описании метода <xref:System.Xml.XmlReader.GetValueAsync%2A>.  
  
   
  
## Examples  
 В следующем примере считывается XML-файл и отображается каждый из узлов.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 В примере используется файл `items.xml`.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ValueType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ValueType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueType : Type" Usage="System.Xml.XmlReader.ValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип CLR текущего узла.</summary>
        <value>Тип CLR, соответствующий типизированному значению узла. Значение по умолчанию — <see langword="System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Список сопоставлений по умолчанию см. [в разделе Поддержка типов в классах System. XML](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) .  
  
 Элемент типа `xs:int` имеет `ValueType` `System.Int32` по умолчанию. Однако `ValueType` может быть одним из допустимых типов, которые можно сопоставить с `xs:int`, например `System.Int16` или `System.Double`.  
  
 Если узел не типизирован или узел является элементом, содержащим смешанное содержимое, значение узла сопоставляется с типом `System.String`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <block subset="none" type="overrides"><para>Разработчики должны предоставлять <see langword="ValueType" /> для каждого узла, даже если это только тип <see langword="System.String" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlLang As String" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlReader.XmlLang" />
      <MemberSignature Language="C#" Value="public abstract string XmlLang { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property XmlLang As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ XmlLang { System::String ^ get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает текущую область действия <see langword="xml:lang" />.</summary>
        <value>Текущая область действия <see langword="xml:lang" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство представляет область `xml:lang`, в которой находится текущий узел. Например, ниже приведен фрагмент XML с `xml:lang`, для которого в корневом элементе задан английский язык US:  
  
```xml  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 Если средство чтения находится на элементе `name`, можно использовать это свойство, чтобы определить, что оно находится в области атрибута английского языка (США) `xml:lang`.  
  
   
  
## Examples  
 Пример использования этого свойства см. в разделе <xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlSpace" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlSpace As XmlSpace" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlReader.XmlSpace" />
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlSpace XmlSpace { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property XmlSpace As XmlSpace" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>При переопределении в производном классе получает текущую область действия <see langword="xml:space" />.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Xml.XmlSpace" />. Если область действия <see langword="xml:space" /> отсутствует, данное свойство принимает значение <see langword="XmlSpace.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Пример использования этого свойства см. в разделе <xref:System.Xml.XmlTextReader.XmlSpace%2A> (в классе `XmlTextReader`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод <see cref="T:System.Xml.XmlReader" /> вызван перед завершением предыдущей асинхронной операции. В этом случае возникает исключение <see cref="T:System.InvalidOperationException" /> с сообщением "Асинхронная операция уже выполняется".</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlLang" />
      </Docs>
    </Member>
  </Members>
</Type>
