<Type Name="ClientScriptManager" FullName="System.Web.UI.ClientScriptManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6168b3c68c5da16b52610f467bf142b8c7177fe9" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70532605" /></Metadata><TypeSignature Language="C#" Value="public sealed class ClientScriptManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ClientScriptManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.ClientScriptManager" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ClientScriptManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ClientScriptManager sealed" />
  <TypeSignature Language="F#" Value="type ClientScriptManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Определяет методы для управления клиентскими скриптами в веб-приложениях.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager> Класс используется для управления клиентскими скриптами и их добавления в веб-приложения. Ссылку на <xref:System.Web.UI.ClientScriptManager> класс можно получить <xref:System.Web.UI.Page.ClientScript%2A> из свойства <xref:System.Web.UI.Page> объекта.  
  
 Клиентский скрипт можно добавить на веб-страницу декларативно, включив скрипт в HTML-разметку страницы. Однако существуют ситуации, когда требуется динамически добавлять клиентский скрипт. Чтобы динамически добавить скрипт, <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> используйте метод <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> , метод <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> , метод или <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метод, в зависимости от того, когда и как нужно добавить скрипт. Дополнительные сведения см. [в разделе инструкции. динамическое добавление клиентского скрипта в веб-страницы ASP.NET](https://msdn.microsoft.com/library/e89f1306-e43d-49ae-a66a-e18b71007666).  
  
 Класс однозначно определяет скрипты по ключу <xref:System.String> и  <xref:System.Type> .  <xref:System.Web.UI.ClientScriptManager> Скрипты с одинаковыми ключом и типом считаются дубликатами. Использование типа скрипта помогает избежать путаницы похожих сценариев из разных пользовательских элементов управления, которые могут использоваться на странице.  
  
 <xref:System.Web.UI.ClientScriptManager> Класс можно использовать для вызова клиентских обратных вызовов в ситуациях, когда желательно запускать серверный код из клиента без выполнения обратной передачи. Это называется выполнением нестандартного обратного вызова на сервер. При обратном вызове клиента функция клиентского скрипта отправляет асинхронный запрос на веб-страницу ASP.NET. Веб-страница запускает измененную версию своего обычного жизненного цикла для обработки обратного вызова. <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Используйте метод для получения ссылки на клиентскую функцию, которая при вызове инициирует обратный вызов клиента к серверному событию. Дополнительные сведения см. в разделе [реализация обратных вызовов клиента без обратной передачи](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  Обратные вызовы сценариев не будут работать в старых браузерах, которые не поддерживают модель DOM (DOM), и для них требуется, чтобы на клиенте был включен ECMAScript. Чтобы проверить, поддерживает ли браузер обратные вызовы, используйте <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> свойство, доступное <xref:System.Web.HttpRequest.Browser%2A> через свойство встроенного <xref:System.Web.HttpContext.Request%2A> объекта ASP.NET.  
  
 <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Используйте метод <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A>  и метод для определения события обратной передачи клиента. Эти методы позволяют выполнять функции клиентского скрипта при вызове, чтобы сервер переводился обратно на страницу. Событие обратной передачи клиента отличается от обратного вызова клиента в том, что веб-страница завершает нормальный жизненный цикл для обработки события обратной передачи клиента.  
  
> [!NOTE]
>  Если <xref:System.Web.UI.WebControls.Button> используется элемент управления `false` <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> и для свойства задано значение, то можно использовать <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод, чтобы вернуть клиентское событие обратной передачи для <xref:System.Web.UI.WebControls.Button> элемента управления.  
  
 Свойство элемента управления , <xref:System.Web.UI.WebControls.ImageButton>  элемента <xref:System.Web.UI.WebControls.LinkButton> управления и элемента управления можно использовать для запуска клиентского скрипта. <xref:System.Web.UI.WebControls.Button> <xref:System.Web.UI.WebControls.Button.OnClientClick%2A>  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метода <xref:System.Web.UI.ClientScriptManager> класса. На странице определены два клиентских скрипта: `PopupScript`, который отображает предупреждающее сообщение при загрузке страницы, и `ButtonClickScript`, определяющее обработчик клиента `onClick` для события кнопки HTML.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback" />
    <altmember cref="P:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp" />
    <related type="Article" href="https://msdn.microsoft.com/library/13edb6b9-2dea-43c6-b8c1-a47207de19aa">Клиентский скрипт в веб-страницы ASP.NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetCallbackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событию сервера.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Сервер <see cref="T:System.Web.UI.Control" />, обрабатывающий обратные вызовы клиента. Элемент управления должен реализовать интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" /> и предоставить метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Аргумент, передаваемый от клиентского скрипта серверу. 
 Метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Имя клиентского обработчика событий, который принимает результаты успешно выполненного события сервера.</param>
        <param name="context">Клиентский скрипт, оцениваемый на стороне клиента до инициализации обратного вызова. Результат скрипта отправляется обратно клиентскому обработчику событий.</param>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событию сервера. Клиентская функция для перегруженного метода включает указанный элемент управления, аргумент, клиентский скрипт и контекст.</summary>
        <returns>Имя клиентской функции, осуществляющей обратный вызов клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> Метод выполняет нестандартный обратный вызов сервера, который является измененной версией обычного жизненного цикла страницы. Дополнительные сведения см. в разделе [реализация обратных вызовов клиента без обратной передачи](https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
> [!NOTE]
>  При использовании обозревателя Microsoft Internet Explorer (версии 5,0 или более поздней) механизм обратного вызова скрипта реализуется через COM-объект Microsoft. XmlHttp и требует, чтобы браузер был настроен для запуска элементов управления ActiveX. Для других браузеров используется XMLHttpRequest, использующий локальный модель DOM браузера (DOM). Чтобы проверить, поддерживает ли браузер обратные вызовы клиента, используйте <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsCallback%2A> свойство. Чтобы проверить, поддерживает ли браузер XML через HTTP, используйте <xref:System.Web.Configuration.HttpCapabilitiesBase.SupportsXmlHttp%2A> свойство. Оба свойства доступны через <xref:System.Web.HttpRequest.Browser%2A> свойство встроенного объекта ASP.NET. <xref:System.Web.HttpContext.Request%2A>  
  
 <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> Перегрузка <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A>  метода выполняет обратный вызов синхронно с использованием XML через HTTP. При синхронной отправке данных в сценарии обратного вызова синхронные обратные вызовы немедленно возвращаются и не блокируют браузер. Два синхронных обратных вызова не могут выполняться одновременно в браузере. При срабатывании второго синхронного обратного вызова, когда он находится в состоянии ожидания, второй синхронный обратный вызов отменяет первый, а только второй обратный вызов возвратит.  
  
 Для асинхронной отправки данных используйте одну из перегрузок, принимающую `useAsync` параметр, который представляет собой логическое значение, контролирующее это поведение. В асинхронном сценарии можно использовать несколько ожидающих обратных вызовов. Однако порядок, в котором они возвращаются, не гарантированно соответствует порядку, в котором они были инициированы.  
  
 Кроме того, эта перегрузка <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метода указывает отсутствие клиентской функции для выполнения условия ошибки <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> , сформированного методом. Чтобы указать обработчик обратного вызова ошибок клиента, используйте одну из перегрузок, принимающих `clientErrorCallback` параметр.  
  
 Метод принимает необязательный строковый `argument` параметр и возвращает строку. <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%28System.Web.UI.Control%2CSystem.String%2CSystem.String%2CSystem.String%29> Чтобы передать или получить несколько значений, объедините значения из входных или возвращаемых строк соответственно.  
  
> [!NOTE]
>  Избегайте использования состояния представления в реализации свойств страницы или элемента управления, которые необходимо обновить во время операций обратного вызова скрипта. Если свойства должны содержаться в запросах страниц, можно использовать состояние сеанса.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать две перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метода в сценарии обратного вызова клиента, которые увеличивают целые числа.  
  
 Показаны два механизма обратного вызова. различие между ними заключается в использовании `context` параметра. Функция обратного вызова `context` клиента предоставляется с помощью параметра. `ReceiveServerData1` В отличие `ReceiveServerData2` от этого функция обратного вызова клиента определяется `<script>` в блоке на странице. Метод — это обработчик сервера, который увеличивает передаваемое ему значение, <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> а метод возвращает увеличенное значение в виде строки. <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> Если метод возвращает ошибку, `ProcessCallBackError` вызывается Клиентская функция. <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный элемент управления <see cref="T:System.Web.UI.Control" /> не реализует интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Сервер <see cref="T:System.Web.UI.Control" />, обрабатывающий обратные вызовы клиента. Элемент управления должен реализовать интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" /> и предоставить метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Аргумент, передаваемый от клиентского скрипта серверу. 
 Метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Имя клиентского обработчика событий, который принимает результаты успешно выполненного события сервера.</param>
        <param name="context">Клиентский скрипт, оцениваемый на стороне клиента до инициализации обратного вызова. Результат скрипта отправляется обратно клиентскому обработчику событий.</param>
        <param name="useAsync"><see langword="true" /> для выполнения обратного вызова асинхронно; <see langword="false" /> для выполнения обратного вызова синхронно.</param>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событиям сервера. Клиентская функция для перегруженного метода включает указанный элемент управления, аргумент, клиентский скрипт, контекст и логическое значение.</summary>
        <returns>Имя клиентской функции, осуществляющей обратный вызов клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для `useAsync` <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> этой `true` перегрузки метода требуется параметр, который позволяет асинхронно выполнять обратный вызов клиента, присвоив ему значение. Перегруженные версии этого метода, не требующие `useAsync` параметра, устанавливают `false` значение по умолчанию.  
  
 Дополнительные сведения об этом методе см. в комментариях к методу перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный элемент управления <see cref="T:System.Web.UI.Control" /> не реализует интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(string target, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.String,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCallbackEventReference (target As String, argument As String, clientCallback As String, context As String, clientErrorCallback As String, useAsync As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::String ^ target, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : string * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (target, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="target">Имя сервера <see cref="T:System.Web.UI.Control" />, обрабатывающего обратный вызов клиента. Элемент управления должен реализовать интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" /> и предоставить метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Аргумент, передаваемый от клиентского скрипта серверу. 
 Метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="clientCallback">Имя клиентского обработчика событий, который принимает результаты успешно выполненного события сервера.</param>
        <param name="context">Клиентский скрипт, оцениваемый на стороне клиента до инициализации обратного вызова. Результат скрипта отправляется обратно клиентскому обработчику событий.</param>
        <param name="clientErrorCallback">Имя клиентского обработчика событий, принимающего результат, когда в обработчике событий сервера возникает ошибка.</param>
        <param name="useAsync"><see langword="true" /> для выполнения обратного вызова асинхронно; <see langword="false" /> для выполнения обратного вызова синхронно.</param>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событиям сервера. Клиентская функция для перегруженного метода включает указанную цель, аргумент, клиентский скрипт, контекст, обработчик ошибок и логическое значение.</summary>
        <returns>Имя клиентской функции, осуществляющей обратный вызов клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метода `target` принимает <xref:System.Web.UI.Control> строковый параметр вместо параметра. Используйте эту перегрузку, если необходимо, чтобы обратный вызов перейдет к чему-либо, <xref:System.Web.UI.Control.UniqueID%2A> отличному от строки, содержащей элемент управления.  
  
 Кроме того, для этой перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метода `useAsync` требуется `clientErrorCallback` параметр и. Параметр позволяет асинхронно выполнять обратный вызов клиента, присвоив ему `true`значение. `useAsync` Перегруженные версии этого метода, не требующие `useAsync` параметра, устанавливают `false` значение по умолчанию. Параметр позволяет определить имя клиентской функции, вызываемой, если обработчик сервера <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> (метод) возвращает ошибку. `clientErrorCallback` Перегруженные версии этого метода, не требующие `clientErrorCallback` , чтобы параметр установил значение null.  
  
 Дополнительные сведения об этом методе см. в комментариях к методу перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> .  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать две перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метода в сценарии обратного вызова клиента, которые увеличивают целые числа.  
  
 Показаны два механизма обратного вызова. различие между ними заключается в использовании `context` параметра. Функция обратного вызова `context` клиента предоставляется с помощью параметра. `ReceiveServerData1` В отличие `ReceiveServerData2` от этого функция обратного вызова клиента определяется `<script>` в блоке на странице. Метод — это обработчик сервера, который увеличивает передаваемое ему значение, <xref:System.Web.UI.ICallbackEventHandler.GetCallbackResult%2A> а метод возвращает увеличенное значение в виде строки. <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> Если метод возвращает ошибку, вызывается Клиентская функция  `ProcessCallBackError` . <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A>  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/cs/getcallbackeventreference.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager7#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager7/vb/getcallbackeventreference.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetCallbackEventReference">
      <MemberSignature Language="C#" Value="public string GetCallbackEventReference (System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetCallbackEventReference(class System.Web.UI.Control control, string argument, string clientCallback, string context, string clientErrorCallback, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetCallbackEventReference(System.Web.UI.Control,System.String,System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetCallbackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, System::String ^ clientCallback, System::String ^ context, System::String ^ clientErrorCallback, bool useAsync);" />
      <MemberSignature Language="F#" Value="member this.GetCallbackEventReference : System.Web.UI.Control * string * string * string * string * bool -&gt; string" Usage="clientScriptManager.GetCallbackEventReference (control, argument, clientCallback, context, clientErrorCallback, useAsync)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="clientCallback" Type="System.String" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="clientErrorCallback" Type="System.String" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Сервер <see cref="T:System.Web.UI.Control" />, обрабатывающий обратные вызовы клиента. Элемент управления должен реализовать интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" /> и предоставить метод <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" />.</param>
        <param name="argument">Аргумент, передаваемый от клиентского скрипта методу <see cref="M:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent(System.String)" /> сервера.</param>
        <param name="clientCallback">Имя клиентского обработчика событий, который принимает результаты успешно выполненного события сервера.</param>
        <param name="context">Клиентский скрипт, оцениваемый на стороне клиента до инициализации обратного вызова. Результат скрипта отправляется обратно клиентскому обработчику событий.</param>
        <param name="clientErrorCallback">Имя клиентского обработчика событий, принимающего результат, когда в обработчике событий сервера возникает ошибка.</param>
        <param name="useAsync"><see langword="true" /> для выполнения обратного вызова асинхронно; <see langword="false" /> для выполнения обратного вызова синхронно.</param>
        <summary>Получает ссылку на клиентскую функцию, которая при вызове инициализирует обратный вызов клиента к событиям сервера. Клиентская функция для перегруженного метода включает указанный элемент управления, аргумент, клиентский скрипт, контекст, обработчик ошибок и логическое значение.</summary>
        <returns>Имя клиентской функции, осуществляющей обратный вызов клиента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для этой перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> метода `useAsync` требуется `clientErrorCallback` параметр и. Параметр позволяет асинхронно выполнять обратный вызов клиента, присвоив ему `true`значение. `useAsync` Перегруженные версии этого метода, не требующие `useAsync` параметра, устанавливают `false` значение по умолчанию. Параметр позволяет определить имя клиентской функции, вызываемой, если обработчик сервера <xref:System.Web.UI.ICallbackEventHandler.RaiseCallbackEvent%2A> (метод) возвращает ошибку. `clientErrorCallback` Перегруженные версии этого метода, не требующие `clientErrorCallback` , чтобы параметр установил значение null.  
  
 Дополнительные сведения об этом методе см. в комментариях к методу перегрузки <xref:System.Web.UI.ClientScriptManager.GetCallbackEventReference%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Указанный элемент управления <see cref="T:System.Web.UI.Control" /> не реализует интерфейс <see cref="T:System.Web.UI.ICallbackEventHandler" />.</exception>
        <altmember cref="T:System.Web.UI.ICallbackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackClientHyperlink">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает ссылку с добавленным <see langword="javascript:" /> в начале, которую можно использовать в клиентском событии для обратной передачи серверу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, обрабатывающий обратную передачу.</param>
        <param name="argument">Параметр, передаваемый серверному элементу управления.</param>
        <summary>Возвращает ссылку, с <see langword="javascript:" /> в начале, которую можно использовать в клиентском событии для обратной передачи серверу указанного элемента управления с указанными аргументами события.</summary>
        <returns>Строка, представляющая вызов JavaScript функции обратной передачи, включающей идентификатор целевого элемента управления и аргументы события.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для использования <xref:System.Web.UI.IPostBackEventHandler> метода требуется элемент управления, обрабатывающий обратную передачу для реализации интерфейса. <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Чтобы реализовать <xref:System.Web.UI.IPostBackEventHandler> интерфейс <xref:System.Web.UI.Page>для, используйте директиву.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> метода. Пользовательский элемент управления `MyControl`, <xref:System.Web.UI.IPostBackEventHandler> реализует интерфейс. При нажатии <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> элемента привязки HTML на странице вызывается метод пользовательского элемента управления.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Следующий пример кода имеет те же функциональные возможности, что и предыдущий, за исключением того, что вместо пользовательского элемента <xref:System.Web.UI.Page> управления класс <xref:System.Web.UI.IPostBackEventHandler> реализует интерфейс.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackClientHyperlink (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления, обрабатывающий обратную передачу.</param>
        <param name="argument">Параметр, передаваемый серверному элементу управления.</param>
        <param name="registerForEventValidation"><see langword="true" />, чтобы регистрировать событие обратной передачи для проверки; <see langword="false" />, чтобы не регистрировать событие обратной передачи для проверки.</param>
        <summary>Возвращает ссылку с добавленным <see langword="javascript:" /> в начале, которую можно использовать в клиентском событии для обратной передачи серверу для указанного элемента управления с указанными аргументами события и логическим обозначением, следует ли регистрировать обратную передачу для проверки события.</summary>
        <returns>Строка, представляющая вызов JavaScript функции обратной передачи, включающей идентификатор целевого элемента управления и аргументы события.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для использования <xref:System.Web.UI.IPostBackEventHandler> метода требуется элемент управления, обрабатывающий обратную передачу для реализации интерфейса. <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> Чтобы реализовать <xref:System.Web.UI.IPostBackEventHandler> интерфейс <xref:System.Web.UI.Page>для, используйте директиву.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions -&gt; string" Usage="clientScriptManager.GetPostBackEventReference options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options"><see cref="T:System.Web.UI.PostBackOptions" />, определяющий обратную передачу.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным экземпляром <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <returns>Строка, инициирующая клиентскую обратную передачу (при рассмотрении строки в качестве клиентского скрипта).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы реализовать <xref:System.Web.UI.IPostBackEventHandler> интерфейс <xref:System.Web.UI.Page>для, используйте директиву.  
  
 Метод можно использовать <xref:System.Web.UI.WebControls.Button> с элементом управления, если <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойство имеет `false`значение. <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> В этом сценарии <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод возвращает событие обратной передачи клиента <xref:System.Web.UI.WebControls.Button> для элемента управления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <see cref="T:System.Web.UI.PostBackOptions" /> равно <see langword="null" /></exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления <see cref="T:System.Web.UI.Control" />, обрабатывающий обратную передачу на сервер.</param>
        <param name="argument">Строка необязательных аргументов для передачи элементу управления, обрабатывающему обратную передачу.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным элементом управления, обрабатывающим обратную передачу, и строчным аргументом с дополнительной информацией о событии.</summary>
        <returns>Строка, инициирующая — при рассмотрении ее в качестве скрипта на стороне клиента — обратную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы реализовать <xref:System.Web.UI.IPostBackEventHandler> интерфейс <xref:System.Web.UI.Page>для, используйте директиву.  
  
 Метод можно использовать <xref:System.Web.UI.WebControls.Button> с элементом управления, если <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойство имеет `false`значение. <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> В этом сценарии <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод возвращает событие обратной передачи клиента <xref:System.Web.UI.WebControls.Button> для элемента управления.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метода. Пользовательский элемент управления `MyControl`, <xref:System.Web.UI.IPostBackEventHandler> реализует интерфейс. При нажатии <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> кнопки на странице вызывается метод пользовательского элемента управления.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreferencecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreferencevb.aspx#1)]  
  
 Следующий пример кода имеет те же функциональные возможности, что и предыдущий, за исключением того, что вместо пользовательского элемента <xref:System.Web.UI.Page> управления класс <xref:System.Web.UI.IPostBackEventHandler> реализует интерфейс.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/cs/getpostbackeventreference2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager8#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager8/vb/getpostbackeventreference2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.PostBackOptions options, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.PostBackOptions options, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.PostBackOptions,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPostBackEventReference (options As PostBackOptions, registerForEventValidation As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::PostBackOptions ^ options, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.PostBackOptions * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (options, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="options"><see cref="T:System.Web.UI.PostBackOptions" />, определяющий обратную передачу.</param>
        <param name="registerForEventValidation"><see langword="true" /> для регистрации ссылки на событие для проверки; в противном случае — <see langword="false" />.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным объектом <see cref="T:System.Web.UI.PostBackOptions" />. По выбору регистрирует ссылку на событие для проверки.</summary>
        <returns>Строка, инициирующая клиентскую обратную передачу (при рассмотрении строки в качестве клиентского скрипта).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы реализовать <xref:System.Web.UI.IPostBackEventHandler> интерфейс <xref:System.Web.UI.Page> для объекта, используйте директиву.  
  
 Метод можно использовать <xref:System.Web.UI.WebControls.Button> с элементом управления, если <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойство имеет `false`значение. <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> В этом сценарии <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод возвращает событие обратной передачи клиента <xref:System.Web.UI.WebControls.Button> для элемента управления.  
  
 Если `registerForEventValidation` имеет `true`значение , <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> метод вызывает метод, чтобы зарегистрировать ссылку на событие для проверки с уникальным идентификатором элемента управления, представляющим клиентский элемент управления, создающий событие. <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <see cref="T:System.Web.UI.PostBackOptions" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <altmember cref="T:System.Web.UI.WebControls.Button" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument, bool registerForEventValidation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument, bool registerForEventValidation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetPostBackEventReference(System.Web.UI.Control,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument, bool registerForEventValidation);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string * bool -&gt; string" Usage="clientScriptManager.GetPostBackEventReference (control, argument, registerForEventValidation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
        <Parameter Name="registerForEventValidation" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Серверный элемент управления <see cref="T:System.Web.UI.Control" />, обрабатывающий обратную передачу на сервер.</param>
        <param name="argument">Строка необязательных аргументов для передачи элементу управления <paramref name="control" />.</param>
        <param name="registerForEventValidation"><see langword="true" /> для регистрации ссылки на событие для проверки; в противном случае — <see langword="false" />.</param>
        <summary>Возвращает строку, которая может использоваться в клиентском событии для инициирования обратной передачи серверу. Строка ссылки определяется указанным элементом управления, обрабатывающим обратную передачу, и строчным аргументом с дополнительной информацией о событии. По выбору регистрирует ссылку на событие для проверки.</summary>
        <returns>Строка, инициирующая — при рассмотрении ее в качестве скрипта на стороне клиента — обратную передачу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы реализовать <xref:System.Web.UI.IPostBackEventHandler> интерфейс <xref:System.Web.UI.Page>для, используйте директиву.  
  
 Метод можно использовать <xref:System.Web.UI.WebControls.Button> с элементом управления, если <xref:System.Web.UI.WebControls.Button.UseSubmitBehavior%2A> свойство имеет `false`значение. <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> В этом сценарии <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> метод возвращает событие обратной передачи клиента <xref:System.Web.UI.WebControls.Button> для элемента управления.  
  
 Если `registerForEventValidation` имеет значение true <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%28System.Web.UI.PostBackOptions%2CSystem.Boolean%29> , метод вызывает <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%28System.String%2CSystem.String%29> метод, чтобы зарегистрировать ссылку на событие для проверки с уникальным идентификатором элемента управления, представляющим клиентский элемент управления, создающий событие.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Заданный объект <see cref="T:System.Web.UI.Control" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.PostBackOptions" />
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185">Обратные вызовы клиента без обратной передачи на страницах ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetWebResourceUrl">
      <MemberSignature Language="C#" Value="public string GetWebResourceUrl (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetWebResourceUrl(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetWebResourceUrl(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.GetWebResourceUrl : Type * string -&gt; string" Usage="clientScriptManager.GetWebResourceUrl (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип ресурса.</param>
        <param name="resourceName">Полное имя ресурса в сборке.</param>
        <summary>Возвращает ссылку URL-адреса на ресурс в сборке.</summary>
        <returns>Ссылка URL-адреса на ресурс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Метод возвращает ссылку URL-адреса на ресурс, внедренный в сборку. Возвращенная ссылка не является URL-адресом в кодировке. Ресурсы могут быть файлами скриптов, изображениями или любыми статическими файлами. Тип указывается на основе объекта, который будет обращаться к ресурсу.  
  
 Веб-ресурс, зарегистрированный на странице, однозначно идентифицируется по типу и имени. На странице можно зарегистрировать только один ресурс с заданной парой типа и именем. При попытке регистрации ресурса, который уже зарегистрирован, не создается дубликат зарегистрированного ресурса.  
  
 Метод используется в сочетании <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> с методом доступа к ресурсам, внедренным в сборки. <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> Дополнительные сведения об использовании ресурсов в приложениях см. в разделе [ASP.NET Web Page Resources Overview](https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd).  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.GetWebResourceUrl%2A> метода. Параметр *типа* в этом примере устанавливается в тип класса в сборке, содержащей ресурс. `resourceName` Параметр указывается с полным путем к ресурсу, который включает пространство имен по умолчанию.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 В следующем примере кода показано, как программно применить <xref:System.Web.UI.WebResourceAttribute> атрибут метаданных, чтобы пометить сборку для ресурсов, которые будут обслуживаться. Скомпилируйте следующий класс в библиотеке классов с пространством имен по умолчанию, `Samples.AspNet.CS.Controls` заданным как, или `Samples.AspNet.VB.Controls`, в зависимости от используемого языка.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Для этого примера требуется файл JavaScript с `Script_include.js`именем. JS-файл является внедренным ресурсом в сборке, содержащей `ClientScriptResourceLabel` объект. Если вы используете Visual Studio, в окно свойств проекта библиотеки классов задайте для **действия сборки** значение **внедренный ресурс** при выборе файла скрипта. При компиляции библиотеки в командной строке используйте параметр [/Resource](~/docs/csharp/language-reference/compiler-options/resource-compiler-option.md) , чтобы внедрить ресурс.  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип веб-ресурса — <see langword="null" />.

-или-

Имя веб-ресурса — <see langword="null" />.  
  
- или - 
Длина имени веб-ресурса равна 0.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <related type="Article" href="https://msdn.microsoft.com/library/0936b3b2-9e6e-4abe-9c06-364efef9dbbd">Обзор ресурсов веб-страницы ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5212666e-98ab-47e4-a497-b5545ab15c7f">/Resource (внедрение файла ресурсов в выходной файл)C# (параметры компилятора)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eee2f227-91f2-4f2b-a9d6-1c51c5320858">/resource (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptBlockRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, зарегистрирован ли блок клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ блока клиентского скрипта, используемый для поиска.</param>
        <summary>Определяет, зарегистрирован ли блок клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя указанный ключ.</summary>
        <returns><see langword="true" />, если блок клиентского скрипта зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метода, чтобы избежать регистрации повторяющихся скриптов. Это особенно важно, если для создания скрипта требуется большой объем серверных ресурсов.  
  
 Клиентский скрипт однозначно идентифицируется по ключу и типу. Скрипты с одинаковыми ключом и типом считаются дубликатами.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метода вызывает перегрузку, которая принимает `key` и, и `type` параметр с типом, заданным как <xref:System.Web.UI.Page> объект.  
  
   
  
## Examples  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs2.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb2.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptBlockRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип блока клиентского скрипта, используемый для поиска.</param>
        <param name="key">Ключ блока клиентского скрипта, используемый для поиска.</param>
        <summary>Определяет, зарегистрирован ли блок клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя ключ и тип.</summary>
        <returns><see langword="true" />, если блок клиентского скрипта зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метода, чтобы избежать регистрации повторяющихся скриптов. Это особенно важно, если для создания скрипта требуется большой объем серверных ресурсов.  
  
 Клиентский скрипт однозначно идентифицируется по ключу и типу. Скрипты с одинаковыми ключом и типом считаются дубликатами. Тип указывается на основе объекта, который будет обращаться к ресурсу. Например, при использовании `Page` экземпляра для доступа к ресурсу необходимо `Page` указать тип.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метода. Обратите внимание, что если логика для проверки существующего блока клиентских сценариев была удалена, в исходном коде HTML отображаемой страницы не было двух повторяющихся клиентских скриптов, так как <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метод проверяет наличие дубликатов. Преимущество проверки заключается в сокращении числа ненужных вычислений.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип клиентского скрипта — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsClientScriptIncludeRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, зарегистрировано ли включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptIncludeRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ включения клиентского скрипта, используемый для поиска.</param>
        <summary>Определяет, зарегистрировано ли включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя указанный ключ.</summary>
        <returns><see langword="true" />, если включение клиентского скрипта зарегистрировано; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метода, чтобы избежать регистрации повторяющихся скриптов. Это особенно важно, если для создания скрипта требуется большой объем серверных ресурсов.  
  
 Включение клиентского скрипта однозначно идентифицируется по ключу и типу. Скрипты с одинаковыми ключом и типом считаются дубликатами.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метода вызывает перегрузку, которая принимает `key` и, и `type` параметр с типом, заданным как <xref:System.Web.UI.Page> объект.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptIncludeRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptIncludeRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptIncludeRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptIncludeRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptIncludeRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsClientScriptIncludeRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип включения клиентского скрипта, используемый для поиска.</param>
        <param name="key">Ключ включения клиентского скрипта, используемый для поиска.</param>
        <summary>Определяет, зарегистрировано ли включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя ключ и тип.</summary>
        <returns><see langword="true" />, если включение клиентского скрипта зарегистрировано; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метода, чтобы избежать регистрации повторяющихся включений клиентского скрипта. Это особенно важно, если для создания скрипта требуется большой объем серверных ресурсов.  
  
 Включение клиентского скрипта однозначно идентифицируется по ключу и типу. Скрипты с одинаковыми ключом и типом считаются дубликатами. Тип указывается на основе объекта, который будет обращаться к ресурсу. Например, при использовании экземпляра страницы для доступа к ресурсу необходимо указать `Page` тип.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> метода. Обратите внимание, что если была удалена логика проверки существующих клиентских скриптов, в исходном коде HTML отображаемой страницы не было бы двух повторяющихся клиентских скриптов, так как <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метод проверяет наличие дубликатов. Преимущество проверки заключается в сокращении числа ненужных вычислений.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Для этого примера требуется файл JavaScript с `Script_include.js`именем и следующим содержимым:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип включения клиентского скрипта — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOnSubmitStatementRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, зарегистрирован ли оператор OnSubmit с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsOnSubmitStatementRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ оператора OnSubmit, используемый для поиска.</param>
        <summary>Определяет, зарегистрирован ли оператор OnSubmit с объектом <see cref="T:System.Web.UI.Page" />, используя указанный ключ.</summary>
        <returns><see langword="true" />, если оператор OnSubmit зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метода, чтобы избежать регистрации повторяющихся инструкций OnSubmit. Это особенно важно, если для создания инструкции требуется большой объем серверных ресурсов.  
  
 Оператор однозначно идентифицируется ключом и типом. Инструкции с одинаковыми ключом и типом считаются дубликатами.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> метода вызывает перегрузку, которая принимает `key` и, и `type` параметр с типом, заданным как <xref:System.Web.UI.Page> объект.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsOnSubmitStatementRegistered">
      <MemberSignature Language="C#" Value="public bool IsOnSubmitStatementRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOnSubmitStatementRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOnSubmitStatementRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsOnSubmitStatementRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsOnSubmitStatementRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип оператора OnSubmit, используемый для поиска.</param>
        <param name="key">Ключ оператора OnSubmit, используемый для поиска.</param>
        <summary>Определяет, зарегистрирован ли оператор OnSubmit с объектом <see cref="T:System.Web.UI.Page" />, используя указанные ключ и тип.</summary>
        <returns><see langword="true" />, если оператор OnSubmit зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метода, чтобы избежать регистрации повторяющихся инструкций. Это особенно важно, если для создания инструкции требуется большой объем серверных ресурсов.  
  
 Оператор однозначно идентифицируется ключом и типом. Инструкции с одинаковыми ключом и типом считаются дубликатами. Тип указывается на основе объекта, который будет обращаться к ресурсу. Например, при использовании `Page` экземпляра для доступа к ресурсу необходимо `Page` указать тип.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> метода. Сценарий с именем `OnSubmitScript` регистрируется в <xref:System.Web.UI.Page> , чтобы при отправке формы страницы вызывался скрипт.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип оператора OnSubmit — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered(System.String)" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartupScriptRegistered">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, зарегистрирован ли скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ скрипта, активизируемого при запуске, для поиска.</param>
        <summary>Определяет, зарегистрирован ли скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />, используя указанный ключ.</summary>
        <returns><see langword="true" />, если скрипт, активизируемый при запуске, зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метода, чтобы избежать регистрации повторяющихся скриптов. Это особенно важно, если для создания скрипта требуется большой объем серверных ресурсов.  
  
 Сценарий запуска однозначно идентифицируется по ключу и его типу. Скрипты с одинаковыми ключом и типом считаются дубликатами.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метода вызывает перегрузку, которая принимает строку `key` и `type` параметр с типом, заданным как <xref:System.Web.UI.Page> объект.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (Type type, string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(class System.Type type, string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(Type ^ type, System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : Type * string -&gt; bool" Usage="clientScriptManager.IsStartupScriptRegistered (type, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип скрипта запуска, используемый при поиске.</param>
        <param name="key">Ключ скрипта, активизируемого при запуске, для поиска.</param>
        <summary>Определяет, зарегистрирован ли скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />, используя указанные ключ и тип.</summary>
        <returns><see langword="true" />, если скрипт, активизируемый при запуске, зарегистрирован; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод перед вызовом <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метода, чтобы избежать регистрации повторяющихся скриптов. Это особенно важно, если для создания скрипта требуется большой объем серверных ресурсов.  
  
 Скрипт запуска клиента однозначно идентифицируется по ключу и типу. Скрипты с одинаковыми ключом и типом считаются дубликатами.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метода. Обратите внимание, что если логика для проверки существующего блока сценария запуска была удалена, в исходном коде HTML отображаемой страницы не будет двух повторяющихся сценариев запуска, так как <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метод проверяет наличие дубликатов. Преимущество проверки заключается в сокращении числа ненужных вычислений.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип скрипта, активизируемого при запуске, — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered(System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterStartupScript" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="clientScriptManager.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">Имя массива для регистрации.</param>
        <param name="arrayValue">Значение или значения массива для регистрации.</param>
        <summary>Регистрирует объявление массива JavaScript с объектом <see cref="T:System.Web.UI.Page" />, используя имя массива и значение массива.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Проверяет, существует ли зарегистрированный массив с тем же именем, что и имя, заданное `arrayName` в параметре, и, если это так, добавляет значения, `arrayValue` указанные в параметре. <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> Так как базовый механизм хранения основан на <xref:System.Collections.ArrayList>, допускаются дубликаты. Если зарегистрированный массив с тем же именем, что `arrayName` и у параметра, не существует, он создается и значения `arrayValue` в параметре добавляются в него.  
  
 Если требуется, чтобы строковые литералы были в результирующем массиве JavaScript, включите\\ `arrayValue` в параметр одинарные кавычки (') или экранированные двойные кавычки ("). Значение `arrayValue` параметра должно быть одним элементом. Если в массив нужно добавить более одного значения, выполните несколько вызовов с помощью <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> метода.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> методов и. <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> Пример регистрирует массив и скрытое значение и определяет `OnClick` событие `<input>` кнопки для вычисления суммы двух значений массива и скрытого значения.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="arrayName" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="Overload:System.String.Split" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptBlock">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого клиентского скрипта.</param>
        <param name="key">Ключ регистрируемого клиентского скрипта.</param>
        <param name="script">Константа регистрируемого клиентского скрипта.</param>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ и константу скрипта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентский скрипт однозначно идентифицируется по ключу и типу. Скрипты с одинаковыми ключом и типом считаются дубликатами. На странице можно зарегистрировать только один скрипт с заданным типом и парой ключей. При попытке регистрации скрипта, который уже зарегистрирован, не создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метод, чтобы определить, уже зарегистрирован ли клиентский скрипт с заданным ключом и парой типов, и избежать ненужной попытки добавить скрипт.  
  
 В этой перегрузке <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метода необходимо убедиться, что скрипт, предоставленный `script` в `<script>` параметре, заключен в блок element.  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Метод добавляет блок скрипта в верхнюю часть отображаемой страницы. Не гарантируется, что блоки сценариев будут выводиться в том порядке, в котором они зарегистрированы. Если важен порядок блоков скрипта, используйте <xref:System.Text.StringBuilder> объект для сбора скриптов в одной строке, а затем зарегистрируйте их в одном блоке клиентского сценария.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метода.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager12#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager12/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptBlock (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptBlock(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptBlock(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptBlock : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterClientScriptBlock (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого клиентского скрипта.</param>
        <param name="key">Ключ регистрируемого клиентского скрипта.</param>
        <param name="script">Константа регистрируемого клиентского скрипта.</param>
        <param name="addScriptTags">Логическое значение, указывающее, требуется ли добавление тегов скрипта.</param>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ, константу скрипта и логическое значение, указывающее следует ли добавление тегов скрипта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентский скрипт однозначно идентифицируется по ключу и типу. Скрипты с одинаковыми ключом и типом считаются дубликатами. На странице можно зарегистрировать только один скрипт с заданным типом и парой ключей. При попытке регистрации скрипта, который уже зарегистрирован, не создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> метод, чтобы определить, уже зарегистрирован ли клиентский скрипт с заданной парой ключей и типов. Это позволяет избежать ненужной попытки добавить скрипт.  
  
 В этой перегрузке <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метода можно указать, упакован ли скрипт, предоставленный `script` в `<script>` параметре, блоком элементов с помощью `addScriptTags` параметра. Значение  `addScriptTags` указывает, что теги скрипта будут добавляться автоматически. `true`  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> Метод добавляет блок скрипта в верхнюю часть отображаемой страницы. Не гарантируется, что блоки сценариев будут выводиться в том порядке, в котором они зарегистрированы. Если важен порядок блоков скрипта, используйте <xref:System.Text.StringBuilder> объект для сбора скриптов в одной строке, а затем зарегистрируйте их в одном блоке клиентского сценария.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> метода. Обратите внимание `addScriptTags` , что параметр имеет `true` значение, поэтому начальный и закрывающий теги скрипта не включаются `script` в параметр.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип блока клиентского скрипта — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock(System.Type,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClientScriptInclude">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterClientScriptInclude (key As String, url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ключ регистрируемого включения клиентского скрипта.</param>
        <param name="url">URL-адрес регистрируемого включения клиентского скрипта.</param>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />, используя ключ и URL-адрес, который позволяет вызывать скрипт из клиента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Включение клиентского скрипта однозначно идентифицируется по ключу и типу. Скрипты с одинаковыми ключом и типом считаются дубликатами. На странице можно зарегистрировать только один скрипт с заданным типом и парой ключей. При попытке регистрации скрипта, который уже зарегистрирован, не создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered%2A> метод, чтобы определить, включена ли регистрация клиентского скрипта с заданным ключом и парой типов, и избежать ненужной попытки добавить скрипт.  
  
> [!NOTE]
>  Чтобы разрешить URL-адрес клиента, используйте <xref:System.Web.UI.Control.ResolveClientUrl%2A> метод. Этот метод использует контекст URL-адреса, по которому он вызывается для разрешения пути.  
  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метода вызывает перегрузку, которая `key`принимает `type` , `URL`и параметр.  
  
 Метод добавляет блок скрипта в верхней части отображаемой страницы.  
  
   
  
## Examples  
 Связанные сведения, в том числе синтаксис, использование и пример, см. <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A>в разделе.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptInclude">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptInclude (Type type, string key, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptInclude(class System.Type type, string key, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptInclude(Type ^ type, System::String ^ key, System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptInclude : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptInclude (type, key, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого включения клиентского скрипта.</param>
        <param name="key">Ключ регистрируемого включения клиентского скрипта.</param>
        <param name="url">URL-адрес регистрируемого включения клиентского скрипта.</param>
        <summary>Регистрирует включение клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ и URL-адрес.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метода принимает параметры *ключа* и *URL-адреса* для идентификации `type` скрипта, а также параметр для указания кода включения клиентского скрипта. Тип указывается на основе объекта, который будет обращаться к ресурсу. Например, при использовании `Page` экземпляра для доступа к ресурсу необходимо `Page` указать тип.  
  
> [!NOTE]
>  Чтобы разрешить URL-адрес клиента, используйте <xref:System.Web.UI.Control.ResolveClientUrl%2A> метод. Этот метод использует контекст URL-адреса, по которому он вызывается для разрешения пути.  
  
 Этот метод добавляет блок скрипта в верхней части отображаемой страницы.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> метода. Обратите внимание, что если логика для проверки существующих клиентских скриптов была удалена, на странице, подготовленной для просмотра, по-прежнему не будет <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude%2A> повторяющихся клиентских скриптов, так как метод проверяет наличие дубликатов. Преимущество проверки заключается в сокращении числа ненужных вычислений.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/cs/clientscriptincludes.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager2/vb/clientscriptincludes.aspx#1)]  
  
 Для этого примера требуется файл JavaScript с именем Script_include. js со следующим содержимым:  
  
```  
function DoClick() {Form1.Message.value='Text from include script.'}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип включения клиентского скрипта — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">URL-адрес имеет значение <see langword="null" />.  
  
-или- 
URL пуст.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude(System.String,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsClientScriptIncludeRegistered" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptResource">
      <MemberSignature Language="C#" Value="public void RegisterClientScriptResource (Type type, string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterClientScriptResource(class System.Type type, string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterClientScriptResource(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterClientScriptResource(Type ^ type, System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="member this.RegisterClientScriptResource : Type * string -&gt; unit" Usage="clientScriptManager.RegisterClientScriptResource (type, resourceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого ресурса клиентского скрипта.</param>
        <param name="resourceName">Имя регистрируемого ресурса клиентского скрипта.</param>
        <summary>Регистрирует ресурс клиентского скрипта с объектом <see cref="T:System.Web.UI.Page" />, используя тип и имя ресурса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Метод используется при доступе к скомпилированным ресурсам из сборок через обработчик HTTP-ресурсов WebMethod. axd. Метод регистрирует скрипт <xref:System.Web.UI.Page> с объектом и предотвращает дублирование скриптов. <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> Этот метод заключает содержимое URL-адреса `<script>` ресурса в блок элемента.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptResource%2A> метода.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/clientscriptwebresource.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/clientscriptwebresource.aspx#1)]  
  
 В следующем примере кода показано, как программно применить <xref:System.Web.UI.WebResourceAttribute> атрибут метаданных, чтобы пометить сборку для ресурсов, которые будут обслуживаться.  
  
 [!code-csharp[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/cs/resource.cs#2)]
 [!code-vb[System.Web.UI.ClientScriptManager4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager4/vb/resource.vb#2)]  
  
 Для этого примера требуется файл JavaScript с `Script_include.js`именем и следующим содержимым:  
  
```  
function DoClick() {Form1.Message.value='Text from resource script.'}  
```  
  
 Скомпилируйте файл как ресурс `Samples.AspNet.CS.Controls` в сборке, содержащей `ClientScriptResourceLabel` класс. `Script_include.js`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Тип клиентского ресурса — <see langword="null" />.

- или -

Имя клиентского ресурса — <see langword="null" />.  
  
- или - 
Длина имени клиентского ресурса равна 0.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetWebResourceUrl(System.Type,System.String)" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.RegisterClientScriptInclude" />
        <altmember cref="T:System.Web.Handlers.AssemblyResourceLoader" />
        <altmember cref="T:System.Web.UI.WebResourceAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterExpandoAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует пару "имя-значение" как пользовательский (expando) атрибут указанного элемента управления.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="controlId">Элемент управления <see cref="T:System.Web.UI.Control" /> на странице, содержащей пользовательский атрибут.</param>
        <param name="attributeName">Имя регистрируемого пользовательского атрибута.</param>
        <param name="attributeValue">Значение пользовательского атрибута.</param>
        <summary>Регистрирует пару "имя-значение" как пользовательский (expando) атрибут указанного элемента управления с указанными идентификатором, именем атрибута и значением атрибута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод регистрирует пару "имя-значение" как пользовательский атрибут (expando) для указанного  <xref:System.Web.UI.Control> .  <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Атрибут expando задается динамически из JavaScript для сохранения совместимости XHTML для разметки отображаемого элемента управления. Кавычки и символы обратной косой черты в значениях настраиваемого атрибута (expando) преобразуются в escape-последовательность. Если вы не хотите заменять кавычки и символы обратной косой черты, вызовите <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> метод перегрузки и `encode` задайте для `false`параметра значение.  
  
 Если атрибут expando не найден или элемент управления, в который добавляется атрибут expando, не найден, то клиентский сценарий по-прежнему создается, но не влияет на элемент управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <Member MemberName="RegisterExpandoAttribute">
      <MemberSignature Language="C#" Value="public void RegisterExpandoAttribute (string controlId, string attributeName, string attributeValue, bool encode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterExpandoAttribute(string controlId, string attributeName, string attributeValue, bool encode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterExpandoAttribute (controlId As String, attributeName As String, attributeValue As String, encode As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterExpandoAttribute(System::String ^ controlId, System::String ^ attributeName, System::String ^ attributeValue, bool encode);" />
      <MemberSignature Language="F#" Value="member this.RegisterExpandoAttribute : string * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterExpandoAttribute (controlId, attributeName, attributeValue, encode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="controlId" Type="System.String" />
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="attributeValue" Type="System.String" />
        <Parameter Name="encode" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="controlId">Элемент управления <see cref="T:System.Web.UI.Control" /> на странице, содержащей пользовательский атрибут.</param>
        <param name="attributeName">Имя регистрируемого пользовательского атрибута.</param>
        <param name="attributeValue">Значение пользовательского атрибута.</param>
        <param name="encode">Логическое значение, указывающее будет ли кодироваться регистрируемый пользовательский атрибут.</param>
        <summary>Регистрирует пару "имя-значение" как пользовательский (expando) атрибут указанного элемента управления с указанными идентификатором, именем атрибута, значением атрибута и логическим значением, определяющим, будет ли кодироваться значение атрибута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод регистрирует пару "имя-значение" как пользовательский атрибут (expando) для указанного  <xref:System.Web.UI.Control> .  <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> Атрибут expando задается динамически из JavaScript для сохранения совместимости XHTML для разметки отображаемого элемента управления. Задайте для `encode` `true` параметра значение, если требуется экранирование кавычек и символов обратной косой черты в значении атрибута expando.  
  
 Если атрибут expando не найден или элемент управления, в который добавляется атрибут expando, не найден, то клиентский сценарий по-прежнему создается, но не влияет на элемент управления.  
  
   
  
## Examples  
 В следующем примере кода показано, <xref:System.Web.UI.ClientScriptManager.RegisterExpandoAttribute%2A> как использовать метод <xref:System.Web.UI.ClientScriptManager> класса. Клиентский сценарий на подготовленной странице задает `title` атрибут `<span>` элемента.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/cs/clientscriptexpando.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager6/vb/clientscriptexpando.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.JScript.Expando" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterForEventValidation">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует ссылку на событие для проверки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Уникальный ИД, представляющий клиентский элемент управления, генерирующий событие.</param>
        <summary>Регистрирует ссылку на событие для проверки с уникальным ИД элемента управления, представляющим клиентский элемент управления, генерирующий событие.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения и примеры см. в <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> описании метода.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метод <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> и метод для регистрации обратного вызова для проверки и проверки того, что обратный вызов создан на странице.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/eventvalidation2cs.aspx#2)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/eventvalidation2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (System.Web.UI.PostBackOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(class System.Web.UI.PostBackOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.Web.UI.PostBackOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (options As PostBackOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::Web::UI::PostBackOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : System.Web.UI.PostBackOptions -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Web.UI.PostBackOptions" />
      </Parameters>
      <Docs>
        <param name="options">Объект <see cref="T:System.Web.UI.PostBackOptions" />, определяющий, как создается клиентский скрипт JavaScript для инициации обратной передачи.</param>
        <summary>Регистрирует ссылку на событие для проверки с <see cref="T:System.Web.UI.PostBackOptions" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения и примеры см. в <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> описании метода.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.ValidateEvent" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForEventValidation">
      <MemberSignature Language="C#" Value="public void RegisterForEventValidation (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterForEventValidation(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterForEventValidation (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterForEventValidation(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.RegisterForEventValidation : string * string -&gt; unit" Usage="clientScriptManager.RegisterForEventValidation (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Уникальный ИД, представляющий клиентский элемент управления, генерирующий событие.</param>
        <param name="argument">Аргументы события, переданные вместе с клиентским событием.</param>
        <summary>Регистрирует ссылку на событие для проверки с уникальным ИД элемента управления, представляющим клиентский элемент управления, генерирующий событие, и аргументами события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метода <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> и метода для регистрации обратного вызова для проверки и проверки того, что обратный вызов создан на странице. Для улучшения проверки, показанной в примере, можно изменить параметр проверки `argument` , чтобы он содержал сведения, относящиеся к пользователю, например удостоверение или роль.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метода для регистрации обратного вызова для проверки.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager10#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager10/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод вызывается до метода <see cref="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/18fc94c9-56fc-46c3-9f29-7358f18667df">Обратный вызов клиента с примером реализации проверки</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterHiddenField : string * string -&gt; unit" Usage="clientScriptManager.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">Имя регистрируемого скрытого поля.</param>
        <param name="hiddenFieldInitialValue">Начальное значение регистрируемого поля.</param>
        <summary>Регистрирует скрытое значение с объектом <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод создает скрытый `<input>` элемент на отображаемой HTML-странице. <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> методов и. <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> Пример регистрирует массив и скрытое значение и определяет `OnClick` событие `<input>` кнопки для вычисления суммы двух значений массива и скрытого значения.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/cs/clientscriptregisterarray.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager5#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager5/vb/clientscriptregisterarray.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hiddenFieldName" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.WebControls.HiddenField" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterOnSubmitStatement (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого оператора OnSubmit.</param>
        <param name="key">Ключ регистрируемого оператора OnSubmit.</param>
        <param name="script">Константа скрипта регистрируемого оператора OnSubmit.</param>
        <summary>Регистрирует оператор OnSubmit с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ и константу скрипта. Оператор выполняется, если <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> представляется на рассмотрение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Оператор OnSubmit однозначно идентифицируется по ключу и типу. Инструкции с одинаковыми ключом и типом считаются дубликатами. На странице можно зарегистрировать только одну инструкцию с заданным типом и парой ключей. Попытка зарегистрировать уже зарегистрированную инструкцию не приведет к созданию дубликата инструкции.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered%2A> метод, чтобы определить, зарегистрирован ли оператор OnSubmit с заданным ключом и парой типов и избежать ненужной попытки добавить скрипт.  
  
 `script` Параметр <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>  метода может содержать несколько команд сценария, если они правильно разделяются точкой с запятой (;).  
  
 <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> Добавляет скрипт, который выполняется до отправки страницы, и дает возможность отменить отправку.  
  
 Дополнительные сведения о формах HTML и `OnSubmit` атрибуте см. на [веб-сайте консорциум W3C (W3C)](https://go.microsoft.com/fwlink/?linkid=37125).  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> метода.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/cs/clientscriptonsubmit.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager3/vb/clientscriptonsubmit.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="type" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
        <altmember cref="Overload:System.Web.UI.ClientScriptManager.IsOnSubmitStatementRegistered" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterStartupScript">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="key">Ключ регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="script">Константа регистрируемого скрипта, активизируемого при запуске.</param>
        <summary>Регистрирует скрипт, активизируемый при запуске, с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ и константу скрипта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентский скрипт однозначно идентифицируется по ключу и типу. Скрипты с одинаковыми ключом и типом считаются дубликатами. На странице можно зарегистрировать только один скрипт с заданным типом и парой ключей. При попытке регистрации скрипта, который уже зарегистрирован, не создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метод, чтобы определить, уже зарегистрирован ли скрипт запуска с заданным ключом и парой типов, и избежать ненужной попытки добавить скрипт.  
  
 В этой перегрузке <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метода необходимо убедиться, что скрипт, предоставленный `script` в `<script>` параметре, заключен в блок элемента.  
  
 Блок скрипта, добавленный <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> методом, выполняется при завершении загрузки страницы, но до возникновения <xref:System.Web.UI.Control.OnLoad%2A> события страницы. Не гарантируется, что блоки сценариев будут выводиться в том порядке, в котором они зарегистрированы. Если важен порядок блоков скрипта, используйте <xref:System.Text.StringBuilder> объект для сбора скриптов в одной строке, а затем зарегистрируйте их в одном блоке клиентского сценария.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метода. Обратите внимание, что начальный и закрывающий теги скрипта `script` включены в параметр. Чтобы добавить теги скрипта на основе дополнительного параметра, см <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> . метод.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/cs/default.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager11#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.ui.clientscriptmanager11/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public void RegisterStartupScript (Type type, string key, string script, bool addScriptTags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterStartupScript(class System.Type type, string key, string script, bool addScriptTags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterStartupScript(Type ^ type, System::String ^ key, System::String ^ script, bool addScriptTags);" />
      <MemberSignature Language="F#" Value="member this.RegisterStartupScript : Type * string * string * bool -&gt; unit" Usage="clientScriptManager.RegisterStartupScript (type, key, script, addScriptTags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
        <Parameter Name="addScriptTags" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Тип регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="key">Ключ регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="script">Константа регистрируемого скрипта, активизируемого при запуске.</param>
        <param name="addScriptTags">Логическое значение, указывающее, требуется ли добавление тегов скрипта.</param>
        <summary>Регистрирует клиентский скрипт с объектом <see cref="T:System.Web.UI.Page" />, используя тип, ключ, константу скрипта и логическое значение, указывающее следует ли добавлять теги скрипта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сценарий запуска однозначно идентифицируется по ключу и его типу. Скрипты с одинаковыми ключом и типом считаются дубликатами. На странице можно зарегистрировать только один скрипт с заданным типом и парой ключей. При попытке регистрации скрипта, который уже зарегистрирован, не создается дубликат скрипта.  
  
 Вызовите <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> метод, чтобы определить, уже зарегистрирован ли скрипт запуска с заданным ключом и парой типов, и избежать ненужной попытки добавить скрипт.  
  
 В этой перегрузке <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метода можно указать, упакован ли скрипт, предоставленный `script` в `<script>` параметре, блоком элементов с помощью `addScriptTags` параметра. Значение  `addScriptTags` указывает, что теги скрипта будут добавляться автоматически. `true`  
  
 Блок скрипта, добавленный <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> методом, выполняется при завершении загрузки страницы, но до возникновения <xref:System.Web.UI.Control.OnLoad%2A> события страницы. Не гарантируется, что блоки сценариев будут выводиться в том порядке, в котором они зарегистрированы. Если важен порядок блоков скрипта, используйте <xref:System.Text.StringBuilder> объект для сбора скриптов в одной строке, а затем зарегистрируйте их в одном блоке клиентского сценария.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> метода. Обратите внимание `addScriptTags` , что параметр имеет `false` значение, поэтому начальный и закрывающий `script` теги скрипта включаются в параметр.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/cs/page_registerstartupscriptcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager1/vb/page_registerstartupscriptvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterStartupScript(System.Type,System.String,System.String)" />
        <altmember cref="F:System.Web.UI.HtmlTextWriterTag.Script" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateEvent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Проверяет клиентское событие.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string -&gt; unit" Usage="clientScriptManager.ValidateEvent uniqueId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Уникальный ИД, представляющий клиентский элемент управления, генерирующий событие.</param>
        <summary>Проверяет клиентское событие, зарегистрированное для проверки, используя метод <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEvent">
      <MemberSignature Language="C#" Value="public void ValidateEvent (string uniqueId, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateEvent(string uniqueId, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.ClientScriptManager.ValidateEvent(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateEvent (uniqueId As String, argument As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateEvent(System::String ^ uniqueId, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.ValidateEvent : string * string -&gt; unit" Usage="clientScriptManager.ValidateEvent (uniqueId, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uniqueId" Type="System.String" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uniqueId">Уникальный ИД, представляющий клиентский элемент управления, генерирующий событие.</param>
        <param name="argument">Аргументы события, переданные вместе с клиентским событием.</param>
        <summary>Проверяет клиентское событие, зарегистрированное для проверки, используя метод <see cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано использование <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> метода <xref:System.Web.UI.ClientScriptManager.ValidateEvent%2A> и метода для регистрации обратного вызова для проверки и проверки того, что обратный вызов создан на странице. Чтобы улучшить показанную здесь проверку, можно изменить параметр проверки `argument` , чтобы он содержал сведения, относящиеся к пользователю, например удостоверение или роль.  
  
 [!code-aspx-csharp[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/cs/EventValidationCS.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ClientScriptManager9#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ClientScriptManager9/vb/EventValidationVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="uniqueId" /> имеет значение <see langword="null" /> или равен пустой строке ("").</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String,System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
