<Type Name="ConfigurationManager" FullName="System.Configuration.ConfigurationManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e77e990d9b4f906567d2e3058f973156321efd5f" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75144676" /></Metadata><TypeSignature Language="C#" Value="public static class ConfigurationManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ConfigurationManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ConfigurationManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ConfigurationManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ConfigurationManager abstract sealed" />
  <TypeSignature Language="F#" Value="type ConfigurationManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Configuration</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет доступ к файлам конфигурации для клиентских приложений. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Configuration.ConfigurationManager> позволяет получать доступ к сведениям о конфигурации компьютера, приложения и пользователя. Этот класс заменяет класс <xref:System.Configuration.ConfigurationSettings>, который является устаревшим. Для веб-приложений используйте класс <xref:System.Web.Configuration.WebConfigurationManager>.  
  
 Чтобы использовать класс <xref:System.Configuration.ConfigurationManager>, проект должен ссылаться на сборку `System.Configuration`. По умолчанию некоторые шаблоны проектов, например консольное приложение, не ссылаются на эту сборку, поэтому необходимо вручную сослаться на нее.  
  
> [!NOTE]
>  Имя и расположение файла конфигурации приложения зависят от узла приложения. Дополнительные сведения см. в разделе [Настройка приложений с помощью файлов конфигурации](~/docs/framework/configure-apps/index.md).  
  
 Для управления сведениями о конфигурации можно использовать встроенные типы <xref:System.Configuration> или наследовать от них. С помощью этих типов можно работать непосредственно с информацией о конфигурации, а файлы конфигурации можно расширять, чтобы они включали пользовательские сведения.  
  
 Класс <xref:System.Configuration.ConfigurationManager> содержит члены, которые позволяют выполнять следующие задачи:  
  
-   Чтение раздела из файла конфигурации. Чтобы получить доступ к сведениям о конфигурации, вызовите метод <xref:System.Configuration.ConfigurationManager.GetSection%2A>. Для некоторых разделов, таких как `appSettings` и `connectionStrings`, используйте классы <xref:System.Configuration.ConfigurationManager.AppSettings%2A> и <xref:System.Configuration.ConfigurationManager.ConnectionStrings%2A>. Эти члены выполняют операции только для чтения, используют один кэшированный экземпляр конфигурации и поддерживают многопоточность.  
  
-   Чтение и запись файлов конфигурации в целом. Приложение может считывать и записывать параметры конфигурации на любом уровне, для самого себя или для других приложений или компьютеров локально или удаленно. Используйте один из методов, предоставляемых классом <xref:System.Configuration.ConfigurationManager>, чтобы открыть файл конфигурации, например SampleApp. exe. config. Эти методы возвращают объект <xref:System.Configuration.Configuration>, который, в свою очередь, предоставляет методы и свойства, которые можно использовать для работы с связанными файлами конфигурации. Методы выполняют операции чтения или записи и создают данные конфигурации при каждом записи файла.  
  
-   Поддержка задач настройки. Для поддержки различных задач настройки используются следующие типы:  
  
    -   <xref:System.Configuration.SectionInformation>  
  
    -   <xref:System.Configuration.PropertyInformation>  
  
    -   <xref:System.Configuration.PropertyInformationCollection>  
  
    -   <xref:System.Configuration.ElementInformation>  
  
    -   <xref:System.Configuration.ContextInformation>  
  
    -   <xref:System.Configuration.ConfigurationSectionGroup>  
  
    -   <xref:System.Configuration.ConfigurationSectionGroupCollection>  
  
     Помимо работы с существующими сведениями о конфигурации, можно создавать пользовательские элементы конфигурации и работать с ними, расширяя встроенные типы конфигурации, такие как <xref:System.Configuration.ConfigurationElement>, <xref:System.Configuration.ConfigurationElementCollection>, <xref:System.Configuration.ConfigurationProperty>и классы <xref:System.Configuration.ConfigurationSection>. Пример программного расширения встроенного типа конфигурации см. в разделе <xref:System.Configuration.ConfigurationSection>. Пример расширения встроенного типа конфигурации, использующего модель на основе атрибутов, см. в разделе <xref:System.Configuration.ConfigurationElement>.  
  
   
  
## Examples  
 В первом примере показано простое консольное приложение, которое считывает параметры приложения, добавляет новый параметр и обновляет существующий параметр.  
  
```csharp  
using System;  
using System.Configuration;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadAllSettings();  
            ReadSetting("Setting1");  
            ReadSetting("NotValid");  
            AddUpdateAppSettings("NewSetting", "May 7, 2014");  
            AddUpdateAppSettings("Setting1", "May 8, 2014");  
            ReadAllSettings();  
        }  
  
        static void ReadAllSettings()  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
  
                if (appSettings.Count == 0)  
                {  
                    Console.WriteLine("AppSettings is empty.");  
                }  
                else  
                {  
                    foreach (var key in appSettings.AllKeys)  
                    {  
                        Console.WriteLine("Key: {0} Value: {1}", key, appSettings[key]);  
                    }  
                }  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void ReadSetting(string key)  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
                string result = appSettings[key] ?? "Not Found";  
                Console.WriteLine(result);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void AddUpdateAppSettings(string key, string value)  
        {  
            try  
            {  
                var configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);  
                var settings = configFile.AppSettings.Settings;  
                if (settings[key] == null)  
                {  
                    settings.Add(key, value);  
                }  
                else  
                {  
                    settings[key].Value = value;  
                }  
                configFile.Save(ConfigurationSaveMode.Modified);  
                ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error writing app settings");  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Module Module1  
  
    Sub Main()  
        ReadAllSettings()  
        ReadSetting("Setting1")  
        ReadSetting("NotValid")  
        AddUpdateAppSettings("NewSetting", "May 7, 2014")  
        AddUpdateAppSettings("Setting1", "May 8, 2014")  
        ReadAllSettings()  
    End Sub  
  
    Sub ReadAllSettings()  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
  
            If appSettings.Count = 0 Then  
                Console.WriteLine("AppSettings is empty.")  
            Else  
                For Each key As String In appSettings.AllKeys  
                    Console.WriteLine("Key: {0} Value: {1}", key, appSettings(key))  
                Next  
            End If  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub ReadSetting(key As String)  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
            Dim result As String = appSettings(key)  
            If IsNothing(result) Then  
                result = "Not found"  
            End If  
            Console.WriteLine(result)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub AddUpdateAppSettings(key As String, value As String)  
        Try  
            Dim configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None)  
            Dim settings = configFile.AppSettings.Settings  
            If IsNothing(settings(key)) Then  
                settings.Add(key, value)  
            Else  
                settings(key).Value = value  
            End If  
            configFile.Save(ConfigurationSaveMode.Modified)  
            ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error writing app settings")  
        End Try  
    End Sub  
  
End Module  
```  
  
 В предыдущем примере предполагается, что проект содержит файл App. config, как показано ниже.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
  <appSettings>  
    <add key="Setting1" value="May 5, 2014"/>  
    <add key="Setting2" value="May 6, 2014"/>  
  </appSettings>  
</configuration>  
```  
  
 В следующем примере показано, как использовать строку подключения для чтения данных из базы данных.  
  
```csharp  
using System;  
using System.Configuration;  
using System.Data.SqlClient;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadProducts();  
        }  
  
        static void ReadProducts()  
        {  
            var connectionString = ConfigurationManager.ConnectionStrings["WingtipToys"].ConnectionString;  
            string queryString = "SELECT Id, ProductName FROM dbo.Products;";  
            using (var connection = new SqlConnection(connectionString))  
            {  
                var command = new SqlCommand(queryString, connection);  
                connection.Open();  
                using (var reader = command.ExecuteReader())  
                {  
                    while (reader.Read())  
                    {  
                        Console.WriteLine(String.Format("{0}, {1}", reader[0], reader[1]));  
                    }  
                }  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Imports System.Data.SqlClient  
Module Module1  
  
    Sub Main()  
        ReadProducts()  
    End Sub  
  
    Sub ReadProducts()  
        Dim connectionString = ConfigurationManager.ConnectionStrings("WingtipToys").ConnectionString  
        Dim queryString = "SELECT Id, ProductName FROM dbo.Products;"  
        Using connection As New SqlConnection(connectionString)  
            Dim command = New SqlCommand(queryString, connection)  
            connection.Open()  
  
            Using reader As SqlDataReader = command.ExecuteReader()  
                While reader.Read()  
                    Console.WriteLine(String.Format("{0}, {1}", reader(0), reader(1)))  
                End While  
            End Using  
        End Using  
    End Sub  
  
End Module  
```  
  
 В предыдущем примере предполагается, что проект имеет файл App. config, как показано ниже.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
    <connectionStrings>  
      <add name="WingtipToys" connectionString="Data Source=(LocalDB)\v11.0;Initial Catalog=WingtipToys;Integrated Security=True;Pooling=False" />  
    </connectionStrings>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Класс <see cref="T:System.Configuration.Configuration" /> обеспечивает программный доступ для редактирования файлов конфигурации. Вы используете один из открытых методов, предоставляемых <see cref="T:System.Configuration.ConfigurationManager" />. Эти методы возвращают объект <see cref="T:System.Configuration.Configuration" />, который, в свою очередь, предоставляет необходимые методы и свойства для управления базовыми файлами конфигурации. Вы можете получить доступ к этим файлам для чтения или записи.  
  
Для чтения файлов конфигурации используйте <see cref="M:System.Configuration.Configuration.GetSection(System.String)" /> или <see cref="M:System.Configuration.Configuration.GetSectionGroup(System.String)" /> для чтения сведений о конфигурации. Пользователь или процесс, выполняющий чтение, должен иметь следующие разрешения: 
— Разрешение на чтение файла конфигурации на текущем уровне иерархии конфигурации.  
  
— Разрешения на чтение всех родительских файлов конфигурации.  
  
Если приложению требуется доступ только для чтения к своей собственной конфигурации, рекомендуется использовать метод <see cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />. Этот метод предоставляет доступ к кэшированным значениям конфигурации для текущего приложения, что обеспечивает лучшую производительность по сравнению с классом <see cref="T:System.Configuration.Configuration" />.  
  
Для записи в файлы конфигурации используйте один из методов <see cref="Overload:System.Configuration.Configuration.Save" />. Пользователь или процесс, выполняющий запись, должен иметь следующие разрешения: 
— Разрешение на запись в файл конфигурации и каталог на текущем уровне иерархии конфигурации.  
  
— Разрешения на чтение для всех файлов конфигурации.</para></block>
    <altmember cref="T:System.Configuration.Configuration" />
    <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
    <related type="Article" href="~/docs/framework/configure-apps/index.md">Файлы конфигурации</related>
  </Docs>
  <Members>
    <Member MemberName="AppSettings">
      <MemberSignature Language="C#" Value="public static System.Collections.Specialized.NameValueCollection AppSettings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Specialized.NameValueCollection AppSettings" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationManager.AppSettings" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AppSettings As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Specialized::NameValueCollection ^ AppSettings { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AppSettings : System.Collections.Specialized.NameValueCollection" Usage="System.Configuration.ConfigurationManager.AppSettings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает данные <see cref="T:System.Configuration.AppSettingsSection" /> для конфигурации текущего приложения по умолчанию.</summary>
        <value>Объект <see cref="T:System.Collections.Specialized.NameValueCollection" />, который содержит содержимое объекта <see cref="T:System.Configuration.AppSettingsSection" /> для конфигурации текущего приложения по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Configuration.AppSettingsSection> содержит содержимое раздела `appSettings` файла конфигурации.  
  
   
  
## Examples  
 В первом примере показано простое консольное приложение, которое считывает параметры приложения, добавляет новый параметр и обновляет существующий параметр.  
  
```csharp  
using System;  
using System.Configuration;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadAllSettings();  
            ReadSetting("Setting1");  
            ReadSetting("NotValid");  
            AddUpdateAppSettings("NewSetting", "May 7, 2014");  
            AddUpdateAppSettings("Setting1", "May 8, 2014");  
            ReadAllSettings();  
        }  
  
        static void ReadAllSettings()  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
  
                if (appSettings.Count == 0)  
                {  
                    Console.WriteLine("AppSettings is empty.");  
                }  
                else  
                {  
                    foreach (var key in appSettings.AllKeys)  
                    {  
                        Console.WriteLine("Key: {0} Value: {1}", key, appSettings[key]);  
                    }  
                }  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void ReadSetting(string key)  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
                string result = appSettings[key] ?? "Not Found";  
                Console.WriteLine(result);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void AddUpdateAppSettings(string key, string value)  
        {  
            try  
            {  
                var configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);  
                var settings = configFile.AppSettings.Settings;  
                if (settings[key] == null)  
                {  
                    settings.Add(key, value);  
                }  
                else  
                {  
                    settings[key].Value = value;  
                }  
                configFile.Save(ConfigurationSaveMode.Modified);  
                ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error writing app settings");  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Module Module1  
  
    Sub Main()  
        ReadAllSettings()  
        ReadSetting("Setting1")  
        ReadSetting("NotValid")  
        AddUpdateAppSettings("NewSetting", "May 7, 2014")  
        AddUpdateAppSettings("Setting1", "May 8, 2014")  
        ReadAllSettings()  
    End Sub  
  
    Sub ReadAllSettings()  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
  
            If appSettings.Count = 0 Then  
                Console.WriteLine("AppSettings is empty.")  
            Else  
                For Each key As String In appSettings.AllKeys  
                    Console.WriteLine("Key: {0} Value: {1}", key, appSettings(key))  
                Next  
            End If  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub ReadSetting(key As String)  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
            Dim result As String = appSettings(key)  
            If IsNothing(result) Then  
                result = "Not found"  
            End If  
            Console.WriteLine(result)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub AddUpdateAppSettings(key As String, value As String)  
        Try  
            Dim configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None)  
            Dim settings = configFile.AppSettings.Settings  
            If IsNothing(settings(key)) Then  
                settings.Add(key, value)  
            Else  
                settings(key).Value = value  
            End If  
            configFile.Save(ConfigurationSaveMode.Modified)  
            ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error writing app settings")  
        End Try  
    End Sub  
  
End Module  
```  
  
 В предыдущем примере предполагается, что проект содержит файл App. config, как показано ниже.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
  <appSettings>  
    <add key="Setting1" value="May 5, 2014"/>  
    <add key="Setting2" value="May 6, 2014"/>  
  </appSettings>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Не удалось извлечь объект <see cref="T:System.Collections.Specialized.NameValueCollection" /> с параметрами приложения.</exception>
        <altmember cref="T:System.Configuration.AppSettingsSection" />
        <altmember cref="T:System.Collections.Specialized.NameValueCollection" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionStrings">
      <MemberSignature Language="C#" Value="public static System.Configuration.ConnectionStringSettingsCollection ConnectionStrings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Configuration.ConnectionStringSettingsCollection ConnectionStrings" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationManager.ConnectionStrings" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ConnectionStrings As ConnectionStringSettingsCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Configuration::ConnectionStringSettingsCollection ^ ConnectionStrings { System::Configuration::ConnectionStringSettingsCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionStrings : System.Configuration.ConnectionStringSettingsCollection" Usage="System.Configuration.ConfigurationManager.ConnectionStrings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConnectionStringSettingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает данные <see cref="T:System.Configuration.ConnectionStringsSection" /> для конфигурации текущего приложения по умолчанию.</summary>
        <value>Объект <see cref="T:System.Configuration.ConnectionStringSettingsCollection" />, который содержит содержимое объекта <see cref="T:System.Configuration.ConnectionStringsSection" /> для конфигурации текущего приложения по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Configuration.ConnectionStringsSection> содержит содержимое раздела `connectionStrings` файла конфигурации.  
  
   
  
## Examples  
 В следующем примере показано, как использовать строку подключения для чтения данных из базы данных.  
  
```csharp  
using System;  
using System.Configuration;  
using System.Data.SqlClient;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadProducts();  
        }  
  
        static void ReadProducts()  
        {  
            var connectionString = ConfigurationManager.ConnectionStrings["WingtipToys"].ConnectionString;  
            string queryString = "SELECT Id, ProductName FROM dbo.Products;";  
            using (var connection = new SqlConnection(connectionString))  
            {  
                var command = new SqlCommand(queryString, connection);  
                connection.Open();  
                using (var reader = command.ExecuteReader())  
                {  
                    while (reader.Read())  
                    {  
                        Console.WriteLine(String.Format("{0}, {1}", reader[0], reader[1]));  
                    }  
                }  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Imports System.Data.SqlClient  
Module Module1  
  
    Sub Main()  
        ReadProducts()  
    End Sub  
  
    Sub ReadProducts()  
        Dim connectionString = ConfigurationManager.ConnectionStrings("WingtipToys").ConnectionString  
        Dim queryString = "SELECT Id, ProductName FROM dbo.Products;"  
        Using connection As New SqlConnection(connectionString)  
            Dim command = New SqlCommand(queryString, connection)  
            connection.Open()  
  
            Using reader As SqlDataReader = command.ExecuteReader()  
                While reader.Read()  
                    Console.WriteLine(String.Format("{0}, {1}", reader(0), reader(1)))  
                End While  
            End Using  
        End Using  
    End Sub  
  
End Module  
```  
  
 В предыдущем примере предполагается, что проект имеет файл App. config, как показано ниже.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
    <connectionStrings>  
      <add name="WingtipToys" connectionString="Data Source=(LocalDB)\v11.0;Initial Catalog=WingtipToys;Integrated Security=True;Pooling=False" />  
    </connectionStrings>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Не удалось получить объект <see cref="T:System.Configuration.ConnectionStringSettingsCollection" />.</exception>
        <altmember cref="T:System.Configuration.ConnectionStringsSection" />
        <altmember cref="T:System.Configuration.ConnectionStringSettingsCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public static object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="static member GetSection : string -&gt; obj" Usage="System.Configuration.ConfigurationManager.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Путь и имя раздела конфигурации. Имена узлов разделяются косой чертой, например system.net/mailSettings/smtp.</param>
        <summary>Извлекает указанный раздел конфигурации для конфигурации по умолчанию текущего приложения.</summary>
        <returns>Указанный объект <see cref="T:System.Configuration.ConfigurationSection" /> или значение <see langword="null" />, если раздел не существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для клиентских приложений этот метод извлекает файл конфигурации, полученный путем объединения файла конфигурации приложения, локального файла конфигурации пользователя и перемещаемого файла конфигурации.  
  
 Метод <xref:System.Configuration.ConfigurationManager.GetSection%2A> обращается к сведениям о конфигурации времени выполнения, которые она не может изменить. Чтобы изменить конфигурацию, используйте метод <xref:System.Configuration.Configuration.GetSection%2A> в файле конфигурации, полученном с помощью одного из следующих открытых методов:  
  
-   <xref:System.Configuration.ConfigurationManager.OpenExeConfiguration%2A>  
  
-   <xref:System.Configuration.ConfigurationManager.OpenMachineConfiguration%2A>  
  
-   <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%2A>  
  
   
  
## Examples  
 В следующем примере показано, как использовать метод <xref:System.Configuration.ConfigurationManager.GetSection%2A>. Пример является частью более крупного примера, предоставляемого для класса <xref:System.Configuration.ConfigurationManager>.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#7)]
 [!code-vb[System.Configuration.ConfigurationManager#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Не удалось загрузить файл конфигурации.</exception>
        <block subset="none" type="overrides"><para>Необходимо привести возвращаемое значение к ожидаемому типу конфигурации. Чтобы избежать возможного приведения исключений, следует использовать операцию условного приведения, например оператор C# <see langword="as" /> в или функции [TryCast](~/docs/visual-basic/language-reference/operators/trycast-operator.md) в Visual Basic.</para></block>
        <altmember cref="T:System.Configuration.ConfigurationSection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExeConfiguration">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает указанный файл конфигурации клиента в качестве объекта <see cref="T:System.Configuration.Configuration" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenExeConfiguration (System.Configuration.ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenExeConfiguration(valuetype System.Configuration.ConfigurationUserLevel userLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenExeConfiguration(System.Configuration.ConfigurationUserLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExeConfiguration (userLevel As ConfigurationUserLevel) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenExeConfiguration(System::Configuration::ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="F#" Value="static member OpenExeConfiguration : System.Configuration.ConfigurationUserLevel -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenExeConfiguration userLevel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userLevel" Type="System.Configuration.ConfigurationUserLevel" />
      </Parameters>
      <Docs>
        <param name="userLevel">Объект <see cref="T:System.Configuration.ConfigurationUserLevel" />, для которого открывается конфигурация.</param>
        <summary>Открывает файл конфигурации для текущего приложения в качестве объекта <see cref="T:System.Configuration.Configuration" />.</summary>
        <returns>Объект <see cref="T:System.Configuration.Configuration" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентские приложения используют глобальную конфигурацию, применимую ко всем пользователям, отдельные конфигурации, применяемые к отдельным пользователям, и конфигурации, которые применяются к перемещающимся пользователям. Параметр `userLevel` определяет расположение открываемого файла конфигурации, указывая, не имеет ли он пользовательского уровня (файл конфигурации находится в том же каталоге, что и приложение) или имеет уровень "на пользователя" (файл конфигурации находится в папке параметров приложения, определенной на уровне пользователя).  
  
 Укажите, какую конфигурацию следует получить, передав одно из следующих значений для `userLevel`:  
  
-   Чтобы получить объект <xref:System.Configuration.Configuration>, который применяется ко всем пользователям, присвойте `userLevel` значение <xref:System.Configuration.ConfigurationUserLevel.None>.  
  
-   Чтобы получить объект локальной <xref:System.Configuration.Configuration>, применяемый к текущему пользователю, задайте для `userLevel` значение <xref:System.Configuration.ConfigurationUserLevel.PerUserRoamingAndLocal>.  
  
-   Чтобы получить объект перемещаемого <xref:System.Configuration.Configuration>, который применяется к текущему пользователю, задайте для `userLevel` значение <xref:System.Configuration.ConfigurationUserLevel.PerUserRoaming>.  
  
    > [!NOTE]
    >  Чтобы получить объект <xref:System.Configuration.Configuration> для ресурса, ваш код должен иметь разрешения на чтение всех файлов конфигурации, из которых он наследует параметры. Чтобы обновить файл конфигурации, код должен дополнительно иметь разрешения на запись как для файла конфигурации, так и для каталога, в котором он существует.  
  
   
  
## Examples  
 В следующем примере кода показано применение метода <xref:System.Configuration.ConfigurationManager.OpenExeConfiguration%2A>.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#5)]
 [!code-vb[System.Configuration.ConfigurationManager#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Не удалось загрузить файл конфигурации.</exception>
        <altmember cref="T:System.Configuration.ConfigurationUserLevel" />
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <Member MemberName="OpenExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenExeConfiguration (string exePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenExeConfiguration(string exePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenExeConfiguration(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExeConfiguration (exePath As String) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenExeConfiguration(System::String ^ exePath);" />
      <MemberSignature Language="F#" Value="static member OpenExeConfiguration : string -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenExeConfiguration exePath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="exePath">Путь к исполняемому файлу (EXE-файлу).</param>
        <summary>Открывает указанный файл конфигурации клиента в качестве объекта <see cref="T:System.Configuration.Configuration" />.</summary>
        <returns>Объект <see cref="T:System.Configuration.Configuration" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клиентские приложения используют глобальную конфигурацию, применимую ко всем пользователям, отдельные конфигурации, применяемые к отдельным пользователям, и конфигурации, которые применяются к перемещающимся пользователям. Значение `userLevel` определяет расположение открываемого файла конфигурации. Он указывает, не имеет ли уровень пользователя (файл конфигурации находится в том же каталоге, что и приложение) или имеет уровень "на пользователя" (файл конфигурации находится в пути параметров приложения, определенном типом уровня пользователя).  
  
 Вызов этой перегрузки метода эквивалентен вызову перегрузки <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%28System.Configuration.ExeConfigurationFileMap%2CSystem.Configuration.ConfigurationUserLevel%2CSystem.Boolean%29> с параметром `preLoad`, для которого задано значение `false`.  
  
   
  
## Examples  
 В следующем примере кода показано применение метода <xref:System.Configuration.ConfigurationManager.OpenExeConfiguration%2A>.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#6)]
 [!code-vb[System.Configuration.ConfigurationManager#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Не удалось загрузить файл конфигурации.</exception>
        <altmember cref="T:System.Configuration.ConfigurationUserLevel" />
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <Member MemberName="OpenMachineConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMachineConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMachineConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMachineConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMachineConfiguration () As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMachineConfiguration();" />
      <MemberSignature Language="F#" Value="static member OpenMachineConfiguration : unit -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMachineConfiguration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Открывает файл конфигурации компьютера на текущем компьютере в качестве объекта <see cref="T:System.Configuration.Configuration" />.</summary>
        <returns>Объект <see cref="T:System.Configuration.Configuration" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры конфигурации компьютера применяются ко всему компьютеру и всем приложениям, которые находятся на нем, если только они не были переопределены для локального приложения. Параметры конфигурации компьютера считываются из файла Machine. config текущей версии .NET Framework. Файл Machine. config находится в следующем подкаталоге:  
  
 *% WINDIR%* \микрософт.нет\фрамеворк\\*версии*\конфиг  
  
> [!NOTE]
>  Чтобы получить объект <xref:System.Configuration.Configuration> для ресурса, ваш код должен иметь разрешения на чтение всех файлов конфигурации, из которых он наследует параметры. Чтобы обновить файл конфигурации, код должен дополнительно иметь разрешения на запись как для файла конфигурации, так и для каталога, в котором он существует. Невозможно получить доступ к файлу Machine. config для других версий .NET Framework, которые могут быть установлены на компьютере.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Configuration.ConfigurationManager.OpenMachineConfiguration%2A> для получения всех разделов, содержащихся в файле конфигурации.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#4)]
 [!code-vb[System.Configuration.ConfigurationManager#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Не удалось загрузить файл конфигурации.</exception>
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenMappedExeConfiguration">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает указанный файл конфигурации клиента в качестве объекта <see cref="T:System.Configuration.Configuration" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenMappedExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMappedExeConfiguration (System.Configuration.ExeConfigurationFileMap fileMap, System.Configuration.ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMappedExeConfiguration(class System.Configuration.ExeConfigurationFileMap fileMap, valuetype System.Configuration.ConfigurationUserLevel userLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(System.Configuration.ExeConfigurationFileMap,System.Configuration.ConfigurationUserLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMappedExeConfiguration (fileMap As ExeConfigurationFileMap, userLevel As ConfigurationUserLevel) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMappedExeConfiguration(System::Configuration::ExeConfigurationFileMap ^ fileMap, System::Configuration::ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="F#" Value="static member OpenMappedExeConfiguration : System.Configuration.ExeConfigurationFileMap * System.Configuration.ConfigurationUserLevel -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMappedExeConfiguration (fileMap, userLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileMap" Type="System.Configuration.ExeConfigurationFileMap" />
        <Parameter Name="userLevel" Type="System.Configuration.ConfigurationUserLevel" />
      </Parameters>
      <Docs>
        <param name="fileMap">Объект <see cref="T:System.Configuration.ExeConfigurationFileMap" />, который ссылается на файл конфигурации, используемый вместо файла конфигурации приложения по умолчанию.</param>
        <param name="userLevel">Объект <see cref="T:System.Configuration.ConfigurationUserLevel" />, для которого открывается конфигурация.</param>
        <summary>Открывает указанный файл конфигурации клиента в качестве объекта <see cref="T:System.Configuration.Configuration" />, который использует указанные сопоставление файлов и уровень пользователя.</summary>
        <returns>Объект конфигурации.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Configuration.ConfigurationUserLevel> определяет расположение открываемого файла конфигурации. Указывает, имеет ли файл пользовательский уровень (файл конфигурации находится в том же каталоге, что и приложение) или имеет уровень "на пользователя" (файл конфигурации находится в пути параметров приложения, определенном `userLevel`).  
  
> [!NOTE]
>  Чтобы получить объект <xref:System.Configuration.Configuration> для ресурса, ваш код должен иметь разрешения на чтение всех файлов конфигурации, из которых он наследует параметры. Чтобы обновить файл конфигурации, код должен дополнительно иметь разрешения на запись как для файла конфигурации, так и для каталога, в котором он существует.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%2A> для получения всех разделов, содержащихся в файле конфигурации.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#9)]
 [!code-vb[System.Configuration.ConfigurationManager#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Не удалось загрузить файл конфигурации.</exception>
        <altmember cref="T:System.Configuration.ConfigurationUserLevel" />
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <Member MemberName="OpenMappedExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMappedExeConfiguration (System.Configuration.ExeConfigurationFileMap fileMap, System.Configuration.ConfigurationUserLevel userLevel, bool preLoad);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMappedExeConfiguration(class System.Configuration.ExeConfigurationFileMap fileMap, valuetype System.Configuration.ConfigurationUserLevel userLevel, bool preLoad) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(System.Configuration.ExeConfigurationFileMap,System.Configuration.ConfigurationUserLevel,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMappedExeConfiguration (fileMap As ExeConfigurationFileMap, userLevel As ConfigurationUserLevel, preLoad As Boolean) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMappedExeConfiguration(System::Configuration::ExeConfigurationFileMap ^ fileMap, System::Configuration::ConfigurationUserLevel userLevel, bool preLoad);" />
      <MemberSignature Language="F#" Value="static member OpenMappedExeConfiguration : System.Configuration.ExeConfigurationFileMap * System.Configuration.ConfigurationUserLevel * bool -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMappedExeConfiguration (fileMap, userLevel, preLoad)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileMap" Type="System.Configuration.ExeConfigurationFileMap" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="userLevel" Type="System.Configuration.ConfigurationUserLevel" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="preLoad" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="fileMap">Объект <see cref="T:System.Configuration.ExeConfigurationFileMap" />, который ссылается на файл конфигурации, используемый вместо файла конфигурации приложения по умолчанию.</param>
        <param name="userLevel">Объект <see cref="T:System.Configuration.ConfigurationUserLevel" />, для которого открывается конфигурация.</param>
        <param name="preLoad">Значение <see langword="true" /> для предварительной загрузки всех групп разделов и разделов; в противном случае — значение <see langword="false" />.</param>
        <summary>Открывает указанный файл конфигурации клиента в качестве объекта <see cref="T:System.Configuration.Configuration" />, который использует указанное сопоставление файлов, уровень пользователя и параметр предварительной загрузки.</summary>
        <returns>Объект конфигурации.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Configuration.ConfigurationUserLevel> определяет расположение открываемого файла конфигурации. Указывает, имеет ли файл уровень пользователя (файл конфигурации находится в том же каталоге, что и приложение) или имеет уровень "на пользователя" (файл конфигурации находится в папке параметров приложения, которая определяется `userLevel`).  
  
> [!NOTE]
>  Чтобы получить объект <xref:System.Configuration.Configuration> для ресурса, ваш код должен иметь разрешения на чтение всех файлов конфигурации, из которых он наследует параметры. Чтобы обновить файл конфигурации, код должен дополнительно иметь разрешения на запись как для файла конфигурации, так и для каталога, в котором он существует.  
  
 Пример кода см. в описании перегрузки <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Не удалось загрузить файл конфигурации.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenMappedMachineConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMappedMachineConfiguration (System.Configuration.ConfigurationFileMap fileMap);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMappedMachineConfiguration(class System.Configuration.ConfigurationFileMap fileMap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMappedMachineConfiguration(System.Configuration.ConfigurationFileMap)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMappedMachineConfiguration (fileMap As ConfigurationFileMap) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMappedMachineConfiguration(System::Configuration::ConfigurationFileMap ^ fileMap);" />
      <MemberSignature Language="F#" Value="static member OpenMappedMachineConfiguration : System.Configuration.ConfigurationFileMap -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMappedMachineConfiguration fileMap" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileMap" Type="System.Configuration.ConfigurationFileMap" />
      </Parameters>
      <Docs>
        <param name="fileMap">Объект <see cref="T:System.Configuration.ExeConfigurationFileMap" />, который ссылается на файл конфигурации, используемый вместо файла конфигурации приложения по умолчанию.</param>
        <summary>Открывает файл конфигурации компьютера в качестве объекта <see cref="T:System.Configuration.Configuration" />, который использует указанное сопоставление файлов.</summary>
        <returns>Объект <see cref="T:System.Configuration.Configuration" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметры конфигурации компьютера применяются ко всему компьютеру и всем приложениям, которые находятся на нем, если только они не были переопределены для локального приложения. Параметры конфигурации компьютера считываются из файла Machine. config текущей версии .NET Framework. Файл Machine. config находится в следующем подкаталоге:  
  
 *% WINDIR%* \микрософт.нет\фрамеворк\\*версии*\конфиг  
  
> [!NOTE]
>  Чтобы получить объект <xref:System.Configuration.Configuration> для ресурса, ваш код должен иметь разрешения на чтение всех файлов конфигурации, из которых он наследует параметры. Чтобы обновить файл конфигурации, код должен дополнительно иметь разрешения на запись как для файла конфигурации, так и для каталога, в котором он существует. Невозможно получить доступ к файлу Machine. config для других версий .NET Framework, которые могут быть установлены на компьютере.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Configuration.ConfigurationManager.OpenMappedMachineConfiguration%2A> для получения всех разделов в файле конфигурации.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#4)]
 [!code-vb[System.Configuration.ConfigurationManager#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Не удалось загрузить файл конфигурации.</exception>
        <altmember cref="T:System.Configuration.Configuration" />
        <altmember cref="T:System.Configuration.ConfigurationFileMap" />
      </Docs>
    </Member>
    <Member MemberName="RefreshSection">
      <MemberSignature Language="C#" Value="public static void RefreshSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RefreshSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.RefreshSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RefreshSection (sectionName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RefreshSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="static member RefreshSection : string -&gt; unit" Usage="System.Configuration.ConfigurationManager.RefreshSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Имя раздела конфигурации, или имя пути и раздела конфигурации того раздела, который необходимо обновить.</param>
        <summary>Обновляет раздел с заданным именем, чтобы при следующем извлечении он повторно считывался с диска.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод делает кэш недействительным для указанного раздела конфигурации, не затрагивая другие разделы.  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод <xref:System.Configuration.ConfigurationManager.RefreshSection%2A> для обновления раздела конфигурации параметров приложения.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#7)]
 [!code-vb[System.Configuration.ConfigurationManager#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
