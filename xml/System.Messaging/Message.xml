<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4ba1180388c7cd9201aebbf54e27cf168bad982a" /><Meta Name="ms.sourcegitcommit" Value="43c8e74d92c78325492baf27e41b400443f0dfbf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/08/2019" /><Meta Name="ms.locfileid" Value="68858998" /></Metadata><TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет доступ к свойствам, необходимым для определения сообщения службы MSMQ.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message> Используйте класс для просмотра или получения сообщений из очереди или для точного управления свойствами сообщений при отправке сообщения в очередь.  
  
 <xref:System.Messaging.MessageQueue>использует класс при считывании или получении сообщений из очередей, так как <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> методы и <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> создают новый экземпляр <xref:System.Messaging.Message> класса и устанавливают свойства экземпляра. <xref:System.Messaging.Message> Свойства <xref:System.Messaging.Message> класса, доступные только для чтения, применяются для получения сообщений из очереди, в то время как свойства чтения и записи применяются для отправки и получения сообщений. При <xref:System.Messaging.MessageQueue> просмотре или получении сообщения из очереди его <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> свойство определяет, какое из свойств сообщения извлекается.  
  
 Метод<xref:System.Messaging.MessageQueue.Send%2A>классапозволяет указать любой тип объекта для сообщения, отправляемого в эту очередь. <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue> Свойство экземпляра можно использовать для указания параметров общих сообщений, отправляемых в очередь. <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> К типам параметров относятся модуль форматирования, метка, шифрование и проверка подлинности. Можно также указать значения для соответствующих <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> членов при координации обмена сообщениями с подтверждениями и сообщениями отчетов. <xref:System.Messaging.Message> Использование экземпляра для отправки сообщения в очередь предоставляет гибкие возможности для доступа и изменения многих из этих свойств — для одного сообщения или для каждого сообщения. <xref:System.Messaging.Message>свойства имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.  
  
 Данные сообщения хранятся в <xref:System.Messaging.Message.Body%2A> свойстве и в меньшем экстенте <xref:System.Messaging.Message.AppSpecific%2A> , свойствах и <xref:System.Messaging.Message.Extension%2A> . При шифровании, сериализации или десериализации данных сообщения затрагиваются только содержимое <xref:System.Messaging.Message.Body%2A> свойства.  
  
 Содержимое <xref:System.Messaging.Message.Body%2A> свойства сериализуется при отправке сообщения <xref:System.Messaging.Message.Formatter%2A> с помощью указанного свойства. Сериализованное содержимое находится в <xref:System.Messaging.Message.BodyStream%2A> свойстве. Можно также задать <xref:System.Messaging.Message.BodyStream%2A> свойство напрямую, например, для отправки файла в качестве содержимого данных сообщения. Вы можете изменить <xref:System.Messaging.Message.Body%2A> свойства или <xref:System.Messaging.Message.Formatter%2A> в любое время перед отправкой сообщения, и данные будут сериализованы соответствующим образом при вызове. <xref:System.Messaging.MessageQueue.Send%2A>  
  
 Свойства, определяемые <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> свойством, применяются только к сообщениям, не относящимся к типу <xref:System.Messaging.Message>. Если указать <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> свойство <xref:System.Messaging.MessageQueue>для, свойства с идентичным именем в <xref:System.Messaging.Message> экземпляре, отправленном в эту очередь, приведут к тому, что эти свойства по умолчанию будут проигнорированы.  
  
 Список начальных значений свойств для экземпляра <xref:System.Messaging.Message>см. в <xref:System.Messaging.Message.%23ctor%2A> разделе Конструктор.  
  
   
  
## Examples  
 В следующем примере кода показано форматирование текста сообщения с помощью <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 В следующем примере кода показано форматирование текста сообщения с помощью <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.Message" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.Message" /> с пустым текстом сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для создания нового экземпляра <xref:System.Messaging.Message> класса, имеющего пустое тело.  
  
 Перед отправкой <xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.Message> объекта укажите <xref:System.Messaging.Message.BodyStream%2A> либо свойство, либо свойство. <xref:System.Messaging.Message.Body%2A> Свойство может быть любым объектом, который может быть сериализован, например текстовой строкой, объектом структуры, экземпляром класса или внедренным объектом.  
  
 Если содержимое сообщения не записывается непосредственно в <xref:System.Messaging.Message.BodyStream%2A> свойство, <xref:System.Messaging.Message.Formatter%2A> задайте свойство перед отправкой сообщения. Тело сериализуется с помощью <xref:System.Messaging.Message.Formatter%2A> значения свойства во <xref:System.Messaging.MessageQueue.Send%2A> время вызова <xref:System.Messaging.MessageQueue> метода в экземпляре.  
  
 Объект <xref:System.Messaging.XmlMessageFormatter> является слабо связанным, поэтому при использовании этого формата нет необходимости иметь один и тот же тип объекта для отправителя и получателя. <xref:System.Messaging.ActiveXMessageFormatter> И<xref:System.Messaging.BinaryMessageFormatter> сериализуются данные в двоичное представление. <xref:System.Messaging.ActiveXMessageFormatter> Используется при отправке или получении COM-компонентов.  
  
 В следующей таблице показаны начальные значения свойств для экземпляра <xref:System.Messaging.Message>.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Базовый поставщик служб шифрования Майкрософт версии 1,0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Пустая строка ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Пустая строка ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 В следующем примере кода два сообщения с разными приоритетами отправляются в очередь и затем извлекаются в дальнейшем.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">Объект, сериализуемый в текст сообщения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.Message" />, используя <see cref="T:System.Messaging.XmlMessageFormatter" /> для сериализации заданного объекта в текст сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для создания нового экземпляра <xref:System.Messaging.Message> класса, содержащего объект <xref:System.Messaging.Message.Body%2A> , заданный `body` параметром. `body` Параметр может быть любым объектом, который может быть сериализован, например текстовой строкой, объектом структуры, экземпляром класса или внедренным объектом. Тело сериализуется с помощью, <xref:System.Messaging.XmlMessageFormatter> если не <xref:System.Messaging.Message.Formatter%2A> изменить свойство перед <xref:System.Messaging.Message> отправкой. Если изменить <xref:System.Messaging.Message.Body%2A> свойство или <xref:System.Messaging.Message.Formatter%2A> в любое время до вызова метода <xref:System.Messaging.MessageQueue.Send%2A>, сообщение будет сериализовано в соответствии с новым значением свойства.  
  
 Объект <xref:System.Messaging.XmlMessageFormatter> является слабо связанным, поэтому при использовании этого формата нет необходимости иметь один и тот же тип объекта для отправителя и получателя. <xref:System.Messaging.ActiveXMessageFormatter> И<xref:System.Messaging.BinaryMessageFormatter> сериализуются данные в двоичное представление. <xref:System.Messaging.ActiveXMessageFormatter> Используется при отправке или получении COM-компонентов.  
  
 В следующей таблице показаны начальные значения свойств для экземпляра <xref:System.Messaging.Message>.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Базовый поставщик служб шифрования Майкрософт версии 1,0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Параметр `body`.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Пустая строка ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Пустая строка ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 В следующем примере кода создается новая очередь, отправляется сообщение, содержащее в него заказ, а затем извлекается.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">Объект, сериализуемый в текст сообщения.</param>
        <param name="formatter">Объект <see cref="T:System.Messaging.IMessageFormatter" />, задающий модуль форматирования, с помощью которого осуществляется сериализация текста сообщения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.Message" />, используя указанный модуль форматирования для сериализации заданного объекта в текст сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для создания нового экземпляра <xref:System.Messaging.Message> класса, содержащего объект <xref:System.Messaging.Message.Body%2A> , заданный `body` параметром, который использует любой допустимый модуль форматирования для сериализации тела. `body` Параметр — это любой объект, который может быть сериализован, например текстовая строка, объект структуры, экземпляр класса или внедренный объект. Если изменить <xref:System.Messaging.Message.Body%2A> свойство или <xref:System.Messaging.Message.Formatter%2A> в любое время до вызова метода <xref:System.Messaging.MessageQueue.Send%2A>, сообщение будет сериализовано в соответствии с новым значением свойства.  
  
 Объект <xref:System.Messaging.XmlMessageFormatter> является слабо связанным, поэтому при использовании этого формата нет необходимости иметь один и тот же тип объекта для отправителя и получателя. <xref:System.Messaging.ActiveXMessageFormatter> И<xref:System.Messaging.BinaryMessageFormatter> сериализуются данные в двоичное представление. <xref:System.Messaging.ActiveXMessageFormatter> Используется при отправке или получении COM-компонентов.  
  
 В следующей таблице показаны начальные значения свойств для экземпляра <xref:System.Messaging.Message>.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Базовый поставщик служб шифрования Майкрософт версии 1,0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Параметр `body`.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Пустая строка ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.Formatter%2A>|Параметр `formatter`.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Пустая строка ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает тип сообщения подтверждения, которое должно возвращаться приложению, передающему исходное сообщение.</summary>
        <value>Одно из значений <see cref="T:System.Messaging.AcknowledgeTypes" />, которые представляют как типы подтверждающих сообщений, размещаемых системой в очереди администрирования, так и условия, при которых подтверждения возвращаются в приложение, передавшее исходное сообщение. Значение по умолчанию — <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AcknowledgeType%2A> Свойство определяет тип сообщений подтверждения, запрошенных отправляющим приложением. <xref:System.Messaging.Message.AcknowledgeType%2A> Задайте свойство перед отправкой сообщения для запроса уведомления об определенных случаях. Например, сообщение достигает очереди места назначения, извлекается сообщение или истекает время ожидания, из-за которого сообщение не удается достичь или получить из очередь назначения.  
  
 Очередь сообщений возвращает уведомление, отправляя подтверждающие сообщения <xref:System.Messaging.Message.AdministrationQueue%2A> свойству, заданному исходным сообщением. <xref:System.Messaging.Message.Acknowledgment%2A> Свойство сообщения подтверждения указывает тип подтверждения, который он представляет. Например, если сообщение подтверждения было отправлено из-за того, что сообщение не достигло места назначения <xref:System.Messaging.Message.TimeToReachQueue%2A> до истечения интервала <xref:System.Messaging.Message.Acknowledgment%2A> , свойство сообщения подтверждения будет содержать это значение `ReachQueueTimeout`.  
  
   
  
## Examples  
 Следующий пример кода отправляет и получает сообщение, содержащее заказ в очередь и из нее. Он специально запрашивает положительное подтверждение, когда исходное сообщение достигает или извлекается из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.AcknowledgeType" />.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает классификацию подтверждения, представляемого данным сообщением.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Messaging.Acknowledgment" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При получении сообщения из очереди администрирования прочтите <xref:System.Messaging.Message.Acknowledgment%2A> свойство, чтобы проверить состояние исходного сообщения.  
  
 При отправке сообщения в очередь назначения службе очереди сообщений можно запрашивать размещение сообщения подтверждения. Такое сообщение может указывать, например, было ли сообщение получено и получено в течение заданного времени ожидания, или же может указывать, что пошло не так в случае сбоя доставки. Очередь назначения возвращает подтверждающие сообщения и отправляет их в очередь администрирования, указанную в <xref:System.Messaging.Message.AdministrationQueue%2A> свойстве исходного сообщения. <xref:System.Messaging.Message.Id%2A> Свойство сообщения подтверждения идентифицирует сообщение подтверждения, а не исходное сообщение. Идентификатор исходного сообщения можно найти в <xref:System.Messaging.Message> <xref:System.Messaging.Message.CorrelationId%2A> свойстве экземпляра подтверждения.  
  
 Если этот <xref:System.Messaging.Message> экземпляр представляет сообщение подтверждения <xref:System.Messaging.Message.Acknowledgment%2A> , свойство указывает тип подтверждения. В противном случае `Normal` <xref:System.Messaging.Message.Acknowledgment%2A> свойство содержит значение.  
  
 <xref:System.Messaging.Message.AcknowledgeType%2A> Используйте свойство исходного сообщения, чтобы указать обстоятельства, при которых будут возвращаться подтверждения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает очередь, принимающую подтверждающие сообщения, созданные службой очереди сообщений.</summary>
        <value>Класс <see cref="T:System.Messaging.MessageQueue" />, задающий очередь администрирования, используемую для сообщений подтверждения, создаваемых системой. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Очередь, указанная в <xref:System.Messaging.Message.AdministrationQueue%2A> свойстве, может быть любой нетранзакционной очередью. Подтверждающие сообщения, передаваемые в очередь администрирования, могут указывать, достигло ли исходное сообщение своей конечной очереди, а также было ли оно удалено из очереди.  
  
 Если свойство имеет любое значение, отличное от `None`, то в отправляющем приложении должна быть указана очередь, которая будет использоваться в качестве очереди администрирования. <xref:System.Messaging.Message.AcknowledgeType%2A>  
  
   
  
## Examples  
 Следующий пример кода отправляет и получает сообщение, содержащее заказ в очередь и из нее. Он специально запрашивает положительное подтверждение, когда исходное сообщение достигает или извлекается из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.AdministrationQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает дополнительные сведения, зависящие от приложения.</summary>
        <value>Сведения, зависящие от приложения. По умолчанию используется значение ноль.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AppSpecific%2A> Свойство содержит сведения, относящиеся к приложению, которые можно использовать для организации различных типов сообщений. Например, можно использовать индексы, связанные с приложением. Для интерпретации <xref:System.Messaging.Message.AppSpecific%2A> сведений о свойствах отвечает приложение.  
  
 По возможности следует включать данные сообщений в текст сообщения, а не в <xref:System.Messaging.Message.AppSpecific%2A> свойство.  
  
 При работе с внешними очередями используйте <xref:System.Messaging.Message.Extension%2A> свойство, чтобы указать свойства сообщения, не существующие в очереди сообщений. Как и в <xref:System.Messaging.Message.AppSpecific%2A> случае со свойством, приложение несет ответственность за понимание содержимого <xref:System.Messaging.Message.Extension%2A> свойства.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.AppSpecific" />.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время поступления сообщения в очередь местоназначения.</summary>
        <value>Объект <see cref="T:System.DateTime" />, который представляет время поступления сообщения в очередь местоназначения. Это время представляет собой локальное время (отсчитываемое относительно гринвичского времени) компьютера, на котором располагается очередь местоназначения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> Свойство сообщения указывает, насколько быстро должно быть получено сообщение из очереди назначения. Таймер <xref:System.Messaging.Message.TimeToBeReceived%2A> свойства запускается при отправке сообщения, а не при поступлении сообщения в очередь.  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Messaging.Message.ArrivedTime%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.ArrivedTime" />.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должен ли быть присоединен к сообщению идентификатор отправителя.</summary>
        <value>Значение <see langword="true" />, если <see cref="P:System.Messaging.Message.SenderId" /> должен быть присоединен к сообщению, в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderId%2A> Свойство представляет собой массив байтов, представляющий идентификатор отправляющего пользователя. Идентификатор отправителя задается очередью сообщений и используется принимающим диспетчером очереди для проверки наличия у отправителя прав доступа к очереди.  
  
 Отсутствие идентификатора отправителя является указанием отправляющего приложения о том, что службе очереди сообщений не следует проверять отправителя сообщения и не проверять права доступа отправителя на получение очереди. Объект <xref:System.Messaging.Message.SenderId%2A> заслуживает доверия только в том случае, если сообщение прошло проверку подлинности при достижении очереди назначения. Сообщение отклоняется при достижении очереди назначения, если очередь принимает только сообщения, прошедшие проверку подлинности, <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> а <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> свойство `false`или имеет значение.  
  
> [!CAUTION]
>  Если сообщение отклоняется, оно либо отправляется в очередь недоставленных сообщений (если <xref:System.Messaging.Message.UseDeadLetterQueue%2A> имеет `true`значение), либо игнорируется. Вы можете запросить подтверждения, когда сообщение не пойдет в очередь. В противном <xref:System.Messaging.Message.UseDeadLetterQueue%2A> случае `false` , если сообщение может быть потеряно без предупреждения.  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение <xref:System.Messaging.Message.AttachSenderId%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.AttachSenderId" />.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, прошло ли сообщение проверку подлинности.</summary>
        <value>Значение <see langword="true" />, если была запрошена проверка подлинности при поступлении сообщения в очередь; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Authenticated%2A> Свойство используется только приложением, когда оно взаимодействует с сообщением и пытается определить, была ли запрошена проверка подлинности. Если сообщение находится в очереди, сообщение прошло проверку подлинности. И наоборот, если <xref:System.Messaging.Message.Authenticated%2A> свойство имеет `true`значение, принимающий Диспетчер очереди проходил проверку подлинности сообщения при получении этого сообщения.  
  
 Невозможно определить, прошло ли сообщение проверку подлинности, просмотрев его свойства. Служба очередей сообщений отклоняет сообщения, которые не прошли проверку подлинности, прежде чем они будут доставлены в очередь. Однако можно запросить отправку сообщения подтверждения, если сбой доставки предотвращает поступление сообщения в очередь.  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Messaging.Message.Authenticated%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Authenticated" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя поставщика служб шифрования, используемого для создания цифровой подписи сообщения.</summary>
        <value>Имя поставщика служб шифрования, используемого для создания цифровой подписи сообщения. По умолчанию это Microsoft Base Cryptographic Provider, версия 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обычно используется <xref:System.Messaging.Message.AuthenticationProviderName%2A> при работе с внешними очередями. Службе очереди сообщений требуется имя поставщика проверки подлинности и тип поставщика проверки подлинности поставщика служб шифрования (поставщик проверки подлинности) для проверки цифровых подписей сообщений, отправленных во внешнюю очередь и сообщения, переданные в сообщение. Постановка в очередь из внешней очереди.  
  
 При отправке сообщения всегда задавайте <xref:System.Messaging.Message.AuthenticationProviderName%2A> свойства и <xref:System.Messaging.Message.ConnectorType%2A> вместе. При отправке сообщения служба очередей сообщений игнорирует имя поставщика проверки подлинности, если тип соединителя не задан.  
  
 Свойство не может иметь `null`значение, но может быть пустой строкой (""). <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Невозможно задать свойство <see cref="P:System.Messaging.Message.AuthenticationProviderName" />.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.AuthenticationProviderName" />.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.AuthenticationProviderName" /> было установлено равным <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает тип поставщика служб шифрования, используемого для создания цифровой подписи сообщения.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Messaging.CryptographicProviderType" />. Значение по умолчанию — <see langword="RSA_FULL" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило, <xref:System.Messaging.Message.AuthenticationProviderType%2A> свойство используется при работе с внешними очередями для указания поставщика служб шифрования, связанного с сообщением. Службе очереди сообщений требуется имя поставщика проверки подлинности и тип поставщика проверки подлинности поставщика служб шифрования (поставщик проверки подлинности) для проверки цифровых подписей сообщений, отправленных во внешнюю очередь и сообщения, переданные в сообщение. Постановка в очередь из внешней очереди.  
  
 Предназначен `RsaFull` только для использования с обменом сообщениями.  
  
 При отправке сообщения всегда задавайте <xref:System.Messaging.Message.AuthenticationProviderType%2A> свойства и <xref:System.Messaging.Message.ConnectorType%2A> вместе. При отправке сообщения служба очередей сообщений игнорирует тип поставщика проверки подлинности, если тип соединителя не задан.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Невозможно задать свойство <see cref="P:System.Messaging.Message.AuthenticationProviderType" />.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.AuthenticationProviderType" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает содержимое сообщения.</summary>
        <value>Объект, задающий содержимое сообщения. Таким объектом может быть строка, дата, денежная единица, число, байтовый массив или любой управляемый объект.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Body%2A> Свойство сообщения обычно содержит данные, связанные с сообщением. Хотя можно также отсылать данные, относящиеся к приложению, <xref:System.Messaging.Message.AppSpecific%2A> в <xref:System.Messaging.Message.Extension%2A> свойствах и, когда это возможно, необходимо <xref:System.Messaging.Message.Body%2A> включить данные сообщений в сообщение. Сериализуются или шифруются только содержимое Свойства.<xref:System.Messaging.Message.Body%2A>  
  
 <xref:System.Messaging.Message.Body%2A> Свойство может содержать любой объект, размер которого не превышает 4 МБ. При использовании <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> для отправки любого объекта, который не относится к <xref:System.Messaging.MessageQueue>типу <xref:System.Messaging.Message> <xref:System.Messaging.Message.Body%2A> , этот объект <xref:System.Messaging.Message> будет находиться <xref:System.Messaging.MessageQueue.Peek%2A> в свойстве экземпляра, возвращаемого или <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 Строковый аргумент в `MessageQueue.Send("hello.")` является примером такого универсального объекта.  
  
 <xref:System.Messaging.Message.BodyType%2A> Свойство указывает тип сведений, хранящихся в тексте сообщения. Очередь сообщений использует эти сведения для обнаружения типа <xref:System.Messaging.Message.Body%2A> содержимого свойства.  
  
 Перед отправкой <xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.Message> объекта укажите <xref:System.Messaging.Message.BodyStream%2A> либо свойство, либо свойство. <xref:System.Messaging.Message.Body%2A> Свойство может быть любым сериализуемым объектом, таким как текстовая строка, объект структуры, экземпляр класса или внедренный объект.  
  
 Если содержимое сообщения не записывается непосредственно в <xref:System.Messaging.Message.BodyStream%2A> свойство, <xref:System.Messaging.Message.Formatter%2A> задайте свойство перед отправкой сообщения. При вызове <xref:System.Messaging.MessageQueue>методадля экземпляра тело сериализуется с помощью модуля форматирования, содержащегося в <xref:System.Messaging.Message.Formatter%2A> свойстве. <xref:System.Messaging.MessageQueue.Send%2A> Если сообщение отправляется без указания значения для <xref:System.Messaging.Message.Formatter%2A> свойства, форматер по умолчанию принимает <xref:System.Messaging.XmlMessageFormatter>значение.  
  
> [!NOTE]
>  Попытка задать текст сообщения, чтобы <xref:System.Decimal.MaxValue> <xref:System.OverflowException> вызовет `Send` <xref:System.Messaging.ActiveXMessageFormatter> метод <xref:System.Messaging.MessageQueue> при вызове метода класса и использовании.  
  
   
  
## Examples  
 В следующем примере кода два сообщения с разными приоритетами отправляются в очередь и затем извлекаются в дальнейшем.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение свойства <see cref="P:System.Messaging.Message.Formatter" /> — <see langword="null" />.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает сведения в тексте сообщения.</summary>
        <value>Объект <see cref="T:System.IO.Stream" />, содержащий сериализованные сведения, включенные в объект <see cref="P:System.Messaging.Message.Body" /> сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текст сообщения может состоять из любого типа данных, например строки, даты, валюты, числа, массива байтов или любого управляемого объекта. Эти сведения сериализуются в объект <xref:System.IO.Stream> для передачи в очередь.  
  
 Перед отправкой <xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.Message> объекта укажите <xref:System.Messaging.Message.BodyStream%2A> либо свойство, либо свойство. Если задать <xref:System.Messaging.Message.Body%2A> свойство, содержимое будет сериализовано <xref:System.Messaging.Message.BodyStream%2A> в свойство. Однако вы можете написать <xref:System.Messaging.Message.BodyStream%2A> свойство напрямую. Это полезно, например, когда нужно открыть подключение к файлу и передать его содержимое в виде текста сообщения.  
  
 Если содержимое сообщения не записывается непосредственно в <xref:System.Messaging.Message.BodyStream%2A> свойство, <xref:System.Messaging.Message.Formatter%2A> задайте свойство перед отправкой сообщения. При вызове <xref:System.Messaging.MessageQueue>методадля экземпляра тело сериализуется с помощью модуля форматирования, содержащегося в <xref:System.Messaging.Message.Formatter%2A> свойстве. <xref:System.Messaging.MessageQueue.Send%2A> Если сообщение отправляется без указания значения для <xref:System.Messaging.Message.Formatter%2A> свойства, форматер по умолчанию принимает <xref:System.Messaging.XmlMessageFormatter>значение.  
  
 Если задать <xref:System.Messaging.Message.UseEncryption%2A> для `true` свойства значение для текста сообщения, сообщение будет зашифровано при его отправке, а <xref:System.Messaging.Message.Body%2A> не при задании свойства. <xref:System.Messaging.Message.BodyStream%2A> Поэтому свойство не шифруется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает тип данных, содержащихся в тексте сообщения.</summary>
        <value>Истинный тип текста сообщения, такой как строка, дата, денежная единица или число.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Очередь сообщений распознает содержимое текста как объект или как сериализованный поток. Свойство указывает тип объекта <xref:System.Messaging.Message.Body%2A> в свойстве сообщения. <xref:System.Messaging.Message.BodyType%2A>  
  
 <xref:System.Messaging.XmlMessageFormatter> Выполняет привязку собственных типов и объекта в теле сообщения. Если используется <xref:System.Messaging.XmlMessageFormatter>, модуль форматирования <xref:System.Messaging.Message.BodyType%2A> задает свойство для вас.  
  
 Другие модули форматирования могут также предоставлять функции привязки, как показано в следующем C# коде.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Messaging.Message.BodyType%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, что передающим приложением заданы некоторые свойства сообщения, обычно устанавливаемые службой очереди сообщений.</summary>
        <value><see cref="T:System.Guid" /> определяется приложением и используется совместно связующими приложениями или шифрованием сообщений. Этот объект <see cref="T:System.Guid" /> позволяет принимающему приложению интерпретировать установленные передающим приложением свойства, которые обычно задаются службой Message Queuing.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Служба очереди сообщений требует <xref:System.Messaging.Message.ConnectorType%2A> , чтобы свойство было задано каждый раз, когда приложение задает свойство сообщения, которое обычно задается службой очереди сообщений. Приложение обычно использует <xref:System.Messaging.Message.ConnectorType%2A> в следующих двух случаях:  
  
-   Каждый раз, когда приложение соединителя передает сообщение. <xref:System.Messaging.Message.ConnectorType%2A> Сообщает отправляющему и принимающему приложениям способ интерпретации свойств сообщения о безопасности и подтверждении.  
  
-   Каждый раз, когда отправляющее приложение, а не очередь сообщений, шифрует сообщение. Сообщает очереди сообщений об <xref:System.Messaging.Message.DestinationSymmetricKey%2A> использовании значения свойства для расшифровки сообщения. <xref:System.Messaging.Message.ConnectorType%2A>  
  
 Необходимо задать свойство, <xref:System.Messaging.Message.ConnectorType%2A> если заданы следующие свойства (в противном случае очередь будет игнорировать эти свойства при отправке сообщения):  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.ConnectorType" />.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает идентификатор сообщения, используемый подтверждениями, отчетами и ответными сообщениями для ссылки на исходное сообщение.</summary>
        <value>Идентификатор сообщения задается свойством <see cref="P:System.Messaging.Message.Id" /> исходного сообщения. Этот идентификатор корреляции используется службой MSMQ при создании подтверждающего сообщения или сообщения-отчета, а также приложением при создании ответного сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда очередь сообщений создает подтверждение или сообщение отчета, оно использует свойство идентификатора корреляции для указания идентификатора сообщения исходного сообщения. Таким образом, код корреляции связывает отчет или подтверждение с исходным сообщением.  
  
 Затем отправляющее приложение может сопоставить подтверждение или отчет с исходным сообщением, используя <xref:System.Messaging.Message.CorrelationId%2A> свойство для задания <xref:System.Messaging.Message.Id%2A> свойства исходного сообщения.  
  
 Приложения соединителя также должны устанавливать <xref:System.Messaging.Message.CorrelationId%2A> в качестве свойства подтверждения и сообщения отчета идентификатор исходного сообщения.  
  
 Когда приложение отправляет ответное сообщение в отправляющее приложение, можно задать <xref:System.Messaging.Message.CorrelationId%2A> для свойства ответного сообщения идентификатор исходного сообщения. Затем отправляющее приложение может сопоставить ответное сообщение с отправленным сообщением.  
  
   
  
## Examples  
 Следующий пример кода отправляет и получает сообщение, которое содержит порядок в очередь и из нее. Он специально запрашивает положительное подтверждение, когда исходное сообщение достигает или извлекается из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.CorrelationId" />.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <see cref="P:System.Messaging.Message.CorrelationId" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает планируемую очередь местоназначения для сообщения.</summary>
        <value>Объект <see cref="T:System.Messaging.MessageQueue" />, который задает предполагаемую очередь назначения для сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.DestinationQueue%2A> Свойство чаще всего используется для определения исходного назначения сообщения, полученного в журнале или очереди недоставленных сообщений. Обычно нет необходимости изучать это свойство, так как обычно сообщение извлекается из очереди назначения.  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Messaging.Message.DestinationQueue%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.DestinationQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает симметричный ключ, применяемый для шифрования сообщений, шифруемых приложением, или сообщений, отправляемых во внешние очереди.</summary>
        <value>Массив байтовых значений, задающий целевой симметричный ключ, используемый для шифрования сообщения. По умолчанию задан массив нулевой длины.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для двух сценариев требуется использовать <xref:System.Messaging.Message.DestinationSymmetricKey%2A> свойство. Первый — когда приложение, а не очередь сообщений, шифрует сообщение. Второй — при отправке зашифрованного сообщения в систему очередей, отличную от очереди сообщений.  
  
 Перед установкой этого свойства необходимо зашифровать симметричный ключ с помощью открытого ключа принимающего Queue Manager. При отправке сообщения, зашифрованного приложением, диспетчер очереди приема использует симметричный ключ для расшифровки сообщения перед его отправкой в очередь назначения.  
  
 При отправке сообщения во внешнюю очередь сообщение сначала получается соответствующим приложением-соединителем, которое пересылает зашифрованное сообщение с присоединенным симметричным ключом к принимающему приложению. Затем принимающее приложение несет ответственность за расшифровку сообщения с помощью симметричного ключа.  
  
 При задании <xref:System.Messaging.Message.DestinationSymmetricKey%2A> свойства необходимо также <xref:System.Messaging.Message.ConnectorType%2A> задать свойство. При отправке сообщения служба Message Queuing игнорирует это <xref:System.Messaging.Message.DestinationSymmetricKey%2A> свойство, <xref:System.Messaging.Message.ConnectorType%2A> если свойство также не задано.  
  
 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Свойство имеет максимальный размер массива, равный 256.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.DestinationSymmetricKey" />.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает цифровую подпись, используемую службой очереди сообщений при проверке подлинности сообщения.</summary>
        <value>Массив байтовых значений, задающий цифровую подпись очереди сообщений 1.0, используемую для проверки подлинности сообщения. По умолчанию задан массив нулевой длины.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Служба очереди сообщений использует цифровую подпись при проверке подлинности сообщений, отправленных службой очередей сообщений версии 1,0. В большинстве случаев очередь сообщений создает и задает <xref:System.Messaging.Message.DigitalSignature%2A> свойство, когда отправляющее приложение запрашивает проверку подлинности. Принимающее приложение использует это свойство для получения цифровой подписи, прикрепленной к сообщению.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> Свойство можно использовать только при работе с очередью сообщений версии 2,0. При запросе проверки подлинности в отправляющем приложении должны быть указаны сигнатуры очереди сообщений версии 1,0. Если отправляющее приложение отправляет сигнатуру очереди сообщений версии 2,0, это свойство содержит буфер из четырех байтов, каждый из которых содержит ноль.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> Свойство вместе <xref:System.Messaging.Message.SenderCertificate%2A> со свойством также используется приложениями-соединителями при отправке сообщения. В этом сценарии приложение соединителя, а не Message Queuing, создает цифровую подпись, которая основывается на сертификате пользователя, отправляющего сообщение.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> Свойство имеет максимальный размер массива, равный 256.  
  
 При задании <xref:System.Messaging.Message.DigitalSignature%2A> свойства необходимо также <xref:System.Messaging.Message.ConnectorType%2A> задать свойство. При отправке сообщения служба Message Queuing игнорирует это <xref:System.Messaging.Message.DigitalSignature%2A> свойство, <xref:System.Messaging.Message.ConnectorType%2A> если свойство не задано.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.DigitalSignature" />.</exception>
        <exception cref="T:System.ArgumentException">Значение свойства <see cref="P:System.Messaging.Message.DigitalSignature" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает алгоритм шифрования, используемый для шифрования тела конфиденциального сообщения.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Messaging.EncryptionAlgorithm" />. Значение по умолчанию — <see langword="RC2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если сообщение является частным (зашифрованным), оно шифруется перед отправкой и расшифровывается при получении. <xref:System.Messaging.Message.EncryptionAlgorithm%2A> Свойство определяет алгоритм, используемый для шифрования текста конфиденциального сообщения.  
  
 Очередь может потребовать, чтобы входящие сообщения были зашифрованы. Если приложение отправляет незашифрованное (не закрытое) сообщение в очередь, принимающую только конфиденциальные сообщения, или если отправляет частное сообщение в очередь, принимающую только сообщения, не являющиеся частными, очередь отклоняет сообщение. Отправляющее приложение может запросить возврат сообщения об отрицательном подтверждении в таком случае.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.EncryptionAlgorithm" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает дополнительные, определяемые приложением сведения, связанные с данным сообщением.</summary>
        <value>Массив байтовых значений, предоставляющий дополнительные, определяемые приложением, сведения, связанные с данным сообщением. По умолчанию задан массив нулевой длины.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Extension%2A> Свойство предоставляет сведения, определяемые приложением, такие как большой двоичный объект, связанный с сообщением. Принимающее приложение несет ответственность за интерпретацию содержимого <xref:System.Messaging.Message.Extension%2A> свойства.  
  
 Там, где это возможно, следует включить данные сообщения <xref:System.Messaging.Message.Body%2A> в свойство сообщения, а не в <xref:System.Messaging.Message.Extension%2A> свойство.  
  
 При работе с внешними очередями используйте <xref:System.Messaging.Message.Extension%2A> свойство, чтобы указать свойства сообщения, не существующие в очереди сообщений.  
  
 Внешняя очередь существует в системе очередей, отличной от очереди сообщений Майкрософт. Очередь сообщений взаимодействует с такими очередями через приложение соединителя.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Extension" />.</exception>
        <exception cref="T:System.ArgumentException">Значение свойства <see cref="P:System.Messaging.Message.Extension" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает модуль форматирования, используемый для сериализации объекта в текст сообщения или десериализации объекта из текста сообщения.</summary>
        <value>Объект <see cref="T:System.Messaging.IMessageFormatter" />, создающий поток, записываемый в текст сообщения или считываемый из него. Значение по умолчанию — <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Formatter%2A> Используйте свойство при чтении и записи сообщения. При отправке сообщения в очередь модуль форматирования сериализует <xref:System.Messaging.Message.Body%2A> свойство в поток, который может быть отправлен в очередь сообщений. При чтении из очереди модуль форматирования десериализует данные сообщения в <xref:System.Messaging.Message.Body%2A> свойство.  
  
 Если содержимое сообщения не записывается непосредственно в <xref:System.Messaging.Message.BodyStream%2A> свойство, <xref:System.Messaging.Message.Formatter%2A> задайте свойство перед отправкой сообщения. При вызове <xref:System.Messaging.MessageQueue>методадля экземпляра тело сериализуется с помощью модуля форматирования, содержащегося в <xref:System.Messaging.Message.Formatter%2A> свойстве. <xref:System.Messaging.MessageQueue.Send%2A> Если сообщение отправляется без указания значения для <xref:System.Messaging.Message.Formatter%2A> свойства, форматер по умолчанию принимает <xref:System.Messaging.XmlMessageFormatter>значение.  
  
 Объект <xref:System.Messaging.XmlMessageFormatter> является слабо связанным, поэтому при использовании этого формата нет необходимости иметь один и тот же тип объекта для отправителя и получателя. <xref:System.Messaging.ActiveXMessageFormatter> И<xref:System.Messaging.BinaryMessageFormatter> сериализуются данные в двоичное представление. <xref:System.Messaging.ActiveXMessageFormatter> Используется при отправке или получении COM-компонентов.  
  
   
  
## Examples  
 В следующем примере кода показано форматирование текста сообщения с помощью <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 В следующем примере кода показано форматирование текста сообщения с помощью <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение свойства <see cref="P:System.Messaging.Message.Formatter" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает алгоритм хэширования, используемый службой очереди сообщений при проверке подлинности сообщения или при создании цифровой подписи для сообщения.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Messaging.HashAlgorithm" />. Для Windows XP значение по умолчанию равно <see langword="SHA" />. В противном случае значением по умолчанию будет <see langword="MD5" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 На исходном компьютере очередь сообщений использует алгоритм хэширования при создании цифровой подписи сообщения. Затем целевой Диспетчер очереди использует тот же алгоритм хэширования для проверки подлинности сообщения при его получении.  

 Из-за проблем с MD5 и SHA1 Корпорация Майкрософт рекомендует использовать SHA256. 
 
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.HashAlgorithm" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает идентификатор сообщения.</summary>
        <value>Уникальный идентификатор сообщения, создаваемый службой Message Queuing.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Очередь сообщений создает идентификатор сообщения при отправке сообщения. Идентификатор состоит из 20 байт и включает два элемента: компьютер <xref:System.Guid> отправляющего компьютера и уникальный идентификатор сообщения на компьютере. Объединение двух этих элементов создает идентификатор сообщения, уникальный в данной сети.  
  
 Служба очереди сообщений создает идентификаторы сообщений для всех сообщений, включая подтверждения и сообщения отчетов. Сообщение подтверждения обычно отправляется службой очереди сообщений в ответ на получение или сбой исходного отправленного сообщения. Значение <xref:System.Messaging.Message.Id%2A> свойства исходного сообщения можно найти <xref:System.Messaging.Message.CorrelationId%2A> в свойстве сообщения подтверждения.  
  
 <xref:System.Messaging.Message.Id%2A> Свойство также можно использовать при отправке ответного сообщения в очередь ответов. Чтобы включить идентификатор исходного сообщения в ответное сообщение, задайте <xref:System.Messaging.Message.CorrelationId%2A> свойству ответного сообщения <xref:System.Messaging.Message.Id%2A> свойство исходного сообщения. Приложение, считывающее ответное сообщение, может затем использовать идентификатор корреляции ответного сообщения для идентификации исходного сообщения.  
  
   
  
## Examples  
 Следующий пример кода отправляет и получает сообщение, содержащее заказ в очередь и из нее. Он специально запрашивает положительное подтверждение, когда исходное сообщение достигает или извлекается из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Id" />.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на отсутствие тайм-аута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A>и <xref:System.Messaging.Message.TimeToReachQueue%2A> требует значения, указывающего время ожидания. Для первого времени ожидания — это максимально допустимое время для получения сообщения из очереди. В последнем случае время ожидания — это время, разрешенное для получения сообщения в очередь. В обоих случаях можно указать время ожидания как количество секунд или использовать <xref:System.Messaging.Message.InfiniteTimeout> , чтобы указать, что время ожидания не существует.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Messaging.Message.InfiniteTimeout> поля.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, является ли это сообщением первым переданным сообщением транзакции.</summary>
        <value>Значение <see langword="true" />, если данное сообщение было первым сообщением, переданным в транзакции, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Принимающие приложения используют <xref:System.Messaging.Message.IsFirstInTransaction%2A> свойство для проверки того, что сообщение было первым сообщением, отправленным в одной транзакции в одну очередь.  
  
 Это свойство доступно только в службе очередей сообщений версии 2,0 и более поздних версий.  
  
 Чтобы проверить границы транзакций, можно использовать <xref:System.Messaging.Message.IsFirstInTransaction%2A> свойство вместе с двумя другими свойствами: <xref:System.Messaging.Message.IsLastInTransaction%2A> и <xref:System.Messaging.Message.TransactionId%2A>. Используйте первый из них, чтобы проверить, было ли сообщение отправлено последним в транзакции, и использовать второй для получения идентификатора транзакции.  
  
 Если в транзакции отправляется только одно сообщение, <xref:System.Messaging.Message.IsFirstInTransaction%2A> для `true`свойств и <xref:System.Messaging.Message.IsLastInTransaction%2A> устанавливается значение.  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Messaging.Message.IsFirstInTransaction%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.IsFirstInTransaction" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, является ли это сообщением последним переданным сообщением транзакции.</summary>
        <value>Значение <see langword="true" />, если данное сообщение было последним сообщением, переданным в транзакции; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Принимающие приложения используют <xref:System.Messaging.Message.IsLastInTransaction%2A> свойство для проверки того, что сообщение было последним сообщением, отправленным в одной транзакции в одну очередь.  
  
 Это свойство доступно только в службе очередей сообщений версии 2,0 и более поздних версий.  
  
 Чтобы проверить границы транзакций, можно использовать <xref:System.Messaging.Message.IsLastInTransaction%2A> свойство вместе с двумя другими свойствами: <xref:System.Messaging.Message.IsFirstInTransaction%2A> и <xref:System.Messaging.Message.TransactionId%2A>. Используйте первый из них, чтобы проверить, было ли сообщение отправлено первым в транзакции, и использовать второй для получения идентификатора транзакции.  
  
 Если в транзакции отправляется только одно сообщение, <xref:System.Messaging.Message.IsFirstInTransaction%2A> для `true`свойств и <xref:System.Messaging.Message.IsLastInTransaction%2A> устанавливается значение.  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Messaging.Message.IsLastInTransaction%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.IsLastInTransaction" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает определяемую приложением строку в кодировке Юникод, описывающую данное сообщение.</summary>
        <value>Метка сообщения. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метку сообщения можно использовать для решения ряда задач. Например, ее можно использовать для отображения или выборочной обработки сообщений на основе значений этой метки. Метка не обязательно должна быть уникальной в сообщениях.  
  
 Метки очередей сообщений и метки сообщений представляют определяемые приложением значения, которые могут помочь в идентификации очереди или сообщения в понятных для человека терминах. Приложение может интерпретировать содержимое метки, которое не имеет встроенного значения для приложения очереди сообщений.  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение <xref:System.Messaging.Message.Label%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Label" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представлено в MSMQ 3.0. Получает идентификатор просмотра сообщения.</summary>
        <value>Код просмотра сообщения, который создается службой Message Queuing и уникален в очереди, где находится сообщение.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.LookupId%2A> Свойство предоставляет доступ только для чтения к идентификатору просмотра сообщения. Идентификатор уточняющего запроса, представленный в MSMQ 3,0, является 64-битным идентификатором, который создается службой очереди сообщений и назначается каждому сообщению, когда сообщение помещается в очередь. Идентификатор уточняющего запроса не совпадает с идентификатором сообщения, формируемого при отправке сообщения.  
  
 Служба очереди сообщений создает идентификатор уточняющего запроса для всех сообщений, помещаемых в любую очередь, включая созданные приложением, административные очереди, а также созданные системой журналы, недоставленные сообщения, соединитель и исходящие очереди. Другими словами, сюда входят сообщения, отправленные отправляющим приложением и очередью сообщений. Идентификатор уточняющего запроса уникален для очереди и не имеет смысла за пределами очереди.  
  
 Если сообщение отправляется в несколько очередей назначения или если копия сообщения хранится в журнале компьютера или в журнале очереди, то каждая копия сообщения будет иметь собственный идентификатор поиска, когда он помещается в соответствующую очередь.  
  
 <xref:System.Messaging.Message.LookupId%2A> Свойство может быть прочитано только для сообщений, полученных из очереди.  
  
 Идентификатор уточняющего запроса используется для чтения определенного сообщения в очереди. Когда идентификатор уточняющего запроса сообщения известен, принимающее приложение может вызвать <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> функцию или <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> , чтобы перейти непосредственно к этому сообщению и просмотреть или извлечь его из очереди, в отличие от курсоров, которые должны начинаться в начале очереди. Перейдите к концу очереди,  
  
 Получение идентификаторов поиска сообщений в очереди является обязанностью приложения. Одним из возможных способов получения идентификаторов поиска является создание триггера для очереди назначения, вызывающей компонент, который кэширует идентификаторы каждого сообщения в том виде, в каком они помещены в очередь.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.LookupId" />.</exception>
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип сообщения: <see langword="Normal" />, <see langword="Acknowledgment" /> или <see langword="Report" />.</summary>
        <value>Одно из значений перечисления <see cref="P:System.Messaging.Message.MessageType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Очередь сообщений обычно задает это свойство при отправке сообщения. Сообщение Message Queuing может относиться к одному из следующих типов:  
  
-   `Normal`— Это либо типичное сообщение, отправленное из приложения в очередь, либо ответное сообщение, возвращенное в отправляющее приложение.  
  
-   `Acknowledgement`, который очередь сообщений создает каждый раз при запросе отправляющего приложения. Например, служба Message Queuing может создавать положительные или отрицательные сообщения для указания того, что исходное сообщение было доставлено или прочитано. Служба Message Queuing возвращает соответствующее подтверждающее сообщение в очередь администрирования, указанную передающим приложением.  
  
-   `Report`, который очередь сообщений создает каждый раз, когда очередь отчетов определяется в исходном диспетчере очереди. При разрешенной трассировке служба Message Queuing передает сообщение-отчет в очередь отчетов Message Queuing при каждом поступлении исходного сообщения на сервер Message Queuing или при отправке с этого сервера.  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Messaging.Message.MessageType%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.MessageType" />.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает приоритет сообщения, используемый для определения места сообщения при его поступлении в очередь.</summary>
        <value>Одно из значений <see cref="T:System.Messaging.MessagePriority" />, представляющих уровни приоритета нетранзакционных сообщений. Значение по умолчанию — <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Priority%2A> Свойство влияет на то, как очередь сообщений обрабатывает сообщение как при наведении, так и при достижении места назначения. Сообщениям с более высоким приоритетом отдается предпочтение при маршрутизации, и они помещаются ближе к началу конечной очереди. Сообщения, имеющие одинаковый приоритет, помещаются в очередь в порядке поступления.  
  
 Осмысленный приоритет можно задать только для нетранзакционных сообщений. Служба очередей сообщений автоматически устанавливает для сообщений `Lowest`о транзакциях приоритет, что приводит к игнорированию приоритета транзакционного сообщения.  
  
   
  
## Examples  
 В следующем примере кода два сообщения с разными приоритетами отправляются в очередь и затем извлекаются в дальнейшем.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Priority" />.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, будет ли сообщение гарантированно доставлено в случае отказа компьютера или неисправности в сети.</summary>
        <value>Значение <see langword="true" />, если доставка сообщения гарантируется (за счет сохранения сообщения на диске во время нахождения на маршруте), и значение <see langword="false" />, если доставка не гарантируется. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Recoverable%2A> Свойство указывает, гарантируется ли доставка сообщения, даже если компьютер аварийно завершает работу, пока сообщение направляется в очередь назначения.  
  
 Если доставка сообщения гарантирована, сообщение сохраняется локально на каждом шаге маршрута, пока сообщение не будет успешно перенаправлено на следующий компьютер. Присвоение <xref:System.Messaging.Message.Recoverable%2A> `true` свойству значения может повлиять на пропускную способность.  
  
 Если сообщение является транзакционным, очередь сообщений автоматически обрабатывает сообщение как восстанавливаемое независимо от значения <xref:System.Messaging.Message.Recoverable%2A> свойства.  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение <xref:System.Messaging.Message.Recoverable%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Recoverable" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает очередь, принимающую ответные сообщения, создаваемые приложением.</summary>
        <value>Очередь сообщений <see cref="T:System.Messaging.MessageQueue" />, в которую возвращаются ответные сообщения, создаваемые приложениями. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.ResponseQueue%2A> Свойство определяет очередь, которая получает генерируемые приложением ответные сообщения, которые принимающее приложение возвращает в отправляющее приложение. Передающее приложение задает очереди ответов при передаче их сообщений. В качестве очереди ответов может быть указана любая доступная очередь.  
  
 Сообщения, возвращаемые в очередь ответов, зависят от приложения. Приложение должно определить содержимое этих сообщений и действия, которые необходимо выполнить при приеме сообщений.  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение <xref:System.Messaging.Message.ResponseQueue%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.ResponseQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает контекст безопасности для сообщения.</summary>
        <value>Объект <see cref="T:System.Messaging.SecurityContext" />, содержащий контекст безопасности для сообщения, если ранее свойство было установлено; в противном случае — значение NULL.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает сертификат безопасности, используемый при проверке подлинности сообщений.</summary>
        <value>Массив байтовых значений, представляющий сертификат безопасности, который используется службой очереди сообщений для проверки отправителя сообщения. По умолчанию задан массив нулевой длины.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Принимающее приложение использует свойство <xref:System.Messaging.Message.SenderCertificate%2A> , если сообщение содержит внешний сертификат безопасности.  
  
 Очередь сообщений может проверять подлинность сообщения с помощью внутреннего или внешнего сертификата безопасности. Служба очереди сообщений предоставляет внутренние сертификаты, которые используются для проверки целостности сообщений. Центр сертификации предоставляет внешний сертификат, доступ к которому можно получить с помощью <xref:System.Messaging.Message.SenderCertificate%2A> свойства сообщения. Помимо разрешения очереди сообщений для проверки подлинности сообщения, внешний сертификат позволяет принимающему приложению проверить отправителя. Внутренний сертификат не имеет пригодного для использования значения для принимающего приложения.  
  
 Внешний сертификат должен быть зарегистрирован в службе каталогов системы очереди сообщений. Внешний сертификат содержит сведения о центре сертификации, пользователе сертификата, срок действия сертификата, Открытый ключ пользователя сертификата и подпись центра сертификации.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.SenderCertificate" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает идентификатор пользователя, отправившего сообщение.</summary>
        <value>Массив байтовых значений, описывающий отправителя. Принимающая служба Queue Manager использует этот идентификатор при проверке подлинности сообщения, чтобы проверить отправителя сообщения и права отправителя на доступ к очереди.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство имеет `false`значение, идентификатор <xref:System.Messaging.Message.SenderId%2A> отправителя, указанный в свойстве, не прикрепляется к сообщению при его отправке. <xref:System.Messaging.Message.AttachSenderId%2A> Это указывает очереди сообщений, что отправитель не должен проверяться при отправке сообщения в очередь назначения. Если свойство равно `true` ,<xref:System.Messaging.Message.SenderId%2A> значение свойства заслуживает доверия только в том случае, если сообщение прошло проверку подлинности. <xref:System.Messaging.Message.AttachSenderId%2A> Используйте свойство в сочетании со свойством, чтобы проверить права доступа отправителя. <xref:System.Messaging.Message.SenderId%2A> <xref:System.Messaging.Message.Authenticated%2A>  
  
 Приложение-соединитель — это приложение, использующее сервер соединителя для обмена данными между очередью сообщений и другими системами очередей. Служба очереди сообщений требует, чтобы приложения соединителя обеспечивали идентификацию отправителя. Необходимо задать <xref:System.Messaging.Message.ConnectorType%2A> свойство при отправке сообщения через приложение соединителя.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.SenderId" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает версию очереди сообщений, используемую для передачи сообщения.</summary>
        <value>Версия Message Queuing, используемая для передачи сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderVersion%2A> Свойство важно для некоторых функций. Например, обработка транзакций поддерживается только в Message Queuing 2,0 и более поздних версиях, а цифровые подписи используются для проверки подлинности сообщений, отправленных MSMQ 1,0.  
  
 Диспетчер отправляющей очереди задает <xref:System.Messaging.Message.SenderVersion%2A> свойство при отправке сообщения.  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Messaging.Message.SenderVersion%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.SenderVersion" />.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает дату и время, установленные на передающем компьютере на момент передачи данного сообщения диспетчером исходной очереди.</summary>
        <value>Объект <see cref="T:System.DateTime" />, представляющий время передачи данного сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство корректируется на местное время компьютера, на котором был создан этот экземпляр <xref:System.Messaging.Message> класса. <xref:System.Messaging.Message.SentTime%2A> Этот часовой пояс может отличаться от исходных и конечных очередей.  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Messaging.Message.SentTime%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.SentTime" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя компьютера, с которого было передано данное сообщение.</summary>
        <value>Имя компьютера, с которого было передано данное сообщение.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Формат <xref:System.Messaging.Message.SourceMachine%2A> свойства не включает предшествующие две косые черты (\\\\). Например, `myServer` является допустимым <xref:System.Messaging.Message.SourceMachine%2A>.  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Messaging.Message.SourceMachine%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.SourceMachine" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Нет доступа к сведениям о компьютере или службе каталогов.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает максимальное время, в течение которого сообщение должно быть извлечено из очереди местоназначения.</summary>
        <value>Суммарное время, в течение которого переданное сообщение должно быть получено из очереди местоназначения. Значение по умолчанию — <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> Свойство указывает общее время, когда отправленное сообщение должно быть получено из очереди назначения. Ограничение времени включает время, затраченное на получение очереди назначения, и время, затраченное на ожидание в очереди до получения сообщения.  
  
> [!CAUTION]
>  При использовании зависимых клиентских компьютеров убедитесь, что часы на клиентском компьютере синхронизированы с часами на сервере, на котором запущена служба очереди сообщений. В противном случае непредсказуемое поведение может возникать при отправке сообщения, <xref:System.Messaging.Message.InfiniteTimeout>свойство которого <xref:System.Messaging.Message.TimeToBeReceived%2A> не имеет значение.  
  
 Если интервал, заданный <xref:System.Messaging.Message.TimeToBeReceived%2A> свойством, истечет до удаления сообщения из очереди, очередь сообщений отбрасывает сообщение одним из двух способов. Если свойство <xref:System.Messaging.Message.UseDeadLetterQueue%2A> сообщения имеет значение `true`, это сообщение будет передано в очередь недоставленных сообщений. Если <xref:System.Messaging.Message.UseDeadLetterQueue%2A> параметр `false`имеет значение, сообщение игнорируется.  
  
 Вы можете задать для <xref:System.Messaging.Message.AcknowledgeType%2A> свойства сообщения запрос на отправку сообщения об отрицательном подтверждении в отправляющее приложение, если сообщение не получено до истечения срока действия таймера.  
  
 Если значение, заданное <xref:System.Messaging.Message.TimeToBeReceived%2A> свойством, меньше значения, заданного <xref:System.Messaging.Message.TimeToReachQueue%2A> свойством, <xref:System.Messaging.Message.TimeToBeReceived%2A> имеет приоритет.  
  
 При отправке нескольких сообщений в одной транзакции очередь сообщений использует <xref:System.Messaging.Message.TimeToBeReceived%2A> свойство первого сообщения.  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение <xref:System.Messaging.Message.TimeToBeReceived%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.TimeToBeReceived" />.</exception>
        <exception cref="T:System.ArgumentException">Задано недопустимое значение для <see cref="P:System.Messaging.Message.TimeToBeReceived" />.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает максимальное время, в течение которого сообщение должно дойти до очереди.</summary>
        <value>Лимит времени, отсчитываемый с момента отправки сообщения, в течение которого сообщение должно достичь очереди местоназначения. Значение по умолчанию — <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если интервал времени, заданный <xref:System.Messaging.Message.TimeToReachQueue%2A> свойством, истекает до того, как сообщение достигнет места назначения, очередь сообщений отклоняет сообщение одним из двух способов. Если свойство <xref:System.Messaging.Message.UseDeadLetterQueue%2A> сообщения имеет значение `true`, это сообщение будет передано в очередь недоставленных сообщений. Если <xref:System.Messaging.Message.UseDeadLetterQueue%2A> параметр `false`имеет значение, сообщение игнорируется.  
  
 Можно задать для <xref:System.Messaging.Message.AcknowledgeType%2A> свойства сообщения значение запросить, чтобы служба очереди сообщений отправляла сообщение об отрицательном подтверждении обратно в приложение, если оно не поступает до истечения срока действия таймера.  
  
 <xref:System.Messaging.Message.TimeToReachQueue%2A> Если свойство имеет значение 0 секунд, служба очереди сообщений пытается отправить сообщение адресату, если очередь ожидает сообщения. Если очередь является локальной, сообщение всегда достигает этого сообщения.  
  
 Если значение, заданное <xref:System.Messaging.Message.TimeToReachQueue%2A> свойством, больше значения, заданного <xref:System.Messaging.Message.TimeToBeReceived%2A> свойством, <xref:System.Messaging.Message.TimeToBeReceived%2A> приоритет получает.  
  
 При отправке нескольких сообщений в одной транзакции очередь сообщений использует <xref:System.Messaging.Message.TimeToReachQueue%2A> свойство первого сообщения.  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение <xref:System.Messaging.Message.TimeToReachQueue%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.TimeToReachQueue" />.</exception>
        <exception cref="T:System.ArgumentException">Задано недопустимое значение для <see cref="P:System.Messaging.Message.TimeToReachQueue" />. Возможно, это отрицательное число.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает идентификатор транзакции, частью которой является данное сообщение.</summary>
        <value>Идентификатор транзакции, связанной с данным сообщением.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Принимающие приложения используют <xref:System.Messaging.Message.TransactionId%2A> свойство для проверки того, что сообщение было отправлено как часть определенной транзакции. Идентификатор транзакции содержит идентификатор отправляющего компьютера (первые 16 бит), за которым следует 4-байтовый порядковый номер транзакции.  
  
 Это свойство доступно только для очереди сообщений версии 2,0 и более поздних версий.  
  
 Идентификаторы транзакций не обязательно должны быть уникальными, так как порядковые номера транзакций не являются постоянными и снова начинаются с 2 <sup>20</sup>. Очередь сообщений гарантирует, что только последующие транзакции будут иметь разные порядковые номера транзакций.  
  
 Для проверки границ транзакций <xref:System.Messaging.Message.TransactionId%2A> можно использовать свойство вместе <xref:System.Messaging.Message.IsFirstInTransaction%2A> со <xref:System.Messaging.Message.IsLastInTransaction%2A> свойствами и.  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Messaging.Message.TransactionId%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.TransactionId" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает очередь состояний транзакций на компьютере-источнике.</summary>
        <value>Очередь состояний транзакций на компьютере-источнике, используемая для передачи подтверждающих сообщений обратно в передающее приложение. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TransactionStatusQueue%2A> Свойство определяет транзакционную очередь на исходном компьютере, которая получает подтверждения получения для чтения от приложений-соединителей. Служба очереди сообщений задает свойство, а приложения соединителя используют свойство при извлечении транзактных сообщений, отправленных во внешние очереди.  
  
 Внешняя очередь существует в системе очередей, отличной от очереди сообщений Майкрософт. Очередь сообщений взаимодействует с такими очередями через приложение соединителя.  
  
 Приложение соединителя может использовать очередь состояния транзакций для отправки сообщений подтверждения обратно в приложение, отправляющее сообщение. Очередь состояния транзакций должна получить эти подтверждения, даже если отправляющее приложение не запрашивает другие подтверждения.  
  
   
  
## Examples  
 В следующем примере кода выводится значение <xref:System.Messaging.Message.TransactionStatusQueue%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
- или - 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.TransactionStatusQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, проводилась ли (или должна ли проводиться) проверка подлинности до отправки сообщения.</summary>
        <value>Значение <see langword="true" />, если передающее приложение запрашивает проверку подлинности для данного сообщения; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseAuthentication%2A> Свойство указывает, требуется ли проверка подлинности сообщения. Если отправляющее приложение запрашивает проверку подлинности, служба очереди сообщений создает цифровую подпись и использует ее для подписывания сообщения при его отправке и проверки подлинности сообщения при его получении.  
  
 Если <xref:System.Messaging.Message.UseAuthentication%2A> параметр `false` имеет значение и сообщение отправляется в очередь, принимающую только сообщения, прошедшие проверку подлинности, сообщение будет отклонено при достижении очереди.  
  
 Невозможно определить, прошло ли сообщение проверку подлинности, просмотрев его свойства. Очередь сообщений отклоняет такие сообщения перед их доставкой в очередь. Однако можно запросить отправку сообщения подтверждения, если сбой доставки предотвращает поступление сообщения в очередь.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.UseAuthentication" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должна ли копия сообщения, которое не может быть доставлено, передаваться в очередь недоставленных сообщений.</summary>
        <value>Значение <see langword="true" />, если при сбое доставки сообщения его копия направляется в очередь недоставленных сообщений; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства <xref:System.Messaging.Message.UseJournalQueue%2A> и<xref:System.Messaging.Message.UseDeadLetterQueue%2A> определяют, каким способом служба очередей сообщений отслеживает сообщение. Если <xref:System.Messaging.Message.UseDeadLetterQueue%2A> имеет `true`значение, сбой доставки (нетранзакционного сообщения) приводит к тому, что сообщение отправляется в нетранзакционную очередь недоставленных сообщений на компьютере, который не может доставить сообщение. Например, ошибка доставки может быть вызвана истечением срока действия таймера сообщения.  
  
 В случае сбоя доставки транзакционного сообщения очередь сообщений отправляет сообщение в очередь недоставленных транзактных сообщений на исходном компьютере во всех отрицательных и сомнительных случаях.  
  
 Если сообщения хранятся в очереди недоставленных сообщений, следует периодически очищать очередь, чтобы удалить сообщения, которые больше не нужны. Сообщения, хранящиеся в очередях недоставленных сообщений, засчитывается в соответствии с квотой на размер компьютера, на котором находится очередь. Квота компьютера задается администратором и относится к размеру, выделенному для хранения сообщений на целом компьютере, а не только в одной очереди.  
  
 Не создается журнал или очередь недоставленных сообщений. Это Системные очереди, создаваемые очередью сообщений.  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение <xref:System.Messaging.Message.UseDeadLetterQueue%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.UseDeadLetterQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее, является ли сообщение конфиденциальным.</summary>
        <value>Значение <see langword="true" />, если требуется, чтобы служба Message Queuing шифровала сообщения; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если сообщение является частным, его текст шифруется перед отправкой и расшифровывается при получении. Чтобы отправить частное сообщение, в отправляющем приложении должно быть указано, что шифрование используется и, при необходимости, алгоритм шифрования.  
  
 При отправке конфиденциальных сообщений приложению не требуется выполнять шифрование сообщений. Очередь сообщений может шифровать текст сообщения, если приложение отправляет сообщения в Microsoft Windows 2000 Enterprise, который имеет доступ к службе каталогов. При получении частных сообщений Диспетчер очереди приема всегда расшифровывает текст сообщения.  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение <xref:System.Messaging.Message.UseEncryption%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.UseEncryption" />.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должна ли копия сообщения храниться в журнале компьютера, являющегося источником этого сообщения.</summary>
        <value>Чтобы потребовать хранения копии сообщения в журнале компьютера-источника после успешной передачи сообщения с компьютера на следующий сервер, это значение должно быть равным <see langword="true" />; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства <xref:System.Messaging.Message.UseJournalQueue%2A> и<xref:System.Messaging.Message.UseDeadLetterQueue%2A> определяют, каким способом служба очередей сообщений отслеживает сообщение. Если <xref:System.Messaging.Message.UseJournalQueue%2A> имеет `true`значение, то копия хранится в журнале компьютера на исходном компьютере на каждом шаге, на котором передается сообщение.  
  
 Отправленное сообщение копируется в очередь журнала только в том случае, если очередь назначения находится на удаленном компьютере. Если назначение находится на локальном компьютере, сообщение отправляется непосредственно в очередь. нет промежуточных шагов, требующих ведения журнала.  
  
 При хранении сообщений в очереди журнала следует периодически очищать очередь, чтобы удалить сообщения, которые больше не нужны. Сообщения, хранящиеся в очередях журнала, учитываются в квоте для компьютера, на котором находится очередь. (Квота компьютера задается администратором.)  
  
 Не создается журнал или очередь недоставленных сообщений. Это Системные очереди, создаваемые очередью сообщений.  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение <xref:System.Messaging.Message.UseJournalQueue%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.UseJournalQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, нужно ли отслеживать сообщение в процессе его перемещения в очередь места назначения.</summary>
        <value>Значение <see langword="true" />, если необходимо, чтобы на каждом промежуточном этапе прохождения сообщения в очередь места назначения создавался отчет, передаваемый в очередь системных отчетов; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseTracing%2A> Свойство указывает, следует ли отслеживаниь маршрута сообщения по мере его перемещения в очередь назначения. Если `true`значение равно, сообщение отчета (созданное службой очереди сообщений) отправляется в очередь отчетов каждый раз, когда сообщение проходит через сервер маршрутизации очереди сообщений. Очередь отчетов задается диспетчером исходной очереди. Очереди отчетов не ограничиваются сообщениями отчетов, созданными службой очереди сообщений; сообщения, создаваемые приложением, также могут отправляться в очереди отчетов.  
  
 Использование трассировки включает в себя настройку Active Directory и указание очереди отчетов для предприятия очереди сообщений. Администратор настраивает эти параметры.  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение <xref:System.Messaging.Message.UseTracing%2A> свойства сообщения.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.UseTracing" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>