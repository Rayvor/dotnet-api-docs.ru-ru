<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0e234b3b0ce5723f1236ecf3b326917ce1c6b59d" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67237947" /></Metadata><TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет доступ к свойствам, необходимым для определения сообщения службы MSMQ.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Messaging.Message> класс для считывания и получения сообщений из очереди, или для детального управления свойствами сообщения при отправке сообщения в очередь.  
  
 <xref:System.Messaging.MessageQueue> использует <xref:System.Messaging.Message> класса при чтении или получении сообщений из очереди, так как оба <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> и <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> методы создают новый экземпляр класса <xref:System.Messaging.Message> класс и установить свойства этого экземпляра. <xref:System.Messaging.Message> Применяются только для чтения свойства класса для извлечения сообщений из очереди, хотя свойства чтения/записи применяются к отправке и получении сообщений. Когда <xref:System.Messaging.MessageQueue> просматривает или получает сообщение из очереди, его <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> свойство определяет, какие из свойств сообщений извлекаются.  
  
 <xref:System.Messaging.MessageQueue> Класса <xref:System.Messaging.MessageQueue.Send%2A> метод позволяет указать любой тип объекта для сообщения, отправляемые в эту очередь. Можно использовать <xref:System.Messaging.MessageQueue> экземпляра <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> свойство, чтобы указать параметры для универсального сообщения, отправленные в очередь. Типы параметров включают модуль форматирования, меток, шифрования и проверки подлинности. Можно также указать значения для соответствующих <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> членов при координации приложения обмена сообщениями для ответа на сообщения подтверждения и отчетов. С помощью <xref:System.Messaging.Message> экземпляру отправлять сообщения в очередь обеспечивает гибкость доступа и изменения, многие из этих свойств — для одного сообщения, либо на основе сообщений. <xref:System.Messaging.Message> свойства имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.  
  
 Данные сообщения хранятся в <xref:System.Messaging.Message.Body%2A> свойства и в меньшей степени <xref:System.Messaging.Message.AppSpecific%2A> и <xref:System.Messaging.Message.Extension%2A> свойства. Когда данные сообщения зашифрованы, сериализации или десериализации, только содержимое <xref:System.Messaging.Message.Body%2A> влияет свойство.  
  
 Содержание <xref:System.Messaging.Message.Body%2A> свойства сериализуются в том случае, когда сообщение отправляется с помощью <xref:System.Messaging.Message.Formatter%2A> свойству. Сериализованное содержимое находится в <xref:System.Messaging.Message.BodyStream%2A> свойство. Можно также задать <xref:System.Messaging.Message.BodyStream%2A> свойства напрямую, например, чтобы отправить файл как содержимое данных сообщения. Вы можете изменить <xref:System.Messaging.Message.Body%2A> или <xref:System.Messaging.Message.Formatter%2A> в любое время перед отправкой сообщения и данные будут сериализованы свойства соответствующим образом при вызове <xref:System.Messaging.MessageQueue.Send%2A>.  
  
 Свойства, определенные <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> свойство применяется только к сообщениям, которые не имеют тип <xref:System.Messaging.Message>. Если указать <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> свойство для <xref:System.Messaging.MessageQueue>, идентичными именам свойств в <xref:System.Messaging.Message> экземпляр отправляется очереди вызывать эти свойства по умолчанию пропускаются.  
  
 Список начальных значений свойств для экземпляра <xref:System.Messaging.Message>, см. в разделе <xref:System.Messaging.Message.%23ctor%2A> конструктор.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется форматирование тела сообщения с помощью <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 В следующем примере кода демонстрируется форматирование тела сообщения с помощью <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.Message" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.Message" /> с пустым текстом сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, чтобы создать новый экземпляр класса <xref:System.Messaging.Message> класс с пустым телом.  
  
 Укажите либо <xref:System.Messaging.Message.Body%2A> свойство или <xref:System.Messaging.Message.BodyStream%2A> свойство перед отправкой <xref:System.Messaging.Message> объекта. <xref:System.Messaging.Message.Body%2A> Свойство может быть любой объект, который может быть сериализован, например текстовой строки, объекта структуры, экземпляр класса или внедренный объект.  
  
 Если не записывается содержимое сообщения непосредственно в <xref:System.Messaging.Message.BodyStream%2A> задайте <xref:System.Messaging.Message.Formatter%2A> свойство перед отправкой сообщения. Текст сообщения сериализуется с помощью <xref:System.Messaging.Message.Formatter%2A> значения свойства во время <xref:System.Messaging.MessageQueue.Send%2A> вызывается метод <xref:System.Messaging.MessageQueue> экземпляра.  
  
 <xref:System.Messaging.XmlMessageFormatter> Слабо связанный, поэтому нет необходимости в тот же объект введите на отправителя и получателя, при использовании этого формата. <xref:System.Messaging.ActiveXMessageFormatter> И <xref:System.Messaging.BinaryMessageFormatter> сериализовать данные в двоичное представление. <xref:System.Messaging.ActiveXMessageFormatter> Используется при отправке или получении COM-компонентов.  
  
 В следующей таблице представлены исходные значения свойств для экземпляра <xref:System.Messaging.Message>.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider версии 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Пустая строка (»»)|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Пустая строка (»»)|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 В следующем примере кода два сообщения с различными приоритетами отправляются в очередь и последовательно извлекаются.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">Объект, сериализуемый в текст сообщения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.Message" />, используя <see cref="T:System.Messaging.XmlMessageFormatter" /> для сериализации заданного объекта в текст сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, чтобы создать новый экземпляр класса <xref:System.Messaging.Message> класс, содержащий <xref:System.Messaging.Message.Body%2A> определяется `body` параметра. `body` Параметр может быть любой объект, который может быть сериализован, например текстовой строки, объекта структуры, экземпляр класса или внедренный объект. Текст сообщения сериализуется с помощью <xref:System.Messaging.XmlMessageFormatter> только после изменения <xref:System.Messaging.Message.Formatter%2A> свойства перед <xref:System.Messaging.Message> отправляется. При изменении <xref:System.Messaging.Message.Body%2A> или <xref:System.Messaging.Message.Formatter%2A> в любой момент перед вызовом <xref:System.Messaging.MessageQueue.Send%2A>, сообщение будет сериализован в соответствии с новое значение свойства.  
  
 <xref:System.Messaging.XmlMessageFormatter> Слабо связанный, поэтому нет необходимости в тот же объект введите на отправителя и получателя, при использовании этого формата. <xref:System.Messaging.ActiveXMessageFormatter> И <xref:System.Messaging.BinaryMessageFormatter> сериализовать данные в двоичное представление. <xref:System.Messaging.ActiveXMessageFormatter> Используется при отправке или получении COM-компонентов.  
  
 В следующей таблице представлены исходные значения свойств для экземпляра <xref:System.Messaging.Message>.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider версии 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Параметр `body`.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Пустая строка (»»)|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Пустая строка (»»)|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 В следующем примере кода создает новую очередь, отправляет сообщение, которое содержит заказа к нему, а затем извлекает его.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">Объект, сериализуемый в текст сообщения.</param>
        <param name="formatter">Объект <see cref="T:System.Messaging.IMessageFormatter" />, задающий модуль форматирования, с помощью которого осуществляется сериализация текста сообщения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.Message" />, используя указанный модуль форматирования для сериализации заданного объекта в текст сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, чтобы создать новый экземпляр класса <xref:System.Messaging.Message> класс, содержащий <xref:System.Messaging.Message.Body%2A> определяется `body` , с применением любой допустимый модуль форматирования для сериализации текста сообщения. `body` Параметр — это любой объект, который может быть сериализован, например текстовой строки, объекта структуры, экземпляр класса или внедренный объект. При изменении <xref:System.Messaging.Message.Body%2A> или <xref:System.Messaging.Message.Formatter%2A> в любой момент перед вызовом <xref:System.Messaging.MessageQueue.Send%2A>, сообщение будет сериализован в соответствии с новое значение свойства.  
  
 <xref:System.Messaging.XmlMessageFormatter> Слабо связанный, поэтому нет необходимости в тот же объект введите на отправителя и получателя, при использовании этого формата. <xref:System.Messaging.ActiveXMessageFormatter> И <xref:System.Messaging.BinaryMessageFormatter> сериализовать данные в двоичное представление. <xref:System.Messaging.ActiveXMessageFormatter> Используется при отправке или получении COM-компонентов.  
  
 В следующей таблице представлены исходные значения свойств для экземпляра <xref:System.Messaging.Message>.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider версии 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Параметр `body`.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Пустая строка (»»)|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.Formatter%2A>|Параметр `formatter`.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Пустая строка (»»)|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает тип сообщения подтверждения, которое должно возвращаться приложению, передающему исходное сообщение.</summary>
        <value>Одно из значений <see cref="T:System.Messaging.AcknowledgeTypes" />, которые представляют как типы подтверждающих сообщений, размещаемых системой в очереди администрирования, так и условия, при которых подтверждения возвращаются в приложение, передавшее исходное сообщение. Значение по умолчанию — <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AcknowledgeType%2A> Свойство задает тип сообщения подтверждения, запрошенного передающим приложением. Задайте <xref:System.Messaging.Message.AcknowledgeType%2A> свойство перед отправкой сообщения для запроса уведомления об определенных событиях - например, сообщение достигло своей очереди места назначения, сообщение извлекается или тайм-аут, предотвращая сообщение или из очередь назначения.  
  
 Служба Message Queuing возвращает уведомления путем отправки сообщений подтверждения <xref:System.Messaging.Message.AdministrationQueue%2A> свойство, указанное исходное сообщение. Сообщение подтверждения <xref:System.Messaging.Message.Acknowledgment%2A> свойство указывает тип подтверждения, который он представляет. Например, если подтверждающее сообщение было отправлено, так как сообщение не было получено назначения перед <xref:System.Messaging.Message.TimeToReachQueue%2A> истекло время ожидания, <xref:System.Messaging.Message.Acknowledgment%2A> свойство подтверждающего сообщения будет содержать значение `ReachQueueTimeout`.  
  
   
  
## Examples  
 В следующем примере кода отправляет и получает сообщение, содержащее к и из очереди. Он специально запрашивает положительного подтверждения в случае, когда исходное сообщение достигает или извлечено из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.AcknowledgeType" />.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает классификацию подтверждения, представляемого данным сообщением.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Messaging.Acknowledgment" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При получении сообщения из очереди администрирования, чтение <xref:System.Messaging.Message.Acknowledgment%2A> свойство для проверки состояния исходного сообщения.  
  
 Когда сообщение отправляется в очередь назначения, очереди сообщений может запросить подтверждающее сообщение. Такое сообщение, например, можно указать, ли сообщение получено и был извлечен в пределах заданного времени ожидания, или он может указывать, что пошло не так в случае сбоя доставки. Очередь назначения возвращает подтверждающие сообщения и помещает их в очередь администрирования, указанную в исходном сообщении <xref:System.Messaging.Message.AdministrationQueue%2A> свойство. <xref:System.Messaging.Message.Id%2A> Свойство подтверждающего сообщения идентифицирует сообщение подтверждения, а не исходное сообщение. Идентификатор исходного сообщения можно найти в подтверждении <xref:System.Messaging.Message> экземпляра <xref:System.Messaging.Message.CorrelationId%2A> свойство.  
  
 Если этот <xref:System.Messaging.Message> экземпляр представляет сообщение подтверждения <xref:System.Messaging.Message.Acknowledgment%2A> свойство задает тип подтверждения. В противном случае <xref:System.Messaging.Message.Acknowledgment%2A> свойство содержит значение `Normal`.  
  
 Используйте <xref:System.Messaging.Message.AcknowledgeType%2A> свойство исходного сообщения для определения условий, при которых будут возвращены уведомления о доставке.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает очередь, принимающую подтверждающие сообщения, созданные службой очереди сообщений.</summary>
        <value>Класс <see cref="T:System.Messaging.MessageQueue" />, задающий очередь администрирования, используемую для сообщений подтверждения, создаваемых системой. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Очередь, указанная в <xref:System.Messaging.Message.AdministrationQueue%2A> свойство может быть любой нетранзакционную очередь. Подтверждающие сообщения, передаваемые в очередь администрирования, могут указывать, достигло ли исходное сообщение своей конечной очереди, а также было ли оно удалено из очереди.  
  
 Когда <xref:System.Messaging.Message.AcknowledgeType%2A> свойство имеет любое значение, отличное от `None`, отправляющего приложения необходимо указать очереди для использования в качестве очереди администрирования.  
  
   
  
## Examples  
 В следующем примере кода отправляет и получает сообщение, содержащее к и из очереди. Он специально запрашивает положительного подтверждения в случае, когда исходное сообщение достигает или извлечено из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.AdministrationQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает дополнительные сведения, зависящие от приложения.</summary>
        <value>Сведения, зависящие от приложения. По умолчанию используется значение ноль.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AppSpecific%2A> Свойство содержит сведения о приложении, которое можно использовать для организации различных типов сообщений. Например, можно использовать индексы, связанные с приложением. Он отвечает за приложение для интерпретации <xref:System.Messaging.Message.AppSpecific%2A> сведения о свойстве.  
  
 Когда это возможно, данные сообщения следует включать в теле сообщения, а не <xref:System.Messaging.Message.AppSpecific%2A> свойство.  
  
 При работе с внешними очередями используйте <xref:System.Messaging.Message.Extension%2A> свойство, чтобы указать свойства сообщения, которые не существуют в очереди сообщений. Как и в <xref:System.Messaging.Message.AppSpecific%2A> свойство, он отвечает за приложение, чтобы понять содержание <xref:System.Messaging.Message.Extension%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.AppSpecific" />.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время поступления сообщения в очередь местоназначения.</summary>
        <value>Объект <see cref="T:System.DateTime" />, который представляет время поступления сообщения в очередь местоназначения. Это время представляет собой локальное время (отсчитываемое относительно гринвичского времени) компьютера, на котором располагается очередь местоназначения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сообщения <xref:System.Messaging.Message.TimeToBeReceived%2A> свойство указывает, насколько быстро сообщение должно быть получено из очереди местоназначения. <xref:System.Messaging.Message.TimeToBeReceived%2A> Свойство таймер запускается, когда сообщение отправляется не в том случае, когда приходит сообщение в очереди.  
  
   
  
## Examples  
 В следующем примере кода отображает значение сообщения <xref:System.Messaging.Message.ArrivedTime%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.ArrivedTime" />.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должен ли быть присоединен к сообщению идентификатор отправителя.</summary>
        <value>Значение <see langword="true" />, если <see cref="P:System.Messaging.Message.SenderId" /> должен быть присоединен к сообщению, в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderId%2A> Свойство представляет собой массив байтов, представляющий идентификатор пользователя, отправившего сообщение. Идентификатор отправителя задаются службой Message Queuing и используется для проверки прав доступа к очереди отправителя по диспетчеру принимающей очереди.  
  
 Отсутствие отправителя, идентификатор, чтобы указать отправляющим приложением, что очереди сообщений должен не проверки отправителя сообщения, ни проверка доступа отправителя rights очередь. <xref:System.Messaging.Message.SenderId%2A> Является доверенной, только в том случае, если сообщение прошло проверку подлинности, при его поступлении в очередь назначения. Сообщение отклоняется в том случае, когда достигнет конечной очереди, если очередь принимает только сообщения, прошедшие проверку подлинности и либо <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> или <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> свойство `false`.  
  
> [!CAUTION]
>  Если сообщение отклоняется, это либо передается в очередь недоставленных сообщений-(если <xref:System.Messaging.Message.UseDeadLetterQueue%2A> — `true`), или он учитывается. Вы можете запросить подтверждения, если сообщение не удалось достичь очереди. В противном случае, если <xref:System.Messaging.Message.UseDeadLetterQueue%2A> является `false` сообщения могут быть потеряны без предупреждения.  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение сообщения <xref:System.Messaging.Message.AttachSenderId%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.AttachSenderId" />.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, прошло ли сообщение проверку подлинности.</summary>
        <value>Значение <see langword="true" />, если была запрошена проверка подлинности при поступлении сообщения в очередь; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Authenticated%2A> Свойство используется только этим приложением, их взаимодействия с сообщением и пытается определить, была ли запрошена проверка подлинности. Если сообщение в очереди, сообщение прошло проверку подлинности. И наоборот Если <xref:System.Messaging.Message.Authenticated%2A> свойство `true`, диспетчер принимающей очереди прошел проверку подлинности сообщения при его поступлении.  
  
 Не удается определить, если сообщение не прошел проверку подлинности, просмотрев его свойства. Служба Message Queuing отклоняет сообщения, не прошедшие проверку подлинности, прежде чем они попадут в очередь. Тем не менее можно запросить подтверждающее сообщение, когда сообщение о сбое доставки сообщения от поступающих в очередь.  
  
   
  
## Examples  
 В следующем примере кода отображает значение сообщения <xref:System.Messaging.Message.Authenticated%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Authenticated" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя поставщика служб шифрования, используемого для создания цифровой подписи сообщения.</summary>
        <value>Имя поставщика служб шифрования, используемого для создания цифровой подписи сообщения. По умолчанию это Microsoft Base Cryptographic Provider, версия 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило, используется <xref:System.Messaging.Message.AuthenticationProviderName%2A> при работе с внешними очередями. Служба очереди сообщений требуется имя поставщика проверки подлинности и тип поставщика проверки подлинности (поставщик проверки подлинности) для проверки цифровых подписей сообщений, передаваемых сообщений и сообщений, отправленных в очередь внешнего поставщика служб шифрования Очереди из внешней очереди.  
  
 При отправке сообщения, всегда значение <xref:System.Messaging.Message.AuthenticationProviderName%2A> и <xref:System.Messaging.Message.ConnectorType%2A> свойство. При отправке сообщения Message Queuing не обрабатывает имя поставщика проверки подлинности, если не установлен тип соединителя.  
  
 <xref:System.Messaging.Message.AuthenticationProviderName%2A> Свойство не может быть `null`, но это может быть пустой строкой (»»).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Невозможно задать свойство <see cref="P:System.Messaging.Message.AuthenticationProviderName" />.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.AuthenticationProviderName" />.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.AuthenticationProviderName" /> было установлено равным <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает тип поставщика служб шифрования, используемого для создания цифровой подписи сообщения.</summary>
        <value>Одно из значений <see cref="T:System.Messaging.CryptographicProviderType" />. Значение по умолчанию — <see langword="RSA_FULL" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило, используется <xref:System.Messaging.Message.AuthenticationProviderType%2A> свойство при работе с внешними очередями, чтобы указать, какие службы криптографии, связанного с сообщением. Служба очереди сообщений требуется имя поставщика проверки подлинности и тип поставщика проверки подлинности (поставщик проверки подлинности) для проверки цифровых подписей сообщений, передаваемых сообщений и сообщений, отправленных в очередь внешнего поставщика служб шифрования Очереди из внешней очереди.  
  
 Только `RsaFull` предназначен для использования с системой обмена сообщениями.  
  
 При отправке сообщения, всегда значение <xref:System.Messaging.Message.AuthenticationProviderType%2A> и <xref:System.Messaging.Message.ConnectorType%2A> свойство. При отправке сообщения Message Queuing не обрабатывает тип поставщика проверки подлинности, если не установлен тип соединителя.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Невозможно задать свойство <see cref="P:System.Messaging.Message.AuthenticationProviderType" />.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.AuthenticationProviderType" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает содержимое сообщения.</summary>
        <value>Объект, задающий содержимое сообщения. Таким объектом может быть строка, дата, денежная единица, число, байтовый массив или любой управляемый объект.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сообщения <xref:System.Messaging.Message.Body%2A> свойство обычно содержит данные, связанные с данным сообщением. Несмотря на то, что вы также можете отправлять данные приложения <xref:System.Messaging.Message.AppSpecific%2A> и <xref:System.Messaging.Message.Extension%2A> свойства, следует включать данные сообщения в <xref:System.Messaging.Message.Body%2A> сообщения, когда это возможно. Только <xref:System.Messaging.Message.Body%2A> содержимого свойства сериализуются и зашифрованы.  
  
 <xref:System.Messaging.Message.Body%2A> Свойство может содержать любой объект, размер которого не превышает 4 МБ. Если вы используете <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> отправлять любой объект, который не относится к типу <xref:System.Messaging.Message> для <xref:System.Messaging.MessageQueue>, этот объект будет находиться в <xref:System.Messaging.Message.Body%2A> свойство <xref:System.Messaging.Message> экземпляр, возвращаемый <xref:System.Messaging.MessageQueue.Peek%2A> или <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 Строковый аргумент в `MessageQueue.Send("hello.")` является примером универсального объекта.  
  
 <xref:System.Messaging.Message.BodyType%2A> Свойство указывает тип данных, которые хранятся в тексте сообщения. Служба очереди сообщений использует эти сведения для определения типа <xref:System.Messaging.Message.Body%2A> содержимого свойства.  
  
 Укажите либо <xref:System.Messaging.Message.Body%2A> свойство или <xref:System.Messaging.Message.BodyStream%2A> свойство перед отправкой <xref:System.Messaging.Message> объекта. <xref:System.Messaging.Message.Body%2A> Свойство может быть любой сериализуемый объект, например строку текста, структура объекта, экземпляр класса или внедренный объект.  
  
 Если не записывается содержимое сообщения непосредственно в <xref:System.Messaging.Message.BodyStream%2A> задайте <xref:System.Messaging.Message.Formatter%2A> свойство перед отправкой сообщения. Когда <xref:System.Messaging.MessageQueue.Send%2A> вызывается метод <xref:System.Messaging.MessageQueue> экземпляра, тексте сериализуется с помощью модуля форматирования, содержащиеся в <xref:System.Messaging.Message.Formatter%2A> свойство. Если отправить сообщение без указания значения для <xref:System.Messaging.Message.Formatter%2A> , модуль форматирования по умолчанию свойство <xref:System.Messaging.XmlMessageFormatter>.  
  
> [!NOTE]
>  Попытка задать текст сообщения для <xref:System.Decimal.MaxValue> вызовет <xref:System.OverflowException> при `Send` метод <xref:System.Messaging.MessageQueue> класс называется и <xref:System.Messaging.ActiveXMessageFormatter> используется.  
  
   
  
## Examples  
 В следующем примере кода два сообщения с различными приоритетами отправляются в очередь и последовательно извлекаются.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Значение свойства <see cref="P:System.Messaging.Message.Formatter" /> — <see langword="null" />.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает сведения в тексте сообщения.</summary>
        <value>Объект <see cref="T:System.IO.Stream" />, содержащий сериализованные сведения, включенные в объект <see cref="P:System.Messaging.Message.Body" /> сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текст сообщения может состоять из любого типа — например, строки, даты, валюты, число, массив байтов или любого управляемого объекта. Эти сведения, сериализуется в <xref:System.IO.Stream> передается в очередь.  
  
 Укажите либо <xref:System.Messaging.Message.Body%2A> свойство или <xref:System.Messaging.Message.BodyStream%2A> свойство перед отправкой <xref:System.Messaging.Message> объекта. Если задать <xref:System.Messaging.Message.Body%2A> свойства, содержимое сериализуются в <xref:System.Messaging.Message.BodyStream%2A> свойство. Тем не менее, вы можете написать <xref:System.Messaging.Message.BodyStream%2A> свойство напрямую. Это полезно, например, если вы хотите открыть подключение к файлу и передать его содержимое в теле сообщения.  
  
 Если не записывается содержимое сообщения непосредственно в <xref:System.Messaging.Message.BodyStream%2A> задайте <xref:System.Messaging.Message.Formatter%2A> свойство перед отправкой сообщения. Когда <xref:System.Messaging.MessageQueue.Send%2A> вызывается метод <xref:System.Messaging.MessageQueue> экземпляра, тексте сериализуется с помощью модуля форматирования, содержащиеся в <xref:System.Messaging.Message.Formatter%2A> свойство. Если отправить сообщение без указания значения для <xref:System.Messaging.Message.Formatter%2A> , модуль форматирования по умолчанию свойство <xref:System.Messaging.XmlMessageFormatter>.  
  
 Если задать <xref:System.Messaging.Message.UseEncryption%2A> свойства `true` для тела этого сообщения, сообщения шифруются при передаче, не устанавливая <xref:System.Messaging.Message.Body%2A> свойство. Таким образом <xref:System.Messaging.Message.BodyStream%2A> свойство никогда не шифруются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает тип данных, содержащихся в тексте сообщения.</summary>
        <value>Истинный тип текста сообщения, такой как строка, дата, денежная единица или число.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Служба Message Queuing распознает содержимое тела как объект или как сериализованный поток. <xref:System.Messaging.Message.BodyType%2A> Указывает тип объекта в <xref:System.Messaging.Message.Body%2A> свойства сообщения.  
  
 <xref:System.Messaging.XmlMessageFormatter> Выполняет привязку собственных типов и объект в теле сообщения. Если вы используете <xref:System.Messaging.XmlMessageFormatter>, задает модуль форматирования <xref:System.Messaging.Message.BodyType%2A> свойство для вас.  
  
 Другие модули форматирования также, как показано в следующем коде C# включают возможности привязки.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 В следующем примере кода отображает значение сообщения <xref:System.Messaging.Message.BodyType%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, что передающим приложением заданы некоторые свойства сообщения, обычно устанавливаемые службой очереди сообщений.</summary>
        <value><see cref="T:System.Guid" /> определяется приложением и используется совместно связующими приложениями или шифрованием сообщений. Этот объект <see cref="T:System.Guid" /> позволяет принимающему приложению интерпретировать установленные передающим приложением свойства, которые обычно задаются службой Message Queuing.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Служба очереди сообщений требуется <xref:System.Messaging.Message.ConnectorType%2A> установлено всякий раз, когда приложение задает свойство сообщения, обычно устанавливаемые службой очереди сообщений. Обычно приложения используют <xref:System.Messaging.Message.ConnectorType%2A> в следующих двух случаях:  
  
-   Когда приложение-подключатель пересылает сообщение. <xref:System.Messaging.Message.ConnectorType%2A> Отправляющее и принимающее приложения о том, как интерпретировать свойства безопасности и подтверждения сообщения.  
  
-   Каждый раз, когда отправляющего приложения, а не Message Queuing, шифрует сообщение. <xref:System.Messaging.Message.ConnectorType%2A> Сообщает очереди сообщений для использования <xref:System.Messaging.Message.DestinationSymmetricKey%2A> значение свойства для дешифрования сообщения.  
  
 Необходимо задать <xref:System.Messaging.Message.ConnectorType%2A> свойства, если задается любое из следующих свойств (в противном случае очередь не обрабатывает эти свойства при отправке сообщения):  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.ConnectorType" />.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает идентификатор сообщения, используемый подтверждениями, отчетами и ответными сообщениями для ссылки на исходное сообщение.</summary>
        <value>Идентификатор сообщения задается свойством <see cref="P:System.Messaging.Message.Id" /> исходного сообщения. Этот идентификатор корреляции используется службой MSMQ при создании подтверждающего сообщения или сообщения-отчета, а также приложением при создании ответного сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда Message Queuing создает сообщение подтверждение или отчет, он использует свойство идентификатора корреляции для указания идентификатора исходного сообщения. Таким образом, код корреляции связывает отчет или подтверждение с исходным сообщением.  
  
 Передающее приложение может согласовать подтверждение или отчет с исходным сообщением с помощью <xref:System.Messaging.Message.CorrelationId%2A> свойство для идентификации исходного сообщения <xref:System.Messaging.Message.Id%2A> свойство.  
  
 Соединитель приложения также должны устанавливать <xref:System.Messaging.Message.CorrelationId%2A> свойства сообщений подтверждения и отчетов для идентификатора исходного сообщения.  
  
 Если приложение отправляет ответное сообщение для отправляющего приложения, вы можете задать <xref:System.Messaging.Message.CorrelationId%2A> свойства сообщения ответа на сообщение идентификатор исходного сообщения. Отправляющее приложение может сопоставить сообщение, которое было отправлено ответное сообщение.  
  
   
  
## Examples  
 В следующем примере кода отправляет и получает сообщение, содержащее заказ в и из очереди. Он специально запрашивает положительного подтверждения в случае, когда исходное сообщение достигает или извлечено из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.CorrelationId" />.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <see cref="P:System.Messaging.Message.CorrelationId" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает планируемую очередь местоназначения для сообщения.</summary>
        <value>Объект <see cref="T:System.Messaging.MessageQueue" />, который задает предполагаемую очередь назначения для сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.DestinationQueue%2A> Свойство наиболее часто используется для определения первоначального места назначения сообщения, поступившего в журнал или транзакционных сообщений в очереди. Как правило не подлежащие изучению это свойство, поскольку обычно получения сообщения из очереди назначения.  
  
   
  
## Examples  
 В следующем примере кода отображает значение сообщения <xref:System.Messaging.Message.DestinationQueue%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.DestinationQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает симметричный ключ, применяемый для шифрования сообщений, шифруемых приложением, или сообщений, отправляемых во внешние очереди.</summary>
        <value>Массив байтовых значений, задающий целевой симметричный ключ, используемый для шифрования сообщения. По умолчанию задан массив нулевой длины.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два сценария требуется использование <xref:System.Messaging.Message.DestinationSymmetricKey%2A> свойство. Первый — когда приложения, а не Message Queuing, шифрует сообщение. Второй — при отправке зашифрованного сообщения в очереди системы, отличной от очереди сообщений.  
  
 Прежде чем это свойство задано, необходимо шифровать симметричный ключ с помощью открытого ключа диспетчера принимающей очереди. При отправке сообщений, шифруемых приложением, диспетчер принимающей очереди использует симметричный ключ для дешифрования сообщения перед их отправкой в очередь назначения.  
  
 При отправке сообщения в очередь службы внешнего приложения соответствующий соединитель, который пересылает зашифрованное сообщение с присоединенным симметричным ключом в принимающее приложение сначала получает сообщение. Затем это ответственность за принимающее приложение для расшифровки сообщения с помощью симметричного ключа.  
  
 При задании <xref:System.Messaging.Message.DestinationSymmetricKey%2A> свойство, необходимо также задать <xref:System.Messaging.Message.ConnectorType%2A> свойства. При отправке сообщения Message Queuing не обрабатывает <xref:System.Messaging.Message.DestinationSymmetricKey%2A> свойство Если <xref:System.Messaging.Message.ConnectorType%2A> не задается.  
  
 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Свойство имеет максимальный размер массива 256.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.DestinationSymmetricKey" />.</exception>
        <exception cref="T:System.ArgumentException">Значение параметра <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает цифровую подпись, используемую службой очереди сообщений при проверке подлинности сообщения.</summary>
        <value>Массив байтовых значений, задающий цифровую подпись очереди сообщений 1.0, используемую для проверки подлинности сообщения. По умолчанию задан массив нулевой длины.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Очередь сообщений использует цифровой подписи при проверке подлинности сообщений, отправленных службой Message Queuing версии 1.0. В большинстве случаев Message Queuing создает и задает <xref:System.Messaging.Message.DigitalSignature%2A> свойства, если передающее приложение запрашивает проверку подлинности. Принимающее приложение использует это свойство для извлечения цифровой подписи, вложенной в сообщение.  
  
 Можно использовать только <xref:System.Messaging.Message.DigitalSignature%2A> свойство для очереди сообщений версии 2.0. Отправляющее приложение необходимо указать подписи Message Queuing версии 1.0, при запросе проверки подлинности. Если отправляющее приложение отправляет подпись очереди сообщений версии 2.0, это свойство содержит буфер четыре байта каждого содержащего ноль.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> Свойства, вместе с <xref:System.Messaging.Message.SenderCertificate%2A> свойство, также используется соединитель приложений при отправке сообщения. В этом случае соединитель приложения — вместо Message Queuing - создает цифровую подпись, основана она на сертификат пользователя, отправившего сообщение.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> Свойство имеет максимальный размер массива 256.  
  
 При задании <xref:System.Messaging.Message.DigitalSignature%2A> свойство, необходимо также задать <xref:System.Messaging.Message.ConnectorType%2A> свойства. При отправке сообщения Message Queuing не обрабатывает <xref:System.Messaging.Message.DigitalSignature%2A> свойство Если <xref:System.Messaging.Message.ConnectorType%2A> не задается.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.DigitalSignature" />.</exception>
        <exception cref="T:System.ArgumentException">Значение свойства <see cref="P:System.Messaging.Message.DigitalSignature" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает алгоритм шифрования, используемый для шифрования тела конфиденциального сообщения.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Messaging.EncryptionAlgorithm" />. Значение по умолчанию — <see langword="RC2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если сообщение является закрытым (зашифрованный), оно шифруется перед отправкой и расшифровывается при получении. <xref:System.Messaging.Message.EncryptionAlgorithm%2A> Свойство задает алгоритм, используемый для шифрования тела конфиденциального сообщения.  
  
 Очередь может потребовать, чтобы входящие сообщения шифроваться. Если приложение отправляет сообщение без шифрования (отличным от private) в очередь, принимающую только конфиденциальные сообщения или если она отправляет конфиденциальное сообщение в очередь, принимает только неконфиденциальные сообщения, сообщение будет отклонено очереди. Передающее приложение может запросить возврат в таком случае сообщение отрицательного подтверждения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.EncryptionAlgorithm" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает дополнительные, определяемые приложением сведения, связанные с данным сообщением.</summary>
        <value>Массив байтовых значений, предоставляющий дополнительные, определяемые приложением, сведения, связанные с данным сообщением. По умолчанию задан массив нулевой длины.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Extension%2A> Свойство предоставляет дополнительные сведения, определяемые приложением, например большой двоичный объект, который связан с сообщением. Он отвечает за принимающему приложению интерпретировать содержимое <xref:System.Messaging.Message.Extension%2A> свойство.  
  
 Если это возможно, следует включать данные сообщения в <xref:System.Messaging.Message.Body%2A> свойство сообщения, а не <xref:System.Messaging.Message.Extension%2A> свойство.  
  
 При работе с внешними очередями используйте <xref:System.Messaging.Message.Extension%2A> свойство, чтобы указать свойства сообщения, которые не существуют в очереди сообщений.  
  
 Внешний очередь существует в очереди системы, отличной от Microsoft Message Queuing. Служба очереди сообщений взаимодействует с другими очередями через приложение-подключатель.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Extension" />.</exception>
        <exception cref="T:System.ArgumentException">Значение свойства <see cref="P:System.Messaging.Message.Extension" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает модуль форматирования, используемый для сериализации объекта в текст сообщения или десериализации объекта из текста сообщения.</summary>
        <value>Объект <see cref="T:System.Messaging.IMessageFormatter" />, создающий поток, записываемый в текст сообщения или считываемый из него. Значение по умолчанию — <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Messaging.Message.Formatter%2A> свойство при чтении и записи сообщения. Когда сообщение отправляется в очередь, модуль форматирования сериализует <xref:System.Messaging.Message.Body%2A> свойство в поток, который можно отправить в очередь сообщений. При чтении из очереди, модуль форматирования десериализует данные из <xref:System.Messaging.Message.Body%2A> свойство.  
  
 Если не записывается содержимое сообщения непосредственно в <xref:System.Messaging.Message.BodyStream%2A> задайте <xref:System.Messaging.Message.Formatter%2A> свойство перед отправкой сообщения. Когда <xref:System.Messaging.MessageQueue.Send%2A> вызывается метод <xref:System.Messaging.MessageQueue> экземпляра, тексте сериализуется с помощью модуля форматирования, содержащиеся в <xref:System.Messaging.Message.Formatter%2A> свойство. Если отправить сообщение без указания значения для <xref:System.Messaging.Message.Formatter%2A> , модуль форматирования по умолчанию свойство <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.XmlMessageFormatter> Слабо связанный, поэтому нет необходимости в тот же объект введите на отправителя и получателя, при использовании этого формата. <xref:System.Messaging.ActiveXMessageFormatter> И <xref:System.Messaging.BinaryMessageFormatter> сериализовать данные в двоичное представление. <xref:System.Messaging.ActiveXMessageFormatter> Используется при отправке или получении COM-компонентов.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется форматирование тела сообщения с помощью <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 В следующем примере кода демонстрируется форматирование тела сообщения с помощью <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение свойства <see cref="P:System.Messaging.Message.Formatter" /> — <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает алгоритм хэширования, используемый службой очереди сообщений при проверке подлинности сообщения или при создании цифровой подписи для сообщения.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Messaging.HashAlgorithm" />. Для Windows XP значение по умолчанию равно <see langword="SHA" />. В противном случае значением по умолчанию будет <see langword="MD5" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 На исходном компьютере Message Queuing использует алгоритм хэширования, при создании цифровой подписи для сообщения. Целевой диспетчер очереди затем использует один и тот же алгоритм хэширования для проверки подлинности сообщения при его получении.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.HashAlgorithm" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает идентификатор сообщения.</summary>
        <value>Уникальный идентификатор сообщения, создаваемый службой Message Queuing.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Служба Message Queuing создает идентификатор сообщения при отправке сообщения. Идентификатор состоит из 20 байт и двух элементов: компьютер <xref:System.Guid> передающего компьютера и уникальный идентификатор для сообщения на этом компьютере. Объединение двух этих элементов создает идентификатор сообщения, уникальный в данной сети.  
  
 Служба Message Queuing создает идентификаторы для всех сообщений - включая подтверждения и сообщения-отчеты. Подтверждающее сообщение обычно передается службой Message Queuing в ответ на доставку или сбой исходного, отправленного сообщения. Можно найти <xref:System.Messaging.Message.Id%2A> значение свойства исходного сообщения в <xref:System.Messaging.Message.CorrelationId%2A> свойство подтверждающего сообщения.  
  
 Можно также использовать <xref:System.Messaging.Message.Id%2A> при отправке ответного сообщения в очередь ответов. Чтобы включить идентификатор исходного сообщения в ответном сообщении, присвойте <xref:System.Messaging.Message.CorrelationId%2A> свойство сообщение-ответ <xref:System.Messaging.Message.Id%2A> свойства исходного сообщения. Чтение ответного сообщения приложение затем можно использовать идентификатор корреляции из сообщения-ответа для идентификации исходного сообщения.  
  
   
  
## Examples  
 В следующем примере кода отправляет и получает сообщение, содержащее к и из очереди. Он специально запрашивает положительного подтверждения в случае, когда исходное сообщение достигает или извлечено из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Id" />.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на отсутствие тайм-аута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> и <xref:System.Messaging.Message.TimeToReachQueue%2A> требуется значение, указывающее время ожидания. Первом случае время ожидания — это максимальное время, отводимое сообщение должно быть получено из очереди. Для второго время ожидания представляет время, отводимое сообщение должно достичь очереди. В обоих случаях можно указать время ожидания как количество секунд или использовать <xref:System.Messaging.Message.InfiniteTimeout> для указания, что отсутствие тайм-аута.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Messaging.Message.InfiniteTimeout> поля.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, является ли это сообщением первым переданным сообщением транзакции.</summary>
        <value>Значение <see langword="true" />, если данное сообщение было первым сообщением, переданным в транзакции, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Принимающее приложение использует <xref:System.Messaging.Message.IsFirstInTransaction%2A> свойство, чтобы убедиться, что сообщение было первым сообщением в единой транзакции для одной очереди.  
  
 Это свойство доступно только в Message Queuing версии 2.0 и более поздних версий.  
  
 Для проверки границ транзакции можно использовать <xref:System.Messaging.Message.IsFirstInTransaction%2A> свойство вместе с двумя другими свойствами: <xref:System.Messaging.Message.IsLastInTransaction%2A> и <xref:System.Messaging.Message.TransactionId%2A>. Использовать первый тип, для проверки, было ли сообщение отправлено последним в транзакции, а второе — для извлечения идентификатора транзакции.  
  
 Если только одно сообщение отправляется в виде транзакции, <xref:System.Messaging.Message.IsFirstInTransaction%2A> и <xref:System.Messaging.Message.IsLastInTransaction%2A> заданы оба свойства `true`.  
  
   
  
## Examples  
 В следующем примере кода отображает значение сообщения <xref:System.Messaging.Message.IsFirstInTransaction%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.IsFirstInTransaction" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, является ли это сообщением последним переданным сообщением транзакции.</summary>
        <value>Значение <see langword="true" />, если данное сообщение было последним сообщением, переданным в транзакции; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Принимающее приложение использует <xref:System.Messaging.Message.IsLastInTransaction%2A> свойство, чтобы убедиться, что сообщение было последним сообщением в единой транзакции для одной очереди.  
  
 Это свойство доступно только в Message Queuing версии 2.0 и более поздних версий.  
  
 Для проверки границ транзакции можно использовать <xref:System.Messaging.Message.IsLastInTransaction%2A> свойство вместе с двумя другими свойствами: <xref:System.Messaging.Message.IsFirstInTransaction%2A> и <xref:System.Messaging.Message.TransactionId%2A>. Использовать первый тип, для проверки, было ли сообщение отправлено первым в транзакции, а второе — для извлечения идентификатора транзакции.  
  
 Если только одно сообщение отправляется в виде транзакции, <xref:System.Messaging.Message.IsFirstInTransaction%2A> и <xref:System.Messaging.Message.IsLastInTransaction%2A> заданы оба свойства `true`.  
  
   
  
## Examples  
 В следующем примере кода отображает значение сообщения <xref:System.Messaging.Message.IsLastInTransaction%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.IsLastInTransaction" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает определяемую приложением строку в кодировке Юникод, описывающую данное сообщение.</summary>
        <value>Метка сообщения. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метку сообщения можно использовать для решения ряда задач. Например, ее можно использовать для отображения или выборочной обработки сообщений на основе значений этой метки. Метка не обязательно быть уникальным для сообщения.  
  
 Метки очередей сообщений и метки сообщений представляют определяемые приложением значения, которые могут помочь в идентификации очереди или сообщения в понятных для человека терминах. Он отвечает содержимое метки, которое не имеет внутреннего смысла для приложения Message Queuing, интерпретируется приложением.  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение сообщения <xref:System.Messaging.Message.Label%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Label" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представлено в MSMQ 3.0. Получает идентификатор просмотра сообщения.</summary>
        <value>Код просмотра сообщения, который создается службой Message Queuing и уникален в очереди, где находится сообщение.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.LookupId%2A> Свойство предоставляет доступ только для чтения к код просмотра сообщения. Код просмотра, введенный в MSMQ 3.0 является 64-разрядный идентификатор, который создается службой Message Queuing и назначается каждому сообщению, когда сообщение помещается в очередь. Код просмотра не совпадает с идентификатором сообщения, который создается, когда сообщение отправляется.  
  
 Служба Message Queuing создает идентификатор просмотра для всех сообщений, помещаемых в очередь, включая назначения, генерируемые приложением, администрирования и очереди отчетов, а также системных журналов, недоставленных, соединитель и исходящих сообщений. Другими словами такие как сообщения, отправляемые по приложениям, а также службой Message Queuing. Код просмотра является уникальным в очередь и не имеет смысла вне очереди.  
  
 Если сообщение отправляется в несколько конечных очередей или копию сообщение хранится в журнале компьютера или очереди журнала, каждая копия сообщения будет иметь свой собственный код просмотра при ее размещении в соответствующую очередь.  
  
 <xref:System.Messaging.Message.LookupId%2A> Свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
 Код просмотра используется для чтения конкретного сообщения в очереди. После получения код поиска сообщения принимающее приложение может вызвать <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> или <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> функция перейти непосредственно на это сообщение и считываемое или получить его из очереди, в отличие от курсоров, которые должны запускаться в передней части очереди и Перейдите к концу очереди  
  
 Получение кодов просмотра сообщений в очереди отвечает приложение. Один из возможных способов получения кодов просмотра является создание триггера для очереди назначения, который вызывает компонент, который кэширует идентификаторы каждое сообщение, так как они помещаются в очередь.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.LookupId" />.</exception>
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип сообщения: <see langword="Normal" />, <see langword="Acknowledgment" /> или <see langword="Report" />.</summary>
        <value>Одно из значений <see cref="P:System.Messaging.Message.MessageType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Служба очереди сообщений обычно устанавливает это свойство при передаче сообщения. Сообщение Message Queuing может относиться к одному из следующих типов:  
  
-   `Normal`, который обычное сообщение отправляется из приложения в очередь или ответное сообщение, возвращаемое в передающее приложение.  
  
-   `Acknowledgement`, который создается службой Message Queuing передающего приложения. Например, служба Message Queuing может создавать положительные или отрицательные сообщения для указания того, что исходное сообщение было доставлено или прочитано. Служба Message Queuing возвращает соответствующее подтверждающее сообщение в очередь администрирования, указанную передающим приложением.  
  
-   `Report`, который создается службой Message Queuing в диспетчер очереди источника определен в очередь отчетов. При разрешенной трассировке служба Message Queuing передает сообщение-отчет в очередь отчетов Message Queuing при каждом поступлении исходного сообщения на сервер Message Queuing или при отправке с этого сервера.  
  
   
  
## Examples  
 В следующем примере кода отображает значение сообщения <xref:System.Messaging.Message.MessageType%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.MessageType" />.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает приоритет сообщения, используемый для определения места сообщения при его поступлении в очередь.</summary>
        <value>Одно из значений <see cref="T:System.Messaging.MessagePriority" />, представляющих уровни приоритета нетранзакционных сообщений. Значение по умолчанию — <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Priority%2A> Свойство влияет на обработку службой Message Queuing сообщение оба пути и при достижении места назначения. Сообщениям с более высоким приоритетом отдается предпочтение при маршрутизации, и они помещаются ближе к началу конечной очереди. Сообщения, имеющие одинаковый приоритет, помещаются в очередь в порядке поступления.  
  
 Можно задать приоритет значимые только для нетранзакционных сообщений. Служба очередей сообщений автоматически устанавливает приоритет транзактных сообщений для `Lowest`, вследствие чего приоритет транзакционное сообщение можно игнорировать.  
  
   
  
## Examples  
 В следующем примере кода два сообщения с различными приоритетами отправляются в очередь и последовательно извлекаются.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Priority" />.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, будет ли сообщение гарантированно доставлено в случае отказа компьютера или неисправности в сети.</summary>
        <value>Значение <see langword="true" />, если доставка сообщения гарантируется (за счет сохранения сообщения на диске во время нахождения на маршруте), и значение <see langword="false" />, если доставка не гарантируется. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Recoverable%2A> Свойство указывает, гарантируется ли доставка сообщения — даже в случае отказа компьютера во время прохождения в очередь места назначения сообщения.  
  
 Если доставка сообщения гарантируется, оно сохраняется локально на каждом этапе в маршруте, пока не будет успешно перенаправлено на следующий компьютер. Установка <xref:System.Messaging.Message.Recoverable%2A> свойства `true` может повлиять на пропускную способность.  
  
 Если сообщение является транзакционной, очереди сообщений автоматически обрабатывает сообщение как восстанавливаемые, независимо от значения <xref:System.Messaging.Message.Recoverable%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение сообщения <xref:System.Messaging.Message.Recoverable%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.Recoverable" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает очередь, принимающую ответные сообщения, создаваемые приложением.</summary>
        <value>Очередь сообщений <see cref="T:System.Messaging.MessageQueue" />, в которую возвращаются ответные сообщения, создаваемые приложениями. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.ResponseQueue%2A> Свойство идентифицирует очередь, принимающую генерируемые приложением ответные сообщения, которые принимающее приложение возвращает в передающее приложение. Передающее приложение задает очереди ответов при передаче их сообщений. В качестве очереди ответов может быть указана любая доступная очередь.  
  
 Сообщения, возвращаемые в очередь ответов, зависят от приложения. Приложение должно определить содержимое этих сообщений и действия, которые необходимо выполнить при приеме сообщений.  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение сообщения <xref:System.Messaging.Message.ResponseQueue%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.ResponseQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает контекст безопасности для сообщения.</summary>
        <value>Объект <see cref="T:System.Messaging.SecurityContext" />, содержащий контекст безопасности для сообщения, если ранее свойство было установлено; в противном случае — значение NULL.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает сертификат безопасности, используемый при проверке подлинности сообщений.</summary>
        <value>Массив байтовых значений, представляющий сертификат безопасности, который используется службой очереди сообщений для проверки отправителя сообщения. По умолчанию задан массив нулевой длины.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Принимающее приложение использует <xref:System.Messaging.Message.SenderCertificate%2A> свойства, если сообщение включает внешний сертификат безопасности.  
  
 Служба очереди сообщений может проверить подлинность сообщения с использованием либо сертификат внутренней или внешней безопасности. Служба очереди сообщений предоставляет внутренние сертификаты, которые используются для проверки целостности сообщения. Центр сертификации предоставляет внешний сертификат, к которому можно получить через <xref:System.Messaging.Message.SenderCertificate%2A> свойства сообщения. Очереди сообщений для проверки подлинности сообщения, внешний сертификат позволяет принимающему приложению дополнительную проверку отправителя. Внутренний сертификат не имеет подходящего значения принимающему приложению.  
  
 Внешний сертификат должны регистрироваться в службе каталогов системы очереди сообщений. Внешний сертификат содержит сведения о центре сертификации, пользователь сертификата, срок действия сертификата, открытый ключ сертификата пользователя, и подпись центра сертификации.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.SenderCertificate" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает идентификатор пользователя, отправившего сообщение.</summary>
        <value>Массив байтовых значений, описывающий отправителя. Принимающая служба Queue Manager использует этот идентификатор при проверке подлинности сообщения, чтобы проверить отправителя сообщения и права отправителя на доступ к очереди.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Messaging.Message.AttachSenderId%2A> свойство `false`, идентификатор отправителя, указанного в <xref:System.Messaging.Message.SenderId%2A> свойство не присоединяется к сообщению, при их передаче. Это означает для Message Queuing, что отправитель не проверяется при отправке сообщения в очередь места назначения. Если <xref:System.Messaging.Message.AttachSenderId%2A> свойство `true`, <xref:System.Messaging.Message.SenderId%2A> значение свойства trustworthy, только в том случае, если проверка подлинности сообщения. Используйте <xref:System.Messaging.Message.Authenticated%2A> свойство в сочетании с <xref:System.Messaging.Message.SenderId%2A> свойство для проверки прав доступа отправителя.  
  
 Приложение-подключатель — это приложения, использующего сервер соединителя для обеспечения связи между другими системами очередей и сообщений. Служба очереди сообщений требует, чтобы предоставить код отправителя приложения соединителя. Необходимо задать <xref:System.Messaging.Message.ConnectorType%2A> при отправке сообщений через приложение-подключатель.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.SenderId" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает версию очереди сообщений, используемую для передачи сообщения.</summary>
        <value>Версия Message Queuing, используемая для передачи сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderVersion%2A> Свойство важно для некоторых функций. Например обработка транзакций поддерживается только по очереди сообщений версии 2.0 и более поздних версий и цифровые подписи используются для проверки подлинности сообщений, передаваемых MSMQ 1.0.  
  
 Передающая Queue Manager устанавливает <xref:System.Messaging.Message.SenderVersion%2A> свойство при отправке сообщения.  
  
   
  
## Examples  
 В следующем примере кода отображает значение сообщения <xref:System.Messaging.Message.SenderVersion%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.SenderVersion" />.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает дату и время, установленные на передающем компьютере на момент передачи данного сообщения диспетчером исходной очереди.</summary>
        <value>Объект <see cref="T:System.DateTime" />, представляющий время передачи данного сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SentTime%2A> Настройки свойства в местное время компьютера, на котором экземпляр <xref:System.Messaging.Message> был создан класс. Этот часовой пояс может отличаться от используемых исходных и конечных очередей.  
  
   
  
## Examples  
 В следующем примере кода отображает значение сообщения <xref:System.Messaging.Message.SentTime%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.SentTime" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя компьютера, с которого было передано данное сообщение.</summary>
        <value>Имя компьютера, с которого было передано данное сообщение.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Формат <xref:System.Messaging.Message.SourceMachine%2A> свойство не включает предшествующий две косые черты (\\\\). Например `myServer` является допустимым <xref:System.Messaging.Message.SourceMachine%2A>.  
  
   
  
## Examples  
 В следующем примере кода отображает значение сообщения <xref:System.Messaging.Message.SourceMachine%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.SourceMachine" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Нет доступа к сведениям о компьютере или службе каталогов.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает максимальное время, в течение которого сообщение должно быть извлечено из очереди местоназначения.</summary>
        <value>Суммарное время, в течение которого переданное сообщение должно быть получено из очереди местоназначения. Значение по умолчанию — <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> Свойство указывает общее время в течение которого переданное сообщение должно быть получено из очереди назначения. Предельное время включает время, затраченное на очереди назначения и время ожидания в очереди до получения сообщения.  
  
> [!CAUTION]
>  При использовании зависимых клиентских компьютеров, убедитесь, что часы на клиентском компьютере синхронизированы с часами на сервере, на котором выполняется очереди сообщений. В противном случае может привести к непредсказуемому поведению при отправке сообщения, <xref:System.Messaging.Message.TimeToBeReceived%2A> свойство не является <xref:System.Messaging.Message.InfiniteTimeout>.  
  
 Если время, заданное параметром <xref:System.Messaging.Message.TimeToBeReceived%2A> истекает до удаления сообщения из очереди, очереди сообщений отклоняет это сообщение одним из двух способов. Если свойство <xref:System.Messaging.Message.UseDeadLetterQueue%2A> сообщения имеет значение `true`, это сообщение будет передано в очередь недоставленных сообщений. Если <xref:System.Messaging.Message.UseDeadLetterQueue%2A> является `false`, сообщение пропускается.  
  
 Можно задать сообщения <xref:System.Messaging.Message.AcknowledgeType%2A> свойство для запроса, что очереди сообщений отправить сообщение отрицательного подтверждения отказа в передающее приложение, если сообщение не загружается до истечения срока действия таймера.  
  
 Если значение, заданное <xref:System.Messaging.Message.TimeToBeReceived%2A> меньшим, чем значение, заданное параметром <xref:System.Messaging.Message.TimeToReachQueue%2A> свойства <xref:System.Messaging.Message.TimeToBeReceived%2A> имеет более высокий приоритет.  
  
 При отправке нескольких сообщений в одной транзакции, используемый службой очереди сообщений <xref:System.Messaging.Message.TimeToBeReceived%2A> свойства первого сообщения.  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение сообщения <xref:System.Messaging.Message.TimeToBeReceived%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.TimeToBeReceived" />.</exception>
        <exception cref="T:System.ArgumentException">Задано недопустимое значение для <see cref="P:System.Messaging.Message.TimeToBeReceived" />.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает максимальное время, в течение которого сообщение должно дойти до очереди.</summary>
        <value>Лимит времени, отсчитываемый с момента отправки сообщения, в течение которого сообщение должно достичь очереди местоназначения. Значение по умолчанию — <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если время, заданное параметром <xref:System.Messaging.Message.TimeToReachQueue%2A> истекает прежде чем сообщение достигнет конечной очереди, очереди сообщений отклоняет это сообщение одним из двух способов. Если свойство <xref:System.Messaging.Message.UseDeadLetterQueue%2A> сообщения имеет значение `true`, это сообщение будет передано в очередь недоставленных сообщений. Если <xref:System.Messaging.Message.UseDeadLetterQueue%2A> является `false`, сообщение пропускается  
  
 Можно задать сообщения <xref:System.Messaging.Message.AcknowledgeType%2A> свойство для запроса, что очереди сообщений отправить сообщение отрицательного подтверждения обратно в передающее приложение, если сообщение не поступило до истечения времени ожидания.  
  
 Если <xref:System.Messaging.Message.TimeToReachQueue%2A> свойство имеет значение 0 секунд, Message Queuing пытается снова передать сообщение получателю - Если очередь ожидает сообщения. Если очередь является локальной, сообщение всегда достигнет его.  
  
 Если значение, заданное <xref:System.Messaging.Message.TimeToReachQueue%2A> больше, чем значение, заданное параметром <xref:System.Messaging.Message.TimeToBeReceived%2A> свойства <xref:System.Messaging.Message.TimeToBeReceived%2A> имеет более высокий приоритет.  
  
 При отправке нескольких сообщений в одной транзакции, используемый службой очереди сообщений <xref:System.Messaging.Message.TimeToReachQueue%2A> свойства первого сообщения.  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение сообщения <xref:System.Messaging.Message.TimeToReachQueue%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.TimeToReachQueue" />.</exception>
        <exception cref="T:System.ArgumentException">Задано недопустимое значение для <see cref="P:System.Messaging.Message.TimeToReachQueue" />. Возможно, это отрицательное число.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает идентификатор транзакции, частью которой является данное сообщение.</summary>
        <value>Идентификатор транзакции, связанной с данным сообщением.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Принимающее приложение использует <xref:System.Messaging.Message.TransactionId%2A> свойство, чтобы убедиться, что сообщение было отправлено в рамках определенной транзакции. Идентификатор транзакции содержит идентификатор передающего компьютера (первые 16 битов) следуют порядковый номер 4 байтам.  
  
 Это свойство доступно только для очереди сообщений версии 2.0 и более поздних версий.  
  
 Транзакции не гарантируется, что идентификаторы должны быть уникальными, так как последовательные номера транзакций не сохраняются, и они начать заново на 2 <sup>20</sup>. Очередь сообщений гарантирует только что последующих транзакций будет иметь различные транзакции порядковых номеров.  
  
 Можно использовать <xref:System.Messaging.Message.TransactionId%2A> свойство вместе с <xref:System.Messaging.Message.IsFirstInTransaction%2A> и <xref:System.Messaging.Message.IsLastInTransaction%2A> свойства для проверки границ транзакции.  
  
   
  
## Examples  
 В следующем примере кода отображает значение сообщения <xref:System.Messaging.Message.TransactionId%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.TransactionId" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает очередь состояний транзакций на компьютере-источнике.</summary>
        <value>Очередь состояний транзакций на компьютере-источнике, используемая для передачи подтверждающих сообщений обратно в передающее приложение. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TransactionStatusQueue%2A> Свойство идентифицирует очередь транзакций на исходном компьютере, который получает подтверждение получения чтения из соединителя приложений. Служба очереди сообщений задает свойство, и соединитель приложения используют его при поиске транзактных сообщений, отправляемых во внешние очереди.  
  
 Внешний очередь существует в очереди системы, отличной от Microsoft Message Queuing. Служба очереди сообщений взаимодействует с другими очередями через приложение-подключатель.  
  
 Соединитель приложение может использовать очередь состояний транзакций для передачи подтверждающих сообщений в передающее приложение. Очередь состояний транзакций должна получать эти подтверждения, даже если отправляющее приложение не запрашивает других подтверждений.  
  
   
  
## Examples  
 В следующем примере кода отображает значение сообщения <xref:System.Messaging.Message.TransactionStatusQueue%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сообщение не отправлено. Это свойство можно прочитать только для сообщений, извлеченных из очереди.  
  
-или- 
Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.TransactionStatusQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, проводилась ли (или должна ли проводиться) проверка подлинности до отправки сообщения.</summary>
        <value>Значение <see langword="true" />, если передающее приложение запрашивает проверку подлинности для данного сообщения; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseAuthentication%2A> Свойство указывает, должна ли сообщение проверку подлинности. Если отправляющее приложение запрашивает проверку подлинности, Message Queuing создает цифровую подпись и использует его для подписи сообщения при отправке и проверки подлинности сообщения при его получении.  
  
 Если <xref:System.Messaging.Message.UseAuthentication%2A> является `false` и отправляется сообщение в очередь, принимающую только сообщения, прошедшие проверку подлинности, сообщение будет отклонено при поступлении в очередь.  
  
 Не удается определить, если сообщение не прошел проверку подлинности, просмотрев его свойства. Служба Message Queuing отклоняет такие сообщения, прежде чем они попадут в очередь. Тем не менее можно запросить подтверждающее сообщение, когда сообщение о сбое доставки сообщения от поступающих в очередь.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.UseAuthentication" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должна ли копия сообщения, которое не может быть доставлено, передаваться в очередь недоставленных сообщений.</summary>
        <value>Значение <see langword="true" />, если при сбое доставки сообщения его копия направляется в очередь недоставленных сообщений; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A> И <xref:System.Messaging.Message.UseDeadLetterQueue%2A> свойства определяют, как очереди сообщений отслеживает сообщения. Если <xref:System.Messaging.Message.UseDeadLetterQueue%2A> является `true`, вызывает сбой доставки (из нетранзакционной сообщения), сообщение должно отправляться нетранзакционную очередь недоставленных сообщений на компьютере, который не удалось доставить сообщение. Сбой доставки вызвано таймера истекает, например сообщения.  
  
 В случае сбоя доставки для транзакционное сообщение служба Message Queuing передает сообщение в транзакционную очередь недоставленных сообщений-на исходном компьютере во всех случаях отрицательным и сомнительных.  
  
 Если хранение сообщений в очередь недоставленных сообщений, следует снять очереди периодически для удаления сообщений, которые больше не требуются. Сообщения, хранящиеся в очереди недоставленных сообщений, учитываются в размере квоты для компьютера, на котором расположена очередь. Квота компьютера устанавливается администратором и ссылается на объема, выделенного для хранения сообщений на данном компьютере, а не только в одной очереди.  
  
 Не создавайте журнала или очередь недоставленных сообщений. Они обе очереди системы, на которые создается службой Message Queuing.  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение сообщения <xref:System.Messaging.Message.UseDeadLetterQueue%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.UseDeadLetterQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее, является ли сообщение конфиденциальным.</summary>
        <value>Значение <see langword="true" />, если требуется, чтобы служба Message Queuing шифровала сообщения; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если сообщение является закрытым, его текст шифруется перед отправкой и расшифровываются при получении. Для отправки конфиденциального сообщения, отправляющего приложения необходимо указать, будет использоваться шифрование и, при необходимости, алгоритм шифрования.  
  
 При передаче конфиденциальных сообщений, приложения не нужно выполнять шифрование сообщения. Служба очереди сообщений может шифровать текст сообщения, когда приложение отправляет сообщения в рамках предприятия Microsoft Windows 2000, которая имеет доступ к службе каталогов. При получении конфиденциальных сообщений, диспетчер принимающей очереди всегда расшифровывает текст сообщения.  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение сообщения <xref:System.Messaging.Message.UseEncryption%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.UseEncryption" />.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должна ли копия сообщения храниться в журнале компьютера, являющегося источником этого сообщения.</summary>
        <value>Чтобы потребовать хранения копии сообщения в журнале компьютера-источника после успешной передачи сообщения с компьютера на следующий сервер, это значение должно быть равным <see langword="true" />; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A> И <xref:System.Messaging.Message.UseDeadLetterQueue%2A> свойства определяют, как очереди сообщений отслеживает сообщения. Если <xref:System.Messaging.Message.UseJournalQueue%2A> является `true`, а затем его копия сохраняется в журнале исходного компьютера на каждом шаге, в том, что сообщение передается.  
  
 Отправленное сообщение только копируется в очередь журнала, если целевая очередь находится на удаленном компьютере. Если файл находится на локальном компьютере, сообщение отправляется непосредственно в очередь; Существуют нет промежуточных этапов, требующих ведения журнала.  
  
 Если хранение сообщений в очереди журнала, очистки очереди периодически для удаления сообщений, которые больше не требуются. Сообщения, хранящиеся в очереди журнала, входят в квоту для компьютера, на котором расположена очередь. (Квота компьютера устанавливается администратором).  
  
 Не создавайте журнала или очередь недоставленных сообщений. Они обе очереди системы, на которые создается службой Message Queuing.  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение сообщения <xref:System.Messaging.Message.UseJournalQueue%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.UseJournalQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, нужно ли отслеживать сообщение в процессе его перемещения в очередь места назначения.</summary>
        <value>Значение <see langword="true" />, если необходимо, чтобы на каждом промежуточном этапе прохождения сообщения в очередь места назначения создавался отчет, передаваемый в очередь системных отчетов; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseTracing%2A> Свойство указывает, следует ли отслеживать сообщения в процессе его перемещения в очередь назначения. Если `true`, в отчет (сформированные службой Message Queuing) отправляется в очередь отчетов при каждом проходе сообщения через сервер маршрутизации очереди сообщений. Очередь отчетов задается Queue Manager источника. Очереди отчетов не только для вывода сообщений, сформированные службой Message Queuing; генерируемые приложением сообщения также могут отправляться в очередь отчетов.  
  
 С помощью трассировки необходимо создать Active Directory и указании очереди отчета службой очередей сообщений. Администратор настраивает эти параметры.  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение сообщения <xref:System.Messaging.Message.UseTracing%2A> свойство.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Очередь сообщений фильтруется, чтобы не учитывать свойство <see cref="P:System.Messaging.Message.UseTracing" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>