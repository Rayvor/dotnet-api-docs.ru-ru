<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata><Meta Name="ms.openlocfilehash" Value="03ebc47492fb2535a966eaf1a48d67c8637fc20d" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67237933" /></Metadata><TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет доступ к очереди на сервере MSMQ.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Технология очереди сообщений позволяет приложениям, которые запускаются в разное время взаимодействовать через неоднородные сети и системы, которые могут быть временно недоступны. Приложения отправки, получения или просматривать (считывать без удаления) сообщения из очередей. Служба очереди сообщений является дополнительным компонентом [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] и Windows NT и должны устанавливаться отдельно.  
  
 <xref:System.Messaging.MessageQueue> Класс является оболочкой вокруг очереди сообщений. Существует несколько версий очереди сообщений и с использованием <xref:System.Messaging.MessageQueue> класса может привести к немного по-разному, в зависимости от операционной системы вы используете. Дополнительные сведения о конкретных функциях каждую версию очереди сообщений см. в разделе, «Новые возможности в очередь сообщений» Platform SDK в MSDN.  
  
 <xref:System.Messaging.MessageQueue> Класс предоставляет ссылку на очередь MSMQ. Можно указать путь в <xref:System.Messaging.MessageQueue.%23ctor%2A> конструктор для подключения к существующему ресурсу, или можно создать новую очередь на сервере. Перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, или <xref:System.Messaging.MessageQueue.Receive%2A>, необходимо связать новый экземпляр <xref:System.Messaging.MessageQueue> класса существующую очередь. На этом этапе можно изменить свойства очереди, такие как <xref:System.Messaging.MessageQueue.Category%2A> и <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> поддерживает два типа методов извлечения сообщений: синхронные и асинхронные. Синхронные методы, <xref:System.Messaging.MessageQueue.Peek%2A> и <xref:System.Messaging.MessageQueue.Receive%2A>, поток процесса ожидания указанный интервал времени для нового сообщения поступление в очередь. Асинхронные методы, <xref:System.Messaging.MessageQueue.BeginPeek%2A> и <xref:System.Messaging.MessageQueue.BeginReceive%2A>, задачи основного приложения продолжают выполняться в отдельном потоке, до получения сообщения в очереди. Эти методы работают с помощью объектов ответного вызова и состояние объектов для передачи данных между потоками.  
  
 При создании нового экземпляра <xref:System.Messaging.MessageQueue> класс, вы не создаете новую очередь Message Queuing. Вместо этого можно использовать <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, и <xref:System.Messaging.MessageQueue.Purge%2A> методы для управления очередями на сервере.  
  
 В отличие от <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> и <xref:System.Messaging.MessageQueue.Delete%28System.String%29> являются `static` членами, поэтому их можно вызывать, не создавая новый экземпляр <xref:System.Messaging.MessageQueue> класса.  
  
 Можно задать <xref:System.Messaging.MessageQueue> объекта <xref:System.Messaging.MessageQueue.Path%2A> свойство с одним из трех имен: понятное имя, <xref:System.Messaging.MessageQueue.FormatName%2A>, или <xref:System.Messaging.MessageQueue.Label%2A>. Понятное имя, которое определяется очереди <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A> свойства, является <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> для общей очереди, и <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> для частной очереди. <xref:System.Messaging.MessageQueue.FormatName%2A> Свойство предоставляет доступ к очереди сообщений. Наконец, вы можете использовать очередь <xref:System.Messaging.MessageQueue.Label%2A> свойство для задания в очередь <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Список начальных значений свойств для экземпляра <xref:System.Messaging.MessageQueue>, см. в разделе <xref:System.Messaging.MessageQueue.%23ctor%2A> конструктор.  
  
   
  
## Examples  
 В следующем примере кода создает новые <xref:System.Messaging.MessageQueue> объекты с различными типами синтаксис имени пути. В каждом случае он отправляет сообщение в очередь, чей путь, определенный в конструкторе.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 В следующем примере кода отправляет сообщение в очередь и получает сообщение из очереди, с помощью конкретного приложения класс с именем `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Только <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> метод является потокобезопасным.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />. После того как используемый по умолчанию конструктор инициализирует новый экземпляр, необходимо задать свойство <see cref="P:System.Messaging.MessageQueue.Path" /> экземпляра, прежде чем можно будет использовать этот экземпляр.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, чтобы создать новый экземпляр класса <xref:System.Messaging.MessageQueue> класс, который не привязан непосредственно в очередь на сервер очередей сообщений. Прежде чем использовать этот экземпляр, его необходимо подключить к существующей очереди Message Queuing, задав <xref:System.Messaging.MessageQueue.Path%2A> свойство. Кроме того, можно задать <xref:System.Messaging.MessageQueue> ссылка <xref:System.Messaging.MessageQueue.Create%28System.String%29> возвращаемое значение метода, тем самым создавая новую очередь Message Queuing.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> Конструктор создает новый экземпляр класса <xref:System.Messaging.MessageQueue> класса; он не создает новую очередь Message Queuing.  
  
 В следующей таблице представлены исходные значения свойств для экземпляра <xref:System.Messaging.MessageQueue>.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Значения, заданные с помощью конструктора по умолчанию из <xref:System.Messaging.DefaultPropertiesToSend> класса.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Значения, заданные с помощью конструктора по умолчанию из <xref:System.Messaging.MessagePropertyFilter> класса. Все значения фильтра присваиваются `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 В следующем примере кода создается новый <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />, который ссылается на очередь MSMQ по указанному пути.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, если необходимо привязать новый <xref:System.Messaging.MessageQueue> экземпляр для определенной очереди Message Queuing, о которой известно, что путь, имя формата или метка. Если требуется монопольный доступ к первому приложению, которое ссылается на очередь, необходимо задать <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> свойства `true` или используйте конструктор, который передает параметр ограничением доступа на чтение.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> Конструктор создает новый экземпляр класса <xref:System.Messaging.MessageQueue> класса; он не создает новую очередь Message Queuing. Чтобы создать новую очередь в очереди сообщений, используйте <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Синтаксис `path` параметр зависит от типа очереди он ссылается, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общей очереди|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
|Очереди журнала|`MachineName`\\`QueueName`\\`Journal$`|  
|Очереди журнала компьютера|`MachineName`\\`Journal$`|  
|Очередь недоставленных сообщений компьютера|`MachineName`\\`Deadletter$`|  
|Транзакционная очередь недоставленных сообщений компьютера|`MachineName`\\`XactDeadletter$`|  
  
 Кроме того, можно использовать <xref:System.Messaging.MessageQueue.FormatName%2A> или <xref:System.Messaging.MessageQueue.Label%2A> для описания пути к очереди, как показано в следующей таблице.  
  
|Ссылка|Синтаксис|Пример|  
|---------------|------------|-------------|  
|Название формата|`FormatName:` [ *имя формата* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Метка|`Label:` [ *метка* ]|`Label:` TheLabel|  
  
 Чтобы работать в автономном режиме, необходимо использовать синтаксис имени формата, не синтаксис имени пути для конструктора. В противном случае создается исключение, так как основной контроллер домена недоступен для разрешения пути в имя формата.  
  
 В следующей таблице представлены исходные значения свойств для экземпляра <xref:System.Messaging.MessageQueue>. Эти значения определяются свойства очереди Message Queuing с путем, указанным `path` параметра.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Значения, заданные с помощью конструктора по умолчанию из <xref:System.Messaging.DefaultPropertiesToSend> класса.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, если уровень конфиденциальности очереди Message Queuing «Текст»; в противном случае `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Значение свойства имени компьютера очередь Message Queuing.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Значения, заданные с помощью конструктора по умолчанию из <xref:System.Messaging.MessagePropertyFilter> класса.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, если оно не задано с помощью конструктора.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, если оно не задано с помощью конструктора.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, если объект Message Queuing журнал включен; в противном случае `false`.|  
  
   
  
## Examples  
 В следующем примере кода создает новые <xref:System.Messaging.MessageQueue> объекты с различными типами синтаксис имени пути. В каждом случае он отправляет сообщение в очередь, чей путь, определенный в конструкторе.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> имеет неверное значение. Возможно, оно просто не задано.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, для локального компьютера может иметь значение ".".</param>
        <param name="sharedModeDenyReceive">Значение <see langword="true" />, если необходимо предоставить монопольный доступ на чтение первому приложению, которое обратится к очереди; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />, который ссылается на очередь MSMQ по указанному пути и с указанным ограничением доступа на чтение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, если необходимо привязать новый <xref:System.Messaging.MessageQueue> в определенную очередь Message Queuing, о которой известно, что путь, имя формата или метка. Если требуется монопольный доступ к первому приложению, которое ссылается на очередь, установите `sharedModeDenyReceive` параметр `true`. В противном случае значение `sharedModeDenyReceive` для `false` или используйте конструктор, который имеет только `path` параметра.  
  
 Установка `sharedModeDenyReceive` для `true` влияет на все объекты, которые обращаются к очереди сообщений, включая другие приложения. Влияние параметра не только на это приложение.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> Конструктор создает новый экземпляр класса <xref:System.Messaging.MessageQueue> класса; он не создает новую очередь Message Queuing. Чтобы создать новую очередь в очереди сообщений, используйте <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Синтаксис `path` параметр зависит от типа очереди.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общей очереди|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
|Очереди журнала|`MachineName`\\`QueueName`\\`Journal$`|  
|Очереди журнала компьютера|`MachineName`\\`Journal$`|  
|Очередь недоставленных сообщений компьютера|`MachineName`\\`Deadletter$`|  
|Транзакционная очередь недоставленных сообщений компьютера|`MachineName`\\`XactDeadletter$`|  
  
 Кроме того можно использовать формат имя или метку очереди Message Queuing для описания пути к очереди.  
  
|Ссылка|Синтаксис|Пример|  
|---------------|------------|-------------|  
|Название формата|`FormatName:` [ *имя формата* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Метка|`Label:` [ *метка* ]|`Label:` TheLabel|  
  
 Чтобы работать в автономном режиме, необходимо использовать синтаксис имени формата, а не синтаксис понятного имени. В противном случае создается исключение, поскольку основного контроллера домена (на котором установлена Active Directory) не поддерживается для разрешения пути в имя формата.  
  
 Если <xref:System.Messaging.MessageQueue> открывает очередь `sharedModeDenyReceive` параметру присвоить `true`любые <xref:System.Messaging.MessageQueue> что в последующем попытается прочитать данные из очереди, создаст <xref:System.Messaging.MessageQueueException> из-за нарушения совместного доступа. Объект <xref:System.Messaging.MessageQueueException> возникает также в том случае, если <xref:System.Messaging.MessageQueue> пытается получить доступ к очереди в монопольном режиме во время выполнения другой <xref:System.Messaging.MessageQueue> уже имеет монопольного доступа к очереди.  
  
 В следующей таблице представлены исходные значения свойств для экземпляра <xref:System.Messaging.MessageQueue>. Эти значения определяются свойства очереди сообщений, с путем, указанным `path` параметра.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Значения, заданные с помощью конструктора по умолчанию из <xref:System.Messaging.DefaultPropertiesToSend> класса.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, если уровень конфиденциальности очереди Message Queuing «Текст»; в противном случае `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Значение свойства имени компьютера очередь Message Queuing.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Значения, заданные с помощью конструктора по умолчанию из <xref:System.Messaging.MessagePropertyFilter> класса.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, если оно не задано с помощью конструктора.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, если оно не задано с помощью конструктора.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Значение параметра `sharedModeDenyReceive`.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, если объект Message Queuing журнал включен; в противном случае `false`.|  
  
   
  
## Examples  
 В следующем примере кода создается новый <xref:System.Messaging.MessageQueue> с монопольным доступом задает путь к нему и отправляет сообщение в очередь.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> имеет неверное значение. Возможно, оно просто не задано.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, для локального компьютера может иметь значение ".".</param>
        <param name="accessMode">Одно из значений <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, для локального компьютера может иметь значение ".".</param>
        <param name="sharedModeDenyReceive">Значение <see langword="true" />, если необходимо предоставить монопольный доступ на чтение первому приложению, которое обратится к очереди; в противном случае — значение <see langword="false" />.</param>
        <param name="enableCache">Значение <see langword="true" />, если необходимо создать и использовать кэш подключений; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода создается новый <xref:System.Messaging.MessageQueue> с монопольным доступом для чтения и с включенным кэшированием подключения.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, для локального компьютера может иметь значение ".".</param>
        <param name="sharedModeDenyReceive">Значение <see langword="true" />, если необходимо предоставить монопольный доступ на чтение первому приложению, которое обратится к очереди; в противном случае — значение <see langword="false" />.</param>
        <param name="enableCache">Значение <see langword="true" />, если необходимо создать и использовать кэш подключений; в противном случае — значение <see langword="false" />.</param>
        <param name="accessMode">Одно из значений <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее режим доступа для очереди.</summary>
        <value>Одно из значений <see cref="T:System.Messaging.QueueAccessMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режим доступа по умолчанию для очереди — `QueueAccessMode.SendAndReceive`, если не указано иное при вызове конструктора.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, принимает ли очередь только сообщения, прошедшие проверку подлинности.</summary>
        <value>Значение <see langword="true" />, если очередь принимает только сообщения, прошедшие проверку подлинности; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Проверка подлинности сообщений предоставляет способ для проверки целостности сообщений и проверки отправителя сообщения. Чтобы запросить проверку подлинности, передающее приложение задает уровень проверки подлинности сообщения.  
  
 При задании <xref:System.Messaging.MessageQueue.Authenticate%2A> для `true`, вы ограничите доступ к очереди на сервере, не только к этому <xref:System.Messaging.MessageQueue> экземпляра. Будут возвращены после всех клиентов, работающих с той же очереди Message Queuing.  
  
 Очередь, принимающую только сообщения, прошедшего проверку подлинности будет отклонять сообщения без проверки подлинности. Чтобы запросить уведомление об отклонении сообщения, приложение может задать <xref:System.Messaging.Message.AcknowledgeType%2A> свойства сообщения. Поскольку существует других признаков отклонения сообщения, передающее приложение может потерять сообщения, вы можете запросить отправку в очередь недоставленных.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередь сообщений <xref:System.Messaging.MessageQueue.Authenticate%2A> свойство.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает базовый приоритет, используемый службой очереди сообщений для маршрутизации сообщений общей очереди по сети.</summary>
        <value>Элементарный базовый приоритет для всех сообщений, переданных в общую очередь. Значение по умолчанию равно нулю (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовый приоритет очереди сообщений указывает как прохождения сообщения очереди, обрабатывается во время их передачи по сети. Можно задать <xref:System.Messaging.MessageQueue.BasePriority%2A> свойства на основании высокий или низкий приоритет для всех сообщений, отправленных в указанную очередь, отправленными в другие очереди. Задание этого свойства изменяет очередь Message Queuing. Таким образом, любой другой <xref:System.Messaging.MessageQueue> экземпляры будут затронуты данным изменением.  
  
 Очередь сообщений <xref:System.Messaging.MessageQueue.BasePriority%2A> не относится к <xref:System.Messaging.Message.Priority%2A> свойство сообщения, которое указывает порядок, в котором входящее сообщение помещается в очередь.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> применяется только к общим очередям, пути которых указываются с помощью имени формата. Базовый приоритет частной очереди всегда равно нулю (0).  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередь сообщений <xref:System.Messaging.MessageQueue.BasePriority%2A> свойство.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для базового приоритета задано недопустимое значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <summary>Инициирует асинхронную операцию считывания, указывая службе MSMQ на необходимость запуска операции считывания сообщения и уведомления обработчика событий о завершении операции.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициирует асинхронную операцию считывания, не имеющую тайм-аута. Операция остается незавершенной, пока сообщение не станет доступным в очереди.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В асинхронной обработки используется <xref:System.Messaging.MessageQueue.BeginPeek%2A> для вызова <xref:System.Messaging.MessageQueue.PeekCompleted> событие, когда сообщение не станет доступным в очереди.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginPeek%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и свяжите его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Инициирует асинхронную операцию считывания; <xref:System.Messaging.MessageQueue> уведомляется через вызов <xref:System.Messaging.MessageQueue.PeekCompleted> событий, при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> или путем извлечения результата с помощью <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Метод немедленно возвращает результат, но асинхронная операция не завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, его можно вызвать для просмотра очереди, не блокирует текущий поток выполнения. Для синхронного просмотра очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginPeek%2A> Возвращает определяет асинхронную операцию, запущенную методом. Это можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> вызывается. Тем не менее, если вы запустили несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значений в массиве и укажите, следует ли ожидать все операции или завершения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> — `false`, возникает событие завершения, но будет создано исключение при вызове <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается обработчик событий с именем `MyPeekCompleted`, присоединяется к <xref:System.Messaging.MessageQueue.PeekCompleted> делегата обработчика событий и вызовов <xref:System.Messaging.MessageQueue.BeginPeek%2A> инициировать асинхронную операцию в очереди, расположенный по пути «. \myQueue». Когда <xref:System.Messaging.MessageQueue.PeekCompleted> события, в примере считывает сообщение и выводит его текст на экран. Затем в примере вызывается <xref:System.Messaging.MessageQueue.BeginPeek%2A> еще раз, чтобы инициировать новую асинхронную операцию.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <summary>Инициирует асинхронную операцию считывания с заданным тайм-аутом. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В асинхронной обработки используется <xref:System.Messaging.MessageQueue.BeginPeek%2A> для вызова <xref:System.Messaging.MessageQueue.PeekCompleted> событие, когда сообщение не станет доступным в очереди или по истечении заданного интервала времени.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginPeek%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и свяжите его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Инициирует асинхронную операцию считывания; <xref:System.Messaging.MessageQueue> уведомляется через вызов <xref:System.Messaging.MessageQueue.PeekCompleted> событий, при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> или путем извлечения результата с помощью <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Метод немедленно возвращает результат, но асинхронная операция не завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, его можно вызвать для просмотра очереди, не блокирует текущий поток выполнения. Для синхронного просмотра очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginPeek%2A> Возвращает определяет асинхронную операцию, запущенную методом. Это можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> вызывается. Тем не менее, если вы запустили несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значений в массиве и укажите, следует ли ожидать все операции или завершения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Эта перегрузка позволяет задать время ожидания. Если время, заданное параметром `timeout` истекло, этот компонент создает <xref:System.Messaging.MessageQueue.PeekCompleted> событий. Поскольку сообщения отсутствуют, последующий вызов <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> приведет к возникновению исключения.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> — `false`, возникает событие завершения, но будет создано исключение при вызове <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронную операцию считывания, используя путь очереди «. \myQueue». Он создает обработчик событий `MyPeekCompleted`и присоединяет его к <xref:System.Messaging.MessageQueue.PeekCompleted> делегата обработчика событий. <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызывается с временем ожидания длительностью в одну минуту, чтобы инициировать асинхронную операцию считывания. Когда <xref:System.Messaging.MessageQueue.PeekCompleted> события или истечения времени ожидания, сообщение извлекается в том случае, если он существует и основной текст выводится на экран. Затем <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызывается снова, чтобы инициировать операцию асинхронного считывания с тем же временем ожидания.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="stateObject">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <summary>Инициирует асинхронную операцию считывания с указанным тайм-аутом и заданным объектом состояния, который предоставляет связанные данные в течение всего времени выполнения операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В асинхронной обработки используется <xref:System.Messaging.MessageQueue.BeginPeek%2A> для вызова <xref:System.Messaging.MessageQueue.PeekCompleted> событие, когда сообщение не станет доступным в очереди или по истечении заданного интервала времени.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Используйте этот перегруженный метод, чтобы связать сведения с операцией, сохраняются на протяжении всего времени выполнения операции. Обработчик событий можно получить доступ к этой информации, просмотрев <xref:System.IAsyncResult.AsyncState%2A> свойство <xref:System.IAsyncResult> , связанного с операцией.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginPeek%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и свяжите его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Инициирует асинхронную операцию считывания; <xref:System.Messaging.MessageQueue> уведомляется через вызов <xref:System.Messaging.MessageQueue.PeekCompleted> событий, при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> или путем извлечения результата с помощью <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Метод немедленно возвращает результат, но асинхронная операция не завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, его можно вызвать для просмотра очереди, не блокирует текущий поток выполнения. Для синхронного просмотра очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Возвращает <xref:System.IAsyncResult> , определяющий асинхронную операцию, запущенную методом. Это можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> вызывается. Тем не менее, если вы запустили несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значений в массиве и укажите, следует ли ожидать все операции или завершения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Эта перегрузка позволяет задать время ожидания и объект состояния. Если время, заданное параметром `timeout` истекло, этот компонент создает <xref:System.Messaging.MessageQueue.PeekCompleted> событий. Поскольку сообщения отсутствуют, последующий вызов <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> приведет к возникновению исключения.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, если вы вызываете <xref:System.Messaging.MessageQueue.BeginPeek%2A> несколько раз, чтобы инициировать несколько операций, можно идентифицировать каждую операцию с помощью отдельного объекта состояния, определении. Пример такого сценария см. разделе "Пример".  
  
 Объект состояния может использоваться для передачи информации по потокам процессов. Обратный вызов находится в другом потоке в асинхронном сценарии запуска потока, объект состояния маршалировать и передать обратно, а также сведения из события.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> — `false`, возникает событие завершения, но будет создано исключение при вызове <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронную операцию считывания, используя путь очереди «. \myQueue». Он создает обработчик событий `MyPeekCompleted`и присоединяет его к <xref:System.Messaging.MessageQueue.PeekCompleted> делегата обработчика событий. <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызывается, с временем ожидания длительностью в одну минуту. Каждый вызов <xref:System.Messaging.MessageQueue.BeginPeek%2A> имеет уникальный целочисленный идентификатор, определяющий данную операцию. Когда <xref:System.Messaging.MessageQueue.PeekCompleted> события или истечения тайм-аута, сообщение, если таковой существует, извлекается и его текст и относящиеся к операции целочисленный идентификатор записываются на экран. Затем <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызывается снова, чтобы инициировать операцию асинхронного считывания с тем же тайм-аут и с целочисленным просто завершенной операции.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="stateObject">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <param name="callback">Объект <see cref="T:System.AsyncCallback" />, принимающий уведомление о завершении асинхронной операции.</param>
        <summary>Инициирует асинхронную операцию считывания с указанным тайм-аутом и заданным объектом состояния, который предоставляет связанные данные в течение всего времени выполнения операции. Посредством обратного вызова эта перегрузка получает уведомление об отличительных особенностях обработчика событий для операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этой перегрузки, обратный вызов, указанный в параметре обратного вызова инициируется, сообщение не станет доступным в очереди или по истечении заданного интервала времени. <xref:System.Messaging.MessageQueue.PeekCompleted> событие не происходит. Другие перегрузки <xref:System.Messaging.MessageQueue.BeginPeek%2A> полагаются на этот компонент для вызова <xref:System.Messaging.MessageQueue.PeekCompleted> событий.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также возникает, если сообщение уже существует в очереди.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Метод немедленно возвращает результат, но асинхронная операция не завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, его можно вызвать для просмотра очереди, не блокирует текущий поток выполнения. Для синхронного просмотра очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Возвращает <xref:System.IAsyncResult> , определяющий асинхронную операцию, запущенную методом. Это можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> вызывается. Тем не менее, если вы запустили несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значений в массиве и укажите, следует ли ожидать все операции или завершения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, если вы вызываете <xref:System.Messaging.MessageQueue.BeginPeek%2A> несколько раз, чтобы инициировать несколько операций, можно идентифицировать каждую операцию с помощью отдельного объекта состояния, определении.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронную операцию считывания. Пример кода отправляет сообщение в очередь локальных сообщений, затем вызывает <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, передавая: значение времени ожидания 10 секунд; уникальный целочисленный идентификатор конкретного сообщения; и новый экземпляр класса <xref:System.AsyncCallback> , определяющий обработчик событий, `MyPeekCompleted`. Когда <xref:System.Messaging.MessageQueue.PeekCompleted> события, обработчик событий считывает сообщение и выводит на экран текст сообщения и целочисленный идентификатор сообщения.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="action">Одно из значений <see cref="T:System.Messaging.PeekAction" />. Указывает, следует ли считывать текущее сообщение в очереди или следующее сообщение.</param>
        <param name="state">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <param name="callback">Объект <see cref="T:System.AsyncCallback" />, принимающий уведомление о завершении асинхронной операции.</param>
        <summary>Инициирует асинхронную операцию считывания, которая имеет заданный тайм-аут и использует заданный курсор, заданную операцию считывания и заданный объект состояния. Объект состояния предоставляет связанные сведения в течение всего времени выполнения операции. Посредством обратного вызова эта перегрузка получает уведомление об отличительных особенностях обработчика событий для операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этой перегрузки, обратный вызов, указанный в параметре обратного вызова инициируется, когда сообщение не станет доступным в очереди или по истечении заданного интервала времени. <xref:System.Messaging.MessageQueue.PeekCompleted> Событие не происходит. Другие перегрузки <xref:System.Messaging.MessageQueue.BeginPeek%2A> полагаются на этот компонент для вызова <xref:System.Messaging.MessageQueue.PeekCompleted> событий.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также возникает, если сообщение уже существует в очереди.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Метод немедленно возвращает результат, но асинхронная операция не завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, его можно вызвать для просмотра очереди, не блокирует текущий поток выполнения. Для синхронного просмотра очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Возвращает <xref:System.IAsyncResult> , определяющий асинхронную операцию, запущенную методом. Это можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> вызывается. Тем не менее, если вы запустили несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значений в массиве и укажите, следует ли ожидать все операции или завершения любой операции. В этом случае следует использовать <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, если вы вызываете <xref:System.Messaging.MessageQueue.BeginPeek%2A> несколько раз, чтобы инициировать несколько операций, можно идентифицировать каждую операцию с помощью отдельного объекта состояния, определении.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Для параметра <paramref name="action" /> было задано значение, отличное от <see langword="PeekAction.Current" /> или <see langword="PeekAction.Next" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <summary>Инициирует асинхронную операцию получения, указывая службе MSMQ на необходимость запуска операции получения сообщения и уведомления обработчика событий о завершении операции.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициирует асинхронную операцию получения без тайм-аута. Операция остается незавершенной, пока сообщение не станет доступным в очереди.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В асинхронной обработки используется <xref:System.Messaging.MessageQueue.BeginReceive%2A> для вызова <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие, когда сообщение было удалено из очереди.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и свяжите его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Инициирует асинхронную операцию; получения <xref:System.Messaging.MessageQueue> уведомляется через вызов <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий, при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Метод немедленно возвращает результат, но асинхронная операция не завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди без блокировки текущего потока выполнения. Чтобы синхронно сообщение об ошибке, используйте <xref:System.Messaging.MessageQueue.Receive%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Возвращает определяет асинхронную операцию, запущенную методом. Это можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> вызывается. Тем не менее, если вы запустили несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значений в массиве и укажите, следует ли ожидать все операции или завершения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> — `false`, возникает событие завершения, но будет создано исключение при вызове <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и разместите транзакцию и (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> метод обработчика событий, создаваемых для операции просмотра. Обработчик событий может содержать функциональные возможности, как показано в следующем коде C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается цепочка асинхронных запросов. Предполагается, что на локальном компьютере, именем «myQueue» очереди. `Main` Функция начинает асинхронную операцию, которая обрабатывается `MyReceiveCompleted` подпрограммы. `MyReceiveCompleted` обрабатывает текущее сообщение и начинает новую асинхронную операцию получения.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 В следующем примере кода создается очередь асинхронных запросов. Вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> использует <xref:System.IAsyncResult.AsyncWaitHandle%2A> результирующее значение. `Main` Процедура ожидает завершить перед выходом из всех асинхронных операций.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <summary>Инициирует асинхронную операцию получения с указанным тайм-аутом. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В асинхронной обработки используется <xref:System.Messaging.MessageQueue.BeginReceive%2A> для вызова <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие, когда сообщение не станет доступным в очереди или по истечении заданного интервала времени.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и свяжите его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Инициирует асинхронную операцию; получения <xref:System.Messaging.MessageQueue> уведомляется через вызов <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий, при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> или извлечения результата с помощью <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Метод немедленно возвращает результат, но асинхронная операция не завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди без блокировки текущего потока выполнения. Чтобы синхронно сообщение об ошибке, используйте <xref:System.Messaging.MessageQueue.Receive%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> — `false`, возникает событие завершения, но будет создано исключение при вызове <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Возвращает определяет асинхронную операцию, запущенную методом. Это можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> вызывается. Тем не менее, если вы запустили несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значений в массиве и укажите, следует ли ожидать все операции или завершения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Эта перегрузка позволяет задать время ожидания. Если время, заданное параметром `timeout` истекло, этот компонент создает <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий. Поскольку сообщения отсутствуют, последующий вызов <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> приведет к возникновению исключения.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и разместите транзакцию и (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> метод обработчика событий, создаваемых для операции просмотра. Обработчик событий может содержать функциональные возможности, как показано в следующем коде C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронную операцию получения. В примере кода создается обработчик событий `MyReceiveCompleted`и присоединяет его к <xref:System.Messaging.MessageQueue.ReceiveCompleted> делегата обработчика событий. Пример кода отправляет сообщение в очередь локальных сообщений, затем вызывает метод <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, передавая значение времени ожидания 10 секунд. Когда <xref:System.Messaging.MessageQueue.ReceiveCompleted> события, обработчик событий получает сообщение и выводит на экран текст сообщения.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо. Возможно, было введено отрицательное число.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="stateObject">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <summary>Инициирует асинхронную операцию получения с указанным тайм-аутом и заданным объектом состояния, который предоставляет связанные данные в течение всего времени выполнения операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В асинхронной обработки используется <xref:System.Messaging.MessageQueue.BeginReceive%2A> для вызова <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие, когда сообщение не станет доступным в очереди или по истечении заданного интервала времени.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Используйте этот перегруженный метод, чтобы связать сведения с операцией, сохраняются на протяжении всего времени выполнения операции. Обработчик событий может обнаружить эти сведения, просмотрев <xref:System.IAsyncResult.AsyncState%2A> свойство <xref:System.IAsyncResult> , связанного с операцией.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и свяжите его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Инициирует асинхронную операцию; получения <xref:System.Messaging.MessageQueue> уведомляется через вызов <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий, при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> или извлечения результата с помощью <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Метод немедленно возвращает результат, но асинхронная операция не завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди без блокировки текущего потока выполнения. Чтобы синхронно сообщение об ошибке, используйте <xref:System.Messaging.MessageQueue.Receive%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Возвращает определяет асинхронную операцию, запущенную методом. Это можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> вызывается. Тем не менее, если вы запустили несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значений в массиве и укажите, следует ли ожидать все операции или завершения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Эта перегрузка позволяет задать время ожидания и объект состояния. Если время, заданное параметром `timeout` истекло, этот компонент создает <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий. Поскольку сообщения отсутствуют, последующий вызов <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> приведет к возникновению исключения.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, если вы вызываете <xref:System.Messaging.MessageQueue.BeginReceive%2A> несколько раз, чтобы инициировать несколько операций, можно идентифицировать каждую операцию с помощью отдельного объекта состояния, определении.  
  
 Объект состояния может использоваться для передачи информации по потокам процессов. Обратный вызов находится в другом потоке в асинхронном сценарии запуска потока, объект состояния маршалировать и передать обратно, а также сведения из события.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и разместите транзакцию и (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> метод обработчика событий, создаваемых для операции просмотра. Обработчик событий может содержать функциональные возможности, как показано в следующем коде C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронную операцию получения. В примере кода создается обработчик событий `MyReceiveCompleted`и присоединяет его к <xref:System.Messaging.MessageQueue.ReceiveCompleted> делегата обработчика событий. Пример кода отправляет сообщение в очередь локальных сообщений, затем вызывает метод <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, передавая значение времени ожидания 10 секунд и уникальный целочисленный идентификатор конкретного сообщения. Когда <xref:System.Messaging.MessageQueue.ReceiveCompleted> события, обработчик событий получает сообщение и выводит на экран текст сообщения и целочисленный идентификатор сообщения.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="stateObject">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <param name="callback">Объект <see cref="T:System.AsyncCallback" />, принимающий уведомление о завершении асинхронной операции.</param>
        <summary>Инициирует асинхронную операцию получения с указанным тайм-аутом и заданным объектом состояния, который предоставляет связанные данные в течение всего времени выполнения операции. Посредством обратного вызова эта перегрузка получает уведомление об отличительных особенностях обработчика событий для операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этой перегрузки, обратный вызов, указанный в параметре обратного вызова инициируется, сообщение не станет доступным в очереди или по истечении заданного интервала времени. <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие не происходит. Другие перегрузки <xref:System.Messaging.MessageQueue.BeginReceive%2A> полагаются на этот компонент для вызова <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и свяжите его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Инициирует асинхронную операцию; получения <xref:System.Messaging.MessageQueue> уведомляется через вызов <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий, при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> или извлечения результата с помощью <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Метод немедленно возвращает результат, но асинхронная операция не завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди без блокировки текущего потока выполнения. Чтобы синхронно сообщение об ошибке, используйте <xref:System.Messaging.MessageQueue.Receive%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Возвращает определяет асинхронную операцию, запущенную методом. Это можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> вызывается. Тем не менее, если вы запустили несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значений в массиве и укажите, следует ли ожидать все операции или завершения любой операции. В этом случае используется <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, если вы вызываете <xref:System.Messaging.MessageQueue.BeginReceive%2A> несколько раз, чтобы инициировать несколько операций, можно идентифицировать каждую операцию с помощью отдельного объекта состояния, определении.  
  
 Объект состояния может использоваться для передачи информации по потокам процессов. Обратный вызов находится в другом потоке в асинхронном сценарии запуска потока, объект состояния маршалировать и передать обратно, а также сведения из события.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и разместите транзакцию и (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> метод обработчика событий, создаваемых для операции просмотра. Обработчик событий может содержать функциональные возможности, как показано в следующем коде C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронную операцию получения. Пример кода отправляет сообщение в очередь локальных сообщений, затем вызывает <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, передавая: значение времени ожидания 10 секунд; уникальный целочисленный идентификатор конкретного сообщения; и новый экземпляр класса <xref:System.AsyncCallback> , определяющий обработчик событий, `MyReceiveCompleted`. Когда <xref:System.Messaging.MessageQueue.ReceiveCompleted> события, обработчик событий получает сообщение и выводит на экран текст сообщения и целочисленный идентификатор сообщения.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="state">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <param name="callback">Объект <see cref="T:System.AsyncCallback" />, принимающий уведомление о завершении асинхронной операции.</param>
        <summary>Инициирует асинхронную операцию получения, которая имеет заданный тайм-аут и использует заданный курсор и заданный объект состояния. Объект состояния предоставляет связанные сведения в течение всего времени выполнения операции. Посредством обратного вызова эта перегрузка получает уведомление об отличительных особенностях обработчика событий для операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этой перегрузки, обратный вызов, указанный в параметре обратного вызова инициируется, сообщение не станет доступным в очереди или по истечении заданного интервала времени. <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие не происходит. Другие перегрузки <xref:System.Messaging.MessageQueue.BeginReceive%2A> полагаются на этот компонент для вызова <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также возникает, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который будет обрабатывать результаты асинхронной операции и свяжите его с делегатом событий. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Инициирует асинхронную операцию; получения <xref:System.Messaging.MessageQueue> уведомляется через вызов <xref:System.Messaging.MessageQueue.ReceiveCompleted> событий, при поступлении сообщения в очереди. <xref:System.Messaging.MessageQueue> Затем доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> или извлечения результата с помощью <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Метод немедленно возвращает результат, но асинхронная операция не завершена, пока не будет вызван обработчик событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди без блокировки текущего потока выполнения. Чтобы синхронно сообщение об ошибке, используйте <xref:System.Messaging.MessageQueue.Receive%2A> метод.  
  
 После завершения асинхронной операции, можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> снова в обработчике событий, чтобы продолжать получать уведомления.  
  
 <xref:System.IAsyncResult> , <xref:System.Messaging.MessageQueue.BeginReceive%2A> Возвращает определяет асинхронную операцию, запущенную методом. Это можно использовать <xref:System.IAsyncResult> во время операции, несмотря на то, что вы обычно не используют эти сведения, пока <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> вызывается. Тем не менее, если вы запустили несколько асинхронных операций, можно поместить их <xref:System.IAsyncResult> значений в массиве и укажите, следует ли ожидать все операции или завершения любой операции. В этом случае следует использовать <xref:System.IAsyncResult.AsyncWaitHandle%2A> свойство <xref:System.IAsyncResult> для идентификации завершенной операции.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, если вы вызываете <xref:System.Messaging.MessageQueue.BeginReceive%2A> несколько раз, чтобы инициировать несколько операций, можно идентифицировать каждую операцию с помощью отдельного объекта состояния, определении.  
  
 Объект состояния может использоваться для передачи информации по потокам процессов. Обратный вызов находится в другом потоке в асинхронном сценарии запуска потока, объект состояния маршалировать и передать обратно, а также сведения из события.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и разместите транзакцию и (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> метод обработчика событий, создаваемых для операции просмотра. Обработчик событий может содержать функциональные возможности, как показано в следующем коде C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, может ли быть прочитан объект <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <value>Значение <see langword="true" />, если класс <see cref="T:System.Messaging.MessageQueue" /> существует, и приложение может прочитать данные из него; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> Указывает, является ли приложение возможность считывания и получения сообщений из очереди. Если <xref:System.Messaging.MessageQueue.CanRead%2A> — `true`, <xref:System.Messaging.MessageQueue> можно получать и считывать сообщения из очереди. В противном случае это невозможно.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> — `false` Если очередь уже был открыт монопольный доступ на чтение (или если он открыт монопольного доступа, и этот <xref:System.Messaging.MessageQueue> запрашивает монопольный доступ), или если приложение не имеет достаточных прав на доступ к нему. Если приложение пытается прочитать из очереди при <xref:System.Messaging.MessageQueue.CanRead%2A> является `false`, доступ будет запрещен.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередь сообщений <xref:System.Messaging.MessageQueue.CanRead%2A> свойство.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, может ли быть выполнена запись в <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <value>Значение <see langword="true" />, если класс <see cref="T:System.Messaging.MessageQueue" /> существует, и приложение может записать в него данные; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> Указывает, является ли приложение для отправки сообщений в очередь. Если <xref:System.Messaging.MessageQueue.CanWrite%2A> — `true`, <xref:System.Messaging.MessageQueue> может отправлять сообщения в очередь. В противном случае это невозможно.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> — `false` Если очередь уже был открыт монопольный доступ на запись (или если он открыт монопольного доступа, и этот <xref:System.Messaging.MessageQueue> запрашивает монопольный доступ), или если приложение не имеет достаточных прав на доступ к нему. Если приложение пытается записывать в очередь при <xref:System.Messaging.MessageQueue.CanWrite%2A> является `false`, доступ будет запрещен.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередь сообщений <xref:System.Messaging.MessageQueue.CanWrite%2A> свойство.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает категорию очереди.</summary>
        <value>Объект <see cref="T:System.Guid" />, представляющий категорию очереди (идентификатор типа очереди сообщений), которая позволяет приложению классифицировать его очереди. Значение по умолчанию — <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Категория очереди позволяет приложению классифицировать его очереди. Например можно поместить все очереди выставление счетов в одной категории, а все очереди порядок, в другой.  
  
 <xref:System.Messaging.MessageQueue.Category%2A> Свойство предоставляет доступ к свойству идентификатора типов очередей сообщений (который является чтение и запись), доступные через **свойства очереди** диалоговое окно, в консоли управления компьютером. Можно определить новую категорию. Несмотря на то, что можно использовать <xref:System.Guid.NewGuid%2A> для создания значения категории, которое является уникальным для всех <xref:System.Guid> значения, это действие не требуется. Значение категории должно отличаться только из других категорий, а не от всех других <xref:System.Guid> значения. Например, можно назначить {00000000-0000-0000-0000-000000000001} как <xref:System.Messaging.MessageQueue.Category%2A> для одного набора очередей и {00000000-0000-0000-0000-000000000002} как <xref:System.Messaging.MessageQueue.Category%2A> для другого набора.  
  
 Нет необходимости задать <xref:System.Messaging.MessageQueue.Category%2A>. Допускается значение `null`.  
  
 Задание этого свойства изменяет очередь Message Queuing. Таким образом, любой другой <xref:System.Messaging.MessageQueue> экземпляры будут затронуты данным изменением.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередь сообщений <xref:System.Messaging.MessageQueue.Category%2A> свойство.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для категории очереди задано недопустимое значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Очищает кэш подключений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, удаляются имена форматов, хранящиеся в кэше и закрытия дескрипторов открытые и хранящиеся в кэше.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В приведенном ниже примере кода вызывается <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, выделенные классом <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> Освобождает все ресурсы, связанные с <xref:System.Messaging.MessageQueue>, включая общие ресурсы, если это необходимо. Система возвращает себе ресурсы автоматически, если они по-прежнему доступны, например при вызове <xref:System.Messaging.MessageQueue.Send%28System.Object%29> метода, как показано в следующем коде C#.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 При вызове <xref:System.Messaging.MessageQueue.Close%2A>, что все <xref:System.Messaging.MessageQueue> свойства, которые напрямую обращаются к очереди Message Queuing, очищаются. <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, И <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> все остается прежним.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> не всегда освободить чтения и записи в очередь, так как они могут быть общими. Вы можете использовать любую из следующих действий, чтобы убедиться, что <xref:System.Messaging.MessageQueue.Close%2A> освобождает дескрипторы чтения и записи в очередь:  
  
-   Создание <xref:System.Messaging.MessageQueue> с монопольным доступом. Чтобы сделать это, вызовите <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> или <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> конструктора, а набора `sharedModeDenyReceive` параметр `true`.  
  
-   Создание <xref:System.Messaging.MessageQueue> с отключенным кэшированием подключения. Чтобы сделать это, вызовите <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> конструктора и задайте `enableConnectionCache` параметр `false`.  
  
-   Отключите кэширование подключений. Чтобы сделать это, установите <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> свойства `false`.  
  
 Следует вызывать <xref:System.Messaging.MessageQueue.Close%2A> для очереди, прежде чем удалить очередь на сервер очередей сообщений. В противном случае сообщения, отправленные в очередь может вызывать исключения или появиться в очереди недоставленных.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода закрывает очередь Message Queuing.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новую очередь на сервере очереди сообщений по указанному пути.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь создаваемой очереди.</param>
        <summary>Создает нетранзакционную очередь сообщений по указанному пути.</summary>
        <returns>Класс <see cref="T:System.Messaging.MessageQueue" />, представляющий новую очередь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, чтобы создать нетранзакционную очередь Message Queuing.  
  
 Чтобы создать новый экземпляр класса <xref:System.Messaging.MessageQueue> класса в приложении и привязать его к существующей очереди, используйте <xref:System.Messaging.MessageQueue.%23ctor%2A> конструктор. Чтобы создать новую очередь в очереди сообщений, вызовите <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Синтаксис `path` параметр зависит от типа очереди он ссылается, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общей очереди|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
  
 Используйте «.» для локального компьютера. Дополнительные сведения о синтаксисе см. в разделе <xref:System.Messaging.MessageQueue.Path%2A> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода создается общая и частная очереди. Он отправляет сообщение в выбранной очереди.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="path" /> — <see langword="null" /> или пустая строка ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">По указанному пути уже существует очередь.  
  
 -или-  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Путь создаваемой очереди.</param>
        <param name="transactional">Значение <see langword="true" />, если необходимо создать транзакционную очередь; значение <see langword="false" />, если необходимо создать нетранзакционную очередь.</param>
        <summary>Создает транзакционную или нетранзакционную очередь сообщений по указанному пути.</summary>
        <returns>Класс <see cref="T:System.Messaging.MessageQueue" />, представляющий новую очередь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка можно использовать для создания транзакционной очереди в очереди сообщений. Можно создать нетранзакционную очередь, задав `transactional` параметр `false` или путем вызова другой перегрузкой <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Чтобы создать новый экземпляр класса <xref:System.Messaging.MessageQueue> класса в приложении и привязать его к существующей очереди, используйте <xref:System.Messaging.MessageQueue.%23ctor%2A> конструктор. Чтобы создать новую очередь в очереди сообщений, вызовите <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Синтаксис `path` параметр зависит от типа очереди он ссылается, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общей очереди|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
  
 Используйте «.» для локального компьютера. Дополнительные сведения о синтаксисе см. в разделе <xref:System.Messaging.MessageQueue.Path%2A> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода создается общедоступные и частные очереди транзакций. Он отправляет сообщение в выбранной очереди.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="path" /> — <see langword="null" /> или пустая строка ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">По указанному пути уже существует очередь.  
  
 -или-  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый объект <see cref="T:System.Messaging.Cursor" /> для текущей очереди сообщений.</summary>
        <returns>Новый объект <see cref="T:System.Messaging.Cursor" /> для текущей очереди сообщений. Этот курсор используется для сохранения определенного положения в очереди при чтении сообщений очереди.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время и дату создания очереди в службе очереди сообщений.</summary>
        <value>Объект <see cref="T:System.DateTime" /> представляющий дату и время создания очереди.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> не относится к очереди на сервере очереди сообщений, <xref:System.Messaging.MessageQueue> экземпляра.  
  
 Если очередь существует, это свойство представляет время создания очереди, корректируется в местное время сервера, на котором существует очередь.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередь сообщений <xref:System.Messaging.MessageQueue.CreateTime%2A> свойство.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значения свойств сообщения, которые будут использоваться по умолчанию, когда приложение будет отправлять сообщения в очередь.</summary>
        <value>Свойство <see cref="T:System.Messaging.DefaultPropertiesToSend" />, содержащее используемые по умолчанию значения свойств сообщений очереди сообщений, которые применяются, когда приложение отправляет в очередь объекты, отличные от экземпляров <see cref="T:System.Messaging.Message" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При отправке любой объект, который не относится к типу <xref:System.Messaging.Message> в очередь <xref:System.Messaging.MessageQueue> вставляет объект в сообщение очереди сообщений. В этот момент <xref:System.Messaging.MessageQueue> применяет к сообщению значения свойств, заданные вами в <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> свойство. И наоборот при отправке <xref:System.Messaging.Message> в очередь, эти свойства уже заданы для самого экземпляра, поэтому <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> учитывается для <xref:System.Messaging.Message>.  
  
 Несмотря на то, что вы задали свойства через <xref:System.Messaging.MessageQueue> объекта, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ссылается на свойства сообщений, отправленных в очередь, а не к самой очереди.  
  
 В следующей таблице показаны значения по умолчанию для свойства.  
  
|Свойство.|Значение по умолчанию|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Ноль (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|пустая строка (»»)|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода использует приоритет сообщения, чтобы определить свойства по умолчанию для отправки сообщения.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для очереди нельзя задать использующиеся по умолчанию свойства. Возможно, потому что неправильно задано одно из свойств.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Расположение удаляемой очереди.</param>
        <summary>Удаляет очередь с сервера очереди сообщений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Синтаксис `path` параметр зависит от типа очереди.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общей очереди|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
  
 Дополнительные сведения о синтаксисе см. в разделе <xref:System.Messaging.MessageQueue.Path%2A> свойство.  
  
 Кроме того, можно использовать <xref:System.Messaging.MessageQueue.FormatName%2A> или <xref:System.Messaging.MessageQueue.Label%2A> для описания пути к очереди.  
  
|Ссылка|Синтаксис|  
|---------------|------------|  
|Название формата|FormatName: [ *имя формата* ]|  
|Метка|Метка: [ *метка* ]|  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода удаляет очередь MSMQ, если он существует.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="path" /> — <see langword="null" /> или пустая строка ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Для параметра <paramref name="path" /> используется неправильный синтаксис.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, имеет ли этот объект <see cref="T:System.Messaging.MessageQueue" /> монопольный доступ на получение сообщений из очереди сообщений.</summary>
        <value>Значение <see langword="true" />, если этот класс <see cref="T:System.Messaging.MessageQueue" /> имеет права монопольного доступа для получения сообщений из очереди; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Указывает режим общей очереди, на которое указывает данный <xref:System.Messaging.MessageQueue>. Задайте <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> для `true` , только это <xref:System.Messaging.MessageQueue> должны иметь доступ к считывания и получения сообщений из очереди с указанным <xref:System.Messaging.MessageQueue.Path%2A>. Если другой <xref:System.Messaging.MessageQueue> или другое приложение связано с тем же ресурсом очереди, этот экземпляр или приложение не сможет просматривать и получать сообщения, но он по-прежнему можете отправить им.  
  
 Если <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> является `false`, очередь доступна для нескольких приложений для отправки, считывании и приеме сообщений.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередь сообщений <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> свойство.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Уничтожает ресурсы (кроме памяти), используемые классом <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> по окончании использования класса <xref:System.Messaging.MessageQueue>. Метод <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> оставляет класс <xref:System.Messaging.MessageQueue> в непригодном для использования состоянии. После вызова метода <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, необходимо освободить все ссылки на <xref:System.Messaging.MessageQueue> , занимаемая ими память может быть освобожден при коллекцией мусора.  
  
 Следует вызывать <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> перед освобождением последней ссылки на <xref:System.Messaging.MessageQueue>. В противном случае ресурсы <xref:System.Messaging.MessageQueue> является не будут освобождены до сборки мусора не будет <xref:System.Messaging.MessageQueue> вызов деструктора объекта основы.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, будет ли приложение поддерживать кэш подключений.</summary>
        <value>Значение <see langword="true" />, если необходимо создать и использовать кэш подключений; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кэш подключений приведен список ссылок на структуры, содержащие чтения или записи в очереди. Когда <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> — `true`, <xref:System.Messaging.MessageQueue> заимствует маркеры из кэша при каждом вызове <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, или <xref:System.Messaging.MessageQueue.Receive%2A>, вместо того чтобы открытых дескрипторов на новый. Это может повысить производительность. Использование кэша подключений также изолирует <xref:System.Messaging.MessageQueue> от изменений в топологии сети.  
  
 Если создать его в очередь при заполнении, кэш подключений <xref:System.Messaging.MessageQueue> перезаписывает структуре бы недавно использовавшихся на новое подключение. Вы можете очистить кэш полностью путем вызова <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, например, если формат имена очередей, вы работаете с были изменены, чтобы предыдущие чтения и записи, дескрипторы становятся недействительными.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередь сообщений <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> свойство.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, будет ли очередь принимать только неконфиденциальные (незашифрованные) сообщения.</summary>
        <value>Одно из значений <see cref="T:System.Messaging.EncryptionRequired" />. Значение по умолчанию — <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При указании, что шифрование является обязательным для сообщений, отправленных в очередь, шифруются только тела сообщения. Другие элементы (например, <xref:System.Messaging.Message.Label%2A> и <xref:System.Messaging.Message.SenderId%2A> свойства) не могут быть зашифрованы.  
  
 Задание этого свойства изменяет очередь Message Queuing. Таким образом, любой другой <xref:System.Messaging.MessageQueue> экземпляры будут затронуты данным изменением.  
  
 Шифрование сообщения делает закрытого сообщения. Можно указать требования шифрования очереди `None`, `Body`, или `Optional` , задав <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> свойство соответствующим образом. <xref:System.Messaging.Message.UseEncryption%2A> Сообщение должно соответствовать требования шифрования очереди. Если сообщение не зашифровано, но в очереди указана `Body`, или если сообщение зашифровано, но в очереди указана `None`, сообщение не принято по очереди. Если отправляющее приложение запрашивает сообщение отрицательного подтверждения в этом событии, очереди сообщений указывает, что сообщение было отвергнуто в передающее приложение. Если <xref:System.Messaging.Message.UseDeadLetterQueue%2A> свойство `true`, сообщение, которое происходит сбой шифрования отправляется в очередь недоставленных. В противном случае сообщение теряется.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередь сообщений <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> свойство.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, определяющий асинхронную операцию считывания, которая завершается и из которой извлекается конечный результат.</param>
        <summary>Завершает указанную асинхронную операцию считывания.</summary>
        <returns>Класс <see cref="T:System.Messaging.Message" />, связанный с завершенной асинхронной операцией.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Messaging.MessageQueue.PeekCompleted> события <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> завершает операцию, которая была начата <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызова. Чтобы сделать это, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> считывает сообщение.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> можно указать время ожидания, что приводит к <xref:System.Messaging.MessageQueue.PeekCompleted> событие, создаваемое, если истекло время ожидания до появления сообщения в очереди. При возникновении тайм-аута без сообщений, поступающих в очередь, последующий вызов <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> возникло исключение.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> используется для чтения сообщения, которое вызвало <xref:System.Messaging.MessageQueue.PeekCompleted> возникает событие.  
  
 Если вы хотите продолжить асинхронный просмотр сообщений, можно снова вызвать метод <xref:System.Messaging.MessageQueue.BeginPeek%2A> после вызова метода <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается обработчик событий с именем `MyPeekCompleted`, присоединяется к <xref:System.Messaging.MessageQueue.PeekCompleted> делегата обработчика событий и вызовов <xref:System.Messaging.MessageQueue.BeginPeek%2A> инициировать асинхронную операцию в очереди, расположенный по пути «. \myQueue». Когда <xref:System.Messaging.MessageQueue.PeekCompleted> события, в примере считывает сообщение и выводит его текст на экран. Затем в примере вызывается <xref:System.Messaging.MessageQueue.BeginPeek%2A> еще раз, чтобы инициировать новую асинхронную операцию.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="asyncResult" /> используется неправильный синтаксис.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, определяющий асинхронную операцию получения, которая завершается и из которой извлекается конечный результат.</param>
        <summary>Завершает указанную асинхронную операцию получения.</summary>
        <returns>Класс <see cref="T:System.Messaging.Message" />, связанный с завершенной асинхронной операцией.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Messaging.MessageQueue.ReceiveCompleted> события <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> завершает операцию, которая была начата <xref:System.Messaging.MessageQueue.BeginReceive%2A> вызова. Чтобы сделать это, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> получает сообщение.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> можно указать время ожидания, что приводит к <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие, создаваемое, если истекло время ожидания до появления сообщения в очереди. При возникновении тайм-аута без сообщений, поступающих в очередь, последующий вызов <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> возникло исключение.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> используется для чтения (удаление из очереди) сообщения, которое вызвало <xref:System.Messaging.MessageQueue.ReceiveCompleted> возникает событие.  
  
 Если вы хотите продолжить асинхронное получение сообщений, можно снова вызвать метод <xref:System.Messaging.MessageQueue.BeginReceive%2A> после вызова метода <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается цепочка асинхронных запросов. Предполагается, что на локальном компьютере, именем «myQueue» очереди. `Main` Функция начинает асинхронную операцию, которая обрабатывается `MyReceiveCompleted` подпрограммы. `MyReceiveCompleted` обрабатывает текущее сообщение и начинает новую асинхронную операцию получения.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="asyncResult" /> используется неправильный синтаксис.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Расположение искомой очереди.</param>
        <summary>Определяет, существует ли по указанному пути очередь сообщений.</summary>
        <returns>Значение <see langword="true" />, если очередь по указанному пути существует; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Метод определяет, существует ли очередь MSMQ по указанному пути. Метода не существует. Чтобы определить, существует ли очередь с именем указанного формата. Дополнительные сведения о синтаксисе имени формата и других формах синтаксиса пути, см. в разделе <xref:System.Messaging.MessageQueue.Path%2A> свойство.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> является ресурсоемкой операцией. Используйте только в том случае, когда это необходимо в приложении.  
  
> [!NOTE]
>  <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Метод не поддерживает <xref:System.Messaging.MessageQueue.FormatName%2A> префикс.  
  
 Синтаксис `path` параметр зависит от типа очереди, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общей очереди|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> нельзя вызывать для проверки существования удаленной частной очереди.  
  
 Дополнительные сведения о синтаксисе см. в разделе <xref:System.Messaging.MessageQueue.Path%2A> свойство.  
  
 Кроме того, можно использовать <xref:System.Messaging.MessageQueue.Label%2A> для описания пути к очереди.  
  
|Ссылка|Синтаксис|  
|---------------|------------|  
|Метка|Метка: [ `label` ]|  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода проверяет, существует ли очередь Message Queuing и затем удаляет его.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Неправильный синтаксис параметра <paramref name="path" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.  
  
-или- 
Метод <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> вызывается на удаленной частной очереди.</exception>
        <exception cref="T:System.InvalidOperationException">При проверке существования очереди приложение использовало синтаксис имени формата.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает уникальное имя очереди, созданное службой очереди сообщений в момент создания очереди.</summary>
        <value>Имя очереди, которое является уникальным в сети.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A> Свойство содержит имя формата очереди. Служба очереди сообщений использует имя формата для определения, какая очередь, чтобы открыть и доступе к нему. В отличие от большинства характеристик очереди имя формата не является свойством очереди приложения Message Queuing, поэтому не может получить доступ к его через средство управления очереди сообщений. Имя формата — это уникальное имя для очереди, который создается службой Message Queuing при создании очереди или более поздней версии создается приложением.  
  
 Если вы укажите путь, используя синтаксис имени пути (например `myComputer\myQueue`) вместо того чтобы использовать синтаксис имени формата при чтении или записи в очередь, преобразует основного контроллера домена (с использованием Active Directory) <xref:System.Messaging.MessageQueue.Path%2A> в связанных <xref:System.Messaging.MessageQueue.FormatName%2A> перед доступом к очереди. Если приложение работает в автономном режиме, необходимо использовать синтаксис имени формата; в противном случае основной контроллер домена будет недоступен для выполнения преобразования путь.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередь сообщений <xref:System.Messaging.MessageQueue.FormatName%2A> свойство.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> не указывается.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает модуль форматирования, используемый для сериализации объекта в текст сообщения или десериализации из текста сообщения, прочитанного из очереди или записанного в очередь.</summary>
        <value>Объект <see cref="T:System.Messaging.IMessageFormatter" />, создающий поток, записываемый в текст сообщения или считываемый из него. Значение по умолчанию — <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A> Свойство содержит экземпляр объекта средства форматирования, который преобразует сообщения, когда приложение считывает или записывает в очередь.  
  
 Когда приложение отправляет сообщение в очередь, модуль форматирования сериализует объект в поток и вставляет его в тело сообщения. При чтении из очереди, модуль форматирования десериализует данные из <xref:System.Messaging.Message.Body%2A> свойство <xref:System.Messaging.Message>.  
  
 <xref:System.Messaging.XmlMessageFormatter> Слабо связанный, поэтому нет необходимости в тот же объект введите на отправителя и получателя, при использовании этого формата. <xref:System.Messaging.ActiveXMessageFormatter> И <xref:System.Messaging.BinaryMessageFormatter> сериализовать данные в двоичное представление. <xref:System.Messaging.ActiveXMessageFormatter> Используется при отправке или получении COM-компонентов.  
  
 <xref:System.Messaging.BinaryMessageFormatter> и <xref:System.Messaging.ActiveXMessageFormatter> обеспечить большую пропускную способность, чем <xref:System.Messaging.XmlMessageFormatter>. <xref:System.Messaging.ActiveXMessageFormatter> Обеспечивает возможность взаимодействия с приложениями очереди сообщений Visual Basic 6.0.  
  
 Когда приложение отправляет сообщения в очередь <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> применяется только к этих сообщений, которые используют свойства сообщений по умолчанию <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. При отправке <xref:System.Messaging.Message> в очередь, используемый службой очереди сообщений модуль форматирования, определенные в <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> свойства вместо сериализации текста сообщения.  
  
 <xref:System.Messaging.MessageQueue> Класс будет всегда использовать <xref:System.Messaging.Message> получать и считывать сообщения из очереди. Сообщение сериализуется с помощью <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода демонстрируется форматирование тела сообщения с помощью <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 В следующем примере кода демонстрируется форматирование тела сообщения с помощью <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все сообщения из очереди.</summary>
        <returns>Массив типа <see cref="T:System.Messaging.Message" />, который представляет все сообщения очереди в том же порядке, в каком они располагаются в очереди сообщений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Возвращает статический снимок сообщений в очереди, не динамические ссылки на эти сообщения. Таким образом массив нельзя использовать для изменения сообщений в очереди. Если требуется, чтобы в режиме реального времени, динамического взаимодействия с очередью (например, возможность удаления сообщений), вызовите <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> метод, который возвращает динамический список сообщений в очереди.  
  
 Так как <xref:System.Messaging.MessageQueue.GetAllMessages%2A> возвращает копии сообщения в очереди во время вызова метода, массив не отражает новые сообщения, поступающие в очередь или сообщений, удаленных из очереди.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> извлекает только те свойства, которые не отфильтрованные <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Перечисляет сообщения в очереди. Параметр <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> использовать не рекомендуется. Вместо него следует использовать метод <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />.</summary>
        <returns>Объект <see cref="T:System.Collections.IEnumerator" />, обеспечивающий динамическое подключение к сообщениям очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Имя компьютера, на котором расположена очередь, без двух обратных косых черт (\\\\) в начале.</param>
        <summary>Получает идентификатор компьютера, на котором расположена очередь, на которую ссылается этот класс <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <returns>Объект <see cref="T:System.Guid" />, который представляет уникальный идентификатор компьютера, на котором расположена очередь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификатор компьютера можно использовать для двух целей, помимо прочего: для чтения журнала компьютера и задания сертификатов безопасности. Тем не менее, нельзя вызывать <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> на удаленном компьютере, при работе вне сети, так как в приложении необходим доступ к службе каталогов на контроллере домена.  
  
 Идентификатор компьютера (или идентификаторы компьютеров), <xref:System.Guid> , Message Queuing создает при добавлении компьютера на предприятии. Служба очереди сообщений сочетает в себе идентификатор компьютера с `Machine` и `Journal` ключевые слова для создания имени формата журнал компьютера, который имеет синтаксис `Machine=<computeridentifier>;Journal`. Журнал компьютера, который также известен как в очередь журнала является системной очереди, в которой хранятся копии генерируемые приложением сообщения, когда <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> свойство `true`.  
  
 Этот синтаксис для журнала используется только при создании имени формата очереди. Синтаксис имени пути `MachineName` \\ `Journal$`.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В приведенном ниже примере кода вызывается <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Не удается извлечь идентификатор компьютера. Возможной причиной может быть недоступность службы каталогов: например, при работе в автономном режиме.  
  
 -или-  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает объект перечислителя для всех сообщений очереди. Параметр <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> использовать не рекомендуется. Вместо него следует использовать метод <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />.</summary>
        <returns>Объект <see cref="T:System.Messaging.MessageEnumerator" /> содержащий сообщения, которые находятся в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> Создает динамический список всех сообщений в очереди. Можно удалить из очереди сообщение в текущей позиции перечислителя, вызвав <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> для <xref:System.Messaging.MessageEnumerator> , <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> возвращает.  
  
 Так, как курсор не связано с динамический список сообщений в очереди, перечисление отражает все изменения, внесенные в сообщения в очереди, если сообщение находится за текущей позицией курсора. Например перечислитель может автоматически получить доступ к сообщению с более низким приоритетом, размещенному за текущей позицией курсора, но не более высокий приоритет сообщения вставляется перед этой позиции. Тем не менее, вы можете сбросить перечисления, тем самым Возврат курсора в начало списка, путем вызова <xref:System.Messaging.MessageEnumerator.Reset%2A> для <xref:System.Messaging.MessageEnumerator>.  
  
 Порядок сообщений в перечислении отражает их порядка в очереди, поэтому сообщения с более высоким приоритетом отображаются перед более низким приоритетом.  
  
 Если требуется статический снимок сообщений в очереди, а не динамическое подключение к ним, вызовите <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Этот метод возвращает массив <xref:System.Messaging.Message> объекты, которые представляют сообщения на момент вызова метода.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода получает динамический список сообщений в очереди и подсчитывает все сообщения с <xref:System.Messaging.Message.Priority%2A> свойство значение <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает объект перечислителя для всех сообщений очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.MessageEnumerator" /> содержащий сообщения, которые находятся в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> Создает динамический список всех сообщений в очереди. Можно удалить из очереди сообщение в текущей позиции перечислителя, вызвав <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> для <xref:System.Messaging.MessageEnumerator> , <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> возвращает.  
  
 Так, как курсор не связано с динамический список сообщений в очереди, перечисление отражает все изменения, внесенные в сообщения в очереди, если сообщение находится за текущей позицией курсора. Например перечислитель может автоматически получить доступ к сообщению с более низким приоритетом, размещенному за текущей позицией курсора, но не более высокий приоритет сообщения вставляется перед этой позиции. Тем не менее, вы можете сбросить перечисления, тем самым Возврат курсора в начало списка, путем вызова <xref:System.Messaging.MessageEnumerator.Reset%2A> для <xref:System.Messaging.MessageEnumerator>.  
  
 Порядок сообщений в перечислении отражает их порядка в очереди, поэтому сообщения с более высоким приоритетом отображаются перед более низким приоритетом.  
  
 Если требуется статический снимок сообщений в очереди, а не динамическое подключение к ним, вызовите <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Этот метод возвращает массив <xref:System.Messaging.Message> объекты, которые представляют сообщения на момент вызова метода.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает объект перечислителя для динамического списка общих очередей сети.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обеспечивает семантику курсора последовательного доступа для перечисления во всех общих очередях сети.</summary>
        <returns>Объект <see cref="T:System.Messaging.MessageQueueEnumerator" />, обеспечивающий динамическое перечисление всех общих очередей сообщений в сети.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> возвращает перечисление всех общих очередей, которые входят в сеть.  
  
 Поскольку курсор связан с динамическим перечислением, перечисление отражаются все изменения, внесенные в список очередей удалены или добавлены за текущей позицией курсора. Добавление и удаление очередей, расположенных до текущей позиции курсора, не отражаются. Например перечислитель может автоматически получить доступ к очереди, добавленной за позицией курсора, но не вставляется перед этой позиции. Тем не менее, вы можете сбросить перечисления, тем самым Возврат курсора в начало списка, путем вызова <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> для <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Нет, не определен порядок очередей в сети. Перечислитель не упорядочивает их по компьютерам, метки, общедоступных или частных состояние или любому другому доступному критерию.  
  
 Если требуется статический снимок очередей в сети, а не динамическое подключение к ним, вызовите <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> или <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Каждый из этих двух методов возвращает массив <xref:System.Messaging.MessageQueue> объекты, которые представлены очереди на момент вызова метода.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода выполняется итерация по всем очередям сообщений в сети и проверяет путь для каждой очереди. Наконец он отображает количество общих очередей в сети.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Объект <see cref="T:System.Messaging.MessageQueueCriteria" />, содержащий критерии фильтрации доступных очередей сообщений.</param>
        <summary>Обеспечивает семантику курсора последовательного доступа для перечисления во всех общих очередях сети, удовлетворяющих указанным критериям.</summary>
        <returns>Объект <see cref="T:System.Messaging.MessageQueueEnumerator" />, обеспечивающий динамическое перечисление общих очередей сообщений сети, удовлетворяющих ограничениям, заданным параметром <paramref name="criteria" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> возвращен список всех общих очередях сети, который удовлетворяет условию, определенный в приложении. Можно указать критерии можно включить, например, очереди, время создания или изменения, имя компьютера, метки, категории или любое их сочетание.  
  
 Поскольку курсор связан с динамическим перечислением, перечисление отражаются все изменения, внесенные в очередь, находящихся за текущей позицией курсора. Изменение очередей, расположенных до текущей позиции курсора, не отражаются. Например перечислитель может автоматически получить доступ к очереди, добавленной за позицией курсора, но не вставляется перед этой позиции. Тем не менее, вы можете сбросить перечисления, тем самым Возврат курсора в начало списка, путем вызова <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> для <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Нет, не определен порядок очередей в сети. Перечислитель не упорядочивает их по компьютерам, метки, общедоступных или частных состояние или любому другому доступному критерию.  
  
 Статический снимок очередей в сети, а не динамическое подключение к ним, укажите критерии для <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> или вызвать <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Каждый из этих двух методов возвращает массив <xref:System.Messaging.MessageQueue> объекты, которые представлены очереди на момент вызова метода. Вызов <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, или <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> предоставляет те же результаты, что и вызов метода <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> с критериями фильтра свойств <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, и <xref:System.Messaging.MessageQueue.MachineName%2A>, соответственно.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода выполняется итерация по очереди сообщений и отображает путь к каждой очереди, который был создан в последний день, и который существует на компьютере «MyComputer».  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Компьютер, из которого извлекаются частные очереди.</param>
        <summary>Извлекает все частные очереди на указанном компьютере.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные частные очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> Извлекает статический снимок очередей на указанном компьютере.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода извлекает списка очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="machineName" /> — <see langword="null" /> или пустая строка ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Извлекает все общие очереди сети.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает все общие очереди сети.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные общие очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, если требуется полный список всех общих очередях сети. Если вы хотите ограничить список по определенным критериям, такие как <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, или время последнего изменения использовать другую перегрузку этого метода. (Кроме того, можно использовать <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, или <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Извлекает статический снимок очередей. Для взаимодействия с помощью динамического списка очередей, используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода извлекает списка очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Объект <see cref="T:System.Messaging.MessageQueueCriteria" />, содержащий критерии фильтрации очередей.</param>
        <summary>Извлекает все общие очереди сети, удовлетворяющие указанным критериям.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные общие очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы хотите отфильтровать все общие очереди сети метки, категории или имя компьютера, <xref:System.Messaging.MessageQueue> класс содержит конкретные методы, которые предоставляют функциональные возможности (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, и <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, соответственно). Используйте этот перегруженный метод, чтобы получить список всех общих очередях сети, которые соответствуют более чем одному из этих критериев (например, если вы хотите указать метку и категории). Также можно фильтровать по критерию сообщения не <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, и <xref:System.Messaging.MessageQueue.MachineName%2A>. Например использовании этой перегрузки для фильтрации по времени последнего изменения очереди. Просто создайте новый экземпляр класса <xref:System.Messaging.MessageQueueCriteria> , задайте соответствующие свойства в экземпляре и передайте экземпляр как `criteria` параметр.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Извлекает статический снимок очередей. Для взаимодействия с помощью динамического списка очередей, используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода извлекает списка очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">Класс <see cref="T:System.Guid" />, который группирует набор очередей для извлечения.</param>
        <summary>Извлекает все общие очереди сети, принадлежащие к указанной категории.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные общие очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет фильтровать общие очереди по категориям. <xref:System.Messaging.MessageQueue.Category%2A> Свойство предоставляет доступ к очереди сообщений типа свойство ID (который является чтение и запись) определенной очереди. Несмотря на то, что можно использовать <xref:System.Guid.NewGuid%2A> для создания значения категории, которое является уникальным для всех <xref:System.Guid> значения, нет необходимости. Значение категории должно отличаться только из других категорий, а не от всех других <xref:System.Guid> значения. Например, можно назначить {00000000-0000-0000-0000-000000000001} как <xref:System.Messaging.MessageQueue.Category%2A> для одного набора очередей и {00000000-0000-0000-0000-000000000002} как <xref:System.Messaging.MessageQueue.Category%2A> для другого набора.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> Извлекает статический снимок очередей. Для взаимодействия с помощью динамического списка очередей, используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Можно указать категорию как часть <xref:System.Messaging.MessageQueueCriteria> передачи в метод.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода извлекает списка очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Метка, которая группирует набор очередей для извлечения.</param>
        <summary>Извлекает все общие очереди сети с указанной меткой.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные общие очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для фильтрации общих очередей по метке.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> Извлекает статический снимок очередей. Для взаимодействия с помощью динамического списка очередей, используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Метки можно указать как часть <xref:System.Messaging.MessageQueueCriteria> передачи в метод.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода извлекает списка очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="label" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Имя компьютера, на котором располагается набор извлекаемых общих очередей.</param>
        <summary>Извлекает все общие очереди, находящиеся на указанном компьютере.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на общие очереди, находящиеся на компьютере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для фильтрации общих очередей по компьютерам.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> Извлекает статический снимок очередей. Для взаимодействия с помощью динамического списка очередей, используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Можно указать имя компьютера как часть <xref:System.Messaging.MessageQueueCriteria> передачи в метод.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода извлекает списка очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="machineName" /> имеет неверный синтаксис.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает контекст безопасности, который служба MSMQ связывает с текущим пользователем (удостоверением потока) на момент этого вызова.</summary>
        <returns>Объект <see cref="T:System.Messaging.SecurityContext" />, содержащий контекст безопасности.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает уникальный идентификатор очереди сообщений.</summary>
        <value>Свойство <see cref="P:System.Messaging.MessageQueue.Id" />, представляющее идентификатор сообщения, создаваемый приложением очереди сообщений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing присваивает <xref:System.Messaging.MessageQueue.Id%2A> свойства при создании очереди. Это свойство доступно только для общих очередей.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередь сообщений <xref:System.Messaging.MessageQueue.Id%2A> свойство.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что для очереди нет ограничений по размеру.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот элемент часто используется при задании <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> или <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Messaging.MessageQueue.InfiniteQueueSize> член.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что для методов считывания и получения сообщений не существует тайм-аута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> поддерживает два типа методов извлечения сообщений: синхронные и асинхронные. Синхронные методы, <xref:System.Messaging.MessageQueue.Peek%2A> и <xref:System.Messaging.MessageQueue.Receive%2A>, поток процесса ожидания указанный интервал времени для нового сообщения поступление в очередь. Если заданный интервал времени <xref:System.Messaging.MessageQueue.InfiniteTimeout>, поток процесса, пока заблокированных доступно новое сообщение. С другой стороны <xref:System.Messaging.MessageQueue.BeginPeek%2A> и <xref:System.Messaging.MessageQueue.BeginReceive%2A> (асинхронных методов), разрешить основные задачи приложения продолжают выполняться в отдельном потоке, до получения сообщения в очереди.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Messaging.MessageQueue.InfiniteTimeout> член.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает описание очереди.</summary>
        <value>Метка очереди сообщения. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Максимальная длина метки очереди сообщений — 124 символа.  
  
 <xref:System.Messaging.MessageQueue.Label%2A> Свойство не должно быть уникальным для всех очередей. Тем не менее если несколько очередей одного и того же <xref:System.Messaging.MessageQueue.Label%2A>, нельзя использовать <xref:System.Messaging.MessageQueue.Send%28System.Object%29> метод для передачи сообщения к каждому из них. Если вы используете синтаксис метки для <xref:System.Messaging.MessageQueue.Path%2A> свойство при отправке сообщения, будет создано исключение при <xref:System.Messaging.MessageQueue.Label%2A> не является уникальным.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередь сообщений <xref:System.Messaging.MessageQueue.Label%2A> свойство.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для метки задано недопустимое значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время последнего изменения свойств очереди.</summary>
        <value>Объект <see cref="T:System.DateTime" />, который указывает, когда свойства очереди были изменены в последний раз.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Время последнего изменения включает в себя при создании очереди, а также <xref:System.Messaging.MessageQueue> свойство, которое изменяет очередь Message Queuing, такие как <xref:System.Messaging.MessageQueue.BasePriority%2A>. Значение <xref:System.Messaging.MessageQueue.LastModifyTime%2A> свойство представляет системное время на локальном компьютере.  
  
 Необходимо вызвать <xref:System.Messaging.MessageQueue.Refresh%2A> перед получением <xref:System.Messaging.MessageQueue.LastModifyTime%2A> свойство; в противном случае время изменения, связанное с данным <xref:System.Messaging.MessageQueue> могут устареть.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередь сообщений <xref:System.Messaging.MessageQueue.LastModifyTime%2A> свойство.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя компьютера, на котором расположена очередь Message Queuing.</summary>
        <value>Имя компьютера, на котором расположена очередь. По умолчанию службой Message Queuing используется значение ".", т. е. локальный компьютер.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MachineName%2A> — Это встроенный компонент синтаксиса понятное имя очереди <xref:System.Messaging.MessageQueue.Path%2A>. Следующая таблица показывает синтаксис, который следует использовать для очереди заданного типа, когда нужно определить путь к очереди, используя его понятное имя.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общей очереди|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
|Очереди журнала|`MachineName`\\`QueueName`\\`Journal$`|  
|Очереди журнала компьютера|`MachineName`\\`Journal$`|  
|Очередь недоставленных сообщений компьютера|`MachineName`\\`Deadletter$`|  
|Транзакционная очередь недоставленных сообщений компьютера|`MachineName`\\`XactDeadletter$`|  
  
 Используйте «.» для локального компьютера, при указании <xref:System.Messaging.MessageQueue.MachineName%2A>. Только имя компьютера распознается для этого свойства, например, `Server0`. <xref:System.Messaging.MessageQueue.MachineName%2A> Свойство не поддерживает формат IP-адреса.  
  
 Если вы определяете <xref:System.Messaging.MessageQueue.Path%2A> на основе <xref:System.Messaging.MessageQueue.MachineName%2A>, приложение вызывает исключение при работе в автономном режиме, так как контроллер домена является обязательным для перевода пути. Таким образом, необходимо использовать <xref:System.Messaging.MessageQueue.FormatName%2A> для <xref:System.Messaging.MessageQueue.Path%2A> синтаксис при работе в автономном режиме.  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, И <xref:System.Messaging.MessageQueue.QueueName%2A> связанные свойства. Изменение <xref:System.Messaging.MessageQueue.MachineName%2A> свойству <xref:System.Messaging.MessageQueue.Path%2A> изменяемое свойство. Он формируется на основе нового <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A>. Изменение <xref:System.Messaging.MessageQueue.Path%2A> (например, чтобы использовать синтаксис имени формата) сбрасывает <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A> свойства для ссылки на новую очередь. Если <xref:System.Messaging.MessageQueue.QueueName%2A> свойство пусто, <xref:System.Messaging.MessageQueue.Path%2A> устанавливается в очередь журнала компьютера вами.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередь сообщений <xref:System.Messaging.MessageQueue.MachineName%2A> свойство.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <see cref="P:System.Messaging.MessageQueue.MachineName" /> — <see langword="null" />.        
-или-

Недопустимое имя компьютера. Причиной может быть неверный синтаксис.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает максимальный размер очереди журнала.</summary>
        <value>Максимальный размер очереди журнала в килобайтах. По умолчанию службой Message Queuing не устанавливаются ограничения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> предоставляет доступ к ограничению в хранилища очереди сообщений. Это значение, только если <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> является `true`. Задание этого свойства изменяет очередь Message Queuing. Таким образом, любой другой <xref:System.Messaging.MessageQueue> экземпляры будут затронуты данным изменением  
  
 Если хранение сообщений в журнале или в очередь недоставленных сообщений, необходимо периодически очищать очередь сообщений, которые больше не нужны. Сообщений в такой очереди учитываются квоты сообщений для компьютера, на котором расположена очередь. (Администратор устанавливает квота компьютера).  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередь сообщений <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> свойство.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для максимального размера очереди журнала установлено недопустимое значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает максимальный размер очереди.</summary>
        <value>Максимальный размер очереди в килобайтах. По умолчанию службой Message Queuing не устанавливаются ограничения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> Предоставляет доступ к очереди сообщений хранения ограничения на количество сообщений, которая отличается от квоты сообщений компьютера, который администратор определяет. Дополнительные сведения о квоты сообщений, см. в разделе <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Задание этого свойства изменяет очередь Message Queuing. Таким образом, любой другой <xref:System.Messaging.MessageQueue> экземпляры будут затронуты данным изменением  
  
 Если попытка превышают максимальный размер очереди или квоты сообщений компьютера, сообщения могут быть утеряны. При достижении квоты очереди Message Queuing уведомляет очереди администрирования, отправляющего приложения, чтобы указать, что очередь заполнена, возвращая сообщение отрицательного подтверждения. Служба очереди сообщений продолжит отправлять отрицательные подтверждения, пока общий размер сообщений в очереди не станет ниже ограничения.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередь сообщений <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> свойство.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Максимальный размер очереди содержит отрицательное значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает фильтр свойств для получения и считывания сообщений.</summary>
        <value>Объект <see cref="T:System.Messaging.MessagePropertyFilter" />, который очередь использует для фильтрации набора свойств, получаемого или считываемого ею для каждого сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот фильтр — это набор логических значений, ограничивающих свойства сообщения, <xref:System.Messaging.MessageQueue> получаемые или считываемые. Когда <xref:System.Messaging.MessageQueue> получаемые или считываемые сообщения из очереди сервера, он извлекает только те свойства, для которого <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> значение `true`.  
  
 Ниже представлены исходные значения свойств для <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> свойство. Эти параметры аналогичны вызова <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> на <xref:System.Messaging.MessagePropertyFilter>.  
  
|Свойство.|Значение по умолчанию|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 байт|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 байт|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 байт|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> для ограничения полученных свойств сообщения.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение фильтра — <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представлено в MSMQ 3.0. Получает или задает адрес многоадресной рассылки, связанный с данной очередью.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий допустимый групповой адрес (в виде, показанном ниже) или значение <see langword="null" />, которое указывает, что очередь не связана с групповым адресом.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> Свойство используется для сопоставления нетранзакционной очереди с адресом многоадресной рассылки, который может использоваться при отправке сообщений. Невозможно связать транзакционной очереди с адресом многоадресной рассылки. Если отправляющее приложение отправляет сообщения на адрес многоадресной рассылки, служба Message Queuing передает копию сообщения в каждую очередь, связанную с этим адресом.  
  
 Многоадресная IP-рассылка адреса должны быть в диапазоне класса D от 224.0.0.0 до 239.255.255.255, который соответствует установке первых четырех старших разрядов равными 1110. Однако только определенные диапазоны адресов в этом диапазоне будут зарезервированы и доступны для отправки сообщений многоадресной рассылки. Обновленный список зарезервированных адресов многоадресной рассылки, см. в разделе [номер центра IANA (Internet Assigned) адресов многоадресной рассылки](https://go.microsoft.com/fwlink/?linkid=3859) веб-страницы. Существуют ограничения на номер порта.  
  
 Если несколько исходные компьютеры отправляют сообщения многоадресной рассылки, и вы хотите определенной очереди для получения сообщений из только с одного компьютера, каждого исходного компьютера необходимо отправлять сообщения на разные комбинации IP-адрес и порт номер.  
  
 Чтобы отменить связь очереди с адресом многоадресной рассылки, задайте <xref:System.Messaging.MessageQueue.MulticastAddress%2A> строку нулевой длины. Не задавайте его `null`, так как это вызовет <xref:System.ArgumentNullException>.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает путь очереди. После задания свойства <see cref="P:System.Messaging.MessageQueue.Path" /> объект <see cref="T:System.Messaging.MessageQueue" /> будет указывать на новую очередь.</summary>
        <value>Очередь, на которую ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Значение по умолчанию зависит от того, какой используется конструктор <see cref="M:System.Messaging.MessageQueue.#ctor" />. Значение равно либо <see langword="null" />, либо задается параметром <paramref name="path" /> конструктора.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Синтаксис <xref:System.Messaging.MessageQueue.Path%2A> свойство зависит от типа очереди его точки to, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общей очереди|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
|Очереди журнала|`MachineName`\\`QueueName`\\`Journal$`|  
|Очереди журнала компьютера|`MachineName`\\`Journal$`|  
|Очередь недоставленных сообщений компьютера|`MachineName`\\`Deadletter$`|  
|Транзакционная очередь недоставленных сообщений компьютера|`MachineName`\\`XactDeadletter$`|  
  
 Используйте «.» для представления локального компьютера.  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, И <xref:System.Messaging.MessageQueue.QueueName%2A> связанные свойства. Изменение <xref:System.Messaging.MessageQueue.MachineName%2A> свойству <xref:System.Messaging.MessageQueue.Path%2A> изменяемое свойство. Он формируется на основе нового <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A>. Изменение <xref:System.Messaging.MessageQueue.Path%2A> (например, чтобы использовать синтаксис имени формата) сбрасывает <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A> свойства для ссылки на новую очередь.  
  
 Кроме того, можно использовать <xref:System.Messaging.MessageQueue.FormatName%2A> или <xref:System.Messaging.MessageQueue.Label%2A> для описания пути к очереди, как показано в следующей таблице.  
  
|Ссылка|Синтаксис|Пример|  
|---------------|------------|-------------|  
|Название формата|`FormatName:` [ *имя формата* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Метка|`Label:` [ *метка* ]|`Label:` TheLabel|  
  
 Если вы используете синтаксис метки для <xref:System.Messaging.MessageQueue.Path%2A> свойство при отправке сообщения, будет создано исключение при <xref:System.Messaging.MessageQueue.Label%2A> не является уникальным.  
  
 Чтобы работать в автономном режиме, необходимо использовать синтаксис имени формата, а не синтаксис понятное имя в первой таблице. В противном случае создается исключение, поскольку основного контроллера домена (на котором установлена Active Directory) не поддерживается для разрешения пути в имя формата.  
  
 После задания нового пути очередь сообщений будет закрыта и все дескрипторы.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
> [!NOTE]
>  В режиме рабочей группы можно использовать только частные очереди. Укажите путь, используя синтаксис частную очередь `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 В следующем примере кода создает новые <xref:System.Messaging.MessageQueue> объекты с различными типами синтаксис имени пути. В каждом случае он отправляет сообщение в очередь, чей путь, определенный в конструкторе.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый путь. Возможно из-за неправильного синтаксиса.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <summary>Возвращает копию первого сообщения в очереди, не удаляя его из очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает, не удаляя (считывает), первое сообщение в очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />. Метод <see cref="M:System.Messaging.MessageQueue.Peek" /> является синхронным, поэтому он блокирует текущий поток до тех пор, пока сообщение не станет доступным.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, представляющий первое сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для считывания очереди или ожидания поступления сообщения в очереди.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Метод считывает, но не удаляет из очереди первое сообщение. Таким образом, повторные вызовы <xref:System.Messaging.MessageQueue.Peek%2A> возвращать то же сообщение, в том случае, если сообщение с более высоким приоритетом не поступит в очередь. <xref:System.Messaging.MessageQueue.Receive%2A> Метод, с другой стороны, считывает и удаляет из очереди первое сообщение. Повторные вызовы <xref:System.Messaging.MessageQueue.Receive%2A>, поэтому возвращать различные сообщения.  
  
 Служба Message Queuing упорядочивает сообщения в очереди в соответствии с приоритетом и временем поступления. Новое сообщение помещается перед более старым, только в том случае, если он имеет более высокий приоритет.  
  
 Метод <xref:System.Messaging.MessageQueue.Peek%2A> используется, если текущий поток можно заблокировать на время, пока ожидается поступление сообщения в очередь. Так как эта перегрузка не указывает время ожидания, приложение может ожидать неопределенное время. Если работа приложения должна продолжаться без ожидания, используйте асинхронный метод <xref:System.Messaging.MessageQueue.BeginPeek%2A>. Кроме того, можно указать время ожидания для поступления сообщения в очереди с помощью перегрузки <xref:System.Messaging.MessageQueue.Peek%2A> , указывающий время ожидания.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующих примерах используется <xref:System.Messaging.MessageQueue.Peek%2A> метод в очередь.  
  
 В первом примере приложение ожидает, пока сообщение не станет доступным в очереди. Обратите внимание, что первый пример не осуществляет доступ к сообщение, поступающее; он просто приостанавливает обработку до получения сообщения. Если сообщение уже существует в очереди, то возвращается немедленно.  
  
 Во втором примере, сообщение, содержащее определяемые приложением `Order` класс отправляются в очередь и затем считывается из очереди.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, показывающий максимальное время ожидания появления первого сообщения в очереди.</param>
        <summary>Возвращает, не удаляя (считывает), первое сообщение в очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />. Метод <see cref="M:System.Messaging.MessageQueue.Peek" /> является синхронным, поэтому он блокирует текущий поток до тех пор, пока сообщение не станет доступным или пока не истечет заданный тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, представляющий первое сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для считывания очереди или ожидания в указанный период времени поступления сообщения в очереди. Метод возвращает немедленно, если сообщение уже существует в очереди.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Метод считывает, но не удаляет из очереди первое сообщение. Таким образом, повторные вызовы <xref:System.Messaging.MessageQueue.Peek%2A> возвращать то же сообщение, в том случае, если сообщение с более высоким приоритетом не поступит в очередь. <xref:System.Messaging.MessageQueue.Receive%2A> Метод, с другой стороны, считывает и удаляет из очереди первое сообщение. Повторные вызовы <xref:System.Messaging.MessageQueue.Receive%2A>, поэтому возвращать различные сообщения.  
  
 Служба Message Queuing упорядочивает сообщения в очереди в соответствии с приоритетом и временем поступления. Новое сообщение помещается перед более старым, только в том случае, если он имеет более высокий приоритет.  
  
 Метод <xref:System.Messaging.MessageQueue.Peek%2A> используется, если текущий поток можно заблокировать на время, пока ожидается поступление сообщения в очередь. Поток будет заблокирован в течение указанного периода времени, или не ограничено, если вы говорите о рассчитанном <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Если работа приложения должна продолжаться без ожидания, используйте асинхронный метод <xref:System.Messaging.MessageQueue.BeginPeek%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Messaging.MessageQueue.Peek%2A> метод с таймаут, равный нулю, чтобы проверить, пуста ли очередь.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, показывающий максимальное время ожидания появления первого сообщения в очереди.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="action">Одно из значений <see cref="T:System.Messaging.PeekAction" />. Указывает, следует ли считывать текущее сообщение в очереди или следующее сообщение.</param>
        <summary>Возвращает, не удаляя (считывает), текущее или следующее сообщение в очереди, используя заданный курсор. Метод <see cref="M:System.Messaging.MessageQueue.Peek" /> является синхронным, поэтому он блокирует текущий поток до тех пор, пока сообщение не станет доступным или пока не истечет заданный тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, представляющий сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для считывания очереди или ожидания в указанный период времени поступления сообщения в очереди. Метод возвращает немедленно, если сообщение уже существует в очереди.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Метод считывает, но не удаляет сообщение из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод, с другой стороны, считывает и удаляет сообщение из очереди.  
  
 Метод <xref:System.Messaging.MessageQueue.Peek%2A> используется, если текущий поток можно заблокировать на время, пока ожидается поступление сообщения в очередь. Поток блокируется вплоть до указанного периода времени, или не ограничено, если вы говорите о рассчитанном <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Если работа приложения должна продолжаться без ожидания, используйте асинхронный метод <xref:System.Messaging.MessageQueue.BeginPeek%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Для параметра <paramref name="action" /> было задано значение, отличное от <see langword="PeekAction.Current" /> или <see langword="PeekAction.Next" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо. Возможно, значение параметра <paramref name="timeout" /> меньше, чем <see cref="F:System.TimeSpan.Zero" />, или больше, чем <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Считывает сообщение, которое соответствует заданному идентификатору корреляции.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> считываемого сообщения.</param>
        <summary>Считывает сообщение, которое соответствует заданному идентификатору корреляции, и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором корреляции.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод ищет в очередь, ссылается <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Если сообщение не найдено, соответствующий `correlationID` параметра, возникает исключение.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь, чтобы связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют просматривать сообщения из очереди. <xref:System.Messaging.MessageQueue.Peek%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод используется для получения сообщения, указав свой уникальный идентификатор.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода отправляет и получает сообщение, содержащее заказ в и из очереди. Он специально запрашивает положительного подтверждения в случае, когда исходное сообщение достигает или извлечено из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> считываемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Считывает сообщение, которое соответствует заданному идентификатору корреляции и ожидает, пока в очереди не появится сообщение с указанным идентификатором корреляции или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод ищет в очередь, ссылается <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Если сообщение не найдено, соответствующий `correlationID` параметра и новое сообщение прибывает в очереди в течение периода, указанного `timeout` параметра, возникает исключение.  
  
 `timeout` Параметр задает общее время выполнения для этого метода. Вместо этого он задает время ожидания нового сообщения поступление в очередь. Каждый раз при поступлении нового сообщения, этот метод проверяет <xref:System.Messaging.Message.CorrelationId%2A> нового сообщения, соответствует ли `correlationId` параметра. В противном случае этот метод запускает ожидания через и ожидает прихода нового сообщения. Таким образом, если новые сообщения продолжают поступать до истечения времени ожидания, существует возможность продолжать выполняться неопределенно долго, пока не истечет период ожидания без либо новых сообщений или до получения сообщения, этот метод <xref:System.Messaging.Message.CorrelationId%2A> соответствует `correlationId` параметра.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь, чтобы связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют просматривать сообщения из очереди. <xref:System.Messaging.MessageQueue.Peek%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод используется для получения сообщения, указав свой уникальный идентификатор.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Сообщение с заданным параметром <paramref name="correlationId" /> не существует в очереди и не поступило до истечения тайм-аута.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщений до истечения тайм-аута не поступало.  
  
 -или-  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает копию сообщения с указанным идентификатором сообщения, не удаляя это сообщение из очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> считываемого сообщения.</param>
        <summary>Считывает сообщение, идентификатор которого соответствует параметру <paramref name="id" />.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> для чтения, не удаляя его из очереди, сообщение со свойством с известным идентификатором сообщения. Идентификатор сообщения является уникальным на предприятии очереди сообщений, поэтому будет существовать не более одного сообщения в очереди, которое соответствует заданной `id` параметра. Эта перегрузка создает исключение, если в настоящий момент очереди нет сообщения.  
  
 Два дополнительных метода позволяют просматривать сообщения в очереди: <xref:System.Messaging.MessageQueue.Peek%2A> и <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. <xref:System.Messaging.MessageQueue.Peek%2A> Метод возвращает первое сообщение в очереди; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> возвращает подтверждение, отчета или сообщение ответа, генерируемые приложением, которое был создан в результате сообщение, отправленное в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Нет сообщения с указанным параметром <paramref name="id" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> считываемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Считывает сообщение, идентификатор которого соответствует параметру <paramref name="id" />. Ожидает, пока сообщение не появится в очереди, или не возникнет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> для чтения, не удаляя его из очереди, сообщение со свойством с известным идентификатором сообщения. Идентификатор сообщения является уникальным на предприятии очереди сообщений, поэтому будет существовать не более одного сообщения в очереди, которое соответствует заданной `id` параметра. Эта перегрузка создает исключение, если в настоящий момент очереди нет сообщения, а новое сообщение не поступило до истечения времени ожидания.  
  
 `timeout` Параметр задает общее время выполнения для этого метода. Вместо этого он задает время ожидания нового сообщения поступление в очередь. Каждый раз при поступлении нового сообщения, этот метод проверяет <xref:System.Messaging.Message.Id%2A> нового сообщения, соответствует ли `id` параметра. В противном случае этот метод запускает ожидания через и ожидает прихода нового сообщения. Таким образом, если новые сообщения продолжают поступать до истечения времени ожидания, существует возможность продолжать выполняться неопределенно долго, пока не истечет период ожидания без либо новых сообщений или до получения сообщения, этот метод <xref:System.Messaging.Message.Id%2A> соответствует `id` параметра.  
  
 Два дополнительных метода позволяют просматривать сообщения в очереди: <xref:System.Messaging.MessageQueue.Peek%2A> и <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. <xref:System.Messaging.MessageQueue.Peek%2A> Метод возвращает первое сообщение в очереди; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> возвращает подтверждение, отчета или сообщение ответа, генерируемые приложением, которое был создан в результате сообщение, отправленное в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Сообщение с заданным параметром <paramref name="id" /> не существует в очереди и не поступило до истечения периода времени, установленного параметром <paramref name="timeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Представлено в MSMQ 3.0. Считывает конкретное сообщение из очереди. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> считываемого сообщения.</param>
        <summary>Представлено в MSMQ 3.0. Считывает сообщение, соответствующее заданному идентификатору просмотра, из нетранзакционной очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.LookupId" /> которого соответствует переданному в объект параметру <paramref name="lookupId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно используйте для чтения сообщения с известным кодом просмотра, не удаляя его из очереди. Этот метод немедленно создает исключение, если в очереди нет сообщения.  
  
 <xref:System.Messaging.Message.LookupId%2A> Свойство сообщения является уникальным для очереди где находится сообщение, поэтому будет существовать не более одного сообщения в очереди, которое соответствует заданной `lookupId` параметра.  
  
 Для чтения сообщения с указанным кодом просмотра и удалите его из очереди, используйте <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> метод.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Одно из значений <see cref="T:System.Messaging.MessageLookupAction" />, задающее порядок чтения сообщения в очереди. Укажите одно из следующих значений: 
 <see langword="MessageLookupAction.Current" />: считывает сообщение, заданное параметром <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.Next" />: считывает сообщение, следующее за сообщением, заданным параметром <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.Previous" />: считывает сообщение, предшествующее сообщению, заданному параметром <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.First" />: считывает первое сообщение в очереди. Параметр <paramref name="lookupId" /> должен быть установлен равным 0.  
  
 <see langword="MessageLookupAction.Last" />: считывает последнее сообщение в очереди. Параметр <paramref name="lookupId" /> должен быть установлен равным 0.</param>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> считываемого сообщения или значение 0. Значение, равное 0, используется при доступе к первому или последнему сообщению в очереди.</param>
        <summary>Представлено в MSMQ 3.0. Считывает конкретное сообщение из очереди. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, задаваемый передаваемыми параметрами <paramref name="action" /> и <paramref name="lookupId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно используйте для чтения сообщения с известным кодом просмотра, не удаляя его из очереди. Этот метод немедленно создает исключение, если в очереди нет сообщения.  
  
 <xref:System.Messaging.Message.LookupId%2A> Свойство сообщения является уникальным для очереди где находится сообщение, поэтому будет существовать не более одного сообщения в очереди, которое соответствует заданной `lookupId` параметра.  
  
 Чтобы прочитать сообщение с указанным идентификатором и удалите его из очереди, используйте <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> метод.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="action" /> не является одним из членов <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда сообщение читается без удаления из очереди. Это результат асинхронной операции — <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> используется при асинхронной обработке, чтобы вызвать <xref:System.Messaging.MessageQueue.PeekCompleted> событие, когда сообщение в очереди.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> используется для завершения операции, инициированной вызовом <xref:System.Messaging.MessageQueue.BeginPeek%2A> и просмотра сообщения при <xref:System.Messaging.MessageQueue.PeekCompleted> события.  
  
 При создании делегата <xref:System.Messaging.PeekCompletedEventHandler> необходимо указать метод, обрабатывающий событие. Чтобы связать событие с обработчиком событий, нужно добавить в событие экземпляр делегата. Обработчик событий вызывается всякий раз, когда происходит событие, если делегат не удален. Дополнительные сведения о делегатов обработчиков событий, см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создается обработчик событий с именем `MyPeekCompleted`, присоединяется к <xref:System.Messaging.MessageQueue.PeekCompleted> делегата обработчика событий и вызовов <xref:System.Messaging.MessageQueue.BeginPeek%2A> инициировать асинхронную операцию в очереди, расположенный по пути «. \myQueue». Когда <xref:System.Messaging.MessageQueue.PeekCompleted> события, в примере считывает сообщение и выводит его текст на экран. Затем в примере вызывается <xref:System.Messaging.MessageQueue.BeginPeek%2A> еще раз, чтобы инициировать асинхронную операцию просмотра  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все сообщения, содержащиеся в очереди.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Очистка очереди приводит к очереди сообщений задать флаг изменения очереди, который влияет на <xref:System.Messaging.MessageQueue.LastModifyTime%2A> свойство. Сообщения, удаленные из очереди будут утеряны; они отправляются в очередь недоставленных сообщений или в очередь журнала.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает понятное имя, определяющее очередь.</summary>
        <value>Имя, определяющее очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />. Значение <see langword="null" /> недопустимо.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете объединить <xref:System.Messaging.MessageQueue.QueueName%2A> с <xref:System.Messaging.MessageQueue.MachineName%2A> создать понятное <xref:System.Messaging.MessageQueue.Path%2A> имя для очереди. Синтаксис понятное имя разновидность <xref:System.Messaging.MessageQueue.Path%2A> свойство зависит от типа очереди, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общей очереди|`MachineName`\\`QueueName`|  
|Частной очереди|`MachineName`\\`Private$`\\`QueueName`|  
|Очереди журнала|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Используйте «.» для представления локального компьютера.  
  
 Изменение <xref:System.Messaging.MessageQueue.QueueName%2A> свойство влияет на <xref:System.Messaging.MessageQueue.Path%2A> свойство. Если задать <xref:System.Messaging.MessageQueue.QueueName%2A> без параметра <xref:System.Messaging.MessageQueue.MachineName%2A> свойство, <xref:System.Messaging.MessageQueue.Path%2A> свойство становится.\\ `QueueName`. В противном случае <xref:System.Messaging.MessageQueue.Path%2A> становится `MachineName` \\ `QueueName`.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередь сообщений <xref:System.Messaging.MessageQueue.QueueName%2A> свойство.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение имени очереди — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает собственный дескриптор, предназначенный для чтения сообщений из очереди сообщений.</summary>
        <value>Дескриптор собственного объекта очереди, который используется для считывания и получения сообщений из очереди.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A> Предоставляет собственный дескриптор Windows для объекта очереди сообщений, который используется для просмотра и получения сообщений из очереди. Если вы измените путь к очереди, маркер закрыть и открыть с новым значением.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <summary>Получает первое сообщение в очереди, удаляя его из очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает первое доступное в очереди сообщение, на которое ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Этот вызов является синхронным и он блокирует текущий поток выполнения, пока сообщение не станет доступным.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщения из очереди или подождать, пока в очереди есть сообщения.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет синхронное чтение сообщения, тем самым убирая его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращает сообщения, которые расположены в очереди, или новые сообщения с более высоким приоритетом.  
  
 Чтобы прочитать первое сообщение в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. <xref:System.Messaging.MessageQueue.Peek%2A> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь.  
  
 Вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поскольку данная перегруженная версия <xref:System.Messaging.MessageQueue.Receive%2A> метод задает неограниченное время ожидания, приложение может ожидать неопределенное время. Если обработка приложения должна продолжаться без ожидания сообщения, рассмотрите возможность использования асинхронного метода, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода получает сообщение из очереди и выводит сведения о сообщении на экран.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает первое доступное в транзакционной очереди сообщение, на которое ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Этот вызов является синхронным и он блокирует текущий поток выполнения, пока сообщение не станет доступным.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для получения сообщения из транзакционной очереди с помощью контекста внутренней транзакции, определенного `transaction` параметр или подождите, пока в очереди есть сообщения.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет синхронное чтение сообщения, тем самым убирая его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращает сообщения, которые расположены в очереди.  
  
 Так как этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращается в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 Чтобы прочитать первое сообщение в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. <xref:System.Messaging.MessageQueue.Peek%2A> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.Peek%2A>. Так как <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет сообщения из очереди, отсутствует откат путем вызова <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поскольку данная перегруженная версия <xref:System.Messaging.MessageQueue.Receive%2A> метод задает неограниченное время ожидания, приложение может ожидать неопределенное время. Если обработка приложения должна продолжаться без ожидания сообщения, рассмотрите возможность использования асинхронного метода, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода подключается к транзакционной очереди на локальном компьютере и отправляет сообщение в очередь. Затем он получает сообщение, содержащее заказ. При обнаружении нетранзакционную очередь, вызовет исключение и производится откат транзакции.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.  
  
 -или-  
  
 Очередь является нетранзакционной.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает первое доступное в очереди сообщение, на которое ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Этот вызов является синхронным и он блокирует текущий поток выполнения, пока сообщение не станет доступным.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для получения сообщения из очереди с помощью контекста транзакции, определенного `transactionType` параметр или подождите, пока в очереди есть сообщения.  
  
 Укажите `Automatic` для `transactionType` параметра, если уже имеется контекст внешней транзакции, присоединенный к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получать сообщения в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получить сообщение из транзакционной очереди вне контекста транзакции.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет синхронное чтение сообщения, тем самым убирая его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращает сообщения, которые расположены в очереди.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращаться в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 Чтобы прочитать первое сообщение в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. <xref:System.Messaging.MessageQueue.Peek%2A> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.Peek%2A>. Так как <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет сообщения из очереди, отсутствует откат путем вызова <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поскольку данная перегруженная версия <xref:System.Messaging.MessageQueue.Receive%2A> метод задает неограниченное время ожидания, приложение может ожидать неопределенное время. Если обработка приложения должна продолжаться без ожидания сообщения, рассмотрите возможность использования асинхронного метода, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Получает первое сообщение, доступное в очереди, на которую ссылается объект <see cref="T:System.Messaging.MessageQueue" />, и ожидает пока в очереди не появится сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщений и их возврата в течение указанного срока, если в очереди нет сообщений.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет синхронное чтение сообщения, удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращает сообщения, которые расположены в очереди, или новые сообщения с более высоким приоритетом.  
  
 Чтобы прочитать первое сообщение в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. <xref:System.Messaging.MessageQueue.Peek%2A> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь.  
  
 Вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поток будет заблокирован на указанный период времени, или не ограничено, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра. Если обработка приложения должна продолжаться без ожидания сообщение, рассмотрите возможность использования асинхронного метода, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода получает сообщение из очереди и выводит сведения о сообщении на экран. В примере приостанавливается выполнение до пяти секунд при ожидании поступления сообщения в очереди.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 -или-  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <summary>Получает текущее сообщение в очереди, используя заданный курсор. Если доступных сообщений нет, этот метод ожидает, пока не станет доступным сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 -или-  
  
 При обращении к методу службы очереди сообщений возникла ошибка.  
  
 Используйте эту перегрузку для получения сообщений и их возврата в течение указанного срока, если в очереди нет сообщений.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает первое сообщение, доступное в транзакционной очереди, на которую ссылается объект <see cref="T:System.Messaging.MessageQueue" />, и ожидает, пока в очереди не появится сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для получения сообщения из транзакционной очереди с помощью контекста внутренней транзакции, определенного `transaction` и возврата в определенный период времени, если нет сообщений в очереди.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет синхронное чтение сообщения, тем самым убирая его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращает сообщения, которые расположены в очереди.  
  
 Так как этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращается в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 Чтобы прочитать первое сообщение в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. <xref:System.Messaging.MessageQueue.Peek%2A> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.Peek%2A>. Так как <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет сообщения из очереди, отсутствует откат путем вызова <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поток будет заблокирован на указанный период времени, или не ограничено, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра. Если обработка приложения должна продолжаться без ожидания сообщение, рассмотрите возможность использования асинхронного метода, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода показано использование этого метода.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 -или-  
  
 Очередь является нетранзакционной.  
  
 -или-  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает первое доступное в очереди сообщение, на которое ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Данный вызов является синхронным, и он ожидает, пока в очереди не появится сообщение, или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для получения сообщения из очереди с помощью контекста транзакции, определенного `transactionType` и возврата в указанный период времени, если нет сообщений в очереди.  
  
 Укажите `Automatic` для `transactionType` параметра, если уже имеется контекст внешней транзакции, присоединенный к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получать сообщения в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получить сообщение из транзакционной очереди вне контекста транзакции.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет синхронное чтение сообщения, тем самым убирая его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращает сообщения, которые расположены в очереди.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращаться в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 Чтобы прочитать первое сообщение в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. <xref:System.Messaging.MessageQueue.Peek%2A> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.Peek%2A>. Так как <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет сообщения из очереди, отсутствует откат путем вызова <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поток будет заблокирован на указанный период времени, или не ограничено, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра. Если обработка приложения должна продолжаться без ожидания сообщение, рассмотрите возможность использования асинхронного метода, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода показано использование этого метода.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 -или-  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает текущее сообщение в очереди, используя заданный курсор. Если доступных сообщений нет, этот метод ожидает, пока не станет доступным сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для получения сообщения из транзакционной очереди с помощью контекста внутренней транзакции, определенного `transaction` и возврата в определенный период времени, если нет сообщений в очереди.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет синхронное чтение сообщения, тем самым убирая его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращать сообщения, которые расположены в очереди.  
  
 Так как этот метод вызывается в транзакционной очереди, полученное сообщение возвращается в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 Чтобы прочитать сообщение в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.Peek%2A>. Так как <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет сообщения из очереди, нет ничего для отката путем вызова <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поток блокируется за указанный период времени, или не ограничено, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра. Если обработка приложения должна продолжаться без ожидания сообщение, рассмотрите возможность использования асинхронного метода, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.  
  
-или- 
Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо. Возможно, значение параметра <paramref name="timeout" /> меньше, чем <see cref="F:System.TimeSpan.Zero" />, или больше, чем <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 -или-  
  
 Очередь является нетранзакционной.  
  
 -или-  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает текущее сообщение в очереди, используя заданный курсор. Если доступных сообщений нет, этот метод ожидает, пока не станет доступным сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для получения сообщения из очереди с помощью контекста транзакции, определенного `transactionType` и возврата в указанный период времени, если нет сообщений в очереди.  
  
 Укажите `Automatic` для `transactionType` параметра, если уже имеется контекст внешней транзакции, присоединенный к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получать сообщения в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получить сообщение из транзакционной очереди вне контекста транзакции.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Метод позволяет синхронное чтение сообщения, тем самым убирая его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращать сообщения, которые расположены в очереди.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение возвращается в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 Чтобы прочитать сообщение в очереди, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.Peek%2A> метод. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.Peek%2A>. Так как <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет сообщения из очереди, нет ничего для отката путем вызова <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Вызов <xref:System.Messaging.MessageQueue.Receive%2A> Если текущий поток можно заблокировать, пока ожидается поступление в очередь сообщения. Поток блокируется за указанный период времени, или не ограничено, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра. Если обработка приложения должна продолжаться без ожидания сообщение, рассмотрите возможность использования асинхронного метода, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо. Возможно, значение параметра <paramref name="timeout" /> меньше, чем <see cref="F:System.TimeSpan.Zero" />, или больше, чем <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 -или-  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции (из нетранзакционной очереди), и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором корреляции.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод ищет в нетранзакционную очередь, ссылается <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Если сообщение не найдено, соответствующий `correlationID` параметра, возникает исключение. В противном случае сообщение удаляется из очереди и возвращаются в приложение.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь, чтобы связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> метод получает сообщение, указав свой уникальный идентификатор.  
  
 Чтобы прочитать сообщение с указанным идентификатором корреляции, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода отправляет и получает сообщение, содержащее заказ в и из очереди. Он специально запрашивает положительного подтверждения в случае, когда исходное сообщение достигает или извлечено из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции (из транзакционной очереди), и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором корреляции.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод ищет в транзакционную очередь, ссылается <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Если сообщение не найдено, соответствующий `correlationID` параметра, возникает исключение. В противном случае сообщение удаляется из очереди и возвращается в приложение с помощью контекста внутренней транзакции, определенного `transaction` параметра.  
  
 Так как этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращается в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь, чтобы связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> метод используется для получения сообщения, указав свой уникальный идентификатор.  
  
 Чтобы прочитать сообщение с указанным идентификатором корреляции, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Так как <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> не удаляет сообщения из очереди, отсутствует необходимость отменять обратно в том случае, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.  
  
-или- 
Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Очередь является нетранзакционной.  
  
 -или-  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции, и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором корреляции.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод ищет в очередь, ссылается <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Если сообщение не найдено, соответствующий `correlationID` параметра, возникает исключение. В противном случае сообщение удаляется из очереди и возвращается в приложение с помощью контекста транзакции, определенного `transactionType` параметра.  
  
 Укажите `Automatic` для `transactionType` параметра, если уже имеется контекст внешней транзакции, присоединенный к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получать сообщения в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получить сообщение из транзакционной очереди вне контекста транзакции.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращаться в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь, чтобы связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> метод используется для получения сообщения, указав свой уникальный идентификатор.  
  
 Чтобы прочитать сообщение с указанным идентификатором корреляции, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Так как <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> не удаляет сообщения из очереди, отсутствует необходимость отменять обратно в том случае, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции (из нетранзакционной очереди), и ожидает, пока в очереди не появится сообщение с указанным идентификатором корреляции или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод ищет в нетранзакционную очередь, ссылается <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Этот метод возвращает немедленно, если сообщение с идентификатором корреляции, указанным `correlationId` параметр находится в очереди. В противном случае метод ожидает в течение заданного периода времени прихода нового сообщения. Если новое сообщение не поступило до истечения времени ожидания, создается исключение.  
  
 `timeout` Параметр задает общее время выполнения для этого метода. Вместо этого он задает время ожидания нового сообщения поступление в очередь. Каждый раз при поступлении нового сообщения, этот метод проверяет <xref:System.Messaging.Message.CorrelationId%2A> нового сообщения, соответствует ли `correlationId` параметра. В противном случае этот метод запускает ожидания через и ожидает прихода нового сообщения. Таким образом, если новые сообщения продолжают поступать до истечения времени ожидания, существует возможность продолжать выполняться неопределенно долго, пока не истечет период ожидания без либо новых сообщений или до получения сообщения, этот метод <xref:System.Messaging.Message.CorrelationId%2A> соответствует `correlationId` параметра.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь, чтобы связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> метод используется для получения сообщения, указав свой уникальный идентификатор.  
  
 Чтобы прочитать сообщение с указанным идентификатором корреляции, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с заданным параметром <paramref name="correlationId" /> не существует в очереди и не поступило до истечения тайм-аута.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции (из транзакционной очереди), и ожидает, пока в очереди не появится сообщение с указанным идентификатором корреляции или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод ищет в транзакционную очередь, ссылается <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Этот метод возвращает немедленно, если сообщение с идентификатором корреляции, указанным `correlationId` параметр находится в очереди, используя внутреннюю транзакцию контексте, определенном `transaction` параметра. В противном случае метод ожидает в течение заданного периода времени прихода нового сообщения. Если новое сообщение не поступило до истечения времени ожидания, создается исключение.  
  
 `timeout` Параметр задает общее время выполнения для этого метода. Вместо этого он задает время ожидания нового сообщения поступление в очередь. Каждый раз при поступлении нового сообщения, этот метод проверяет <xref:System.Messaging.Message.CorrelationId%2A> нового сообщения, соответствует ли `correlationId` параметра. В противном случае этот метод запускает ожидания через и ожидает прихода нового сообщения. Таким образом, если новые сообщения продолжают поступать до истечения времени ожидания, существует возможность продолжать выполняться неопределенно долго, пока не истечет период ожидания без либо новых сообщений или до получения сообщения, этот метод <xref:System.Messaging.Message.CorrelationId%2A> соответствует `correlationId` параметра.  
  
 Так как этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращается в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь, чтобы связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> метод используется для получения сообщения, указав свой уникальный идентификатор.  
  
 Чтобы прочитать сообщение с указанным идентификатором корреляции, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Так как <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> не удаляет сообщения из очереди, отсутствует необходимость отменять обратно в том случае, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.  
  
-или- 
Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с заданным параметром <paramref name="correlationId" /> не существует в очереди и не поступило до истечения тайм-аута.  
  
-или- 
Очередь является нетранзакционной.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции и ожидает, пока в очереди не появится сообщение с указанным идентификатором корреляции или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод ищет в очередь, ссылается <xref:System.Messaging.MessageQueue> сообщения которого <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному `correlationId` параметра. Этот метод возвращает немедленно, если сообщение с идентификатором корреляции, указанным `correlationId` параметр находится в очереди, используя контекст транзакции, определяемый `transactionType` параметра. В противном случае метод ожидает в течение заданного периода времени прихода нового сообщения. Если новое сообщение не поступило до истечения времени ожидания, создается исключение.  
  
 `timeout` Параметр задает общее время выполнения для этого метода. Вместо этого он задает время ожидания нового сообщения поступление в очередь. Каждый раз при поступлении нового сообщения, этот метод проверяет <xref:System.Messaging.Message.CorrelationId%2A> нового сообщения, соответствует ли `correlationId` параметра. В противном случае этот метод запускает ожидания через и ожидает прихода нового сообщения. Таким образом, если новые сообщения продолжают поступать до истечения времени ожидания, существует возможность продолжать выполняться неопределенно долго, пока не истечет период ожидания без либо новых сообщений или до получения сообщения, этот метод <xref:System.Messaging.Message.CorrelationId%2A> соответствует `correlationId` параметра. Укажите `Automatic` для `transactionType` параметра, если уже имеется контекст внешней транзакции, присоединенный к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получать сообщения в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получить сообщение из транзакционной очереди вне контекста транзакции.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращаться в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Свойство используется для привязки сообщения, отправленного в очередь, чтобы связанные сообщения ответа, отчет или подтверждение.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> метод используется для получения сообщения, указав свой уникальный идентификатор.  
  
 Чтобы прочитать сообщение с указанным идентификатором корреляции, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Так как <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> не удаляет сообщения из очереди, отсутствует необходимость отменять обратно в том случае, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с заданным параметром <paramref name="correlationId" /> не существует в очереди и не поступило до истечения тайм-аута.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает сообщение, которое соответствует заданному идентификатору, удаляя его из очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <summary>Получает из нетранзакционной очереди сообщение, которое соответствует заданному идентификатору, и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удаления его из очереди. Этот метод немедленно создает исключение, если в очереди нет сообщения.  
  
 <xref:System.Messaging.Message.Id%2A> Свойство сообщения является уникальным на предприятии очереди сообщений, поэтому будет существовать не более одного сообщения в очереди, которое соответствует заданной `id` параметра.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> метод используется для извлечения подтверждения, отчета или сообщение ответа, генерируемые приложением, которое был создан в результате сообщение, отправленное в очередь.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="id" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору (из транзакционной очереди), и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удаляет его из очереди, используя внутреннюю транзакцию контексте, определенном `transaction` параметра. Этот метод создает исключение сразу в очереди нет сообщения  
  
 <xref:System.Messaging.Message.Id%2A> Свойство сообщения является уникальным на предприятии очереди сообщений, поэтому будет существовать не более одного сообщения в очереди, которое соответствует заданной `id` параметра.  
  
 Так как этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращается в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> метод используется для извлечения подтверждения, отчета или сообщение ответа, генерируемые приложением, которое был создан в результате сообщение, отправленное в очередь.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Так как <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> не удаляет сообщения из очереди, отсутствует необходимость отменять обратно в том случае, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.  
  
-или- 
Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="id" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Очередь является нетранзакционной.  
  
 -или-  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору, и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удаления его из очереди. Этот метод немедленно создает исключение, если в очереди нет сообщения. В противном случае сообщение удаляется из очереди и возвращается в приложение с помощью контекста транзакции, определенного `transactionType` параметра.  
  
 Укажите `Automatic` для `transactionType` параметра, если уже имеется контекст внешней транзакции, присоединенный к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получать сообщения в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получить сообщение из транзакционной очереди вне контекста транзакции.  
  
 <xref:System.Messaging.Message.Id%2A> Свойство сообщения является уникальным на предприятии очереди сообщений, поэтому будет существовать не более одного сообщения в очереди, которое соответствует заданной `id` параметра. Если сообщение с указанным идентификатором находится в очереди, не связанную с данным <xref:System.Messaging.MessageQueue> экземпляра, сообщение не будет найден.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращаться в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> метод используется для извлечения подтверждения, отчета или сообщение ответа, генерируемые приложением, которое был создан в результате сообщение, отправленное в очередь.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Так как <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> не удаляет сообщения из очереди, отсутствует необходимость отменять обратно в том случае, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="id" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору (из нетранзакционной очереди), и ожидает, пока в очереди не появится сообщение с указанным идентификатором, или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удаления его из очереди. Этот метод возвращает немедленно, если сообщение с идентификатором, указанным `id` параметр находится в очереди. В противном случае метод ожидает в течение заданного периода времени прихода нового сообщения. Если новое сообщение не поступило до истечения времени ожидания, создается исключение.  
  
 `timeout` Параметр задает общее время выполнения для этого метода. Вместо этого он задает время ожидания нового сообщения поступление в очередь. Каждый раз при поступлении нового сообщения, этот метод проверяет <xref:System.Messaging.Message.Id%2A> нового сообщения, соответствует ли `id` параметра. В противном случае этот метод запускает ожидания через и ожидает прихода нового сообщения. Таким образом, если новые сообщения продолжают поступать до истечения времени ожидания, существует возможность продолжать выполняться неопределенно долго, пока не истечет период ожидания без либо новых сообщений или до получения сообщения, этот метод <xref:System.Messaging.Message.Id%2A> соответствует `id` параметра.  
  
 <xref:System.Messaging.Message.Id%2A> Свойство сообщения является уникальным на предприятии очереди сообщений, поэтому будет существовать не более одного сообщения в очереди, которое соответствует заданной `id` параметра.  
  
 Используйте эту перегрузку <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> при это допустимо для текущего потока блокируются до тех пор, пока новый сообщения продолжают поступать в очереди до истечения времени ожидания, заданные `timeout` параметра. Поток будет заблокирован для по крайней мере заданного периода времени, или не ограничено, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра, или если новые сообщения продолжают поступать в очереди в течение периода времени ожидания, заданного по `timeout` параметр.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> метод используется для извлечения подтверждения, отчета или сообщение ответа, генерируемые приложением, которое был создан в результате сообщение, отправленное в очередь.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с указанным значением параметра <paramref name="id" /> до истечения тайм-аута в очередь не поступало.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору (из транзакционной очереди), и ожидает, пока в очереди не появится сообщение с указанным идентификатором, или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удаляет его из очереди, используя внутреннюю транзакцию контексте, определенном `transaction` параметра. Этот метод возвращает немедленно, если сообщение с идентификатором, указанным `id` параметр находится в очереди. В противном случае метод ожидает в течение заданного периода времени прихода нового сообщения. Если новое сообщение не поступило до истечения времени ожидания, создается исключение.  
  
 `timeout` Параметр задает общее время выполнения для этого метода. Вместо этого он задает время ожидания нового сообщения поступление в очередь. Каждый раз при поступлении нового сообщения, этот метод проверяет <xref:System.Messaging.Message.Id%2A> нового сообщения, соответствует ли `id` параметра. В противном случае этот метод запускает ожидания через и ожидает прихода нового сообщения. Таким образом, если новые сообщения продолжают поступать до истечения времени ожидания, существует возможность продолжать выполняться неопределенно долго, пока не истечет период ожидания без либо новых сообщений или до получения сообщения, этот метод <xref:System.Messaging.Message.Id%2A> соответствует `id` параметра.  
  
 <xref:System.Messaging.Message.Id%2A> Свойство сообщения является уникальным на предприятии очереди сообщений, поэтому будет существовать не более одного сообщения в очереди, которое соответствует заданной `id` параметра.  
  
 Используйте эту перегрузку <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> при это допустимо для текущего потока блокируются до тех пор, пока новый сообщения продолжают поступать в очереди до истечения времени ожидания, заданные `timeout` параметра. Поток будет заблокирован для по крайней мере заданного периода времени, или не ограничено, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра, или если новые сообщения продолжают поступать в очереди в течение указанного периода времени ожидания `timeout` параметр.  
  
 Так как этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращается в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> метод используется для извлечения подтверждения, отчета или сообщение ответа, генерируемые приложением, которое был создан в результате сообщение, отправленное в очередь.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается одно и то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Так как <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> не удаляет сообщения из очереди, отсутствует необходимость отменять обратно в том случае, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.  
  
-или- 
Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с указанным значением параметра <paramref name="id" /> до истечения тайм-аута в очередь не поступало.  
  
-или- 
Очередь является нетранзакционной.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору, и ожидает, пока в очереди не появится сообщение с указанным идентификатором, или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удаления его из очереди. Этот метод возвращает немедленно, если сообщение с идентификатором, указанным `id` параметр находится в очереди, используя контекст транзакции, определяемый `transactionType` параметра. В противном случае метод ожидает в течение заданного периода времени прихода нового сообщения. Если новое сообщение не поступило до истечения времени ожидания, создается исключение.  
  
 `timeout` Параметр задает общее время выполнения для этого метода. Вместо этого он задает время ожидания нового сообщения поступление в очередь. Каждый раз при поступлении нового сообщения, этот метод проверяет <xref:System.Messaging.Message.Id%2A> нового сообщения, соответствует ли `id` параметра. В противном случае этот метод запускает ожидания через и ожидает прихода нового сообщения. Таким образом, если новые сообщения продолжают поступать до истечения времени ожидания, существует возможность продолжать выполняться неопределенно долго, пока не истечет период ожидания без либо новых сообщений или до получения сообщения, этот метод <xref:System.Messaging.Message.Id%2A> соответствует `id` параметра.  
  
 Укажите `Automatic` для `transactionType` параметра, если уже имеется контекст внешней транзакции, присоединенный к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получать сообщения в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получить сообщение из транзакционной очереди вне контекста транзакции.  
  
 <xref:System.Messaging.Message.Id%2A> Свойство сообщения является уникальным на предприятии очереди сообщений, поэтому будет существовать не более одного сообщения в очереди, которое соответствует заданной `id` параметра. Если сообщение с указанным идентификатором находится в очереди, не связанную с данным <xref:System.Messaging.MessageQueue> экземпляра, сообщение не будет найден.  
  
 Используйте эту перегрузку <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> при это допустимо для текущего потока блокируются до тех пор, пока новый сообщения продолжают поступать в очереди до истечения времени ожидания, заданные `timeout` параметра. Поток будет заблокирован для по крайней мере заданного периода времени, или не ограничено, если задано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для `timeout` параметра, или если новые сообщения продолжают поступать в очереди в течение периода времени ожидания, заданного по `timeout` параметр.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращаться в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 Два других метода позволяют получать сообщения из очереди. <xref:System.Messaging.MessageQueue.Receive%2A> Метод возвращает первое сообщение в очереди и <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> метод используется для извлечения подтверждения, отчета или сообщение ответа, генерируемые приложением, которое был создан в результате сообщение, отправленное в очередь.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> метод. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Метод всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращается то же сообщение, если сообщение с более высоким приоритетом не поступит в очередь. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Так как <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> не удаляет сообщения из очереди, отсутствует необходимость отменять обратно в том случае, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с указанным значением параметра <paramref name="id" /> до истечения тайм-аута в очередь не поступало.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Представлено в MSMQ 3.0. Получает конкретное сообщение из очереди. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> получаемого сообщения.</param>
        <summary>Представлено в MSMQ 3.0. Получает сообщение, соответствующее заданному идентификатору просмотра, из нетранзакционной очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.LookupId" /> которого соответствует переданному в объект параметру <paramref name="lookupId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным кодом просмотра и удаления его из очереди. Этот метод немедленно создает исключение, если в очереди нет сообщения.  
  
 <xref:System.Messaging.Message.LookupId%2A> Свойство сообщения является уникальным для очереди где находится сообщение, поэтому будет существовать не более одного сообщения в очереди, которое соответствует заданной `lookupId` параметра.  
  
 Чтобы прочитать сообщение с указанным кодом просмотра, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> метод.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Одно из значений <see cref="T:System.Messaging.MessageLookupAction" />, задающее порядок чтения сообщения в очереди. Укажите одно из следующих значений: 
 <see langword="MessageLookupAction.Current" />: получает сообщение, заданное параметром <paramref name="lookupId" />, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.Next" />: получает сообщение, следующее за сообщением, заданным параметром <paramref name="lookupId" />, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.Previous" />: получает сообщение, предшествующее сообщению, заданному параметром <paramref name="lookupId" />, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.First" />: получает первое сообщение в очереди и удаляет его из очереди. Параметр <paramref name="lookupId" /> должен быть установлен равным 0.  
  
 <see langword="MessageLookupAction.Last" />: получает последнее сообщение в очереди и удаляет его из очереди. Параметр <paramref name="lookupId" /> должен быть установлен равным 0.</param>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> получаемого сообщения или значение 0. Значение, равное 0, используется при доступе к первому или последнему сообщению в очереди.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Представлено в MSMQ 3.0. Получает конкретное сообщение из транзакционной очереди. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, задаваемый передаваемыми параметрами <paramref name="lookupId" /> и <paramref name="action" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным кодом просмотра и удаляет его из очереди, используя контекст транзакции, определяемый `transaction` параметра. Этот метод немедленно создает исключение, если в очереди нет сообщения.  
  
 <xref:System.Messaging.Message.LookupId%2A> Свойство сообщения является уникальным для очереди где находится сообщение, поэтому будет существовать не более одного сообщения в очереди, которое соответствует заданной `lookupId` параметра.  
  
 Так как этот метод вызывается в транзакционной очереди, полученное сообщение будет возвращается в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> метод. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Так как <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> удаляет сообщения из очереди, отсутствует необходимость отменять обратно в том случае, если транзакция прервана.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.  
  
 -или-  
  
 Очередь является нетранзакционной.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="action" /> не является одним из членов <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Одно из значений <see cref="T:System.Messaging.MessageLookupAction" />, задающее порядок чтения сообщения в очереди. Укажите одно из следующих значений: 
 <see langword="MessageLookupAction.Current" />: получает сообщение, заданное параметром <paramref name="lookupId" />, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.Next" />: получает сообщение, следующее за сообщением, заданным параметром <paramref name="lookupId" />, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.Previous" />: получает сообщение, предшествующее сообщению, заданному параметром <paramref name="lookupId" />, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.First" />: получает первое сообщение в очереди и удаляет его из очереди. Параметр <paramref name="lookupId" /> должен быть установлен равным 0.  
  
 <see langword="MessageLookupAction.Last" />: получает последнее сообщение в очереди и удаляет его из очереди. Параметр <paramref name="lookupId" /> должен быть установлен равным 0.</param>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> получаемого сообщения или значение 0. Значение, равное 0, используется при доступе к первому или последнему сообщению в очереди.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Представлено в MSMQ 3.0. Получает из очереди определенное сообщение, используя заданный контекст транзакции. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, задаваемый передаваемыми параметрами <paramref name="action" /> и <paramref name="lookupId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным кодом просмотра и удаляет его из очереди, используя контекст транзакции, определяемый `transactionType` параметра. Этот метод немедленно создает исключение, если в очереди нет сообщения.  
  
 <xref:System.Messaging.Message.LookupId%2A> Свойство сообщения является уникальным для очереди где находится сообщение, поэтому будет существовать не более одного сообщения в очереди, которое соответствует заданной `lookupId` параметра.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> метод. Контекст отсутствует транзакции, связанные с сообщением, возвращенный вызовом к <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Так как <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> удаляет сообщения из очереди, отсутствует необходимость отменять обратно в том случае, если транзакция прервана.  
  
 Укажите `Automatic` для `transactionType` параметра, если уже имеется контекст внешней транзакции, присоединенный к потоку, который вы хотите использовать для получения сообщения. Укажите `Single` Если вы хотите получать сообщения в виде единой внутренней транзакции. Можно указать `None` Если вы хотите получить сообщение из транзакционной очереди вне контекста транзакции.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращаться в очередь, если транзакция прерывается. Сообщение не удаляется без возможности восстановления из очереди, пока транзакция фиксируется.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="action" /> не является одним из членов <see cref="T:System.Messaging.MessageLookupAction" />.  
  
-или- 
Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, если сообщение было удалено из очереди. Это событие инициируется асинхронной операцией, <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> используется при асинхронной обработке, чтобы вызвать <xref:System.Messaging.MessageQueue.ReceiveCompleted> событие, когда сообщение в очереди.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> используется для завершения операции, инициированной вызовом <xref:System.Messaging.MessageQueue.BeginReceive%2A> и просмотра сообщения при <xref:System.Messaging.MessageQueue.ReceiveCompleted> события.  
  
 При создании делегата <xref:System.Messaging.ReceiveCompletedEventHandler> необходимо указать метод, обрабатывающий событие. Чтобы связать событие с обработчиком событий, нужно добавить в событие экземпляр делегата. Обработчик событий вызывается всякий раз, когда происходит событие, если делегат не удален. Дополнительные сведения о делегатов обработчиков событий, см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создается обработчик событий с именем `MyReceiveCompleted`, присоединяется к <xref:System.Messaging.MessageQueue.ReceiveCompleted> делегата обработчика событий и вызовов <xref:System.Messaging.MessageQueue.BeginReceive%2A> инициировать асинхронную операцию получения для очереди, находится по пути «. \myQueue». Когда <xref:System.Messaging.MessageQueue.ReceiveCompleted> события, получает сообщение в примере и выводит его текст на экран. Затем в примере вызывается <xref:System.Messaging.MessageQueue.BeginReceive%2A> еще раз, чтобы начать новую асинхронную операцию получения.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обновляет свойства, представленные объектом <see cref="T:System.Messaging.MessageQueue" /> для отражения текущего состояния ресурса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> синхронизирует свойства <xref:System.Messaging.MessageQueue> с его связанный ресурс очереди сообщений сервера. Если любое свойство, такие как <xref:System.Messaging.MessageQueue.Label%2A> или <xref:System.Messaging.MessageQueue.Category%2A>, был изменен на сервере с момента отправки <xref:System.Messaging.MessageQueue> был создан, <xref:System.Messaging.MessageQueue.Refresh%2A> обновления <xref:System.Messaging.MessageQueue> новыми данными.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Присваивает списку разрешений значения по умолчанию операционной системы. Удаляет все разрешения очередей, добавленные в список по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, вернуть в список разрешений значения по умолчанию. Как правило, это предоставляет создатель очереди все разрешения и позволяет группе всем пользователям следующие права:  
  
-   Получение свойств очереди.  
  
-   Получение разрешений очереди.  
  
-   Запись в очередь.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Отправляет объект в очередь.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <summary>Отправляет объект в нетранзакционную очередь, на которую ссылается этот класс <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для отправки сообщения, которое содержит `obj` параметр в очередь, ссылается <xref:System.Messaging.MessageQueue>. Может быть объектом, который отправляется в очередь <xref:System.Messaging.Message> или любого управляемого объекта. Если отправлять любые объекты, отличные от <xref:System.Messaging.Message>, объект сериализуется и вставляется в текст сообщения.  
  
 Если эта перегрузка используется для отправки сообщения в транзакционную очередь, сообщение будет отправлено в очередь недоставленных. Сообщение как часть транзакции, содержащей другие сообщения, используйте перегрузку, принимающую <xref:System.Messaging.MessageQueueTransaction> или <xref:System.Messaging.MessageQueueTransactionType> как параметр.  
  
 Если вы не установите <xref:System.Messaging.MessageQueue.Formatter%2A> свойство перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Свойство применяется к любому объекту, отличное от <xref:System.Messaging.Message>. Если указать, например, метку или приоритета с помощью <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> член, эти значения применяются к любое сообщение, содержащее объект, который не относится к типу <xref:System.Messaging.Message> когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>, значения свойства, заданные для <xref:System.Messaging.Message> имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> и сообщения <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> свойство имеет приоритет над очереди <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода подключается к очереди сообщений и отправляет сообщение в очередь.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 В следующем примере кода отправляет, определяемые приложением `Order` класса в очередь, а затем получает сообщения из этой очереди.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Отправляет объект в транзакционную очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для отправки сообщения, которое содержит `obj` параметр в транзакционную очередь, ссылается <xref:System.Messaging.MessageQueue>, с помощью контекста внутренней транзакции определяется `transaction` параметра. Может быть объектом, который отправляется в очередь <xref:System.Messaging.Message> или любого управляемого объекта. Если отправлять любые объекты, отличные от <xref:System.Messaging.Message>, объект сериализуется и вставляется в текст сообщения.  
  
 Если эта перегрузка используется для отправки сообщения в нетранзакционную очередь, сообщения могут быть отправлены в очередь недоставленных сообщений-без создания исключения.  
  
 Если вы не установите <xref:System.Messaging.MessageQueue.Formatter%2A> свойство перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Свойство применяется к любому объекту, отличное от <xref:System.Messaging.Message>. Если указать, например, метку или приоритета с помощью <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> член, эти значения применяются к любое сообщение, содержащее объект, который не относится к типу <xref:System.Messaging.Message> когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>, значения свойства, заданные для <xref:System.Messaging.Message> имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> и сообщения <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> свойство имеет приоритет над очереди <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство.  
  
 <xref:System.Messaging.MessageQueueTransaction> такое потоковая обработка с поддержкой, поэтому, если состояние апартамента — `STA`, нельзя использовать транзакции в нескольких потоках. Visual Basic устанавливает состояние основного потока для `STA`, поэтому необходимо применить <xref:System.MTAThreadAttribute> в `Main` подпрограммы. В противном случае при отправке транзакционного сообщения с помощью другого потока создастся исключение <xref:System.Messaging.MessageQueueException>. Можно применить <xref:System.MTAThreadAttribute> , используя следующий фрагмент.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода отправляет строку в транзакционную очередь, а затем получает сообщение из очереди.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
-или- 
Приложение Message Queuing указало на неверное использование транзакции.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Отправляет объект в очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для отправки сообщения, которое содержит `obj` параметр в очередь, ссылается <xref:System.Messaging.MessageQueue>, с помощью контекста транзакции, определенного `transactionType` параметра. Укажите `Automatic` для `transactionType` параметра, если уже имеется контекст внешней транзакции, присоединенный к потоку, который вы хотите использовать для отправки сообщения. Укажите `Single` Если вы хотите отправить сообщение как одна внутренняя транзакция. Можно указать `None` Чтобы отправить транзакционное сообщение в нетранзакционный поток.  
  
 Может быть объектом, который отправляется в очередь <xref:System.Messaging.Message> или любого управляемого объекта. Если отправлять любые объекты, отличные от <xref:System.Messaging.Message>, объект сериализуется и вставляется в текст сообщения.  
  
 Если вы не установите <xref:System.Messaging.MessageQueue.Formatter%2A> свойство перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Свойство применяется к любому объекту, отличное от <xref:System.Messaging.Message>. Если указать, например, метку или приоритета с помощью <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> член, эти значения применяются к любое сообщение, содержащее объект, который не относится к типу <xref:System.Messaging.Message> когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>, значения свойства, заданные для <xref:System.Messaging.Message> имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> и сообщения <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> свойство имеет приоритет над очереди <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="label">Метка сообщения.</param>
        <summary>Отправляет объект в нетранзакционную очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, и задает метку сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для отправки сообщения, которое содержит `obj` параметр в очередь, ссылается <xref:System.Messaging.MessageQueue>. С помощью этой перегрузки можно указать строку метки, которое обозначает сообщение. Может быть объектом, который отправляется в очередь <xref:System.Messaging.Message>, структура, объект данных или любого управляемого объекта. Если отправлять любые объекты, отличные от <xref:System.Messaging.Message>, объект сериализуется и вставляется в текст сообщения.  
  
 Метка сообщения отличается от метки очереди сообщений, но оба зависят от приложения и не имеют внутреннего смысла для Message Queuing.  
  
 Если эта перегрузка используется для отправки сообщения в транзакционную очередь, сообщение будет отправлено в очередь недоставленных. Сообщение как часть транзакции, содержащей другие сообщения, используйте перегрузку, принимающую <xref:System.Messaging.MessageQueueTransaction> или <xref:System.Messaging.MessageQueueTransactionType> как параметр.  
  
 <xref:System.Messaging.MessageQueue.Path%2A> Свойство для данного <xref:System.Messaging.MessageQueue> должен указываться перед отправкой сообщения. Если вы не установите <xref:System.Messaging.MessageQueue.Formatter%2A> свойство перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Свойство применяется к любому объекту, отличное от <xref:System.Messaging.Message>. Если указать, например, метку или приоритета с помощью <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> член, эти значения применяются к любое сообщение, содержащее объект, который не относится к типу <xref:System.Messaging.Message> когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>, значения свойства, заданные для <xref:System.Messaging.Message> имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> и сообщения <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> свойство имеет приоритет над очереди <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="label" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="label">Метка сообщения.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Отправляет объект в транзакционную очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, и задает метку сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для отправки сообщения, которое содержит `obj` параметр в транзакционную очередь, ссылается <xref:System.Messaging.MessageQueue>, с помощью контекста внутренней транзакции определяется `transaction` параметра. С помощью этой перегрузки можно указать строку метки, которое обозначает сообщение. Может быть объектом, который отправляется в очередь <xref:System.Messaging.Message>, структура, объект данных или любого управляемого объекта. Если отправлять любые объекты, отличные от <xref:System.Messaging.Message>, объект сериализуется и вставляется в текст сообщения.  
  
 Метка сообщения отличается от метки очереди сообщений, но оба зависят от приложения и не имеют внутреннего смысла для Message Queuing.  
  
 Если эта перегрузка используется для отправки сообщения в нетранзакционную очередь, сообщения могут быть отправлены в очередь недоставленных сообщений-без создания исключения.  
  
 Если вы не установите <xref:System.Messaging.MessageQueue.Formatter%2A> свойство перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Свойство применяется к любому объекту, отличное от <xref:System.Messaging.Message>. Если указать, например, метку или приоритета с помощью <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> член, эти значения применяются к любое сообщение, содержащее объект, который не относится к типу <xref:System.Messaging.Message> когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>, значения свойства, заданные для <xref:System.Messaging.Message> имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> и сообщения <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> свойство имеет приоритет над очереди <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство  
  
 <xref:System.Messaging.MessageQueueTransaction> такое потоковая обработка с поддержкой, поэтому, если состояние апартамента — `STA`, нельзя использовать транзакции в нескольких потоках. Visual Basic устанавливает состояние основного потока для `STA`, поэтому необходимо применить <xref:System.MTAThreadAttribute> в `Main` подпрограммы. В противном случае при отправке транзакционного сообщения с помощью другого потока создастся исключение <xref:System.Messaging.MessageQueueException>. Можно применить <xref:System.MTAThreadAttribute> , используя следующий фрагмент.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="label" /> имеет значение <see langword="null" />.  
  
-или- 
Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
-или- 
Приложение Message Queuing указало на неверное использование транзакции.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="label">Метка сообщения.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Отправляет объект в очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, и задает метку сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для отправки сообщения, которое содержит `obj` параметр в очередь, ссылается <xref:System.Messaging.MessageQueue>, с помощью контекста транзакции, определенного `transactionType` параметра. Укажите `Automatic` для `transactionType` параметра, если уже имеется контекст внешней транзакции, присоединенный к потоку, который вы хотите использовать для отправки сообщения. Укажите `Single` Если вы хотите отправить сообщение как одна внутренняя транзакция. Можно указать `None` Чтобы отправить транзакционное сообщение в нетранзакционный поток.  
  
 Может быть объектом, который отправляется в очередь <xref:System.Messaging.Message> или любого управляемого объекта. Если отправлять любые объекты, отличные от <xref:System.Messaging.Message>, объект сериализуется и вставляется в текст сообщения. С помощью этой перегрузки можно указать строку метки, которое обозначает сообщение.  
  
 Метка сообщения отличается от метки очереди сообщений, но оба зависят от приложения и не имеют внутреннего смысла для Message Queuing.  
  
 Если вы не установите <xref:System.Messaging.MessageQueue.Formatter%2A> свойство перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Свойство применяется к любому объекту, отличное от <xref:System.Messaging.Message>. Если указать, например, метку или приоритета с помощью <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> член, эти значения применяются к любое сообщение, содержащее объект, который не относится к типу <xref:System.Messaging.Message> когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>, значения свойства, заданные для <xref:System.Messaging.Message> имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>и сообщения <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> свойство имеет приоритет над очереди <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> свойство.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="label" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">Приложение Message Queuing указало на неверное использование транзакции.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
-или- 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет разрешения в текущий набор. Это позволяет контролировать, кто имеет права доступа к свойствам очереди и сообщениям в очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">Объект <see cref="T:System.Messaging.AccessControlList" />, содержащий не менее одного элемента управления доступом, в которых указаны доверенные лица и предоставляемые разрешения.</param>
        <summary>Назначает права доступа к очереди на основе содержимого списка управления доступом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для предоставления, запрета или отмены права с помощью коллекции элементов управления доступом для указания доверенного лица и сведения о разрешениях. Это используется, например, для предоставления разрешений нескольким пользователям одновременно.  
  
 Данное доверенное лицо, указывается при создании `ace` параметр может быть отдельного пользователя, группы пользователей или компьютер. Если данное доверенное лицо — это человек, используйте формат `DOMAIN` \\ `user`. Можно указать «.» для доверенного лица указать локальный компьютер.  
  
 Разрешения, назначенные с помощью <xref:System.Messaging.MessageQueue.SetPermissions%2A> добавить права в существующий список. По умолчанию создатель общей или частной очереди имеет полный доступ, и группы домена, у всех есть разрешение на получение свойств очереди и получите разрешения записи в очередь. При вызове <xref:System.Messaging.MessageQueue.SetPermissions%2A>, разрешения пользователей и добавляется в конец существующего списка.  
  
 Система проверяет каждую <xref:System.Messaging.AccessControlEntry> в последовательности, пока не произойдет одно из следующих событий:  
  
-   Запись запрещения доступа <xref:System.Messaging.AccessControlEntry> явным образом запрещает любое из запрошенных прав доступа к одному из доверенных лиц, указанных в маркере доступа потока.  
  
-   Один или несколько разрешения доступа <xref:System.Messaging.AccessControlEntry> элементы для доверенных лиц, перечисленных в маркере доступа потоке явно предоставлять все запрошенные права доступа.  
  
-   Все <xref:System.Messaging.AccessControlEntry> элементы были проверены, и имеется хотя бы одного запрашиваемого права доступа имеет явного разрешения, в доступе будет отказано.  
  
 При построении `dacl` добавить параметр, <xref:System.Messaging.AccessControlEntry> экземпляры вашего <xref:System.Messaging.AccessControlList> коллекции. При создании каждой записи управления доступом, можно указать универсальный и стандартные права доступа. Права на очередь может быть любое сочетание следующих:  
  
-   Удаление  
  
-   Чтение параметров безопасности  
  
-   Записи безопасности  
  
-   Синхронизация  
  
-   Изменить владельца  
  
-   Чтение  
  
-   Write  
  
-   Выполнение  
  
-   Обязательно  
  
-   Все  
  
-   Нет  
  
 Эти права представляют собой набор битовых флагов, которые можно комбинировать с помощью побитового оператора OR.  
  
-   Полный доступ  
  
-   Удалить сообщение  
  
-   Сообщение об ошибке  
  
-   Просмотр сообщения  
  
-   Получение сообщения журнала  
  
-   Получение свойств очереди  
  
-   Задание свойств очередей  
  
-   Получение разрешений  
  
-   Настройка разрешений  
  
-   Стать владельцем очереди  
  
-   Запись сообщения  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">Объект <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />, который указывает пользователя, тип доступа и тип разрешения.</param>
        <summary>Назначает права доступа к очереди на основе содержимого элемента управления доступом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для предоставления, запрета или отмены права с помощью записи управления доступом для указания доверенного лица и сведения о правах.  
  
 Данное доверенное лицо, указывается при создании `ace` параметр может быть отдельного пользователя, группы пользователей или компьютер. Если данное доверенное лицо — это человек, используйте формат `DOMAIN` \\ `user`. Можно указать «.» для доверенного лица указать локальный компьютер.  
  
 Разрешения, назначенные с помощью <xref:System.Messaging.MessageQueue.SetPermissions%2A> добавить права в существующий список. По умолчанию создатель общей или частной очереди имеет полный доступ, и группы домена, у всех есть разрешение на получение свойств очереди и получите разрешения записи в очередь. При вызове <xref:System.Messaging.MessageQueue.SetPermissions%2A>, разрешения пользователей и добавляется в конец существующего списка.  
  
 Система проверяет каждую <xref:System.Messaging.AccessControlEntry> в последовательности, пока не произойдет одно из следующих событий:  
  
-   Запись запрещения доступа <xref:System.Messaging.AccessControlEntry> явным образом запрещает любое из запрошенных прав доступа к одному из доверенных лиц, указанных в маркере доступа потока.  
  
-   Один или несколько разрешения доступа <xref:System.Messaging.AccessControlEntry> элементы для доверенных лиц, перечисленных в маркере доступа потоке явно предоставлять все запрошенные права доступа.  
  
-   Все <xref:System.Messaging.AccessControlEntry> элементы были проверены, и имеется хотя бы одного запрашиваемого права доступа имеет явного разрешения, в доступе будет отказано.  
  
 Права на очередь, которая задается в `rights` при построении вашего <xref:System.Messaging.MessageQueueAccessControlEntry>, может быть любым сочетанием следующих:  
  
-   Полный доступ  
  
-   Удалить сообщение  
  
-   Сообщение об ошибке  
  
-   Просмотр сообщения  
  
-   Получение сообщения журнала  
  
-   Получение свойств очереди  
  
-   Задание свойств очередей  
  
-   Получение разрешений  
  
-   Настройка разрешений  
  
-   Стать владельцем очереди  
  
-   Запись сообщения  
  
 `rights` Параметр, укажите в конструкторе для `ace` параметр является флагом <xref:System.Messaging.MessageQueueAccessRights> перечисления. Он представляет набор битовых флагов, которые можно комбинировать с помощью битового оператора или при построении `rights` параметра.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">Отдельный пользователь, группа или компьютер, которые получают дополнительные права на работу с очередью.</param>
        <param name="rights">Объект <see cref="T:System.Messaging.MessageQueueAccessRights" />, который показывает набор прав на работу с очередью, которые назначаются службой очереди сообщений параметру <paramref name="user" />.</param>
        <summary>Предоставляет компьютеру, группе или пользователю указанные права доступа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод, чтобы предоставить указанные права для отдельных пользователей. Это может быть любой допустимый доверенного лица, который включает в себя отдельных пользователей, групп пользователей или компьютер. Если пользователь — это человек, используйте формат `DOMAIN` \\ `user` для `user` параметра. Можно указать «.» для `user` параметр, чтобы указать локальный компьютер.  
  
 Разрешения, назначенные с помощью <xref:System.Messaging.MessageQueue.SetPermissions%2A> добавить права в существующий список. По умолчанию создатель общей или частной очереди имеет полный доступ, и группы домена, у всех есть разрешение на получение свойств очереди и получите разрешения записи в очередь. При вызове <xref:System.Messaging.MessageQueue.SetPermissions%2A>, разрешения пользователей и добавляется в конец существующего списка.  
  
 Система проверяет каждую <xref:System.Messaging.AccessControlEntry> в последовательности, пока не произойдет одно из следующих событий:  
  
-   Запись запрещения доступа <xref:System.Messaging.AccessControlEntry> явным образом запрещает любое из запрошенных прав доступа к одному из доверенных лиц, указанных в маркере доступа потока.  
  
-   Один или несколько разрешения доступа <xref:System.Messaging.AccessControlEntry> элементы для доверенных лиц, перечисленных в маркере доступа потоке явно предоставлять все запрошенные права доступа.  
  
-   Все <xref:System.Messaging.AccessControlEntry> элементы были проверены, и имеется хотя бы одного запрашиваемого права доступа имеет явного разрешения, в доступе будет отказано.  
  
 Права на очереди, указанные в `rights` параметр, может быть любое сочетание следующих:  
  
-   Полный доступ  
  
-   Удалить сообщение  
  
-   Сообщение об ошибке  
  
-   Просмотр сообщения  
  
-   Получение сообщения журнала  
  
-   Получение свойств очереди  
  
-   Задание свойств очередей  
  
-   Получение разрешений  
  
-   Настройка разрешений  
  
-   Стать владельцем очереди  
  
-   Запись сообщения  
  
 <xref:System.Messaging.MessageQueueAccessRights> Перечисление представляет набор битовых флагов, которые можно комбинировать с помощью битового оператора или для создания `rights` параметра.  
  
 Эта перегрузка может предоставлять разрешения только; не удается отменить или запретить их. Необходимо использовать другую перегрузку явно предоставлять любые <xref:System.Messaging.AccessControlEntryType> отличное от `Allow`.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="user" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">Отдельный пользователь, группа или компьютер, которые получают дополнительные права на работу с очередью.</param>
        <param name="rights">Объект <see cref="T:System.Messaging.MessageQueueAccessRights" />, который показывает набор прав на работу с очередью, которые назначаются службой очереди сообщений параметру <paramref name="user" />.</param>
        <param name="entryType">Объект <see cref="T:System.Messaging.AccessControlEntryType" />, который указывает, нужно ли предоставить разрешения, отказать в предоставлении разрешений или отозвать разрешения, задаваемые параметром <paramref name="rights" />.</param>
        <summary>Предоставляет компьютеру, группе или пользователю указанные права доступа указанного типа управления доступом (разрешить, отказать, отозвать или задать).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот перегруженный метод для предоставления, запрещения или отозвать указанные права для отдельного пользователя. Это может быть любой допустимый доверенного лица, который включает в себя отдельных пользователей, групп пользователей или компьютер. Если пользователь — это человек, используйте формат `DOMAIN` \\ `user` для `user` параметра. Можно указать «.» для `user` параметр, чтобы указать локальный компьютер.  
  
 Разрешения, назначенные с помощью <xref:System.Messaging.MessageQueue.SetPermissions%2A> добавить права в существующий список. По умолчанию создатель общей или частной очереди имеет полный доступ, и группы домена, у всех есть разрешение на получение свойств очереди и получите разрешения записи в очередь. При вызове <xref:System.Messaging.MessageQueue.SetPermissions%2A>, разрешения пользователей и добавляется в конец существующего списка.  
  
 Система проверяет каждую <xref:System.Messaging.AccessControlEntry> в последовательности, пока не произойдет одно из следующих событий:  
  
-   Запись запрещения доступа <xref:System.Messaging.AccessControlEntry> явным образом запрещает любое из запрошенных прав доступа к одному из доверенных лиц, указанных в маркере доступа потока.  
  
-   Один или несколько разрешения доступа <xref:System.Messaging.AccessControlEntry> элементы для доверенных лиц, перечисленных в маркере доступа потоке явно предоставлять все запрошенные права доступа.  
  
-   Все <xref:System.Messaging.AccessControlEntry> элементы были проверены, и имеется хотя бы одного запрашиваемого права доступа имеет явного разрешения, в доступе будет отказано.  
  
 Права на очереди, указанные в `rights` параметр, может быть любое сочетание следующих:  
  
-   Полный доступ  
  
-   Удалить сообщение  
  
-   Сообщение об ошибке  
  
-   Просмотр сообщения  
  
-   Получение сообщения журнала  
  
-   Получение свойств очереди  
  
-   Задание свойств очередей  
  
-   Получение разрешений  
  
-   Настройка разрешений  
  
-   Стать владельцем очереди  
  
-   Запись сообщения  
  
 <xref:System.Messaging.MessageQueueAccessRights> Перечисление представляет набор битовых флагов, которые можно комбинировать с помощью битового оператора или для создания `rights` параметра.  
  
 Следующая таблица показывает, доступен ли этот метод в режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект, который используется для маршалинга вызовов обработчика событий, возникающих в результате наступления события <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> или события <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />.</summary>
        <value>Объект <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, представляющий объект, который выполняет маршалинг вызова обработчика событий, причиной которого стало событие <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> или <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Messaging.MessageQueue.ReceiveCompleted> или <xref:System.Messaging.MessageQueue.PeekCompleted> событий полученный в результате <xref:System.Messaging.MessageQueue.BeginReceive%2A> или <xref:System.Messaging.MessageQueue.BeginPeek%2A> , запросив, соответственно, для определенного потока. Как правило <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> задается при его связанный компонент помещается внутри элемента управления или формы, так как эти компоненты привязаны к определенному потоку.  
  
 Как правило синхронизирующий объект маршалирует вызов метода в один поток.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, принимает ли очередь только транзакции.</summary>
        <value>Значение <see langword="true" />, если очередь принимает только сообщения, отправляемые как часть транзакции; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обмен транзакционными сообщениями относится к объединению нескольких связанных сообщений в одну транзакцию. Отправка сообщений как часть транзакции гарантирует доставку сообщений в порядке, только один раз и успешно извлечено из очереди назначения.  
  
 Если очередь является транзакционной, он принимает только сообщения, отправляемые как часть транзакции. Тем не менее, отправлено или получено из очереди локальной транзакции без явным образом с помощью транзакций нетранзакционное сообщение <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, и <xref:System.Messaging.MessageQueueTransaction.Abort%2A> синтаксис. Если нетранзакционное сообщение отправляется в транзакционную очередь, этот компонент создаст транзакцию одного сообщения для него, за исключением в случае обращение к очереди на удаленном компьютере, с помощью непосредственного имени формата. В этом случае если вы не укажете контекст транзакции при отправке сообщения, он не создается автоматически, и это сообщение будет отправлено в очередь недоставленных.  
  
 При отправке нетранзакционное сообщение в транзакционную очередь, вы не сможете откатить сообщение в случае возникновения исключения.  
  
 <xref:System.Messaging.MessageQueueTransaction> такое потоковая обработка с поддержкой, поэтому, если состояние апартамента — `STA`, нельзя использовать транзакции в нескольких потоках. Visual Basic устанавливает состояние основного потока для `STA`, поэтому необходимо применить <xref:System.MTAThreadAttribute> в `Main` подпрограммы. В противном случае при отправке транзакционного сообщения с помощью другого потока создастся исключение <xref:System.Messaging.MessageQueueException>. Можно применить <xref:System.MTAThreadAttribute> , используя следующий фрагмент.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода отображает значение очередь сообщений <xref:System.Messaging.MessageQueue.Transactional%2A> свойство.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должны ли полученные сообщения копироваться в очередь журнала.</summary>
        <value>Значение <see langword="true" />, если сообщения, полученные из очереди, копируются в очередь журнала; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда приложение Message Queuing создает новую очередь приложения, автоматически создает связанную очередь журнала в одном расположении. В очередь журнала используется для отслеживания сообщений, удаленных из очереди. Задание этого свойства изменяет очередь Message Queuing. Таким образом, любой другой <xref:System.Messaging.MessageQueue> экземпляры будут затронуты данным изменением.  
  
 В очередь журнала не отслеживает сообщений, удаленных из очереди, так как время получения истечения, а также сообщения, удаленные из очереди с помощью службы каталогов очереди сообщений (Store сведения или Active Directory).  
  
 Приложения не могут отправлять сообщения в очереди журнала; они ограничены доступ только для чтения этих очередей. Кроме того Message Queuing никогда не удаляет сообщения из очереди журнала. Приложение, использующее очередь необходимо очистить эти сообщения, их получения или очистка очереди.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода возвращает и задает значение очередь сообщений <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> свойство.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает собственный дескриптор, который используется для отправки сообщений в очередь сообщений.</summary>
        <value>Дескриптор собственного объекта очереди, который используется для отправки сообщений в очередь.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A> Предоставляет собственный дескриптор Windows для объекта очереди сообщений, который используется для отправки сообщений в очередь. Если вы измените путь к очереди, маркер закрыть и открыть с новым значением.  
  
 Следующая таблица показывает ли это свойство доступно в различных режимах рабочей группы.  
  
|Режиме рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и непосредственное имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Очередь сообщений недоступна для записи.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>