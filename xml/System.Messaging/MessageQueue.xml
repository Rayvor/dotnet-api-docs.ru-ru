<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b9f652741774210e9573fa6e30c760062489dd5b" /><Meta Name="ms.sourcegitcommit" Value="385ff23cc00fe9aa1c93460c62603b45c2041d0b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="11/22/2019" /><Meta Name="ms.locfileid" Value="74386247" /></Metadata><TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет доступ к очереди на сервере MSMQ.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Технология очередей сообщений позволяет приложениям, работающим в разное время, взаимодействовать через разнородные сети и системы, которые могут быть временно автономными. Приложения отправляют, получают или считывают (чтение без удаления) сообщения из очередей. Служба очереди сообщений является необязательным компонентом [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] и Windows NT и должна устанавливаться отдельно.  
  
 Класс <xref:System.Messaging.MessageQueue> является оболочкой для очереди сообщений. Существует несколько версий очереди сообщений, и использование класса <xref:System.Messaging.MessageQueue> может немного различно повлиять на поведение в зависимости от используемой операционной системы. Сведения о конкретных функциях каждой версии очереди сообщений см. в разделе «новые возможности очереди сообщений» пакета Platform SDK на сайте MSDN.  
  
 Класс <xref:System.Messaging.MessageQueue> предоставляет ссылку на очередь очереди сообщений. Можно указать путь в конструкторе <xref:System.Messaging.MessageQueue.%23ctor%2A>, чтобы подключиться к существующему ресурсу, или создать новую очередь на сервере. Прежде чем можно будет вызвать <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>или <xref:System.Messaging.MessageQueue.Receive%2A>, необходимо связать новый экземпляр класса <xref:System.Messaging.MessageQueue> с существующей очередью. На этом этапе можно манипулировать свойствами очереди, такими как <xref:System.Messaging.MessageQueue.Category%2A> и <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> поддерживает два типа извлечения сообщений: синхронные и асинхронные. Синхронные методы, <xref:System.Messaging.MessageQueue.Peek%2A> и <xref:System.Messaging.MessageQueue.Receive%2A>, вызывают ожидание потоком процесса заданного интервала времени для поступления нового сообщения в очередь. Асинхронные методы, <xref:System.Messaging.MessageQueue.BeginPeek%2A> и <xref:System.Messaging.MessageQueue.BeginReceive%2A>, позволяют основным задачам приложения продолжать работу в отдельном потоке, пока сообщение не поступит в очередь. Эти методы работают, используя объекты обратного вызова и объекты состояния для обмена данными между потоками.  
  
 При создании нового экземпляра класса <xref:System.Messaging.MessageQueue> не создается новая очередь очередей сообщений. Вместо этого можно использовать методы <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>и <xref:System.Messaging.MessageQueue.Purge%2A> для управления очередями на сервере.  
  
 В отличие от <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> и <xref:System.Messaging.MessageQueue.Delete%28System.String%29> являются `static` членами, поэтому их можно вызывать без создания нового экземпляра класса <xref:System.Messaging.MessageQueue>.  
  
 Свойство <xref:System.Messaging.MessageQueue.Path%2A> объекта <xref:System.Messaging.MessageQueue> можно задать с помощью одного из трех имен: понятное имя, <xref:System.Messaging.MessageQueue.FormatName%2A>или <xref:System.Messaging.MessageQueue.Label%2A>. Понятное имя, которое определяется свойствами <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A> очереди, <xref:System.Messaging.MessageQueue.MachineName%2A>\\<xref:System.Messaging.MessageQueue.QueueName%2A> для общей очереди и <xref:System.Messaging.MessageQueue.MachineName%2A>\\`Private$`\\<xref:System.Messaging.MessageQueue.QueueName%2A> для частной очереди. Свойство <xref:System.Messaging.MessageQueue.FormatName%2A> обеспечивает автономный доступ к очередям сообщений. Наконец, можно использовать свойство <xref:System.Messaging.MessageQueue.Label%2A> очереди, чтобы задать <xref:System.Messaging.MessageQueue.Path%2A>очереди.  
  
 Список начальных значений свойств для экземпляра <xref:System.Messaging.MessageQueue>см. в разделе Конструктор <xref:System.Messaging.MessageQueue.%23ctor%2A>.  
  
   
  
## Examples  
 В следующем примере кода создаются новые <xref:System.Messaging.MessageQueue> объекты с использованием различных типов синтаксиса имени пути. В каждом случае он отправляет сообщение в очередь, путь которой определен в конструкторе.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 Следующий пример кода отправляет сообщение в очередь и получает сообщение из очереди, используя класс для конкретного приложения с именем `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Только метод <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> является потокобезопасным.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />. После того как конструктор без параметров инициализирует новый экземпляр, необходимо задать свойство <see cref="P:System.Messaging.MessageQueue.Path" /> экземпляра, прежде чем можно будет использовать этот экземпляр.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для создания нового экземпляра класса <xref:System.Messaging.MessageQueue>, который не привязывается сразу к очереди на сервере очереди сообщений. Перед использованием этого экземпляра необходимо подключить его к существующей очереди очереди сообщений, задав свойство <xref:System.Messaging.MessageQueue.Path%2A>. Кроме того, можно задать <xref:System.Messaging.MessageQueue> ссылку на возвращаемое значение метода <xref:System.Messaging.MessageQueue.Create%28System.String%29>, тем самым создавая новую очередь очереди сообщений.  
  
 Конструктор <xref:System.Messaging.MessageQueue.%23ctor%2A> создает новый экземпляр класса <xref:System.Messaging.MessageQueue>; она не создает новую очередь очереди сообщений.  
  
 В следующей таблице показаны начальные значения свойств для экземпляра <xref:System.Messaging.MessageQueue>.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Значения, заданные конструктором без параметров класса <xref:System.Messaging.DefaultPropertiesToSend>.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Значения, заданные конструктором без параметров класса <xref:System.Messaging.MessagePropertyFilter>. Все значения фильтра имеют значение `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 В следующем примере кода создается новый <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />, который ссылается на очередь MSMQ по указанному пути.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, если требуется привязать новый экземпляр <xref:System.Messaging.MessageQueue> к определенной очереди очереди сообщений, для которой известно имя формата или метка. Если вы хотите предоставить эксклюзивный доступ к первому приложению, которое ссылается на очередь, необходимо задать для свойства <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> значение `true` или использовать конструктор, передающий параметр ограничения доступа для чтения.  
  
 Конструктор <xref:System.Messaging.MessageQueue.%23ctor%2A> создает новый экземпляр класса <xref:System.Messaging.MessageQueue>; она не создает новую очередь очереди сообщений. Чтобы создать новую очередь в очереди сообщений, используйте <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Синтаксис параметра `path` зависит от типа очереди, на которую он ссылается, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частная очередь|`MachineName`\\`Private$`\\`QueueName`|  
|Очередь журнала|`MachineName`\\`QueueName`\\`Journal$`|  
|Очередь журнала компьютера|`MachineName`\\`Journal$`|  
|Очередь недоставленных сообщений компьютера|`MachineName`\\`Deadletter$`|  
|Очередь недоставленных транзактных сообщений на компьютере|`MachineName`\\`XactDeadletter$`|  
  
 Кроме того, можно использовать <xref:System.Messaging.MessageQueue.FormatName%2A> или <xref:System.Messaging.MessageQueue.Label%2A> для описания пути очереди, как показано в следующей таблице.  
  
|Ссылка|Синтаксис|Пример|  
|---------------|------------|-------------|  
|Название формата|`FormatName:` [ *имя формата* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Метка|`Label:` [ *Метка* ]|`Label:` Селабел|  
  
 Для работы в автономном режиме необходимо использовать синтаксис имени формата, а не синтаксис имени пути для конструктора. В противном случае создается исключение, так как основной контроллер домена недоступен для разрешения пути к имени формата.  
  
 В следующей таблице показаны начальные значения свойств для экземпляра <xref:System.Messaging.MessageQueue>. Эти значения основываются на свойствах очереди сообщений с указанием пути, указанного параметром `path`.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Значения, заданные конструктором без параметров класса <xref:System.Messaging.DefaultPropertiesToSend>.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, если уровень конфиденциальности очереди сообщений имеет значение "Body"; в противном случае `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Значение свойства "имя компьютера очереди сообщений".|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Значения, заданные конструктором без параметров класса <xref:System.Messaging.MessagePropertyFilter>.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, если он не задан конструктором.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, если он не задан конструктором.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, если включен параметр журнала объекта очереди сообщений; в противном случае `false`.|  
  
   
  
## Examples  
 В следующем примере кода создаются новые <xref:System.Messaging.MessageQueue> объекты с использованием различных типов синтаксиса имени пути. В каждом случае он отправляет сообщение в очередь, путь которой определен в конструкторе.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> имеет неверное значение. Возможно, оно просто не задано.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, для локального компьютера может иметь значение ".".</param>
        <param name="sharedModeDenyReceive">Значение <see langword="true" />, если необходимо предоставить монопольный доступ на чтение первому приложению, которое обратится к очереди; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />, который ссылается на очередь MSMQ по указанному пути и с указанным ограничением доступа на чтение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, если требуется привязать новую <xref:System.Messaging.MessageQueue> к определенной очереди очереди сообщений, для которой известно расположение, имя формата или метку. Если вы хотите предоставить эксклюзивный доступ к первому приложению, которое ссылается на очередь, задайте для параметра `sharedModeDenyReceive` значение `true`. В противном случае задайте для `sharedModeDenyReceive` значение `false` или используйте конструктор, который содержит только параметр `path`.  
  
 Установка `sharedModeDenyReceive` `true` влияет на все объекты, обращающиеся к очереди очереди сообщений, включая другие приложения. Эффекты параметра не ограничиваются этим приложением.  
  
 Конструктор <xref:System.Messaging.MessageQueue.%23ctor%2A> создает новый экземпляр класса <xref:System.Messaging.MessageQueue>. она не создает новую очередь очереди сообщений. Чтобы создать новую очередь в очереди сообщений, используйте <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Синтаксис параметра `path` зависит от типа очереди.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частная очередь|`MachineName`\\`Private$`\\`QueueName`|  
|Очередь журнала|`MachineName`\\`QueueName`\\`Journal$`|  
|Очередь журнала компьютера|`MachineName`\\`Journal$`|  
|Очередь недоставленных сообщений компьютера|`MachineName`\\`Deadletter$`|  
|Очередь недоставленных транзактных сообщений на компьютере|`MachineName`\\`XactDeadletter$`|  
  
 Кроме того, для описания пути очереди можно использовать имя формата или метку очереди сообщений.  
  
|Ссылка|Синтаксис|Пример|  
|---------------|------------|-------------|  
|Название формата|`FormatName:` [ *имя формата* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Метка|`Label:` [ *Метка* ]|`Label:` Селабел|  
  
 Для работы в автономном режиме необходимо использовать синтаксис имени формата, а не синтаксис понятного имени. В противном случае создается исключение, так как основной контроллер домена (на котором размещается Active Directory) недоступен для разрешения пути к имени формата.  
  
 Если <xref:System.Messaging.MessageQueue> открывает очередь с параметром `sharedModeDenyReceive`, для которого задано значение `true`, любые <xref:System.Messaging.MessageQueue>, которые впоследствии пытаются выполнить чтение из очереди, создают <xref:System.Messaging.MessageQueueException> из-за нарушения общего доступа. <xref:System.Messaging.MessageQueueException> также создается, если <xref:System.Messaging.MessageQueue> пытается получить доступ к очереди в монопольном режиме, в то время как другой <xref:System.Messaging.MessageQueue> уже имеет немонопольный доступ к очереди.  
  
 В следующей таблице показаны начальные значения свойств для экземпляра <xref:System.Messaging.MessageQueue>. Эти значения основываются на свойствах очереди очереди сообщений с указанием пути, указанного параметром `path`.  
  
|Свойство.|Исходное значение|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Значения, заданные конструктором без параметров класса <xref:System.Messaging.DefaultPropertiesToSend>.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, если уровень конфиденциальности очереди сообщений имеет значение "Body"; в противном случае `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Значение свойства "имя компьютера очереди сообщений".|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Значения, заданные конструктором без параметров класса <xref:System.Messaging.MessagePropertyFilter>.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, если он не задан конструктором.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, если он не задан конструктором.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Значение параметра `sharedModeDenyReceive`.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, если включен параметр журнала объекта очереди сообщений; в противном случае `false`.|  
  
   
  
## Examples  
 В следующем примере кода создается новый <xref:System.Messaging.MessageQueue> с монопольным доступом, устанавливается его путь и отправляется сообщение в очередь.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> имеет неверное значение. Возможно, оно просто не задано.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, для локального компьютера может иметь значение ".".</param>
        <param name="accessMode">Одно из значений перечисления <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, для локального компьютера может иметь значение ".".</param>
        <param name="sharedModeDenyReceive">Значение <see langword="true" />, если необходимо предоставить монопольный доступ на чтение первому приложению, которое обратится к очереди; в противном случае — значение <see langword="false" />.</param>
        <param name="enableCache">Значение <see langword="true" />, если необходимо создать и использовать кэш подключений; в противном случае — значение <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода создается новый <xref:System.Messaging.MessageQueue> с монопольным доступом на чтение и включенным кэшированием подключений.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="enableCache" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Расположение очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, для локального компьютера может иметь значение ".".</param>
        <param name="sharedModeDenyReceive">Значение <see langword="true" />, если необходимо предоставить монопольный доступ на чтение первому приложению, которое обратится к очереди; в противном случае — значение <see langword="false" />.</param>
        <param name="enableCache">Значение <see langword="true" />, если необходимо создать и использовать кэш подключений; в противном случае — значение <see langword="false" />.</param>
        <param name="accessMode">Одно из значений перечисления <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее режим доступа для очереди.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Messaging.QueueAccessMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Режим доступа по умолчанию для очереди `QueueAccessMode.SendAndReceive`, если не указано иное при вызове конструктора.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, принимает ли очередь только сообщения, прошедшие проверку подлинности.</summary>
        <value>Значение <see langword="true" />, если очередь принимает только сообщения, прошедшие проверку подлинности; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Проверка подлинности сообщений позволяет обеспечить целостность сообщений и проверить, кто отправил сообщение. Чтобы запросить проверку подлинности, отправляющее приложение устанавливает уровень проверки подлинности сообщения.  
  
 Если для <xref:System.Messaging.MessageQueue.Authenticate%2A> задано значение `true`, доступ к очереди на сервере ограничен, а не только с данным экземпляром <xref:System.Messaging.MessageQueue>. Все клиенты, работающие с одной и той же очередью очереди сообщений, будут затронуты.  
  
 Очередь, принимающая только сообщения, прошедшие проверку подлинности, отклоняет сообщение без проверки подлинности. Чтобы запросить уведомление о отклонении сообщений, в отправляющем приложении можно задать свойство <xref:System.Messaging.Message.AcknowledgeType%2A> сообщения. Поскольку никакое другое указание о отклонении сообщений не существует, отправляющее приложение может потерять сообщение, если только не запрашивается его отправка в очередь недоставленных сообщений.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение свойства <xref:System.Messaging.MessageQueue.Authenticate%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает базовый приоритет, используемый службой очереди сообщений для маршрутизации сообщений общей очереди по сети.</summary>
        <value>Элементарный базовый приоритет для всех сообщений, переданных в общую очередь. Значение по умолчанию равно нулю (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовый приоритет очереди сообщений определяет способ обработки маршрута сообщения к этой очереди по мере передачи по сети. Для свойства <xref:System.Messaging.MessageQueue.BasePriority%2A> можно задать значение более высокого или более низкого приоритета для всех сообщений, отправляемых в указанную очередь, чем отправленные в другие очереди. Задание этого свойства изменяет очередь сообщений. Поэтому изменение повлияет на все другие экземпляры <xref:System.Messaging.MessageQueue>.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> очереди сообщений не связана со свойством <xref:System.Messaging.Message.Priority%2A> сообщения, которое указывает порядок, в котором входящее сообщение помещается в очередь.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> применяется только к общим очередям, пути которых указаны с использованием имени формата. Базовый приоритет частной очереди всегда равен нулю (0).  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение свойства <xref:System.Messaging.MessageQueue.BasePriority%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для базового приоритета задано недопустимое значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <summary>Инициирует асинхронную операцию считывания, указывая службе MSMQ на необходимость запуска операции считывания сообщения и уведомления обработчика событий о завершении операции.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициирует асинхронную операцию считывания, не имеющую тайм-аута. Операция остается незавершенной, пока сообщение не станет доступным в очереди.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При асинхронной обработке можно использовать <xref:System.Messaging.MessageQueue.BeginPeek%2A>, чтобы вызвать событие <xref:System.Messaging.MessageQueue.PeekCompleted>, когда сообщение станет доступным в очереди.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также создается, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginPeek%2A>, создайте обработчик событий, обрабатывающий результаты асинхронной операции, и свяжите его с делегатом события. <xref:System.Messaging.MessageQueue.BeginPeek%2A> инициирует асинхронную операцию просмотра; <xref:System.Messaging.MessageQueue> уведомляется, вызывая событие <xref:System.Messaging.MessageQueue.PeekCompleted>, когда сообщение поступает в очередь. Затем <xref:System.Messaging.MessageQueue> может получить доступ к сообщению, вызвав метод <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> или извлекая результат с помощью <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Метод <xref:System.Messaging.MessageQueue.BeginPeek%2A> возвращает значение немедленно, но асинхронная операция не завершается до вызова обработчика событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, его можно вызвать для просмотра очереди, не блокируя текущий поток выполнения. Для синхронного просмотра очереди используйте метод <xref:System.Messaging.MessageQueue.Peek%2A>.  
  
 После завершения асинхронной операции можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> в обработчике событий, чтобы получать уведомления.  
  
 <xref:System.IAsyncResult>, который <xref:System.Messaging.MessageQueue.BeginPeek%2A> возвращает, идентифицирует асинхронную операцию, запущенную методом. Этот <xref:System.IAsyncResult> можно использовать в течение всего времени существования операции, хотя обычно он не используется, пока не будет вызвана <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>. Однако при запуске нескольких асинхронных операций можно поместить их <xref:System.IAsyncResult> значения в массив и указать, следует ли дожидаться завершения всех операций или любой операции. В этом случае для задания завершенной операции используется свойство <xref:System.IAsyncResult.AsyncWaitHandle%2A> <xref:System.IAsyncResult>.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> `false`, вызывается событие завершения, но при вызове <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>возникнет исключение.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается обработчик событий с именем `MyPeekCompleted`, присоединяется к делегату обработчика событий <xref:System.Messaging.MessageQueue.PeekCompleted> и вызывается <xref:System.Messaging.MessageQueue.BeginPeek%2A> для инициации асинхронной операции просмотра в очереди, расположенной по пути ".\Микуеуе". При возникновении события <xref:System.Messaging.MessageQueue.PeekCompleted> в примере считывается сообщение и записывается его текст на экран. Затем в примере вызывается <xref:System.Messaging.MessageQueue.BeginPeek%2A> еще раз, чтобы инициировать новую асинхронную операцию просмотра.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <summary>Инициирует асинхронную операцию считывания с заданным тайм-аутом. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При асинхронной обработке можно использовать <xref:System.Messaging.MessageQueue.BeginPeek%2A>, чтобы вызвать событие <xref:System.Messaging.MessageQueue.PeekCompleted>, когда сообщение станет доступным в очереди или когда истечет указанный интервал времени.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также создается, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginPeek%2A>, создайте обработчик событий, обрабатывающий результаты асинхронной операции, и свяжите его с делегатом события. <xref:System.Messaging.MessageQueue.BeginPeek%2A> инициирует асинхронную операцию просмотра; <xref:System.Messaging.MessageQueue> уведомляется, вызывая событие <xref:System.Messaging.MessageQueue.PeekCompleted>, когда сообщение поступает в очередь. Затем <xref:System.Messaging.MessageQueue> может получить доступ к сообщению, вызвав метод <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> или извлекая результат с помощью <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Метод <xref:System.Messaging.MessageQueue.BeginPeek%2A> возвращает значение немедленно, но асинхронная операция не завершается до вызова обработчика событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, его можно вызвать для просмотра очереди, не блокируя текущий поток выполнения. Для синхронного просмотра очереди используйте метод <xref:System.Messaging.MessageQueue.Peek%2A>.  
  
 После завершения асинхронной операции можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> в обработчике событий, чтобы получать уведомления.  
  
 <xref:System.IAsyncResult>, который <xref:System.Messaging.MessageQueue.BeginPeek%2A> возвращает, идентифицирует асинхронную операцию, запущенную методом. Этот <xref:System.IAsyncResult> можно использовать в течение всего времени существования операции, хотя обычно он не используется, пока не будет вызвана <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>. Однако при запуске нескольких асинхронных операций можно поместить их <xref:System.IAsyncResult> значения в массив и указать, следует ли дожидаться завершения всех операций или любой операции. В этом случае для задания завершенной операции используется свойство <xref:System.IAsyncResult.AsyncWaitHandle%2A> <xref:System.IAsyncResult>.  
  
 Эта перегрузка задает время ожидания. Если интервал, указанный параметром `timeout`, истекает, этот компонент создает событие <xref:System.Messaging.MessageQueue.PeekCompleted>. Поскольку сообщение не существует, последующий вызов <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> будет вызывать исключение.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> `false`, вызывается событие завершения, но при вызове <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>возникнет исключение.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронная операция просмотра с использованием пути очереди ".\Микуеуе". Он создает обработчик событий, `MyPeekCompleted`и прикрепляет его к делегату обработчика событий <xref:System.Messaging.MessageQueue.PeekCompleted>. <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызывается с интервалом в одну минуту, чтобы инициировать асинхронную операцию просмотра. При возникновении <xref:System.Messaging.MessageQueue.PeekCompleted> события или истечения времени ожидания сообщение извлекается, если оно существует, а его текст записывается на экран. Затем <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызывается снова, чтобы инициировать новую асинхронную операцию считывания с тем же временем ожидания.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="stateObject">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <summary>Инициирует асинхронную операцию считывания с указанным тайм-аутом и заданным объектом состояния, который предоставляет связанные данные в течение всего времени выполнения операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При асинхронной обработке можно использовать <xref:System.Messaging.MessageQueue.BeginPeek%2A>, чтобы вызвать событие <xref:System.Messaging.MessageQueue.PeekCompleted>, когда сообщение станет доступным в очереди или когда истечет указанный интервал времени.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также создается, если сообщение уже существует в очереди.  
  
 Используйте эту перегрузку, чтобы связать сведения с операцией, которая будет сохранена в течение всего времени существования операции. Обработчик событий может получить доступ к этим сведениям, просмотрев свойство <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>, связанного с операцией.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginPeek%2A>, создайте обработчик событий, обрабатывающий результаты асинхронной операции, и свяжите его с делегатом события. <xref:System.Messaging.MessageQueue.BeginPeek%2A> инициирует асинхронную операцию просмотра; <xref:System.Messaging.MessageQueue> уведомляется, вызывая событие <xref:System.Messaging.MessageQueue.PeekCompleted>, когда сообщение поступает в очередь. Затем <xref:System.Messaging.MessageQueue> может получить доступ к сообщению, вызвав метод <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> или извлекая результат с помощью <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Метод <xref:System.Messaging.MessageQueue.BeginPeek%2A> возвращает значение немедленно, но асинхронная операция не завершается до вызова обработчика событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, его можно вызвать для просмотра очереди, не блокируя текущий поток выполнения. Для синхронного просмотра очереди используйте метод <xref:System.Messaging.MessageQueue.Peek%2A>.  
  
 После завершения асинхронной операции можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> в обработчике событий, чтобы получать уведомления.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> возвращает <xref:System.IAsyncResult>, который идентифицирует асинхронную операцию, запущенную методом. Этот <xref:System.IAsyncResult> можно использовать в течение всего времени существования операции, хотя обычно он не используется, пока не будет вызвана <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>. Однако при запуске нескольких асинхронных операций можно поместить их <xref:System.IAsyncResult> значения в массив и указать, следует ли дожидаться завершения всех операций или любой операции. В этом случае для задания завершенной операции используется свойство <xref:System.IAsyncResult.AsyncWaitHandle%2A> <xref:System.IAsyncResult>.  
  
 Эта перегрузка задает время ожидания и объект состояния. Если интервал, указанный параметром `timeout`, истекает, этот компонент создает событие <xref:System.Messaging.MessageQueue.PeekCompleted>. Поскольку сообщение не существует, последующий вызов <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> будет вызывать исключение.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, если вы вызываете <xref:System.Messaging.MessageQueue.BeginPeek%2A> несколько раз для инициации нескольких операций, каждую операцию можно определить с помощью отдельного определяемого объекта State. Иллюстрация этого сценария приведена в разделе "пример".  
  
 Объект состояния также можно использовать для передачи сведений между потоками процесса. Если поток запущен, но обратный вызов находится в другом потоке в асинхронном сценарии, объект состояния маршалируется и передается обратно вместе со сведениями из события.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> `false`, вызывается событие завершения, но при вызове <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>возникнет исключение.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронная операция просмотра с использованием пути очереди ".\Микуеуе". Он создает обработчик событий, `MyPeekCompleted`и прикрепляет его к делегату обработчика событий <xref:System.Messaging.MessageQueue.PeekCompleted>. <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызывается со временем ожидания в одну минуту. Каждый вызов <xref:System.Messaging.MessageQueue.BeginPeek%2A> имеет уникальное связанное целое число, определяющее конкретную операцию. При возникновении <xref:System.Messaging.MessageQueue.PeekCompleted> события или истечения времени ожидания сообщение, если оно существует, извлекается, а его текст и целочисленный идентификатор, зависящий от операции, записываются на экран. Затем <xref:System.Messaging.MessageQueue.BeginPeek%2A> вызывается снова для инициации новой асинхронной операции считывания с тем же временем ожидания и со связанным целым числом только что завершенной операции.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="stateObject">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <param name="callback">Объект <see cref="T:System.AsyncCallback" />, принимающий уведомление о завершении асинхронной операции.</param>
        <summary>Инициирует асинхронную операцию считывания с указанным тайм-аутом и заданным объектом состояния, который предоставляет связанные данные в течение всего времени выполнения операции. Посредством обратного вызова эта перегрузка получает уведомление об отличительных особенностях обработчика событий для операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этой перегрузки функция обратного вызова, указанная в параметре обратного вызова, вызывается непосредственно в том случае, когда сообщение становится доступным в очереди или по истечении заданного интервала времени. событие <xref:System.Messaging.MessageQueue.PeekCompleted> не возникает. Другие перегрузки <xref:System.Messaging.MessageQueue.BeginPeek%2A> используют этот компонент для вызова события <xref:System.Messaging.MessageQueue.PeekCompleted>.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также создается, если сообщение уже существует в очереди.  
  
 Метод <xref:System.Messaging.MessageQueue.BeginPeek%2A> возвращает значение немедленно, но асинхронная операция не завершается до вызова обработчика событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, его можно вызвать для просмотра очереди, не блокируя текущий поток выполнения. Для синхронного просмотра очереди используйте метод <xref:System.Messaging.MessageQueue.Peek%2A>.  
  
 После завершения асинхронной операции можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> в обработчике событий, чтобы получать уведомления.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> возвращает <xref:System.IAsyncResult>, который идентифицирует асинхронную операцию, запущенную методом. Этот <xref:System.IAsyncResult> можно использовать в течение всего времени существования операции, хотя обычно он не используется, пока не будет вызвана <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>. Однако при запуске нескольких асинхронных операций можно поместить их <xref:System.IAsyncResult> значения в массив и указать, следует ли дожидаться завершения всех операций или любой операции. В этом случае для задания завершенной операции используется свойство <xref:System.IAsyncResult.AsyncWaitHandle%2A> <xref:System.IAsyncResult>.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, если вы вызываете <xref:System.Messaging.MessageQueue.BeginPeek%2A> несколько раз для инициации нескольких операций, каждую операцию можно определить с помощью отдельного определяемого объекта State.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронная операция просмотра. В примере кода сообщение отправляется в локальную очередь сообщений, затем вызывается <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, передача: время ожидания — десять секунд; уникальное целое число, идентифицирующее конкретное сообщение; и новый экземпляр <xref:System.AsyncCallback>, который идентифицирует обработчик событий `MyPeekCompleted`. При возникновении события <xref:System.Messaging.MessageQueue.PeekCompleted> обработчик событий считывает сообщение и записывает на экран текст сообщения и идентификатор целочисленного сообщения.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="action">Одно из значений перечисления <see cref="T:System.Messaging.PeekAction" />. Указывает, следует ли считывать текущее сообщение в очереди или следующее сообщение.</param>
        <param name="state">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <param name="callback">Объект <see cref="T:System.AsyncCallback" />, принимающий уведомление о завершении асинхронной операции.</param>
        <summary>Инициирует асинхронную операцию считывания, которая имеет заданный тайм-аут и использует заданный курсор, заданную операцию считывания и заданный объект состояния. Объект состояния предоставляет связанные сведения в течение всего времени выполнения операции. Посредством обратного вызова эта перегрузка получает уведомление об отличительных особенностях обработчика событий для операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этой перегрузки функция обратного вызова, указанная в параметре обратного вызова, вызывается напрямую, когда сообщение становится доступным в очереди или по истечении заданного интервала времени. Событие <xref:System.Messaging.MessageQueue.PeekCompleted> не возникает. Другие перегрузки <xref:System.Messaging.MessageQueue.BeginPeek%2A> используют этот компонент для вызова события <xref:System.Messaging.MessageQueue.PeekCompleted>.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> также создается, если сообщение уже существует в очереди.  
  
 Метод <xref:System.Messaging.MessageQueue.BeginPeek%2A> возвращает значение немедленно, но асинхронная операция не завершается до вызова обработчика событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginPeek%2A> является асинхронным, его можно вызвать для просмотра очереди, не блокируя текущий поток выполнения. Для синхронного просмотра очереди используйте метод <xref:System.Messaging.MessageQueue.Peek%2A>.  
  
 После завершения асинхронной операции можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> в обработчике событий, чтобы получать уведомления.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> возвращает <xref:System.IAsyncResult>, который идентифицирует асинхронную операцию, запущенную методом. Этот <xref:System.IAsyncResult> можно использовать в течение всего времени существования операции, хотя обычно он не используется, пока не будет вызвана <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>. Однако при запуске нескольких асинхронных операций можно поместить их <xref:System.IAsyncResult> значения в массив и указать, следует ли дожидаться завершения всех операций или любой операции. В этом случае используйте свойство <xref:System.IAsyncResult.AsyncWaitHandle%2A> <xref:System.IAsyncResult>, чтобы указать завершенную операцию.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, если вы вызываете <xref:System.Messaging.MessageQueue.BeginPeek%2A> несколько раз для инициации нескольких операций, каждую операцию можно определить с помощью отдельного определяемого объекта State.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Для параметра <paramref name="action" /> было задано значение, отличное от <see langword="PeekAction.Current" /> или <see langword="PeekAction.Next" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <summary>Инициирует асинхронную операцию получения, указывая службе MSMQ на необходимость запуска операции получения сообщения и уведомления обработчика событий о завершении операции.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициирует асинхронную операцию получения без тайм-аута. Операция остается незавершенной, пока сообщение не станет доступным в очереди.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При асинхронной обработке можно использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, чтобы вызвать событие <xref:System.Messaging.MessageQueue.ReceiveCompleted>, когда сообщение было удалено из очереди.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также создается, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который обрабатывает результаты асинхронной операции и связывает его с делегатом события. <xref:System.Messaging.MessageQueue.BeginReceive%2A> инициирует асинхронную операцию получения; <xref:System.Messaging.MessageQueue> уведомляется, вызывая событие <xref:System.Messaging.MessageQueue.ReceiveCompleted>, когда сообщение поступает в очередь. После этого <xref:System.Messaging.MessageQueue> может получить доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Метод <xref:System.Messaging.MessageQueue.BeginReceive%2A> возвращает значение немедленно, но асинхронная операция не завершается до вызова обработчика событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди, не блокируя текущий поток выполнения. Чтобы синхронно получить сообщение, используйте метод <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 После завершения асинхронной операции можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> в обработчике событий, чтобы получать уведомления.  
  
 <xref:System.IAsyncResult>, который <xref:System.Messaging.MessageQueue.BeginReceive%2A> возвращает, идентифицирует асинхронную операцию, запущенную методом. Этот <xref:System.IAsyncResult> можно использовать в течение всего времени существования операции, хотя обычно он не используется, пока не будет вызвана <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>. Однако при запуске нескольких асинхронных операций можно поместить их <xref:System.IAsyncResult> значения в массив и указать, следует ли дожидаться завершения всех операций или любой операции. В этом случае для задания завершенной операции используется свойство <xref:System.IAsyncResult.AsyncWaitHandle%2A> <xref:System.IAsyncResult>.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> `false`, вызывается событие завершения, но при вызове <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>возникнет исключение.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и помещайте транзакцию и метод (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> в обработчике событий, созданном для операции просмотра. Обработчик событий может содержать функциональные возможности, как показано в следующем C# коде.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода демонстрируется последовательное выполнение асинхронных запросов. Предполагается, что на локальном компьютере имеется очередь с именем «myQueue». Функция `Main` начинает асинхронную операцию, которая обрабатывается `MyReceiveCompleted` подпрограммы. `MyReceiveCompleted` обрабатывает текущее сообщение и начинает новую асинхронную операцию получения.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 В следующем примере кода асинхронные запросы поступают в очередь. Вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> использует <xref:System.IAsyncResult.AsyncWaitHandle%2A> в его возвращаемом значении. Перед выходом подпрограмма `Main` ожидает завершения всех асинхронных операций.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <summary>Инициирует асинхронную операцию получения с указанным тайм-аутом. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При асинхронной обработке можно использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, чтобы вызвать событие <xref:System.Messaging.MessageQueue.ReceiveCompleted>, когда сообщение станет доступным в очереди или когда истечет указанный интервал времени.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также создается, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который обрабатывает результаты асинхронной операции и связывает его с делегатом события. <xref:System.Messaging.MessageQueue.BeginReceive%2A> инициирует асинхронную операцию получения; <xref:System.Messaging.MessageQueue> уведомляется, вызывая событие <xref:System.Messaging.MessageQueue.ReceiveCompleted>, когда сообщение поступает в очередь. Затем <xref:System.Messaging.MessageQueue> может получить доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> или извлекая результат с помощью <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Метод <xref:System.Messaging.MessageQueue.BeginReceive%2A> возвращает значение немедленно, но асинхронная операция не завершается до вызова обработчика событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди, не блокируя текущий поток выполнения. Чтобы синхронно получить сообщение, используйте метод <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 После завершения асинхронной операции можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> в обработчике событий, чтобы получать уведомления.  
  
 Если <xref:System.Messaging.MessageQueue.CanRead%2A> `false`, вызывается событие завершения, но при вызове <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>возникнет исключение.  
  
 <xref:System.IAsyncResult>, который <xref:System.Messaging.MessageQueue.BeginReceive%2A> возвращает, идентифицирует асинхронную операцию, запущенную методом. Этот <xref:System.IAsyncResult> можно использовать в течение всего времени существования операции, хотя обычно он не используется, пока не будет вызвана <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>. Однако при запуске нескольких асинхронных операций можно поместить их <xref:System.IAsyncResult> значения в массив и указать, следует ли дожидаться завершения всех операций или любой операции. В этом случае для задания завершенной операции используется свойство <xref:System.IAsyncResult.AsyncWaitHandle%2A> <xref:System.IAsyncResult>.  
  
 Эта перегрузка задает время ожидания. Если интервал, указанный параметром `timeout`, истекает, этот компонент создает событие <xref:System.Messaging.MessageQueue.ReceiveCompleted>. Поскольку сообщение не существует, последующий вызов <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> будет вызывать исключение.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и помещайте транзакцию и метод (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> в обработчике событий, созданном для операции просмотра. Обработчик событий может содержать функциональные возможности, как показано в следующем C# коде.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронная операция получения. В примере кода создается обработчик событий, `MyReceiveCompleted`и присоединяется к делегату обработчика событий <xref:System.Messaging.MessageQueue.ReceiveCompleted>. Пример кода отправляет сообщение в локальную очередь сообщений, а затем вызывает <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, передавая значение времени ожидания в десять секунд. При возникновении события <xref:System.Messaging.MessageQueue.ReceiveCompleted> обработчик событий получает сообщение и записывает текст сообщения на экран.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо. Возможно, было введено отрицательное число.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="stateObject">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <summary>Инициирует асинхронную операцию получения с указанным тайм-аутом и заданным объектом состояния, который предоставляет связанные данные в течение всего времени выполнения операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При асинхронной обработке можно использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, чтобы вызвать событие <xref:System.Messaging.MessageQueue.ReceiveCompleted>, когда сообщение станет доступным в очереди или когда истечет указанный интервал времени.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также создается, если сообщение уже существует в очереди.  
  
 Используйте эту перегрузку, чтобы связать сведения с операцией, которая будет сохранена в течение всего времени существования операции. Обработчик событий может обнаружить эти сведения, просмотрев свойство <xref:System.IAsyncResult.AsyncState%2A> <xref:System.IAsyncResult>, связанного с операцией.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который обрабатывает результаты асинхронной операции и связывает его с делегатом события. <xref:System.Messaging.MessageQueue.BeginReceive%2A> инициирует асинхронную операцию получения; <xref:System.Messaging.MessageQueue> уведомляется, вызывая событие <xref:System.Messaging.MessageQueue.ReceiveCompleted>, когда сообщение поступает в очередь. Затем <xref:System.Messaging.MessageQueue> может получить доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> или извлекая результат с помощью <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Метод <xref:System.Messaging.MessageQueue.BeginReceive%2A> возвращает значение немедленно, но асинхронная операция не завершается до вызова обработчика событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди, не блокируя текущий поток выполнения. Чтобы синхронно получить сообщение, используйте метод <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 После завершения асинхронной операции можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> в обработчике событий, чтобы получать уведомления.  
  
 <xref:System.IAsyncResult>, который <xref:System.Messaging.MessageQueue.BeginReceive%2A> возвращает, идентифицирует асинхронную операцию, запущенную методом. Этот <xref:System.IAsyncResult> можно использовать в течение всего времени существования операции, хотя обычно он не используется, пока не будет вызвана <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>. Однако при запуске нескольких асинхронных операций можно поместить их <xref:System.IAsyncResult> значения в массив и указать, следует ли дожидаться завершения всех операций или любой операции. В этом случае для задания завершенной операции используется свойство <xref:System.IAsyncResult.AsyncWaitHandle%2A> <xref:System.IAsyncResult>.  
  
 Эта перегрузка задает время ожидания и объект состояния. Если интервал, указанный параметром `timeout`, истекает, этот компонент создает событие <xref:System.Messaging.MessageQueue.ReceiveCompleted>. Поскольку сообщение не существует, последующий вызов <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> будет вызывать исключение.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, если вы вызываете <xref:System.Messaging.MessageQueue.BeginReceive%2A> несколько раз для инициации нескольких операций, каждую операцию можно определить с помощью отдельного определяемого объекта State.  
  
 Объект состояния также можно использовать для передачи сведений между потоками процесса. Если поток запущен, но обратный вызов находится в другом потоке в асинхронном сценарии, объект состояния маршалируется и передается обратно вместе со сведениями из события.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и помещайте транзакцию и метод (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> в обработчике событий, созданном для операции просмотра. Обработчик событий может содержать функциональные возможности, как показано в следующем C# коде.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронная операция получения. В примере кода создается обработчик событий, `MyReceiveCompleted`и присоединяется к делегату обработчика событий <xref:System.Messaging.MessageQueue.ReceiveCompleted>. В примере кода сообщение отправляется в локальную очередь сообщений, затем вызывается <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, передача значения времени ожидания составляет десять секунд и уникальное целое число, идентифицирующее конкретное сообщение. При возникновении события <xref:System.Messaging.MessageQueue.ReceiveCompleted> обработчик событий получает сообщение и записывает на экран текст сообщения и идентификатор целочисленного сообщения.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="stateObject">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <param name="callback">Объект <see cref="T:System.AsyncCallback" />, принимающий уведомление о завершении асинхронной операции.</param>
        <summary>Инициирует асинхронную операцию получения с указанным тайм-аутом и заданным объектом состояния, который предоставляет связанные данные в течение всего времени выполнения операции. Посредством обратного вызова эта перегрузка получает уведомление об отличительных особенностях обработчика событий для операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этой перегрузки функция обратного вызова, указанная в параметре обратного вызова, вызывается непосредственно в том случае, когда сообщение становится доступным в очереди или по истечении заданного интервала времени. событие <xref:System.Messaging.MessageQueue.ReceiveCompleted> не возникает. Другие перегрузки <xref:System.Messaging.MessageQueue.BeginReceive%2A> используют этот компонент для вызова события <xref:System.Messaging.MessageQueue.ReceiveCompleted>.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также создается, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который обрабатывает результаты асинхронной операции и связывает его с делегатом события. <xref:System.Messaging.MessageQueue.BeginReceive%2A> инициирует асинхронную операцию получения; <xref:System.Messaging.MessageQueue> уведомляется, вызывая событие <xref:System.Messaging.MessageQueue.ReceiveCompleted>, когда сообщение поступает в очередь. Затем <xref:System.Messaging.MessageQueue> может получить доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> или извлекая результат с помощью <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Метод <xref:System.Messaging.MessageQueue.BeginReceive%2A> возвращает значение немедленно, но асинхронная операция не завершается до вызова обработчика событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди, не блокируя текущий поток выполнения. Чтобы синхронно получить сообщение, используйте метод <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 После завершения асинхронной операции можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> в обработчике событий, чтобы получать уведомления.  
  
 <xref:System.IAsyncResult>, который <xref:System.Messaging.MessageQueue.BeginReceive%2A> возвращает, идентифицирует асинхронную операцию, запущенную методом. Этот <xref:System.IAsyncResult> можно использовать в течение всего времени существования операции, хотя обычно он не используется, пока не будет вызвана <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>. Однако при запуске нескольких асинхронных операций можно поместить их <xref:System.IAsyncResult> значения в массив и указать, следует ли дожидаться завершения всех операций или любой операции. В этом случае для задания завершенной операции используется свойство <xref:System.IAsyncResult.AsyncWaitHandle%2A> <xref:System.IAsyncResult>.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, если вы вызываете <xref:System.Messaging.MessageQueue.BeginReceive%2A> несколько раз для инициации нескольких операций, каждую операцию можно определить с помощью отдельного определяемого объекта State.  
  
 Объект состояния также можно использовать для передачи сведений между потоками процесса. Если поток запущен, но обратный вызов находится в другом потоке в асинхронном сценарии, объект состояния маршалируется и передается обратно вместе со сведениями из события.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и помещайте транзакцию и метод (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> в обработчике событий, созданном для операции просмотра. Обработчик событий может содержать функциональные возможности, как показано в следующем C# коде.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается асинхронная операция получения. В примере кода сообщение отправляется в локальную очередь сообщений, затем вызывается <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, передача: время ожидания — десять секунд; уникальное целое число, идентифицирующее конкретное сообщение; и новый экземпляр <xref:System.AsyncCallback>, который идентифицирует обработчик событий `MyReceiveCompleted`. При возникновении события <xref:System.Messaging.MessageQueue.ReceiveCompleted> обработчик событий получает сообщение и записывает на экран текст сообщения и идентификатор целочисленного сообщения.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, который показывает период времени ожидания доступности сообщения.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="state">Задаваемый приложением объект состояния, который содержит сведения, связанные с асинхронной операцией.</param>
        <param name="callback">Объект <see cref="T:System.AsyncCallback" />, принимающий уведомление о завершении асинхронной операции.</param>
        <summary>Инициирует асинхронную операцию получения, которая имеет заданный тайм-аут и использует заданный курсор и заданный объект состояния. Объект состояния предоставляет связанные сведения в течение всего времени выполнения операции. Посредством обратного вызова эта перегрузка получает уведомление об отличительных особенностях обработчика событий для операции. Операция остается незавершенной, пока сообщение не станет доступным в очереди или пока не истечет время ожидания.</summary>
        <returns>Объект <see cref="T:System.IAsyncResult" />, идентифицирующий размещенный асинхронный запрос.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этой перегрузки функция обратного вызова, указанная в параметре обратного вызова, вызывается непосредственно в том случае, когда сообщение становится доступным в очереди или по истечении заданного интервала времени. событие <xref:System.Messaging.MessageQueue.ReceiveCompleted> не возникает. Другие перегрузки <xref:System.Messaging.MessageQueue.BeginReceive%2A> используют этот компонент для вызова события <xref:System.Messaging.MessageQueue.ReceiveCompleted>.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> также создается, если сообщение уже существует в очереди.  
  
 Чтобы использовать <xref:System.Messaging.MessageQueue.BeginReceive%2A>, создайте обработчик событий, который обрабатывает результаты асинхронной операции и связывает его с делегатом события. <xref:System.Messaging.MessageQueue.BeginReceive%2A> инициирует асинхронную операцию получения; <xref:System.Messaging.MessageQueue> уведомляется, вызывая событие <xref:System.Messaging.MessageQueue.ReceiveCompleted>, когда сообщение поступает в очередь. Затем <xref:System.Messaging.MessageQueue> может получить доступ к сообщению, вызвав <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> или извлекая результат с помощью <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Метод <xref:System.Messaging.MessageQueue.BeginReceive%2A> возвращает значение немедленно, но асинхронная операция не завершается до вызова обработчика событий.  
  
 Поскольку <xref:System.Messaging.MessageQueue.BeginReceive%2A> является асинхронным, его можно вызвать для получения сообщения из очереди, не блокируя текущий поток выполнения. Чтобы синхронно получить сообщение, используйте метод <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 После завершения асинхронной операции можно вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> или <xref:System.Messaging.MessageQueue.BeginReceive%2A> в обработчике событий, чтобы получать уведомления.  
  
 <xref:System.IAsyncResult>, который <xref:System.Messaging.MessageQueue.BeginReceive%2A> возвращает, идентифицирует асинхронную операцию, запущенную методом. Этот <xref:System.IAsyncResult> можно использовать в течение всего времени существования операции, хотя обычно он не используется, пока не будет вызвана <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>. Однако при запуске нескольких асинхронных операций можно поместить их <xref:System.IAsyncResult> значения в массив и указать, следует ли дожидаться завершения всех операций или любой операции. В этом случае используйте свойство <xref:System.IAsyncResult.AsyncWaitHandle%2A> <xref:System.IAsyncResult>, чтобы указать завершенную операцию.  
  
 Объект состояния связывает сведения о состоянии с операцией. Например, если вы вызываете <xref:System.Messaging.MessageQueue.BeginReceive%2A> несколько раз для инициации нескольких операций, каждую операцию можно определить с помощью отдельного определяемого объекта State.  
  
 Объект состояния также можно использовать для передачи сведений между потоками процесса. Если поток запущен, но обратный вызов находится в другом потоке в асинхронном сценарии, объект состояния маршалируется и передается обратно вместе со сведениями из события.  
  
 Не используйте асинхронный вызов <xref:System.Messaging.MessageQueue.BeginReceive%2A> с транзакциями. Если вы хотите выполнить транзакционную асинхронную операцию, вызовите <xref:System.Messaging.MessageQueue.BeginPeek%2A>и помещайте транзакцию и метод (синхронный) <xref:System.Messaging.MessageQueue.Receive%2A> в обработчике событий, созданном для операции просмотра. Обработчик событий может содержать функциональные возможности, как показано в следующем C# коде.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, может ли быть прочитан объект <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <value>Значение <see langword="true" />, если класс <see cref="T:System.Messaging.MessageQueue" /> существует, и приложение может прочитать данные из него; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> указывает, может ли приложение просматривать или получать сообщения из очереди. Если <xref:System.Messaging.MessageQueue.CanRead%2A> `true`, <xref:System.Messaging.MessageQueue> может принимать или просматривать сообщения из очереди. В противном случае он не может.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> `false`, если очередь уже открыта с монопольным доступом на чтение (или если она открыта с неисключительным доступом, а эта <xref:System.Messaging.MessageQueue> требует монопольного доступа) или если у приложения недостаточно прав для доступа к нему. Если приложение пытается выполнить чтение из очереди, когда <xref:System.Messaging.MessageQueue.CanRead%2A> `false`, доступ запрещается.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода выводится значение свойства <xref:System.Messaging.MessageQueue.CanRead%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, может ли быть выполнена запись в <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <value>Значение <see langword="true" />, если класс <see cref="T:System.Messaging.MessageQueue" /> существует, и приложение может записать в него данные; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> указывает, может ли приложение передавать сообщения в очередь. Если <xref:System.Messaging.MessageQueue.CanWrite%2A> `true`, <xref:System.Messaging.MessageQueue> может отправить сообщения в очередь. В противном случае он не может.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> `false`, если очередь уже открыта с монопольным доступом на запись (или если она открыта с неисключительным доступом, а эта <xref:System.Messaging.MessageQueue> требует монопольного доступа) или если приложение не имеет достаточных прав для доступа к нему. Если приложение пытается выполнить запись в очередь, когда <xref:System.Messaging.MessageQueue.CanWrite%2A> `false`, доступ запрещается.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода выводится значение свойства <xref:System.Messaging.MessageQueue.CanWrite%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает категорию очереди.</summary>
        <value>Объект <see cref="T:System.Guid" />, представляющий категорию очереди (идентификатор типа очереди сообщений), которая позволяет приложению классифицировать его очереди. Значение по умолчанию — <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Категория очереди позволяет приложению классифицировать свои очереди. Например, можно разместить все очереди выставления счетов в одной категории, а все очереди заказов — в другой.  
  
 Свойство <xref:System.Messaging.MessageQueue.Category%2A> предоставляет доступ к свойству идентификатора типа очереди сообщений (доступному для чтения и записи), доступному в диалоговом окне **Свойства очереди** консоли управления компьютером. Можно определить новую категорию. Хотя <xref:System.Guid.NewGuid%2A> можно использовать для создания значения категории, уникального для всех <xref:System.Guid> значений, такое действие не требуется. Значение категории должно отличаться только от других категорий, а не от всех других <xref:System.Guid> значений. Например, можно назначить {00000000-0000-0000-0000-000000000001} в качестве <xref:System.Messaging.MessageQueue.Category%2A> для одного набора очередей и {00000000-0000-0000-0000-000000000002} в качестве <xref:System.Messaging.MessageQueue.Category%2A> для другого набора.  
  
 Задавать <xref:System.Messaging.MessageQueue.Category%2A>не обязательно. Допускается значение `null`.  
  
 Задание этого свойства изменяет очередь сообщений. Поэтому изменение повлияет на все другие экземпляры <xref:System.Messaging.MessageQueue>.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение свойства <xref:System.Messaging.MessageQueue.Category%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для категории очереди задано недопустимое значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Очищает кэш подключений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>имена форматов, хранящиеся в кэше, удаляются, а открытые и сохраненные в кэше дескрипторы закрываются.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В приведенном ниже примере кода вызывается <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, выделенные классом <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> освобождает все ресурсы, связанные с <xref:System.Messaging.MessageQueue>, включая общие ресурсы, если это уместно. Система повторно запрашивает эти ресурсы, если они все еще доступны, например при вызове метода <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, как показано в следующем C# коде.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 При вызове <xref:System.Messaging.MessageQueue.Close%2A>удаляются все свойства <xref:System.Messaging.MessageQueue>, которые напрямую обращаются к очереди очереди сообщений. <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>и <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> остаются в том виде, в котором они были.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> не всегда освобождает дескрипторы чтения и записи в очередь, так как они могут быть общими. Чтобы убедиться, что <xref:System.Messaging.MessageQueue.Close%2A> освобождает дескрипторы чтения и записи в очередь, можно выполнить любое из следующих действий.  
  
-   Создайте <xref:System.Messaging.MessageQueue> с монопольным доступом. Для этого вызовите конструктор <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> или <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> и задайте для параметра `sharedModeDenyReceive` значение `true`.  
  
-   Создайте <xref:System.Messaging.MessageQueue> с отключенным кэшированием подключений. Для этого вызовите конструктор <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> и задайте для параметра `enableConnectionCache` значение `false`.  
  
-   Отключите кэширование подключения. Для этого задайте для свойства <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> значение `false`.  
  
 Перед удалением очереди на сервере очереди сообщений следует вызвать <xref:System.Messaging.MessageQueue.Close%2A> для очереди. В противном случае сообщения, отправленные в очередь, могут вызвать исключения или появиться в очереди недоставленных сообщений.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода закрывается очередь очереди сообщений.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новую очередь на сервере очереди сообщений по указанному пути.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Путь создаваемой очереди.</param>
        <summary>Создает нетранзакционную очередь сообщений по указанному пути.</summary>
        <returns>Класс <see cref="T:System.Messaging.MessageQueue" />, представляющий новую очередь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, чтобы создать нетранзакционную очередь очереди сообщений.  
  
 Чтобы создать новый экземпляр класса <xref:System.Messaging.MessageQueue> в приложении и привязать его к существующей очереди, используйте конструктор <xref:System.Messaging.MessageQueue.%23ctor%2A>. Чтобы создать новую очередь в очереди сообщений, вызовите <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Синтаксис параметра `path` зависит от типа очереди, на которую он ссылается, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частная очередь|`MachineName`\\`Private$`\\`QueueName`|  
  
 Используйте "." для локального компьютера. Дополнительные сведения о синтаксисе см. в описании свойства <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода создаются общие и частные очереди. Он отправляет сообщение в выбранные очереди.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="path" /> — <see langword="null" /> или пустая строка ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">По указанному пути уже существует очередь.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Путь создаваемой очереди.</param>
        <param name="transactional">Значение <see langword="true" />, если необходимо создать транзакционную очередь; значение <see langword="false" />, если необходимо создать нетранзакционную очередь.</param>
        <summary>Создает транзакционную или нетранзакционную очередь сообщений по указанному пути.</summary>
        <returns>Класс <see cref="T:System.Messaging.MessageQueue" />, представляющий новую очередь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эту перегрузку можно использовать для создания транзакционной очереди в очереди сообщений. Можно создать нетранзакционную очередь, установив параметр `transactional` в значение `false` или вызвав другую перегрузку <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Чтобы создать новый экземпляр класса <xref:System.Messaging.MessageQueue> в приложении и привязать его к существующей очереди, используйте конструктор <xref:System.Messaging.MessageQueue.%23ctor%2A>. Чтобы создать новую очередь в очереди сообщений, вызовите <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Синтаксис параметра `path` зависит от типа очереди, на которую он ссылается, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частная очередь|`MachineName`\\`Private$`\\`QueueName`|  
  
 Используйте "." для локального компьютера. Дополнительные сведения о синтаксисе см. в описании свойства <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода создаются открытые и частные транзакционные очереди. Он отправляет сообщение в выбранные очереди.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="path" /> — <see langword="null" /> или пустая строка ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">По указанному пути уже существует очередь.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый объект <see cref="T:System.Messaging.Cursor" /> для текущей очереди сообщений.</summary>
        <returns>Новый объект <see cref="T:System.Messaging.Cursor" /> для текущей очереди сообщений. Этот курсор используется для сохранения определенного положения в очереди при чтении сообщений очереди.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время и дату создания очереди в службе очереди сообщений.</summary>
        <value>Объект <see cref="T:System.DateTime" /> представляющий дату и время создания очереди.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> относится к очереди на сервере очереди сообщений, а не к экземпляру <xref:System.Messaging.MessageQueue>.  
  
 Если очередь существует, это свойство представляет время создания очереди, корректируется на местное время сервера, на котором существует очередь.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода выводится значение свойства <xref:System.Messaging.MessageQueue.CreateTime%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значения свойств сообщения, которые будут использоваться по умолчанию, когда приложение будет отправлять сообщения в очередь.</summary>
        <value>Свойство <see cref="T:System.Messaging.DefaultPropertiesToSend" />, содержащее используемые по умолчанию значения свойств сообщений очереди сообщений, которые применяются, когда приложение отправляет в очередь объекты, отличные от экземпляров <see cref="T:System.Messaging.Message" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При отправке в очередь любого объекта, который не относится к типу <xref:System.Messaging.Message>, <xref:System.Messaging.MessageQueue> вставляет объект в сообщение очереди сообщений. В это время <xref:System.Messaging.MessageQueue> применяется к сообщению о значениях свойств, указанных в свойстве <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. И наоборот, при отправке <xref:System.Messaging.Message> в очередь эти свойства уже указаны для самого экземпляра, поэтому <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> игнорируется для <xref:System.Messaging.Message>.  
  
 Хотя свойства задаются с помощью объекта <xref:System.Messaging.MessageQueue>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> ссылается на свойства сообщений, которые отправляются в очередь, а не в саму очередь.  
  
 Значения по умолчанию для свойств показаны в следующей таблице.  
  
|Свойство.|Значение по умолчанию|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Ноль (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Массив байтов нулевой длины|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|пустая строка ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода используется приоритет сообщения для определения свойств по умолчанию для отправки сообщения.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для очереди нельзя задать использующиеся по умолчанию свойства. Возможно, потому что неправильно задано одно из свойств.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Расположение удаляемой очереди.</param>
        <summary>Удаляет очередь с сервера очереди сообщений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Синтаксис параметра `path` зависит от типа очереди.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частная очередь|`MachineName`\\`Private$`\\`QueueName`|  
  
 Дополнительные сведения о синтаксисе см. в описании свойства <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Кроме того, можно использовать <xref:System.Messaging.MessageQueue.FormatName%2A> или <xref:System.Messaging.MessageQueue.Label%2A> для описания пути очереди.  
  
|Ссылка|Синтаксис|  
|---------------|------------|  
|Название формата|FormatName: [ *имя формата* ]|  
|Метка|Метка: [ *Метка* ]|  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода удаляется очередь очереди сообщений, если она существует.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="path" /> — <see langword="null" /> или пустая строка ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Для параметра <paramref name="path" /> используется неправильный синтаксис.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, имеет ли этот объект <see cref="T:System.Messaging.MessageQueue" /> монопольный доступ на получение сообщений из очереди сообщений.</summary>
        <value>Значение <see langword="true" />, если этот класс <see cref="T:System.Messaging.MessageQueue" /> имеет права монопольного доступа для получения сообщений из очереди; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> указывает общий режим очереди, на который ссылается эта <xref:System.Messaging.MessageQueue>. Задайте для параметра <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> значение `true`, чтобы указать, что только эта <xref:System.Messaging.MessageQueue> должна иметь доступ для просмотра и получения сообщений из очереди с указанным <xref:System.Messaging.MessageQueue.Path%2A>. Если другой <xref:System.Messaging.MessageQueue> или другое приложение связано с одним и тем же ресурсом очереди, этот экземпляр или приложение не сможет просматривать или получать сообщения, но по-прежнему может отправлять их.  
  
 Если <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> `false`, очередь будет доступна нескольким приложениям для отправки, просмотра или получения сообщений.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение свойства <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</param>
        <summary>Уничтожает ресурсы (кроме памяти), используемые классом <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> по окончании использования класса <xref:System.Messaging.MessageQueue>. Метод <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> оставляет класс <xref:System.Messaging.MessageQueue> в непригодном для использования состоянии. После вызова <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>необходимо освободить все ссылки на <xref:System.Messaging.MessageQueue>, чтобы память, которую он занимают, могла быть освобождена при сборке мусора.  
  
 Перед освобождением последней ссылки на <xref:System.Messaging.MessageQueue>следует вызвать <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>. В противном случае ресурсы, которые использует <xref:System.Messaging.MessageQueue>, не будут освобождены до тех пор, пока сборка мусора не вызовет деструктор объекта <xref:System.Messaging.MessageQueue>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, будет ли приложение поддерживать кэш подключений.</summary>
        <value>Значение <see langword="true" />, если необходимо создать и использовать кэш подключений; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кэш подключений — это список ссылок на структуры, которые содержат дескрипторы чтения или записи для очередей. Если <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> `true`, <xref:System.Messaging.MessageQueue> берет дескрипторы из кэша каждый раз, когда вызывает <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>или <xref:System.Messaging.MessageQueue.Receive%2A>, а не открывает новые дескрипторы. Это может повысить производительность. Использование кэша соединений также изолирует <xref:System.Messaging.MessageQueue> от изменений в топологии сети.  
  
 При создании нового соединения с очередью, когда кэш подключения полон, <xref:System.Messaging.MessageQueue> перезаписывает самый последний доступную структуру с новым соединением. Можно полностью очистить кэш, вызвав <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, например, если имена форматов очередей, с которыми вы работаете, изменились так, чтобы предыдущие дескрипторы чтения и записи стали недействительными.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение свойства <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, будет ли очередь принимать только неконфиденциальные (незашифрованные) сообщения.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Messaging.EncryptionRequired" />. Значение по умолчанию — <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если указано, что шифрование требуется для сообщений, отправляемых в очередь, шифруются только тексты сообщений. Другие члены (например, свойства <xref:System.Messaging.Message.Label%2A> и <xref:System.Messaging.Message.SenderId%2A>) не могут быть зашифрованы.  
  
 Задание этого свойства изменяет очередь сообщений. Поэтому изменение повлияет на все другие экземпляры <xref:System.Messaging.MessageQueue>.  
  
 При шифровании сообщения сообщение становится частным. Чтобы задать для `None`, `Body`или `Optional` требование шифрования очереди, необходимо соответствующим образом установить свойство <xref:System.Messaging.MessageQueue.EncryptionRequired%2A>. Параметр <xref:System.Messaging.Message.UseEncryption%2A> сообщения должен соответствовать требованиям к шифрованию очереди. Если сообщение не зашифровано, а очередь указывает `Body`или если сообщение зашифровано, но в очереди указано `None`, сообщение отклоняется очередью. Если отправляющее приложение запрашивает в этом событии отрицательное сообщение подтверждения, очередь сообщений указывает на отклонение сообщения отправляющему приложению. Если свойство <xref:System.Messaging.Message.UseDeadLetterQueue%2A> имеет значение `true`, сообщение, которое не удается выполнить шифрование, отправляется в очередь недоставленных сообщений. В противном случае сообщение будет потеряно.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение свойства <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, определяющий асинхронную операцию считывания, которая завершается и из которой извлекается конечный результат.</param>
        <summary>Завершает указанную асинхронную операцию считывания.</summary>
        <returns>Класс <see cref="T:System.Messaging.Message" />, связанный с завершенной асинхронной операцией.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события <xref:System.Messaging.MessageQueue.PeekCompleted> <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> завершает операцию, которая была инициирована вызовом <xref:System.Messaging.MessageQueue.BeginPeek%2A>. Для этого <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> просматривает сообщение.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> может указать время ожидания, которое приводит к возникновению события <xref:System.Messaging.MessageQueue.PeekCompleted>, если время ожидания возникает до появления сообщения в очереди. Если время ожидания происходит без сообщения, поступающего в очередь, последующий вызов <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> вызывает исключение.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> используется для чтения сообщения, которое привело к возникновению события <xref:System.Messaging.MessageQueue.PeekCompleted>.  
  
 Если вы хотите продолжить асинхронное считывание сообщений, можно снова вызвать <xref:System.Messaging.MessageQueue.BeginPeek%2A> после вызова <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода создается обработчик событий с именем `MyPeekCompleted`, присоединяется к делегату обработчика событий <xref:System.Messaging.MessageQueue.PeekCompleted> и вызывается <xref:System.Messaging.MessageQueue.BeginPeek%2A> для инициации асинхронной операции просмотра в очереди, расположенной по пути ".\Микуеуе". При возникновении события <xref:System.Messaging.MessageQueue.PeekCompleted> в примере считывается сообщение и записывается его текст на экран. Затем в примере вызывается <xref:System.Messaging.MessageQueue.BeginPeek%2A> еще раз, чтобы инициировать новую асинхронную операцию просмотра.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="asyncResult" /> используется неправильный синтаксис.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект <see cref="T:System.IAsyncResult" />, определяющий асинхронную операцию получения, которая завершается и из которой извлекается конечный результат.</param>
        <summary>Завершает указанную асинхронную операцию получения.</summary>
        <returns>Класс <see cref="T:System.Messaging.Message" />, связанный с завершенной асинхронной операцией.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события <xref:System.Messaging.MessageQueue.ReceiveCompleted> <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> завершает операцию, которая была инициирована вызовом <xref:System.Messaging.MessageQueue.BeginReceive%2A>. Для этого <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> получает сообщение.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> может указать время ожидания, которое приводит к возникновению события <xref:System.Messaging.MessageQueue.ReceiveCompleted>, если время ожидания возникает до появления сообщения в очереди. Если время ожидания происходит без сообщения, поступающего в очередь, последующий вызов <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> вызывает исключение.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> используется для чтения (удаления из очереди) сообщения, которое вызвало возникновение события <xref:System.Messaging.MessageQueue.ReceiveCompleted>.  
  
 Если вы хотите продолжить асинхронное получение сообщений, можно снова вызвать <xref:System.Messaging.MessageQueue.BeginReceive%2A> после вызова <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода демонстрируется последовательное выполнение асинхронных запросов. Предполагается, что на локальном компьютере имеется очередь с именем «myQueue». Функция `Main` начинает асинхронную операцию, которая обрабатывается `MyReceiveCompleted` подпрограммы. `MyReceiveCompleted` обрабатывает текущее сообщение и начинает новую асинхронную операцию получения.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="asyncResult" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="asyncResult" /> используется неправильный синтаксис.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Расположение искомой очереди.</param>
        <summary>Определяет, существует ли по указанному пути очередь сообщений.</summary>
        <returns>Значение <see langword="true" />, если очередь по указанному пути существует; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Messaging.MessageQueue.Exists%28System.String%29> определяет, существует ли очередь очереди сообщений по указанному пути. Метод не существует, чтобы определить, существует ли очередь с указанным именем формата. Дополнительные сведения о синтаксисе имени формата и других формах синтаксиса пути см. в описании свойства <xref:System.Messaging.MessageQueue.Path%2A>.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> является дорогостоящей операцией. Используйте его только в том случае, если это необходимо в приложении.  
  
> [!NOTE]
>  Метод <xref:System.Messaging.MessageQueue.Exists%28System.String%29> не поддерживает префикс <xref:System.Messaging.MessageQueue.FormatName%2A>.  
  
 Синтаксис параметра `path` зависит от типа очереди, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
  
 невозможно вызвать <xref:System.Messaging.MessageQueue.Exists%28System.String%29> для проверки существования удаленной частной очереди.  
  
 Дополнительные сведения о синтаксисе см. в описании свойства <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Кроме того, можно использовать <xref:System.Messaging.MessageQueue.Label%2A> для описания пути очереди.  
  
|Ссылка|Синтаксис|  
|---------------|------------|  
|Метка|Метка: [`label`]|  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода проверяется, существует ли очередь очереди сообщений, а затем удаляется.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Неправильный синтаксис параметра <paramref name="path" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.  
  
- или - 
Метод <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> вызывается на удаленной частной очереди.</exception>
        <exception cref="T:System.InvalidOperationException">При проверке существования очереди приложение использовало синтаксис имени формата.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает уникальное имя очереди, созданное службой очереди сообщений в момент создания очереди.</summary>
        <value>Имя очереди, которое является уникальным в сети.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Messaging.MessageQueue.FormatName%2A> содержит имя формата очереди. Служба очереди сообщений использует имя формата для указания открываемой очереди и способа доступа к ней. В отличие от большинства характеристик очереди, имя формата не является свойством очереди сообщений очереди приложений, поэтому доступ к нему через средство управления очередями сообщений не предоставляется. Имя формата — это просто уникальное имя очереди, которое очередь сообщений создает при создании очереди или создании приложения позже.  
  
 Если указать путь с помощью синтаксиса имени пути (например, `myComputer\myQueue`) вместо использования синтаксиса имени формата при чтении или записи в очередь, основной контроллер домена (который использует Active Directory) преобразует <xref:System.Messaging.MessageQueue.Path%2A> в связанный <xref:System.Messaging.MessageQueue.FormatName%2A> перед доступом к очереди. Если приложение работает в автономном режиме, необходимо использовать синтаксис имени формата. в противном случае основной контроллер домена не будет доступен для преобразования пути.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода выводится значение свойства <xref:System.Messaging.MessageQueue.FormatName%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><see cref="P:System.Messaging.MessageQueue.Path" /> не указывается.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает модуль форматирования, используемый для сериализации объекта в текст сообщения или десериализации из текста сообщения, прочитанного из очереди или записанного в очередь.</summary>
        <value>Объект <see cref="T:System.Messaging.IMessageFormatter" />, создающий поток, записываемый в текст сообщения или считываемый из него. Значение по умолчанию — <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Messaging.MessageQueue.Formatter%2A> содержит экземпляр объекта модуля форматирования, который преобразует сообщения при чтении или записи приложения в очередь.  
  
 Когда приложение отправляет сообщение в очередь, модуль форматирования сериализует объект в поток и вставляет его в текст сообщения. При чтении из очереди модуль форматирования десериализует данные сообщения в свойство <xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.Message>.  
  
 <xref:System.Messaging.XmlMessageFormatter> слабо связан, поэтому при использовании этого формата необязательно иметь тот же тип объекта для отправителя и получателя. <xref:System.Messaging.ActiveXMessageFormatter> и <xref:System.Messaging.BinaryMessageFormatter> сериализуются данные в двоичное представление. <xref:System.Messaging.ActiveXMessageFormatter> используется при отправке или получении COM-компонентов.  
  
 <xref:System.Messaging.BinaryMessageFormatter> и <xref:System.Messaging.ActiveXMessageFormatter> обеспечивают более высокую пропускную способность, чем <xref:System.Messaging.XmlMessageFormatter>. <xref:System.Messaging.ActiveXMessageFormatter> обеспечивает взаимодействие с приложениями очереди сообщений Visual Basic 6,0.  
  
 Когда приложение отправляет сообщения в очередь, <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> применяется только к тем сообщениям, которые используют свойства сообщений по умолчанию, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. При отправке <xref:System.Messaging.Message> в очередь очередь сообщений использует модуль форматирования, определенный в свойстве <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType>, для сериализации тела.  
  
 Класс <xref:System.Messaging.MessageQueue> всегда будет использовать <xref:System.Messaging.Message> для получения или просмотра сообщения из очереди. Сообщение десериализуется с помощью свойства <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType>.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода показано форматирование текста сообщения с помощью <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 В следующем примере кода показано форматирование текста сообщения с помощью <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все сообщения из очереди.</summary>
        <returns>Массив типа <see cref="T:System.Messaging.Message" />, который представляет все сообщения очереди в том же порядке, в каком они располагаются в очереди сообщений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> возвращает статический моментальный снимок сообщений в очереди, а не динамические ссылки на эти сообщения. Поэтому нельзя использовать массив для изменения сообщений в очереди. Если требуется динамическое взаимодействие с очередью в режиме реального времени (например, возможность удаления сообщений), вызовите метод <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>, который возвращает динамический список сообщений в очереди.  
  
 Поскольку <xref:System.Messaging.MessageQueue.GetAllMessages%2A> возвращает копию сообщений в очереди на момент вызова метода, массив не отражает новые сообщения, поступающие в очередь или сообщения, удаленные из очереди.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> извлекает только те свойства, которые не отфильтрованы свойством <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Перечисляет сообщения в очереди. Параметр <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> использовать не рекомендуется. Вместо него следует использовать метод <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />.</summary>
        <returns>Объект <see cref="T:System.Collections.IEnumerator" />, обеспечивающий динамическое подключение к сообщениям очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Имя компьютера, на котором расположена очередь, без двух обратных косых черт (\\\\) в начале.</param>
        <summary>Получает идентификатор компьютера, на котором расположена очередь, на которую ссылается этот класс <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <returns>Объект <see cref="T:System.Guid" />, который представляет уникальный идентификатор компьютера, на котором расположена очередь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификатор компьютера можно использовать в двух целях: для чтения журнала компьютера и для установки сертификатов безопасности. Однако вы не можете вызвать <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> для удаленного компьютера при работе в автономном режиме, так как приложение должно иметь доступ к службе каталогов на контроллере домена.  
  
 Идентификатор компьютера (или идентификатор компьютера) — это <xref:System.Guid>, который служба Message Queuing создает при добавлении компьютера в предприятие. Служба очередей сообщений объединяет идентификатор компьютера с ключевыми словами `Machine` и `Journal`, чтобы создать имя формата журнала компьютера с синтаксисом `Machine=<computeridentifier>;Journal`. Журнал компьютера, который также называется очередью журнала, представляет собой системную очередь, в которой хранятся копии сообщений, созданных приложением, когда свойство <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> `true`.  
  
 Этот синтаксис для журнала допустим только при формировании имени формата для очереди. Синтаксис имени пути `MachineName`\\`Journal$`.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В приведенном ниже примере кода вызывается <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Не удается извлечь идентификатор компьютера. Возможной причиной может быть недоступность службы каталогов: например, при работе в автономном режиме.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает объект перечислителя для всех сообщений очереди. Параметр <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> использовать не рекомендуется. Вместо него следует использовать метод <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />.</summary>
        <returns>Объект <see cref="T:System.Messaging.MessageEnumerator" /> содержащий сообщения, которые находятся в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> создает динамический список всех сообщений в очереди. Можно удалить из очереди сообщение в текущей позиции перечислителя, вызвав <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> для <xref:System.Messaging.MessageEnumerator>, который <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> возвращает.  
  
 Поскольку курсор связан с динамическим списком сообщений в очереди, перечисление отражает любые изменения, внесенные в сообщения в очереди, если сообщение находится за пределами текущего положения курсора. Например, перечислитель может автоматически получить доступ к сообщениям с низким приоритетом, размещенному за пределами текущей позиции курсора, но не с более высоким приоритетом сообщением, вставленным перед этой позицией. Однако можно сбросить перечисление, таким образом переместив курсор обратно в начало списка, вызвав <xref:System.Messaging.MessageEnumerator.Reset%2A> для <xref:System.Messaging.MessageEnumerator>.  
  
 Порядок сообщений в перечислении отражает порядок их следования в очереди, поэтому сообщения с более высоким приоритетом будут отображаться до приоритетов.  
  
 Если требуется статический моментальный снимок сообщений в очереди, а не динамическое соединение с ними, вызовите <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Этот метод возвращает массив объектов <xref:System.Messaging.Message>, которые представляют сообщения на момент вызова метода.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 Следующий пример кода получает динамический список сообщений в очереди и подсчитывает все сообщения со свойством <xref:System.Messaging.Message.Priority%2A>, для которого задано значение <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает объект перечислителя для всех сообщений очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.MessageEnumerator" /> содержащий сообщения, которые находятся в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> создает динамический список всех сообщений в очереди. Можно удалить из очереди сообщение в текущей позиции перечислителя, вызвав <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> для <xref:System.Messaging.MessageEnumerator>, который <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> возвращает.  
  
 Поскольку курсор связан с динамическим списком сообщений в очереди, перечисление отражает любые изменения, внесенные в сообщения в очереди, если сообщение находится за пределами текущего положения курсора. Например, перечислитель может автоматически получить доступ к сообщениям с низким приоритетом, размещенному за пределами текущей позиции курсора, но не с более высоким приоритетом сообщением, вставленным перед этой позицией. Однако можно сбросить перечисление, таким образом переместив курсор обратно в начало списка, вызвав <xref:System.Messaging.MessageEnumerator.Reset%2A> для <xref:System.Messaging.MessageEnumerator>.  
  
 Порядок сообщений в перечислении отражает порядок их следования в очереди, поэтому сообщения с более высоким приоритетом будут отображаться до приоритетов.  
  
 Если требуется статический моментальный снимок сообщений в очереди, а не динамическое соединение с ними, вызовите <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Этот метод возвращает массив объектов <xref:System.Messaging.Message>, которые представляют сообщения на момент вызова метода.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает объект перечислителя для динамического списка общих очередей сети.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обеспечивает семантику курсора последовательного доступа для перечисления во всех общих очередях сети.</summary>
        <returns>Объект <see cref="T:System.Messaging.MessageQueueEnumerator" />, обеспечивающий динамическое перечисление всех общих очередей сообщений в сети.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> возвращает перечисление всех публичных очередей, наявляющихся в сети.  
  
 Так как курсор связан с динамическим списком, перечисление отражает любые изменения, вносимые в список очередей для очередей, удаленных или добавленных за текущую позицию курсора. Добавление или удаление очередей, расположенных перед текущей позицией курсора, не отражается. Например, перечислитель может автоматически получить доступ к очереди, добавленной за пределами курсора, но не одну до этой позиции. Однако можно сбросить перечисление, таким образом переместив курсор обратно в начало списка, вызвав <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> для <xref:System.Messaging.MessageQueueEnumerator>.  
  
 В сети не определено упорядочение очередей. Перечислитель не упорядочивает их, например, по компьютеру, метке, общедоступному или частному состоянию или любым другим критериям, доступным для использования.  
  
 Если требуется статический моментальный снимок очередей в сети, а не динамическое подключение к ним, вызовите <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> или <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Каждый из этих двух методов возвращает массив объектов <xref:System.Messaging.MessageQueue>, которые представляют очереди на момент вызова метода.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода выполняется перебор всех очередей сообщений в сети и проверяется путь для каждой очереди. И, наконец, отображается число общих очередей в сети.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Объект <see cref="T:System.Messaging.MessageQueueCriteria" />, содержащий критерии фильтрации доступных очередей сообщений.</param>
        <summary>Обеспечивает семантику курсора последовательного доступа для перечисления во всех общих очередях сети, удовлетворяющих указанным критериям.</summary>
        <returns>Объект <see cref="T:System.Messaging.MessageQueueEnumerator" />, обеспечивающий динамическое перечисление общих очередей сообщений сети, удовлетворяющих ограничениям, заданным параметром <paramref name="criteria" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> возвращает список всех публичных очередей в сети, удовлетворяющих критериям, определенным в критерии приложения. Можно указать критерии для включения, например, время создания или изменения очереди, имя компьютера, метка, категория или любое сочетание этих параметров.  
  
 Так как курсор связан с динамическим списком, перечисление отражает любые изменения, внесенные в очередь, которая находится за текущей позицией курсора. Изменения в очередях, расположенных до текущей позиции курсора, не отражаются. Например, перечислитель может автоматически получить доступ к очереди, добавленной за пределами курсора, но не одну до этой позиции. Однако можно сбросить перечисление, таким образом переместив курсор обратно в начало списка, вызвав <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> для <xref:System.Messaging.MessageQueueEnumerator>.  
  
 В сети не определено упорядочение очередей. Перечислитель не упорядочивает их, например, по компьютеру, метке, общедоступному или частному состоянию или любым другим критериям, доступным для использования.  
  
 Если требуется статический моментальный снимок очередей в сети, а не динамическое подключение к ним, укажите условия для <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> или вызовите <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Каждый из этих двух методов возвращает массив объектов <xref:System.Messaging.MessageQueue>, которые представляют очереди на момент вызова метода. Вызов <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>или <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> предоставляет те же результаты, что и вызов <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> с условиями фильтрации <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>и <xref:System.Messaging.MessageQueue.MachineName%2A>соответственно.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода выполняется перебор очередей сообщений и отображается путь к каждой очереди, которая была создана за последний день и существует на компьютере "MyComputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Компьютер, из которого извлекаются частные очереди.</param>
        <summary>Извлекает все частные очереди на указанном компьютере.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные частные очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> получает статический моментальный снимок очередей на указанном компьютере.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода извлекаются списки очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="machineName" /> — <see langword="null" /> или пустая строка ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Извлекает все общие очереди сети.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает все общие очереди сети.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные общие очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, если требуется полный список всех общих очередей в сети. Если требуется ограничить список по определенным критериям, таким как <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>или время последнего изменения, используйте другую перегрузку этого метода. (Кроме того, можно использовать <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>или <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> получает статический моментальный снимок очередей. Для взаимодействия с динамическим списком очередей используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода извлекаются списки очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Объект <see cref="T:System.Messaging.MessageQueueCriteria" />, содержащий критерии фильтрации очередей.</param>
        <summary>Извлекает все общие очереди сети, удовлетворяющие указанным критериям.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные общие очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если нужно отфильтровать все общие очереди в сети по метке, категории или имени компьютера, то класс <xref:System.Messaging.MessageQueue> содержит конкретные методы, которые предоставляют эту функциональность (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>и <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>соответственно). Используйте эту перегрузку, чтобы получить список всех публичных очередей в сети, отвечающих нескольким критериям (например, если требуется указать и метку, и категорию). Можно также фильтровать по условию сообщения, отличному от <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>и <xref:System.Messaging.MessageQueue.MachineName%2A>. Например, эта перегрузка используется для фильтрации по времени последнего изменения очереди. Просто создайте новый экземпляр класса <xref:System.Messaging.MessageQueueCriteria>, задайте соответствующие свойства в экземпляре и передайте экземпляр в качестве параметра `criteria`.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> получает статический моментальный снимок очередей. Для взаимодействия с динамическим списком очередей используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода извлекаются списки очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">Класс <see cref="T:System.Guid" />, который группирует набор очередей для извлечения.</param>
        <summary>Извлекает все общие очереди сети, принадлежащие к указанной категории.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные общие очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для фильтрации общих очередей по категориям. Свойство <xref:System.Messaging.MessageQueue.Category%2A> предоставляет доступ к свойству идентификатора типа Message Queuing (которое доступно для чтения и записи) конкретной очереди. Хотя <xref:System.Guid.NewGuid%2A> можно использовать для создания значения категории, уникального для всех <xref:System.Guid> значений, это необязательно. Значение категории должно отличаться только от других категорий, а не от всех других <xref:System.Guid> значений. Например, можно назначить {00000000-0000-0000-0000-000000000001} в качестве <xref:System.Messaging.MessageQueue.Category%2A> для одного набора очередей и {00000000-0000-0000-0000-000000000002} в качестве <xref:System.Messaging.MessageQueue.Category%2A> для другого набора.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> получает статический моментальный снимок очередей. Для взаимодействия с динамическим списком очередей используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Категорию можно указать как часть <xref:System.Messaging.MessageQueueCriteria>, передаваемых в метод.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода извлекаются списки очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Метка, которая группирует набор очередей для извлечения.</param>
        <summary>Извлекает все общие очереди сети с указанной меткой.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на извлеченные общие очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для фильтрации общих очередей по метке.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> получает статический моментальный снимок очередей. Для взаимодействия с динамическим списком очередей используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Метку можно указать как часть <xref:System.Messaging.MessageQueueCriteria>, передаваемых в метод.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода извлекаются списки очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="label" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Имя компьютера, на котором располагается набор извлекаемых общих очередей.</param>
        <summary>Извлекает все общие очереди, находящиеся на указанном компьютере.</summary>
        <returns>Массив объектов <see cref="T:System.Messaging.MessageQueue" />, ссылающихся на общие очереди, находящиеся на компьютере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для фильтрации общих очередей по компьютерам.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> получает статический моментальный снимок очередей. Для взаимодействия с динамическим списком очередей используйте <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Имя компьютера можно указать как часть <xref:System.Messaging.MessageQueueCriteria>, передаваемого в метод.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Нет|  
|Локальный компьютер и прямое имя формата|Нет|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода извлекаются списки очередей.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="machineName" /> имеет неверный синтаксис.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Извлекает контекст безопасности, который служба MSMQ связывает с текущим пользователем (удостоверением потока) на момент этого вызова.</summary>
        <returns>Объект <see cref="T:System.Messaging.SecurityContext" />, содержащий контекст безопасности.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает уникальный идентификатор очереди сообщений.</summary>
        <value>Свойство <see cref="P:System.Messaging.MessageQueue.Id" />, представляющее идентификатор сообщения, создаваемый приложением очереди сообщений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Служба очереди сообщений задает свойство <xref:System.Messaging.MessageQueue.Id%2A> при создании очереди. Это свойство доступно только для общих очередей.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода выводится значение свойства <xref:System.Messaging.MessageQueue.Id%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что для очереди нет ограничений по размеру.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот элемент часто используется при установке <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> или <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано использование элемента <xref:System.Messaging.MessageQueue.InfiniteQueueSize>.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает, что для методов считывания и получения сообщений не существует тайм-аута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> поддерживает два типа извлечения сообщений: синхронные и асинхронные. Синхронные методы, <xref:System.Messaging.MessageQueue.Peek%2A> и <xref:System.Messaging.MessageQueue.Receive%2A>, вызывают ожидание потоком процесса заданного интервала времени для поступления нового сообщения в очередь. Если указанный интервал времени <xref:System.Messaging.MessageQueue.InfiniteTimeout>, поток процесса остается заблокированным, пока не будет доступно новое сообщение. С другой стороны, <xref:System.Messaging.MessageQueue.BeginPeek%2A> и <xref:System.Messaging.MessageQueue.BeginReceive%2A> (асинхронные методы) позволяют основным задачам приложения продолжать работу в отдельном потоке, пока в очередь не поступит сообщение.  
  
   
  
## Examples  
 В следующем примере кода показано использование элемента <xref:System.Messaging.MessageQueue.InfiniteTimeout>.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает описание очереди.</summary>
        <value>Метка очереди сообщения. Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Максимальная длина метки очереди сообщений составляет 124 символов.  
  
 Свойство <xref:System.Messaging.MessageQueue.Label%2A> не обязательно должно быть уникальным для всех очередей. Однако если несколько очередей совместно используют один и тот же <xref:System.Messaging.MessageQueue.Label%2A>, то нельзя использовать метод <xref:System.Messaging.MessageQueue.Send%28System.Object%29> для передачи сообщения всем из них. Если при отправке сообщения используется синтаксис метки для свойства <xref:System.Messaging.MessageQueue.Path%2A>, будет создано исключение, если <xref:System.Messaging.MessageQueue.Label%2A> не является уникальным.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение свойства <xref:System.Messaging.MessageQueue.Label%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для метки задано недопустимое значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает время последнего изменения свойств очереди.</summary>
        <value>Объект <see cref="T:System.DateTime" />, который указывает, когда свойства очереди были изменены в последний раз.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Время последнего изменения включает в себя время создания очереди и любое <xref:System.Messaging.MessageQueue> свойство, изменяющее очередь очереди сообщений, например <xref:System.Messaging.MessageQueue.BasePriority%2A>. Значение свойства <xref:System.Messaging.MessageQueue.LastModifyTime%2A> представляет системное время локального компьютера.  
  
 Необходимо вызвать метод <xref:System.Messaging.MessageQueue.Refresh%2A> перед получением свойства <xref:System.Messaging.MessageQueue.LastModifyTime%2A>. в противном случае время изменения, связанное с этим <xref:System.Messaging.MessageQueue>, может быть неактуальным.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода выводится значение свойства <xref:System.Messaging.MessageQueue.LastModifyTime%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает имя компьютера, на котором расположена очередь Message Queuing.</summary>
        <value>Имя компьютера, на котором расположена очередь. По умолчанию службой Message Queuing используется значение ".", т. е. локальный компьютер.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MachineName%2A> является неотъемлемой частью синтаксиса понятного имени <xref:System.Messaging.MessageQueue.Path%2A>очереди. В следующей таблице показан синтаксис, который следует использовать для очереди указанного типа, если необходимо указать путь очереди, используя его понятное имя.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частная очередь|`MachineName`\\`Private$`\\`QueueName`|  
|Очередь журнала|`MachineName`\\`QueueName`\\`Journal$`|  
|Очередь журнала компьютера|`MachineName`\\`Journal$`|  
|Очередь недоставленных сообщений компьютера|`MachineName`\\`Deadletter$`|  
|Очередь недоставленных транзактных сообщений на компьютере|`MachineName`\\`XactDeadletter$`|  
  
 Используйте "." для локального компьютера при указании <xref:System.Messaging.MessageQueue.MachineName%2A>. Для этого свойства распознается только имя компьютера, например `Server0`. Свойство <xref:System.Messaging.MessageQueue.MachineName%2A> не поддерживает формат IP-адреса.  
  
 При определении <xref:System.Messaging.MessageQueue.Path%2A> в терминах <xref:System.Messaging.MessageQueue.MachineName%2A>приложение создает исключение при автономной работе, поскольку для преобразования пути требуется контроллер домена. Поэтому при работе в автономном режиме необходимо использовать <xref:System.Messaging.MessageQueue.FormatName%2A> для синтаксиса <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Свойства <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>и <xref:System.Messaging.MessageQueue.QueueName%2A> связаны. Изменение свойства <xref:System.Messaging.MessageQueue.MachineName%2A> приводит к изменению свойства <xref:System.Messaging.MessageQueue.Path%2A>. Он строится на основе новых <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A>. Изменение <xref:System.Messaging.MessageQueue.Path%2A> (например, использование синтаксиса имени формата) приводит к сбросу свойств <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A> для ссылки на новую очередь. Если свойство <xref:System.Messaging.MessageQueue.QueueName%2A> пусто, <xref:System.Messaging.MessageQueue.Path%2A> задается в очереди журнала заданного компьютера.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение свойства <xref:System.Messaging.MessageQueue.MachineName%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <see cref="P:System.Messaging.MessageQueue.MachineName" /> — <see langword="null" />.        
- или -

Недопустимое имя компьютера. Причиной может быть неверный синтаксис.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает максимальный размер очереди журнала.</summary>
        <value>Максимальный размер очереди журнала в килобайтах. По умолчанию службой Message Queuing не устанавливаются ограничения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> предоставляет доступ к ограничению хранилища журнала очереди сообщений. Он имеет смысл только в том случае, если <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> `true`. Задание этого свойства изменяет очередь сообщений. Таким образом, это изменение влияет на любые другие экземпляры <xref:System.Messaging.MessageQueue>.  
  
 Если сообщения хранятся в журнале или очереди недоставленных сообщений, следует периодически очищать очередь для удаления сообщений, которые больше не нужны. Сообщения в такой очереди подсчитывается в соответствии с квотой сообщений для компьютера, на котором находится очередь. (Администратор устанавливает квоту компьютера.)  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение свойства <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для максимального размера очереди журнала установлено недопустимое значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает максимальный размер очереди.</summary>
        <value>Максимальный размер очереди в килобайтах. По умолчанию службой Message Queuing не устанавливаются ограничения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> предоставляет доступ к ограничению хранилища сообщений очереди сообщений, отдельно от квоты на сообщения компьютера, определяемой администратором. Дополнительные сведения о квоте сообщений см. в разделе <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Задание этого свойства изменяет очередь сообщений. Таким образом, это изменение влияет на любые другие экземпляры <xref:System.Messaging.MessageQueue>.  
  
 Если предпринимается попытка превышения максимального размера очереди или квоты сообщений компьютера, сообщения могут быть потеряны. По достижении квоты очереди служба очереди сообщений уведомляет очередь администрирования отправляющего приложения, чтобы указать, что очередь заполнена, выполнив возврат сообщения с отрицательным подтверждением. Очередь сообщений по очереди отправляет негативные подтверждения, пока общий размер сообщений в очереди не станет меньше предела.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение свойства <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Максимальный размер очереди содержит отрицательное значение.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает фильтр свойств для получения и считывания сообщений.</summary>
        <value>Объект <see cref="T:System.Messaging.MessagePropertyFilter" />, который очередь использует для фильтрации набора свойств, получаемого или считываемого ею для каждого сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот фильтр представляет собой набор логических значений, которые ограничивают свойства сообщения, которые <xref:System.Messaging.MessageQueue> получает или считывает. Когда <xref:System.Messaging.MessageQueue> получает или считывает сообщение из очереди сервера, он извлекает только те свойства, для которых <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> значение `true`.  
  
 Ниже показаны начальные значения свойств для <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> свойства. Эти параметры идентичны вызову <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> в <xref:System.Messaging.MessagePropertyFilter>.  
  
|Свойство.|Значение по умолчанию|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 байт|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 байт|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 байт|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода используется <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> для ограничения полученных свойств сообщения.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение фильтра — <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представлено в MSMQ 3.0. Получает или задает адрес многоадресной рассылки, связанный с данной очередью.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий допустимый групповой адрес (в виде, показанном ниже) или значение <see langword="null" />, которое указывает, что очередь не связана с групповым адресом.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Messaging.MessageQueue.MulticastAddress%2A> используется для связи нетранзакционной очереди с адресом многоадресной рассылки, который может использоваться при отправке сообщений. Нельзя связать транзакционную очередь с адресом многоадресной рассылки. Когда отправляющее приложение отправляет сообщения на адрес многоадресной рассылки, служба очереди сообщений отправляет копию сообщения в каждую очередь, связанную с этим адресом.  
  
 IP-адреса многоадресной рассылки должны принадлежать классу D в диапазоне от 224.0.0.0 до 239.255.255.255, что соответствует установке первых четырех старших разрядов, равных 1110. Однако только определенные диапазоны адресов в этом диапазоне являются незарезервированными и доступны для отправки многоадресных сообщений. Последний список зарезервированных адресов многоадресной рассылки см. на веб-странице [адресов многоадресной рассылки Интернета (IANA) в Интернете](https://go.microsoft.com/fwlink/?linkid=3859) . Ограничения на номер порта отсутствуют.  
  
 Если несколько исходных компьютеров отправляют сообщения многоадресной рассылки и требуется, чтобы конкретная очередь получала сообщения только с одного исходного компьютера, каждый исходный компьютер должен отправлять сообщения на разные комбинации IP-адреса и номера порта.  
  
 Чтобы отменить связь между очередью и адресом многоадресной рассылки, задайте для свойства <xref:System.Messaging.MessageQueue.MulticastAddress%2A> строку нулевой длины. Не задавайте `null`, так как это приведет к <xref:System.ArgumentNullException>.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает путь очереди. После задания свойства <see cref="P:System.Messaging.MessageQueue.Path" /> объект <see cref="T:System.Messaging.MessageQueue" /> будет указывать на новую очередь.</summary>
        <value>Очередь, на которую ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Значение по умолчанию зависит от того, какой используется конструктор <see cref="M:System.Messaging.MessageQueue.#ctor" />. Значение равно либо <see langword="null" />, либо задается параметром <paramref name="path" /> конструктора.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Синтаксис свойства <xref:System.Messaging.MessageQueue.Path%2A> зависит от типа очереди, на которую он указывает, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частная очередь|`MachineName`\\`Private$`\\`QueueName`|  
|Очередь журнала|`MachineName`\\`QueueName`\\`Journal$`|  
|Очередь журнала компьютера|`MachineName`\\`Journal$`|  
|Очередь недоставленных сообщений компьютера|`MachineName`\\`Deadletter$`|  
|Очередь недоставленных транзактных сообщений на компьютере|`MachineName`\\`XactDeadletter$`|  
  
 Для представления локального компьютера используйте ".".  
  
 Свойства <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>и <xref:System.Messaging.MessageQueue.QueueName%2A> связаны. Изменение свойства <xref:System.Messaging.MessageQueue.MachineName%2A> приводит к изменению свойства <xref:System.Messaging.MessageQueue.Path%2A>. Он строится на основе новых <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A>. Изменение <xref:System.Messaging.MessageQueue.Path%2A> (например, использование синтаксиса имени формата) приводит к сбросу свойств <xref:System.Messaging.MessageQueue.MachineName%2A> и <xref:System.Messaging.MessageQueue.QueueName%2A> для ссылки на новую очередь.  
  
 Кроме того, можно использовать <xref:System.Messaging.MessageQueue.FormatName%2A> или <xref:System.Messaging.MessageQueue.Label%2A> для описания пути очереди, как показано в следующей таблице.  
  
|Ссылка|Синтаксис|Пример|  
|---------------|------------|-------------|  
|Название формата|`FormatName:` [ *имя формата* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Метка|`Label:` [ *Метка* ]|`Label:` Селабел|  
  
 Если при отправке сообщения используется синтаксис метки для свойства <xref:System.Messaging.MessageQueue.Path%2A>, будет создано исключение, если <xref:System.Messaging.MessageQueue.Label%2A> не является уникальным.  
  
 Для работы в автономном режиме необходимо использовать синтаксис имени формата, а не синтаксис понятного имени в первой таблице. В противном случае создается исключение, так как основной контроллер домена (на котором размещается Active Directory) недоступен для разрешения пути к имени формата.  
  
 Установка нового пути закрывает очередь сообщений и освобождает все дескрипторы.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Да|  
  
> [!NOTE]
>  В режиме рабочей группы можно использовать только частные очереди. Путь указывается с помощью синтаксиса частной очереди `MachineName`\\`Private$`\\`QueueName`.  
  
   
  
## Examples  
 В следующем примере кода создаются новые <xref:System.Messaging.MessageQueue> объекты с использованием различных типов синтаксиса имени пути. В каждом случае он отправляет сообщение в очередь, путь которой определен в конструкторе.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Недопустимый путь. Возможно из-за неправильного синтаксиса.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <summary>Возвращает копию первого сообщения в очереди, не удаляя его из очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает, не удаляя (считывает), первое сообщение в очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />. Метод <see cref="M:System.Messaging.MessageQueue.Peek" /> является синхронным, поэтому он блокирует текущий поток до тех пор, пока сообщение не станет доступным.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, представляющий первое сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для просмотра очереди или ожидания сообщения в очереди.  
  
 Метод <xref:System.Messaging.MessageQueue.Peek%2A> считывает, но не удаляет первое сообщение из очереди. Следовательно, повторные вызовы <xref:System.Messaging.MessageQueue.Peek%2A> возвращают одно и то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Метод <xref:System.Messaging.MessageQueue.Receive%2A>, с другой стороны, считывает и удаляет первое сообщение из очереди. Поэтому повторные вызовы <xref:System.Messaging.MessageQueue.Receive%2A>, следовательно, возвращают разные сообщения.  
  
 Очередь сообщений упорядочивает сообщения в очереди в соответствии с приоритетом и временем прибытия. Более старое сообщение помещается перед более старым, только если оно имеет более высокий приоритет.  
  
 Метод <xref:System.Messaging.MessageQueue.Peek%2A> используется, если текущий поток можно заблокировать на время, пока ожидается поступление сообщения в очередь. Так как эта перегрузка не задает время ожидания, приложение может ждать в течение неограниченного времени. Если работа приложения должна продолжаться без ожидания, используйте асинхронный метод <xref:System.Messaging.MessageQueue.BeginPeek%2A>. Кроме того, можно указать время ожидания сообщения, поступающих в очередь, с помощью перегрузки <xref:System.Messaging.MessageQueue.Peek%2A>, которая указывает время ожидания.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующих примерах используется метод <xref:System.Messaging.MessageQueue.Peek%2A> в очереди.  
  
 В первом примере приложение ожидает, пока сообщение не станет доступным в очереди. Обратите внимание, что в первом примере нет доступа к сообщению, которое прибывает. Он просто приостанавливает обработку, пока не поступит сообщение. Если сообщение уже существует в очереди, оно будет возвращаться немедленно.  
  
 Во втором примере в очередь отправляется сообщение, содержащее определяемый приложением `Order` класс, а затем выполняется просмотр из очереди.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, показывающий максимальное время ожидания появления первого сообщения в очереди.</param>
        <summary>Возвращает, не удаляя (считывает), первое сообщение в очереди, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />. Метод <see cref="M:System.Messaging.MessageQueue.Peek" /> является синхронным, поэтому он блокирует текущий поток до тех пор, пока сообщение не станет доступным или пока не истечет заданный тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, представляющий первое сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для просмотра очереди или ожидания указанного периода времени, пока в очереди не появится сообщение. Метод немедленно возвращает значение, если сообщение уже существует в очереди.  
  
 Метод <xref:System.Messaging.MessageQueue.Peek%2A> считывает, но не удаляет первое сообщение из очереди. Следовательно, повторные вызовы <xref:System.Messaging.MessageQueue.Peek%2A> возвращают одно и то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Метод <xref:System.Messaging.MessageQueue.Receive%2A>, с другой стороны, считывает и удаляет первое сообщение из очереди. Поэтому повторные вызовы <xref:System.Messaging.MessageQueue.Receive%2A>, следовательно, возвращают разные сообщения.  
  
 Очередь сообщений упорядочивает сообщения в очереди в соответствии с приоритетом и временем прибытия. Более старое сообщение помещается перед более старым, только если оно имеет более высокий приоритет.  
  
 Метод <xref:System.Messaging.MessageQueue.Peek%2A> используется, если текущий поток можно заблокировать на время, пока ожидается поступление сообщения в очередь. Поток будет заблокирован на указанный период времени или бессрочно, если указано <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Если работа приложения должна продолжаться без ожидания, используйте асинхронный метод <xref:System.Messaging.MessageQueue.BeginPeek%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода используется метод <xref:System.Messaging.MessageQueue.Peek%2A> с нулевым временем ожидания, чтобы проверить, пуста ли очередь.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Объект <see cref="T:System.TimeSpan" />, показывающий максимальное время ожидания появления первого сообщения в очереди.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="action">Одно из значений <see cref="T:System.Messaging.PeekAction" />. Указывает, следует ли считывать текущее сообщение в очереди или следующее сообщение.</param>
        <summary>Возвращает, не удаляя (считывает), текущее или следующее сообщение в очереди, используя заданный курсор. Метод <see cref="M:System.Messaging.MessageQueue.Peek" /> является синхронным, поэтому он блокирует текущий поток до тех пор, пока сообщение не станет доступным или пока не истечет заданный тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, представляющий сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для просмотра очереди или ожидания указанного периода времени, пока в очереди не появится сообщение. Метод немедленно возвращает значение, если сообщение уже существует в очереди.  
  
 Метод <xref:System.Messaging.MessageQueue.Peek%2A> считывает, но не удаляет сообщение из очереди. Метод <xref:System.Messaging.MessageQueue.Receive%2A>, с другой стороны, считывает и удаляет сообщение из очереди.  
  
 Метод <xref:System.Messaging.MessageQueue.Peek%2A> используется, если текущий поток можно заблокировать на время, пока ожидается поступление сообщения в очередь. Поток блокируется на указанный период времени или бессрочно, если указано <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Если работа приложения должна продолжаться без ожидания, используйте асинхронный метод <xref:System.Messaging.MessageQueue.BeginPeek%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Для параметра <paramref name="action" /> было задано значение, отличное от <see langword="PeekAction.Current" /> или <see langword="PeekAction.Next" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо. Возможно, значение параметра <paramref name="timeout" /> меньше, чем <see cref="F:System.TimeSpan.Zero" />, или больше, чем <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Считывает сообщение, которое соответствует заданному идентификатору корреляции.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> считываемого сообщения.</param>
        <summary>Считывает сообщение, которое соответствует заданному идентификатору корреляции, и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором корреляции.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск в очереди, на которую ссылается <xref:System.Messaging.MessageQueue> сообщения, <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному параметру `correlationId`. Если не найдено ни одного сообщения, соответствующего параметру `correlationID`, возникает исключение.  
  
 Свойство <xref:System.Messaging.Message.CorrelationId%2A> используется для привязки сообщения, отправленного в очередь, к связанному ответу, отчету или сообщениям подтверждения.  
  
 Два других метода позволяют просматривать сообщения в очереди. Метод <xref:System.Messaging.MessageQueue.Peek%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> используется для получения сообщения путем указания его уникального идентификатора.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 Следующий пример кода отправляет и получает сообщение, которое содержит порядок в очередь и из нее. Он специально запрашивает положительное подтверждение, когда исходное сообщение достигает или извлекается из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> считываемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Считывает сообщение, которое соответствует заданному идентификатору корреляции и ожидает, пока в очереди не появится сообщение с указанным идентификатором корреляции или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск в очереди, на которую ссылается <xref:System.Messaging.MessageQueue> сообщения, <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному параметру `correlationId`. Если сообщение, соответствующее параметру `correlationID`, не найдено и в очередь не поступает новое сообщение в течение периода, указанного параметром `timeout`, возникает исключение.  
  
 Параметр `timeout` не задает общее время выполнения для этого метода. Вместо этого он указывает время ожидания поступления нового сообщения в очередь. Каждый раз, когда поступает новое сообщение, этот метод проверяет <xref:System.Messaging.Message.CorrelationId%2A> нового сообщения, чтобы проверить, соответствует ли он параметру `correlationId`. В противном случае этот метод запускает период времени ожидания и ожидает поступления другого нового сообщения. Таким образом, если новые сообщения продолжают поступать в течение времени ожидания, этот метод может продолжать работу в течение неограниченного времени, пока не истечет время ожидания, не прибегая новых сообщений, или пока не поступит сообщение, <xref:System.Messaging.Message.CorrelationId%2A> которого соответствует параметру `correlationId`.  
  
 Свойство <xref:System.Messaging.Message.CorrelationId%2A> используется для привязки сообщения, отправленного в очередь, к связанному ответу, отчету или сообщениям подтверждения.  
  
 Два других метода позволяют просматривать сообщения в очереди. Метод <xref:System.Messaging.MessageQueue.Peek%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> используется для получения сообщения путем указания его уникального идентификатора.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Сообщение с заданным параметром <paramref name="correlationId" /> не существует в очереди и не поступило до истечения тайм-аута.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщений до истечения тайм-аута не поступало.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает копию сообщения с указанным идентификатором сообщения, не удаляя это сообщение из очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> считываемого сообщения.</param>
        <summary>Считывает сообщение, идентификатор которого соответствует параметру <paramref name="id" />.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> для чтения, не удаляя из очереди, сообщение с известным идентификатором сообщения. Идентификатор сообщения уникален в рамках организации очереди сообщений, поэтому в очереди должно быть не более одного сообщения, соответствующего указанному параметру `id`. Эта перегрузка создает исключение, если в настоящий момент очередь не содержит сообщение.  
  
 Два дополнительных метода позволяют просматривать сообщения в очереди: <xref:System.Messaging.MessageQueue.Peek%2A> и <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.Peek%2A> возвращает первое сообщение в очереди; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> возвращает сообщение о подтверждении, отчете или созданном приложением ответе, которое было создано в результате сообщения, отправленного в очередь.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Нет сообщения с указанным параметром <paramref name="id" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> считываемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Считывает сообщение, идентификатор которого соответствует параметру <paramref name="id" />. Ожидает, пока сообщение не появится в очереди, или не возникнет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> для чтения, не удаляя из очереди, сообщение с известным идентификатором сообщения. Идентификатор сообщения уникален в рамках организации очереди сообщений, поэтому в очереди должно быть не более одного сообщения, соответствующего указанному параметру `id`. Эта перегрузка создает исключение, если в настоящий момент очередь не содержит сообщение и новое сообщение не поступает до истечения времени ожидания.  
  
 Параметр `timeout` не задает общее время выполнения для этого метода. Вместо этого он указывает время ожидания поступления нового сообщения в очередь. Каждый раз, когда поступает новое сообщение, этот метод проверяет <xref:System.Messaging.Message.Id%2A> нового сообщения, чтобы проверить, соответствует ли он параметру `id`. В противном случае этот метод запускает период времени ожидания и ожидает поступления другого нового сообщения. Таким образом, если новые сообщения продолжают поступать в течение времени ожидания, этот метод может продолжать работу в течение неограниченного времени, пока не истечет время ожидания, не прибегая новых сообщений, или пока не поступит сообщение, <xref:System.Messaging.Message.Id%2A> которого соответствует параметру `id`.  
  
 Два дополнительных метода позволяют просматривать сообщения в очереди: <xref:System.Messaging.MessageQueue.Peek%2A> и <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.Peek%2A> возвращает первое сообщение в очереди; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> возвращает сообщение о подтверждении, отчете или созданном приложением ответе, которое было создано в результате сообщения, отправленного в очередь.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Сообщение с заданным параметром <paramref name="id" /> не существует в очереди и не поступило до истечения периода времени, установленного параметром <paramref name="timeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Представлено в MSMQ 3.0. Считывает конкретное сообщение из очереди. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> считываемого сообщения.</param>
        <summary>Представлено в MSMQ 3.0. Считывает сообщение, соответствующее заданному идентификатору просмотра, из нетранзакционной очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.LookupId" /> которого соответствует переданному в объект параметру <paramref name="lookupId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором поиска, не удаляя его из очереди. Этот метод немедленно создает исключение, если сообщение не находится в очереди.  
  
 Свойство <xref:System.Messaging.Message.LookupId%2A> сообщения является уникальным для очереди, в которой находится сообщение, поэтому в очереди должно быть не более одного сообщения, которое соответствует заданному параметру `lookupId`.  
  
 Чтобы прочитать сообщение с указанным идентификатором уточняющего запроса и удалить его из очереди, используйте метод <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Одно из значений <see cref="T:System.Messaging.MessageLookupAction" />, задающее порядок чтения сообщения в очереди. Укажите одно из следующих значений: 
 <see langword="MessageLookupAction.Current" />. считывает сообщение, заданное параметром <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.Next" />. считывает сообщение, следующее за сообщением, заданным параметром <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.Previous" />. считывает сообщение, предшествующее сообщению, заданному параметром <paramref name="lookupId" />.  
  
 <see langword="MessageLookupAction.First" />. считывает первое сообщение в очереди. Параметр <paramref name="lookupId" /> должен быть установлен равным 0.  
  
 <see langword="MessageLookupAction.Last" />. считывает последнее сообщение в очереди. Параметр <paramref name="lookupId" /> должен быть установлен равным 0.</param>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> считываемого сообщения или значение 0. Значение, равное 0, используется при доступе к первому или последнему сообщению в очереди.</param>
        <summary>Представлено в MSMQ 3.0. Считывает конкретное сообщение из очереди. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, задаваемый передаваемыми параметрами <paramref name="action" /> и <paramref name="lookupId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором поиска, не удаляя его из очереди. Этот метод немедленно создает исключение, если сообщение не находится в очереди.  
  
 Свойство <xref:System.Messaging.Message.LookupId%2A> сообщения является уникальным для очереди, в которой находится сообщение, поэтому в очереди должно быть не более одного сообщения, которое соответствует заданному параметру `lookupId`.  
  
 Чтобы прочитать сообщение с указанным идентификатором и удалить его из очереди, используйте метод <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="action" /> не является одним из членов <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда сообщение читается без удаления из очереди. Это результат асинхронной операции — <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> используется в асинхронной обработке для вызова события <xref:System.Messaging.MessageQueue.PeekCompleted>, когда сообщение доступно в очереди.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> используется для завершения операции, инициированной вызовом метода <xref:System.Messaging.MessageQueue.BeginPeek%2A>, и просмотра сообщения при возникновении события <xref:System.Messaging.MessageQueue.PeekCompleted>.  
  
 При создании делегата <xref:System.Messaging.PeekCompletedEventHandler> необходимо указать метод, обрабатывающий событие. Чтобы связать событие с обработчиком событий, нужно добавить в событие экземпляр делегата. Обработчик событий вызывается всякий раз, когда происходит событие, если делегат не удален. Дополнительные сведения о делегатах обработчиков событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создается обработчик событий с именем `MyPeekCompleted`, присоединяется к делегату обработчика событий <xref:System.Messaging.MessageQueue.PeekCompleted> и вызывается <xref:System.Messaging.MessageQueue.BeginPeek%2A> для инициации асинхронной операции просмотра в очереди, расположенной по пути ".\Микуеуе". При возникновении события <xref:System.Messaging.MessageQueue.PeekCompleted> в примере считывается сообщение и записывается его текст на экран. Затем в примере вызывается <xref:System.Messaging.MessageQueue.BeginPeek%2A> еще раз, чтобы инициировать новую асинхронную операцию просмотра.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все сообщения, содержащиеся в очереди.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Очистка очереди приводит к тому, что очередь сообщений устанавливает флаг изменения очереди, который влияет на свойство <xref:System.Messaging.MessageQueue.LastModifyTime%2A>. Сообщения, удаленные из очереди, теряются. они не отправляются в очередь недоставленных сообщений или в очередь журнала.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает понятное имя, определяющее очередь.</summary>
        <value>Имя, определяющее очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />. Значение <see langword="null" /> недопустимо.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно объединить <xref:System.Messaging.MessageQueue.QueueName%2A> с <xref:System.Messaging.MessageQueue.MachineName%2A>, чтобы создать понятное имя <xref:System.Messaging.MessageQueue.Path%2A> очереди. Синтаксис для варианта понятного имени свойства <xref:System.Messaging.MessageQueue.Path%2A> зависит от типа очереди, как показано в следующей таблице.  
  
|Тип очереди|Синтаксис|  
|----------------|------------|  
|Общая очередь|`MachineName`\\`QueueName`|  
|Частная очередь|`MachineName`\\`Private$`\\`QueueName`|  
|Очередь журнала|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Для представления локального компьютера используйте ".".  
  
 Изменение свойства <xref:System.Messaging.MessageQueue.QueueName%2A> влияет на свойство <xref:System.Messaging.MessageQueue.Path%2A>. Если задать <xref:System.Messaging.MessageQueue.QueueName%2A> без задания свойства <xref:System.Messaging.MessageQueue.MachineName%2A>, свойство <xref:System.Messaging.MessageQueue.Path%2A> будет иметь значение. `QueueName`\\. В противном случае <xref:System.Messaging.MessageQueue.Path%2A> будет `MachineName`\\`QueueName`.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Да|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение свойства <xref:System.Messaging.MessageQueue.QueueName%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение имени очереди — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает собственный дескриптор, предназначенный для чтения сообщений из очереди сообщений.</summary>
        <value>Дескриптор собственного объекта очереди, который используется для считывания и получения сообщений из очереди.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A> предоставляет собственный обработчик Windows для объекта очереди сообщений, который используется для просмотра и получения сообщений из очереди. При изменении пути к очереди маркер закрывается и повторно открывается с новым значением.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <summary>Получает первое сообщение в очереди, удаляя его из очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает первое доступное в очереди сообщение, на которое ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Этот вызов является синхронным и он блокирует текущий поток выполнения, пока сообщение не станет доступным.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщения из очереди или ожидания сообщений в очереди.  
  
 Метод <xref:System.Messaging.MessageQueue.Receive%2A> позволяет синхронно считывать сообщения, тем самым удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> будут возвращать сообщения, следующие за очередью, или новые сообщения с более высоким приоритетом.  
  
 Чтобы прочитать первое сообщение в очереди, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.Peek%2A>. Метод <xref:System.Messaging.MessageQueue.Peek%2A> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом.  
  
 Используйте вызов метода, <xref:System.Messaging.MessageQueue.Receive%2A>, если он приемлем для блокировки текущего потока, пока он ожидает поступления сообщения в очередь. Поскольку эта перегрузка метода <xref:System.Messaging.MessageQueue.Receive%2A> указывает на бесконечное время ожидания, приложение может ждать бесконечно. Если обработка приложения должна быть продолжена без ожидания сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 Следующий пример кода получает сообщение из очереди и выводит сведения об этом сообщении на экран.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает первое доступное в транзакционной очереди сообщение, на которое ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Этот вызов является синхронным и он блокирует текущий поток выполнения, пока сообщение не станет доступным.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщения из транзакционной очереди с помощью контекста внутренней транзакции, определенного параметром `transaction`, или дождитесь поступления сообщений в очередь.  
  
 Метод <xref:System.Messaging.MessageQueue.Receive%2A> позволяет синхронно считывать сообщения, тем самым удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> будут возвращать сообщения, следующие за очередью.  
  
 Поскольку этот метод вызывается для транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Чтобы прочитать первое сообщение в очереди, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.Peek%2A>. Метод <xref:System.Messaging.MessageQueue.Peek%2A> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.Peek%2A>. Поскольку <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет какие-либо сообщения в очереди, для отката вызовом функции <xref:System.Messaging.MessageQueueTransaction.Abort%2A>будет нечего выполняться.  
  
 Используйте вызов метода, <xref:System.Messaging.MessageQueue.Receive%2A>, если он приемлем для блокировки текущего потока, пока он ожидает поступления сообщения в очередь. Поскольку эта перегрузка метода <xref:System.Messaging.MessageQueue.Receive%2A> указывает на бесконечное время ожидания, приложение может ждать бесконечно. Если обработка приложения должна быть продолжена без ожидания сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода выполняется подключение к транзакционной очереди на локальном компьютере и отправка сообщения в очередь. Затем он получает сообщение, содержащее заказ. Если обнаруживает нетранзакционную очередь, она вызывает исключение и выполняет откат транзакции.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.  
  
 - или -  
  
 Очередь является нетранзакционной.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает первое доступное в очереди сообщение, на которое ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Этот вызов является синхронным и он блокирует текущий поток выполнения, пока сообщение не станет доступным.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщения из очереди с помощью контекста транзакции, определенного параметром `transactionType`, или дождитесь поступления сообщений в очередь.  
  
 Укажите `Automatic` для параметра `transactionType`, если к потоку, который требуется использовать для получения сообщения, уже присоединен контекст внешней транзакции. Укажите `Single`, если вы хотите получить сообщение как одну внутреннюю транзакцию. Можно указать `None`, если требуется получить сообщение из транзакционной очереди за пределами контекста транзакции.  
  
 Метод <xref:System.Messaging.MessageQueue.Receive%2A> позволяет синхронно считывать сообщения, тем самым удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> будут возвращать сообщения, следующие за очередью.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Чтобы прочитать первое сообщение в очереди, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.Peek%2A>. Метод <xref:System.Messaging.MessageQueue.Peek%2A> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.Peek%2A>. Поскольку <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет какие-либо сообщения в очереди, для отката вызовом функции <xref:System.Messaging.MessageQueueTransaction.Abort%2A>будет нечего выполняться.  
  
 Используйте вызов метода, <xref:System.Messaging.MessageQueue.Receive%2A>, если он приемлем для блокировки текущего потока, пока он ожидает поступления сообщения в очередь. Поскольку эта перегрузка метода <xref:System.Messaging.MessageQueue.Receive%2A> указывает на бесконечное время ожидания, приложение может ждать бесконечно. Если обработка приложения должна быть продолжена без ожидания сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Получает первое сообщение, доступное в очереди, на которую ссылается объект <see cref="T:System.Messaging.MessageQueue" />, и ожидает пока в очереди не появится сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщений и их возврата в течение указанного срока, если в очереди нет сообщений.  
  
 Метод <xref:System.Messaging.MessageQueue.Receive%2A> позволяет синхронно считывать сообщение, удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> будут возвращать сообщения, следующие за очередью, или новые сообщения с более высоким приоритетом.  
  
 Чтобы прочитать первое сообщение в очереди, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.Peek%2A>. Метод <xref:System.Messaging.MessageQueue.Peek%2A> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом.  
  
 Используйте вызов метода, <xref:System.Messaging.MessageQueue.Receive%2A>, если он приемлем для блокировки текущего потока, пока он ожидает поступления сообщения в очередь. Поток будет заблокирован на указанный период времени или неопределенное время, если указано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для параметра `timeout`. Если обработка приложения должна продолжаться без ожидания сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 Следующий пример кода получает сообщение из очереди и выводит сведения об этом сообщении на экран. В этом примере выполнение приостанавливается до пяти секунд при ожидании поступления сообщения в очередь.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <summary>Получает текущее сообщение в очереди, используя заданный курсор. Если доступных сообщений нет, этот метод ожидает, пока не станет доступным сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.  
  
 Используйте эту перегрузку для получения сообщений и их возврата в течение указанного срока, если в очереди нет сообщений.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает первое сообщение, доступное в транзакционной очереди, на которую ссылается объект <see cref="T:System.Messaging.MessageQueue" />, и ожидает, пока в очереди не появится сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщения из транзакционной очереди с помощью контекста внутренней транзакции, определенного параметром `transaction`, и возврата в течение указанного периода времени, если в очереди нет сообщений.  
  
 Метод <xref:System.Messaging.MessageQueue.Receive%2A> позволяет синхронно считывать сообщения, тем самым удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> будут возвращать сообщения, следующие за очередью.  
  
 Поскольку этот метод вызывается для транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Чтобы прочитать первое сообщение в очереди, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.Peek%2A>. Метод <xref:System.Messaging.MessageQueue.Peek%2A> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.Peek%2A>. Поскольку <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет какие-либо сообщения в очереди, для отката вызовом функции <xref:System.Messaging.MessageQueueTransaction.Abort%2A>будет нечего выполняться.  
  
 Используйте вызов метода, <xref:System.Messaging.MessageQueue.Receive%2A>, если он приемлем для блокировки текущего потока, пока он ожидает поступления сообщения в очередь. Поток будет заблокирован на указанный период времени или неопределенное время, если указано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для параметра `timeout`. Если обработка приложения должна продолжаться без ожидания сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование этого метода.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 - или -  
  
 Очередь является нетранзакционной.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает первое доступное в очереди сообщение, на которое ссылается объект <see cref="T:System.Messaging.MessageQueue" />. Данный вызов является синхронным, и он ожидает, пока в очереди не появится сообщение, или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на первое доступное в очереди сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщения из очереди с помощью контекста транзакции, определенного параметром `transactionType`, и возврата в указанный период времени, если в очереди нет сообщений.  
  
 Укажите `Automatic` для параметра `transactionType`, если к потоку, который требуется использовать для получения сообщения, уже присоединен контекст внешней транзакции. Укажите `Single`, если вы хотите получить сообщение как одну внутреннюю транзакцию. Можно указать `None`, если требуется получить сообщение из транзакционной очереди за пределами контекста транзакции.  
  
 Метод <xref:System.Messaging.MessageQueue.Receive%2A> позволяет синхронно считывать сообщения, тем самым удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> будут возвращать сообщения, следующие за очередью.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Чтобы прочитать первое сообщение в очереди, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.Peek%2A>. Метод <xref:System.Messaging.MessageQueue.Peek%2A> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.Peek%2A>. Поскольку <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет какие-либо сообщения в очереди, для отката вызовом функции <xref:System.Messaging.MessageQueueTransaction.Abort%2A>будет нечего выполняться.  
  
 Используйте вызов метода, <xref:System.Messaging.MessageQueue.Receive%2A>, если он приемлем для блокировки текущего потока, пока он ожидает поступления сообщения в очередь. Поток будет заблокирован на указанный период времени или неопределенное время, если указано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для параметра `timeout`. Если обработка приложения должна продолжаться без ожидания сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование этого метода.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает текущее сообщение в очереди, используя заданный курсор. Если доступных сообщений нет, этот метод ожидает, пока не станет доступным сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщения из транзакционной очереди с помощью контекста внутренней транзакции, определенного параметром `transaction`, и возврата в течение указанного периода времени, если в очереди нет сообщений.  
  
 Метод <xref:System.Messaging.MessageQueue.Receive%2A> позволяет синхронно считывать сообщения, тем самым удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращают сообщения, следующие за очередью.  
  
 Поскольку этот метод вызывается для транзакционной очереди, полученное сообщение возвращается в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Чтобы прочитать сообщение в очереди, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.Peek%2A>. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.Peek%2A>. Поскольку <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет какие-либо сообщения в очереди, нет никаких действий для отката путем вызова метода <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Используйте вызов метода, <xref:System.Messaging.MessageQueue.Receive%2A>, если он приемлем для блокировки текущего потока, пока он ожидает поступления сообщения в очередь. Поток заблокирован на указанный период времени или неопределенное время, если указано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для параметра `timeout`. Если обработка приложения должна продолжаться без ожидания сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.  
  
- или - 
Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо. Возможно, значение параметра <paramref name="timeout" /> меньше, чем <see cref="F:System.TimeSpan.Zero" />, или больше, чем <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 - или -  
  
 Очередь является нетранзакционной.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="cursor">Объект <see cref="T:System.Messaging.Cursor" />, который сохраняет определенное положение в очереди сообщений.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает текущее сообщение в очереди, используя заданный курсор. Если доступных сообщений нет, этот метод ожидает, пока не станет доступным сообщение или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, ссылающийся на сообщение в очереди.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для получения сообщения из очереди с помощью контекста транзакции, определенного параметром `transactionType`, и возврата в указанный период времени, если в очереди нет сообщений.  
  
 Укажите `Automatic` для параметра `transactionType`, если к потоку, который требуется использовать для получения сообщения, уже присоединен контекст внешней транзакции. Укажите `Single`, если вы хотите получить сообщение как одну внутреннюю транзакцию. Можно указать `None`, если требуется получить сообщение из транзакционной очереди за пределами контекста транзакции.  
  
 Метод <xref:System.Messaging.MessageQueue.Receive%2A> позволяет синхронно считывать сообщения, тем самым удаляя его из очереди. Последующие вызовы <xref:System.Messaging.MessageQueue.Receive%2A> возвращают сообщения, следующие за очередью.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение возвращается в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Чтобы прочитать сообщение в очереди, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.Peek%2A>. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.Peek%2A>. Поскольку <xref:System.Messaging.MessageQueue.Peek%2A> не удаляет какие-либо сообщения в очереди, нет никаких действий для отката путем вызова метода <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Используйте вызов метода, <xref:System.Messaging.MessageQueue.Receive%2A>, если он приемлем для блокировки текущего потока, пока он ожидает поступления сообщения в очередь. Поток заблокирован на указанный период времени или неопределенное время, если указано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для параметра `timeout`. Если обработка приложения должна продолжаться без ожидания сообщения, рассмотрите возможность использования асинхронного метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="cursor" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Значение, заданное для параметра <paramref name="timeout" />, недопустимо. Возможно, значение параметра <paramref name="timeout" /> меньше, чем <see cref="F:System.TimeSpan.Zero" />, или больше, чем <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">До истечения тайм-аута в очередь сообщений не поступало.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <threadsafe>Метод не является потокобезопасным.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции (из нетранзакционной очереди), и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором корреляции.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск в нетранзакционной очереди, на которую ссылается <xref:System.Messaging.MessageQueue> для сообщения, <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному параметру `correlationId`. Если не найдено ни одного сообщения, соответствующего параметру `correlationID`, возникает исключение. В противном случае сообщение удаляется из очереди и возвращается приложению.  
  
 Свойство <xref:System.Messaging.Message.CorrelationId%2A> используется для привязки сообщения, отправленного в очередь, к связанному ответу, отчету или сообщениям подтверждения.  
  
 Два других метода позволяют принимать сообщения из очереди. Метод <xref:System.Messaging.MessageQueue.Receive%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> извлекает сообщение, указывая его уникальный идентификатор.  
  
 Чтобы прочитать сообщение с указанным идентификатором корреляции, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 Следующий пример кода отправляет и получает сообщение, которое содержит порядок в очередь и из нее. Он специально запрашивает положительное подтверждение, когда исходное сообщение достигает или извлекается из очереди.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции (из транзакционной очереди), и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором корреляции.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск в транзакционной очереди, на которую ссылается <xref:System.Messaging.MessageQueue>, для сообщения, <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному параметру `correlationId`. Если не найдено ни одного сообщения, соответствующего параметру `correlationID`, возникает исключение. В противном случае сообщение удаляется из очереди и возвращается приложению с помощью контекста внутренней транзакции, определенного параметром `transaction`.  
  
 Поскольку этот метод вызывается для транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Свойство <xref:System.Messaging.Message.CorrelationId%2A> используется для привязки сообщения, отправленного в очередь, к связанному ответу, отчету или сообщениям подтверждения.  
  
 Два других метода позволяют принимать сообщения из очереди. Метод <xref:System.Messaging.MessageQueue.Receive%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> используется для получения сообщения путем указания его уникального идентификатора.  
  
 Чтобы прочитать сообщение с указанным идентификатором корреляции, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> не удаляет какие-либо сообщения в очереди, откат транзакции будет невозможен, если транзакция была прервана.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.  
  
- или - 
Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Очередь является нетранзакционной.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции, и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором корреляции.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск в очереди, на которую ссылается <xref:System.Messaging.MessageQueue> сообщения, <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному параметру `correlationId`. Если не найдено ни одного сообщения, соответствующего параметру `correlationID`, возникает исключение. В противном случае сообщение удаляется из очереди и возвращается приложению с помощью контекста транзакции, определенного параметром `transactionType`.  
  
 Укажите `Automatic` для параметра `transactionType`, если к потоку, который требуется использовать для получения сообщения, уже присоединен контекст внешней транзакции. Укажите `Single`, если вы хотите получить сообщение как одну внутреннюю транзакцию. Можно указать `None`, если требуется получить сообщение из транзакционной очереди за пределами контекста транзакции.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Свойство <xref:System.Messaging.Message.CorrelationId%2A> используется для привязки сообщения, отправленного в очередь, к связанному ответу, отчету или сообщениям подтверждения.  
  
 Два других метода позволяют принимать сообщения из очереди. Метод <xref:System.Messaging.MessageQueue.Receive%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> используется для получения сообщения путем указания его уникального идентификатора.  
  
 Чтобы прочитать сообщение с указанным идентификатором корреляции, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> не удаляет какие-либо сообщения в очереди, откат транзакции будет невозможен, если транзакция была прервана.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции (из нетранзакционной очереди), и ожидает, пока в очереди не появится сообщение с указанным идентификатором корреляции или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск в нетранзакционной очереди, на которую ссылается <xref:System.Messaging.MessageQueue> для сообщения, <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному параметру `correlationId`. Этот метод немедленно возвращает значение, если сообщение с идентификатором корреляции, заданным параметром `correlationId`, находится в очереди. В противном случае метод ожидает поступления нового сообщения в течение заданного периода времени. Если новое сообщение не будет доставлено до истечения времени ожидания, возникает исключение.  
  
 Параметр `timeout` не задает общее время выполнения для этого метода. Вместо этого он указывает время ожидания поступления нового сообщения в очередь. Каждый раз, когда поступает новое сообщение, этот метод проверяет <xref:System.Messaging.Message.CorrelationId%2A> нового сообщения, чтобы проверить, соответствует ли он параметру `correlationId`. В противном случае этот метод запускает период времени ожидания и ожидает поступления другого нового сообщения. Таким образом, если новые сообщения продолжают поступать в течение времени ожидания, этот метод может продолжать работу в течение неограниченного времени, пока не истечет время ожидания, не прибегая новых сообщений, или пока не поступит сообщение, <xref:System.Messaging.Message.CorrelationId%2A> которого соответствует параметру `correlationId`.  
  
 Свойство <xref:System.Messaging.Message.CorrelationId%2A> используется для привязки сообщения, отправленного в очередь, к связанному ответу, отчету или сообщениям подтверждения.  
  
 Два других метода позволяют принимать сообщения из очереди. Метод <xref:System.Messaging.MessageQueue.Receive%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> используется для получения сообщения путем указания его уникального идентификатора.  
  
 Чтобы прочитать сообщение с указанным идентификатором корреляции, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с заданным параметром <paramref name="correlationId" /> не существует в очереди и не поступило до истечения тайм-аута.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции (из транзакционной очереди), и ожидает, пока в очереди не появится сообщение с указанным идентификатором корреляции или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск в транзакционной очереди, на которую ссылается <xref:System.Messaging.MessageQueue>, для сообщения, <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному параметру `correlationId`. Этот метод немедленно возвращает значение, если сообщение с идентификатором корреляции, заданным параметром `correlationId`, находится в очереди, используя контекст внутренней транзакции, определенный параметром `transaction`. В противном случае метод ожидает поступления нового сообщения в течение заданного периода времени. Если новое сообщение не будет доставлено до истечения времени ожидания, возникает исключение.  
  
 Параметр `timeout` не задает общее время выполнения для этого метода. Вместо этого он указывает время ожидания поступления нового сообщения в очередь. Каждый раз, когда поступает новое сообщение, этот метод проверяет <xref:System.Messaging.Message.CorrelationId%2A> нового сообщения, чтобы проверить, соответствует ли он параметру `correlationId`. В противном случае этот метод запускает период времени ожидания и ожидает поступления другого нового сообщения. Таким образом, если новые сообщения продолжают поступать в течение времени ожидания, этот метод может продолжать работу в течение неограниченного времени, пока не истечет время ожидания, не прибегая новых сообщений, или пока не поступит сообщение, <xref:System.Messaging.Message.CorrelationId%2A> которого соответствует параметру `correlationId`.  
  
 Поскольку этот метод вызывается для транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Свойство <xref:System.Messaging.Message.CorrelationId%2A> используется для привязки сообщения, отправленного в очередь, к связанному ответу, отчету или сообщениям подтверждения.  
  
 Два других метода позволяют принимать сообщения из очереди. Метод <xref:System.Messaging.MessageQueue.Receive%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> используется для получения сообщения путем указания его уникального идентификатора.  
  
 Чтобы прочитать сообщение с указанным идентификатором корреляции, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> не удаляет какие-либо сообщения в очереди, откат транзакции будет невозможен, если транзакция была прервана.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.  
  
- или - 
Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с заданным параметром <paramref name="correlationId" /> не существует в очереди и не поступило до истечения тайм-аута.  
  
- или - 
Очередь является нетранзакционной.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Свойство <see cref="P:System.Messaging.Message.CorrelationId" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору корреляции и ожидает, пока в очереди не появится сообщение с указанным идентификатором корреляции или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.CorrelationId" /> которого соответствует переданному в объект параметру <paramref name="correlationId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод выполняет поиск в очереди, на которую ссылается <xref:System.Messaging.MessageQueue> сообщения, <xref:System.Messaging.Message.CorrelationId%2A> соответствует указанному параметру `correlationId`. Этот метод немедленно возвращает значение, если сообщение с идентификатором корреляции, заданным параметром `correlationId`, находится в очереди с использованием контекста транзакции, определенного параметром `transactionType`. В противном случае метод ожидает поступления нового сообщения в течение заданного периода времени. Если новое сообщение не будет доставлено до истечения времени ожидания, возникает исключение.  
  
 Параметр `timeout` не задает общее время выполнения для этого метода. Вместо этого он указывает время ожидания поступления нового сообщения в очередь. Каждый раз, когда поступает новое сообщение, этот метод проверяет <xref:System.Messaging.Message.CorrelationId%2A> нового сообщения, чтобы проверить, соответствует ли он параметру `correlationId`. В противном случае этот метод запускает период времени ожидания и ожидает поступления другого нового сообщения. Таким образом, если новые сообщения продолжают поступать в течение времени ожидания, этот метод может продолжать работу в течение неограниченного времени, пока не истечет время ожидания, не прибегая новых сообщений, или пока не поступит сообщение, <xref:System.Messaging.Message.CorrelationId%2A> которого соответствует параметру `correlationId`. Укажите `Automatic` для параметра `transactionType`, если к потоку, который требуется использовать для получения сообщения, уже присоединен контекст внешней транзакции. Укажите `Single`, если вы хотите получить сообщение как одну внутреннюю транзакцию. Можно указать `None`, если требуется получить сообщение из транзакционной очереди за пределами контекста транзакции.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Свойство <xref:System.Messaging.Message.CorrelationId%2A> используется для привязки сообщения, отправленного в очередь, к связанному ответу, отчету или сообщениям подтверждения.  
  
 Два других метода позволяют принимать сообщения из очереди. Метод <xref:System.Messaging.MessageQueue.Receive%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> используется для получения сообщения путем указания его уникального идентификатора.  
  
 Чтобы прочитать сообщение с указанным идентификатором корреляции, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> не удаляет какие-либо сообщения в очереди, откат транзакции будет невозможен, если транзакция была прервана.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="correlationId" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="correlationId" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с заданным параметром <paramref name="correlationId" /> не существует в очереди и не поступило до истечения тайм-аута.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает сообщение, которое соответствует заданному идентификатору, удаляя его из очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <summary>Получает из нетранзакционной очереди сообщение, которое соответствует заданному идентификатору, и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и его удаления из очереди. Этот метод немедленно создает исключение, если сообщение не находится в очереди.  
  
 Свойство <xref:System.Messaging.Message.Id%2A> сообщения является уникальным в рамках организации очереди сообщений, поэтому в очереди должно быть не более одного сообщения, которое соответствует заданному параметру `id`.  
  
 Два других метода позволяют принимать сообщения из очереди. Метод <xref:System.Messaging.MessageQueue.Receive%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> используется для получения сообщения о подтверждении, отчете или сформированном приложением ответном сообщении, которое было создано в результате сообщения, отправленного в очередь.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="id" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору (из транзакционной очереди), и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удаления его из очереди с помощью контекста внутренней транзакции, определенного параметром `transaction`. Этот метод немедленно создает исключение, если сообщение не находится в очереди  
  
 Свойство <xref:System.Messaging.Message.Id%2A> сообщения является уникальным в рамках организации очереди сообщений, поэтому в очереди должно быть не более одного сообщения, которое соответствует заданному параметру `id`.  
  
 Поскольку этот метод вызывается для транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Два других метода позволяют принимать сообщения из очереди. Метод <xref:System.Messaging.MessageQueue.Receive%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> используется для получения сообщения о подтверждении, отчете или сформированном приложением ответном сообщении, которое было создано в результате сообщения, отправленного в очередь.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> не удаляет какие-либо сообщения в очереди, откат транзакции будет невозможен, если транзакция была прервана.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.  
  
- или - 
Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="id" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Очередь является нетранзакционной.  
  
 - или -  
  
 При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору, и сразу инициирует исключение, если в настоящий момент в очереди нет сообщения с указанным идентификатором.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и его удаления из очереди. Этот метод немедленно создает исключение, если сообщение не находится в очереди. В противном случае сообщение удаляется из очереди и возвращается приложению с помощью контекста транзакции, определенного параметром `transactionType`.  
  
 Укажите `Automatic` для параметра `transactionType`, если к потоку, который требуется использовать для получения сообщения, уже присоединен контекст внешней транзакции. Укажите `Single`, если вы хотите получить сообщение как одну внутреннюю транзакцию. Можно указать `None`, если требуется получить сообщение из транзакционной очереди за пределами контекста транзакции.  
  
 Свойство <xref:System.Messaging.Message.Id%2A> сообщения является уникальным в рамках организации очереди сообщений, поэтому в очереди должно быть не более одного сообщения, которое соответствует заданному параметру `id`. Если сообщение с указанным идентификатором находится в очереди, отличной от той, которая связана с данным экземпляром <xref:System.Messaging.MessageQueue>, сообщение не будет найдено.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Два других метода позволяют принимать сообщения из очереди. Метод <xref:System.Messaging.MessageQueue.Receive%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> используется для получения сообщения о подтверждении, отчете или сформированном приложением ответном сообщении, которое было создано в результате сообщения, отправленного в очередь.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> не удаляет какие-либо сообщения в очереди, откат транзакции будет невозможен, если транзакция была прервана.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="id" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору (из нетранзакционной очереди), и ожидает, пока в очереди не появится сообщение с указанным идентификатором, или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и его удаления из очереди. Этот метод немедленно возвращает значение, если сообщение с идентификатором, указанным в параметре `id`, находится в очереди. В противном случае метод ожидает поступления нового сообщения в течение заданного периода времени. Если новое сообщение не будет доставлено до истечения времени ожидания, возникает исключение.  
  
 Параметр `timeout` не задает общее время выполнения для этого метода. Вместо этого он указывает время ожидания поступления нового сообщения в очередь. Каждый раз, когда поступает новое сообщение, этот метод проверяет <xref:System.Messaging.Message.Id%2A> нового сообщения, чтобы проверить, соответствует ли он параметру `id`. В противном случае этот метод запускает период времени ожидания и ожидает поступления другого нового сообщения. Таким образом, если новые сообщения продолжают поступать в течение времени ожидания, этот метод может продолжать работу в течение неограниченного времени, пока не истечет время ожидания, не прибегая новых сообщений, или пока не поступит сообщение, <xref:System.Messaging.Message.Id%2A> которого соответствует параметру `id`.  
  
 Свойство <xref:System.Messaging.Message.Id%2A> сообщения является уникальным в рамках организации очереди сообщений, поэтому в очереди должно быть не более одного сообщения, которое соответствует заданному параметру `id`.  
  
 Используйте эту перегрузку <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>, если допускается блокировка текущего потока при условии, что новые сообщения продолжают поступать в очередь в течение времени ожидания, заданного параметром `timeout`. Поток будет заблокирован по крайней мере в заданный период времени или неопределенно, если указано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для параметра `timeout` или если новые сообщения по-прежнему поступают в очередь в течение времени ожидания, заданного параметром `timeout`.  
  
 Два других метода позволяют принимать сообщения из очереди. Метод <xref:System.Messaging.MessageQueue.Receive%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> используется для получения сообщения о подтверждении, отчете или сформированном приложением ответном сообщении, которое было создано в результате сообщения, отправленного в очередь.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с указанным значением параметра <paramref name="id" /> до истечения тайм-аута в очередь не поступало.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору (из транзакционной очереди), и ожидает, пока в очереди не появится сообщение с указанным идентификатором, или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и удаления его из очереди с помощью контекста внутренней транзакции, определенного параметром `transaction`. Этот метод немедленно возвращает значение, если сообщение с идентификатором, указанным в параметре `id`, находится в очереди. В противном случае метод ожидает поступления нового сообщения в течение заданного периода времени. Если новое сообщение не будет доставлено до истечения времени ожидания, возникает исключение.  
  
 Параметр `timeout` не задает общее время выполнения для этого метода. Вместо этого он указывает время ожидания поступления нового сообщения в очередь. Каждый раз, когда поступает новое сообщение, этот метод проверяет <xref:System.Messaging.Message.Id%2A> нового сообщения, чтобы проверить, соответствует ли он параметру `id`. В противном случае этот метод запускает период времени ожидания и ожидает поступления другого нового сообщения. Таким образом, если новые сообщения продолжают поступать в течение времени ожидания, этот метод может продолжать работу в течение неограниченного времени, пока не истечет время ожидания, не прибегая новых сообщений, или пока не поступит сообщение, <xref:System.Messaging.Message.Id%2A> которого соответствует параметру `id`.  
  
 Свойство <xref:System.Messaging.Message.Id%2A> сообщения является уникальным в рамках организации очереди сообщений, поэтому в очереди должно быть не более одного сообщения, которое соответствует заданному параметру `id`.  
  
 Используйте эту перегрузку <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>, если допускается блокировка текущего потока при условии, что новые сообщения продолжают поступать в очередь в течение времени ожидания, заданного параметром `timeout`. Поток будет заблокирован по крайней мере на заданный период времени или неопределенно, если указано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для параметра `timeout` или если новые сообщения по-прежнему поступают в очередь в течение времени ожидания, заданного параметром `timeout`.  
  
 Поскольку этот метод вызывается для транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Два других метода позволяют принимать сообщения из очереди. Метод <xref:System.Messaging.MessageQueue.Receive%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> используется для получения сообщения о подтверждении, отчете или сформированном приложением ответном сообщении, которое было создано в результате сообщения, отправленного в очередь.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают одно и то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> не удаляет какие-либо сообщения в очереди, откат транзакции будет невозможен, если транзакция была прервана.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.  
  
- или - 
Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с указанным значением параметра <paramref name="id" /> до истечения тайм-аута в очередь не поступало.  
  
- или - 
Очередь является нетранзакционной.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Свойство <see cref="P:System.Messaging.Message.Id" /> получаемого сообщения.</param>
        <param name="timeout">Структура <see cref="T:System.TimeSpan" />, показывающая время ожидания нового сообщения для проверки.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Получает сообщение, которое соответствует заданному идентификатору, и ожидает, пока в очереди не появится сообщение с указанным идентификатором, или пока не истечет тайм-аут.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Id" /> которого соответствует переданному в объект параметру <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором и его удаления из очереди. Этот метод немедленно возвращает значение, если сообщение с идентификатором, указанным в параметре `id`, находится в очереди с использованием контекста транзакции, определенного параметром `transactionType`. В противном случае метод ожидает поступления нового сообщения в течение заданного периода времени. Если новое сообщение не будет доставлено до истечения времени ожидания, возникает исключение.  
  
 Параметр `timeout` не задает общее время выполнения для этого метода. Вместо этого он указывает время ожидания поступления нового сообщения в очередь. Каждый раз, когда поступает новое сообщение, этот метод проверяет <xref:System.Messaging.Message.Id%2A> нового сообщения, чтобы проверить, соответствует ли он параметру `id`. В противном случае этот метод запускает период времени ожидания и ожидает поступления другого нового сообщения. Таким образом, если новые сообщения продолжают поступать в течение времени ожидания, этот метод может продолжать работу в течение неограниченного времени, пока не истечет время ожидания, не прибегая новых сообщений, или пока не поступит сообщение, <xref:System.Messaging.Message.Id%2A> которого соответствует параметру `id`.  
  
 Укажите `Automatic` для параметра `transactionType`, если к потоку, который требуется использовать для получения сообщения, уже присоединен контекст внешней транзакции. Укажите `Single`, если вы хотите получить сообщение как одну внутреннюю транзакцию. Можно указать `None`, если требуется получить сообщение из транзакционной очереди за пределами контекста транзакции.  
  
 Свойство <xref:System.Messaging.Message.Id%2A> сообщения является уникальным в рамках организации очереди сообщений, поэтому в очереди должно быть не более одного сообщения, которое соответствует заданному параметру `id`. Если сообщение с указанным идентификатором находится в очереди, отличной от той, которая связана с данным экземпляром <xref:System.Messaging.MessageQueue>, сообщение не будет найдено.  
  
 Используйте эту перегрузку <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>, если допускается блокировка текущего потока при условии, что новые сообщения продолжают поступать в очередь в течение времени ожидания, заданного параметром `timeout`. Поток будет заблокирован по крайней мере в заданный период времени или неопределенно, если указано значение <xref:System.Messaging.MessageQueue.InfiniteTimeout> для параметра `timeout` или если новые сообщения по-прежнему поступают в очередь в течение времени ожидания, заданного параметром `timeout`.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Два других метода позволяют принимать сообщения из очереди. Метод <xref:System.Messaging.MessageQueue.Receive%2A> возвращает первое сообщение в очереди, а метод <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> используется для получения сообщения о подтверждении, отчете или сформированном приложением ответном сообщении, которое было создано в результате сообщения, отправленного в очередь.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Метод <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> всегда возвращает первое сообщение в очереди, поэтому последующие вызовы метода возвращают то же сообщение, если в очередь не поступает сообщение с более высоким приоритетом. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Поскольку <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> не удаляет какие-либо сообщения в очереди, откат транзакции будет невозможен, если транзакция была прервана.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="id" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Для параметра <paramref name="timeout" /> задано недопустимое значение; возможно, значение параметра <paramref name="timeout" /> меньше <see cref="F:System.TimeSpan.Zero" /> или больше <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Сообщение с указанным значением параметра <paramref name="id" /> до истечения тайм-аута в очередь не поступало.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Представлено в MSMQ 3.0. Получает конкретное сообщение из очереди. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> получаемого сообщения.</param>
        <summary>Представлено в MSMQ 3.0. Получает сообщение, соответствующее заданному идентификатору просмотра, из нетранзакционной очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.LookupId" /> которого соответствует переданному в объект параметру <paramref name="lookupId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором уточняющего запроса и удаления его из очереди. Этот метод немедленно создает исключение, если сообщение не находится в очереди.  
  
 Свойство <xref:System.Messaging.Message.LookupId%2A> сообщения является уникальным для очереди, в которой находится сообщение, поэтому в очереди должно быть не более одного сообщения, которое соответствует заданному параметру `lookupId`.  
  
 Чтобы прочитать сообщение с указанным идентификатором поиска, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Одно из значений <see cref="T:System.Messaging.MessageLookupAction" />, задающее порядок чтения сообщения в очереди. Укажите одно из следующих значений: 
 <see langword="MessageLookupAction.Current" />. получает сообщение, заданное параметром <paramref name="lookupId" />, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.Next" />. получает сообщение, следующее за сообщением, заданным параметром <paramref name="lookupId" />, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.Previous" />. получает сообщение, предшествующее сообщению, заданному параметром <paramref name="lookupId" />, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.First" />. получает первое сообщение в очереди и удаляет его из очереди. Параметр <paramref name="lookupId" /> должен быть установлен равным 0.  
  
 <see langword="MessageLookupAction.Last" />. получает последнее сообщение в очереди и удаляет его из очереди. Параметр <paramref name="lookupId" /> должен быть установлен равным 0.</param>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> получаемого сообщения или значение 0. Значение, равное 0, используется при доступе к первому или последнему сообщению в очереди.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Представлено в MSMQ 3.0. Получает конкретное сообщение из транзакционной очереди. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, задаваемый передаваемыми параметрами <paramref name="lookupId" /> и <paramref name="action" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором уточняющего запроса и удаления его из очереди с помощью контекста транзакции, определенного параметром `transaction`. Этот метод немедленно создает исключение, если сообщение не находится в очереди.  
  
 Свойство <xref:System.Messaging.Message.LookupId%2A> сообщения является уникальным для очереди, в которой находится сообщение, поэтому в очереди должно быть не более одного сообщения, которое соответствует заданному параметру `lookupId`.  
  
 Поскольку этот метод вызывается для транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Поскольку <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> не удаляет какие-либо сообщения из очереди, в случае отмены транзакции будет нечего возвращаться.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.  
  
 - или -  
  
 Очередь является нетранзакционной.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="action" /> не является одним из членов <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lookupId" Type="System.Int64" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="action">Одно из значений <see cref="T:System.Messaging.MessageLookupAction" />, задающее порядок чтения сообщения в очереди. Укажите одно из следующих значений: 
 <see langword="MessageLookupAction.Current" />. получает сообщение, заданное параметром <paramref name="lookupId" />, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.Next" />. получает сообщение, следующее за сообщением, заданным параметром <paramref name="lookupId" />, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.Previous" />. получает сообщение, предшествующее сообщению, заданному параметром <paramref name="lookupId" />, и удаляет это сообщение из очереди.  
  
 <see langword="MessageLookupAction.First" />. получает первое сообщение в очереди и удаляет его из очереди. Параметр <paramref name="lookupId" /> должен быть установлен равным 0.  
  
 <see langword="MessageLookupAction.Last" />. получает последнее сообщение в очереди и удаляет его из очереди. Параметр <paramref name="lookupId" /> должен быть установлен равным 0.</param>
        <param name="lookupId">Свойство <see cref="P:System.Messaging.Message.LookupId" /> получаемого сообщения или значение 0. Значение, равное 0, используется при доступе к первому или последнему сообщению в очереди.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Представлено в MSMQ 3.0. Получает из очереди определенное сообщение, используя заданный контекст транзакции. Сообщение может быть задано кодом просмотра либо его положением относительно начала или конца очереди.</summary>
        <returns>Объект <see cref="T:System.Messaging.Message" />, задаваемый передаваемыми параметрами <paramref name="action" /> и <paramref name="lookupId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для чтения сообщения с известным идентификатором уточняющего запроса и удаления его из очереди с помощью контекста транзакции, определенного параметром `transactionType`. Этот метод немедленно создает исключение, если сообщение не находится в очереди.  
  
 Свойство <xref:System.Messaging.Message.LookupId%2A> сообщения является уникальным для очереди, в которой находится сообщение, поэтому в очереди должно быть не более одного сообщения, которое соответствует заданному параметру `lookupId`.  
  
 Чтобы прочитать сообщение с указанным идентификатором, не удаляя его из очереди, используйте метод <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Отсутствует контекст транзакции, связанный с сообщением, возвращенным вызовом <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Поскольку <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> не удаляет какие-либо сообщения из очереди, в случае отмены транзакции будет нечего возвращаться.  
  
 Укажите `Automatic` для параметра `transactionType`, если к потоку, который требуется использовать для получения сообщения, уже присоединен контекст внешней транзакции. Укажите `Single`, если вы хотите получить сообщение как одну внутреннюю транзакцию. Можно указать `None`, если требуется получить сообщение из транзакционной очереди за пределами контекста транзакции.  
  
 Если этот метод вызывается для получения сообщения из транзакционной очереди, полученное сообщение будет возвращено в очередь, если транзакция прервана. Сообщение не удаляется навсегда из очереди до тех пор, пока транзакция не будет зафиксирована.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Приложение MSMQ 3.0 не установлено.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось найти сообщение с указанным параметром <paramref name="lookupId" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="action" /> не является одним из членов <see cref="T:System.Messaging.MessageLookupAction" />.  
  
- или - 
Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, если сообщение было удалено из очереди. Это событие инициируется асинхронной операцией, <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> используется в асинхронной обработке для вызова события <xref:System.Messaging.MessageQueue.ReceiveCompleted>, когда сообщение доступно в очереди.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> используется для завершения операции, инициированной вызовом метода <xref:System.Messaging.MessageQueue.BeginReceive%2A>, и просмотра сообщения при возникновении события <xref:System.Messaging.MessageQueue.ReceiveCompleted>.  
  
 При создании делегата <xref:System.Messaging.ReceiveCompletedEventHandler> необходимо указать метод, обрабатывающий событие. Чтобы связать событие с обработчиком событий, нужно добавить в событие экземпляр делегата. Обработчик событий вызывается всякий раз, когда происходит событие, если делегат не удален. Дополнительные сведения о делегатах обработчиков событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Следующий пример кода создает обработчик событий с именем `MyReceiveCompleted`, присоединяет его к делегату обработчика событий <xref:System.Messaging.MessageQueue.ReceiveCompleted> и вызывает <xref:System.Messaging.MessageQueue.BeginReceive%2A> для инициации асинхронной операции получения в очереди, расположенной по пути ".\Микуеуе". Когда возникает событие <xref:System.Messaging.MessageQueue.ReceiveCompleted>, пример получает сообщение и записывает его текст на экран. Затем в примере вызывается <xref:System.Messaging.MessageQueue.BeginReceive%2A> еще раз, чтобы инициировать новую асинхронную операцию получения.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обновляет свойства, представленные объектом <see cref="T:System.Messaging.MessageQueue" /> для отражения текущего состояния ресурса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> синхронизирует свойства <xref:System.Messaging.MessageQueue> со связанным ресурсом сервера очереди сообщений. Если какое бы то ни было свойство, например <xref:System.Messaging.MessageQueue.Label%2A> или <xref:System.Messaging.MessageQueue.Category%2A>, изменилось на сервере с момента создания <xref:System.Messaging.MessageQueue>, <xref:System.Messaging.MessageQueue.Refresh%2A> обновляет <xref:System.Messaging.MessageQueue> новыми данными.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Присваивает списку разрешений значения по умолчанию операционной системы. Удаляет все разрешения очередей, добавленные в список по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.Messaging.MessageQueue.ResetPermissions%2A>список разрешений возвращается к значениям по умолчанию. Как правило, эта группа предоставляет всем разрешениям автора очереди и предоставляет группе все следующие права:  
  
-   Получение свойств очереди.  
  
-   Получение разрешений очереди.  
  
-   Запись в очередь.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Отправляет объект в очередь.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <summary>Отправляет объект в нетранзакционную очередь, на которую ссылается этот класс <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для отправки сообщения, содержащего параметр `obj`, в очередь, на которую ссылается <xref:System.Messaging.MessageQueue>. Объектом, отправляемым в очередь, может быть <xref:System.Messaging.Message> или любой управляемый объект. При отправке любого объекта, отличного от <xref:System.Messaging.Message>, объект сериализуется и вставляется в текст сообщения.  
  
 Если эта перегрузка используется для отправки сообщения в транзакционную очередь, сообщение будет отправлено в очередь недоставленных сообщений. Если необходимо, чтобы сообщение было частью транзакции, содержащей другие сообщения, используйте перегрузку, которая принимает <xref:System.Messaging.MessageQueueTransaction> или <xref:System.Messaging.MessageQueueTransactionType> в качестве параметра.  
  
 Если не задать свойство <xref:System.Messaging.MessageQueue.Formatter%2A> перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию использует <xref:System.Messaging.XmlMessageFormatter>.  
  
 Свойство <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> применяется к любому объекту, кроме <xref:System.Messaging.Message>. Если указать, например, метку или приоритет с помощью члена <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, эти значения будут применяться к любому сообщению, содержащему объект, который не относится к типу <xref:System.Messaging.Message>, когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>значения свойств, заданные для <xref:System.Messaging.Message>, имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, а свойство <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> сообщения имеет приоритет над свойством <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> очереди.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 Следующий пример кода подключается к очереди сообщений и отправляет сообщение в очередь.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 В следующем примере кода определяемый приложением класс `Order` отправляется в очередь, а затем получает сообщение из этой очереди.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Отправляет объект в транзакционную очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для отправки сообщения, содержащего параметр `obj`, в очередь транзакций, на которую ссылается <xref:System.Messaging.MessageQueue>, используя контекст внутренней транзакции, определенный параметром `transaction`. Объектом, отправляемым в очередь, может быть <xref:System.Messaging.Message> или любой управляемый объект. При отправке любого объекта, отличного от <xref:System.Messaging.Message>, объект сериализуется и вставляется в текст сообщения.  
  
 При использовании этой перегрузки для отправки сообщения в нетранзакционную очередь сообщение может быть отправлено в очередь недоставленных сообщений без возникновения исключения.  
  
 Если не задать свойство <xref:System.Messaging.MessageQueue.Formatter%2A> перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию использует <xref:System.Messaging.XmlMessageFormatter>.  
  
 Свойство <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> применяется к любому объекту, кроме <xref:System.Messaging.Message>. Если указать, например, метку или приоритет с помощью члена <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, эти значения будут применяться к любому сообщению, содержащему объект, который не относится к типу <xref:System.Messaging.Message>, когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>значения свойств, заданные для <xref:System.Messaging.Message>, имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, а свойство <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> сообщения имеет приоритет над свойством <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> очереди.  
  
 <xref:System.Messaging.MessageQueueTransaction> учитывается потоковая подразделение, поэтому, если состояние апартамента — `STA`, нельзя использовать транзакцию в нескольких потоках. Visual Basic задает для основного потока состояние `STA`, поэтому необходимо применить <xref:System.MTAThreadAttribute> в подподпрограмме `Main`. В противном случае при отправке транзакционного сообщения с помощью другого потока создастся исключение <xref:System.Messaging.MessageQueueException>. Вы применяете <xref:System.MTAThreadAttribute> с помощью следующего фрагмента.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем примере кода строка отправляется в транзакционную очередь, а затем получает сообщение из этой очереди.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
- или - 
Приложение Message Queuing указало на неверное использование транзакции.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Отправляет объект в очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для отправки сообщения, содержащего параметр `obj`, в очередь, на которую ссылается <xref:System.Messaging.MessageQueue>, используя контекст транзакции, определенный параметром `transactionType`. Укажите `Automatic` для параметра `transactionType`, если к потоку, который требуется использовать для отправки сообщения, уже присоединен контекст внешней транзакции. Укажите `Single`, если вы хотите отправить сообщение как единую внутреннюю транзакцию. Можно указать `None`, если требуется отправить транзакционное сообщение в поток, не являющийся транзакционным.  
  
 Объектом, отправляемым в очередь, может быть <xref:System.Messaging.Message> или любой управляемый объект. При отправке любого объекта, отличного от <xref:System.Messaging.Message>, объект сериализуется и вставляется в текст сообщения.  
  
 Если не задать свойство <xref:System.Messaging.MessageQueue.Formatter%2A> перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию использует <xref:System.Messaging.XmlMessageFormatter>.  
  
 Свойство <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> применяется к любому объекту, кроме <xref:System.Messaging.Message>. Если указать, например, метку или приоритет с помощью члена <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, эти значения будут применяться к любому сообщению, содержащему объект, который не относится к типу <xref:System.Messaging.Message>, когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>значения свойств, заданные для <xref:System.Messaging.Message>, имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, а свойство <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> сообщения имеет приоритет над свойством <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> очереди.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="label">Метка сообщения.</param>
        <summary>Отправляет объект в нетранзакционную очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, и задает метку сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для отправки сообщения, содержащего параметр `obj`, в очередь, на которую ссылается <xref:System.Messaging.MessageQueue>. С помощью этой перегрузки можно указать строку, определяющую сообщение. Объект, отправляемый в очередь, может быть <xref:System.Messaging.Message>, структурой, объектом данных или любым управляемым объектом. При отправке любого объекта, отличного от <xref:System.Messaging.Message>, объект сериализуется и вставляется в текст сообщения.  
  
 Метка сообщения отличается от метки очереди сообщений, но обе они зависят от приложения и не имеют значения, наследуемого очередью сообщений.  
  
 Если эта перегрузка используется для отправки сообщения в транзакционную очередь, сообщение будет отправлено в очередь недоставленных сообщений. Если необходимо, чтобы сообщение было частью транзакции, содержащей другие сообщения, используйте перегрузку, которая принимает <xref:System.Messaging.MessageQueueTransaction> или <xref:System.Messaging.MessageQueueTransactionType> в качестве параметра.  
  
 Перед отправкой сообщения необходимо указать свойство <xref:System.Messaging.MessageQueue.Path%2A> для этого экземпляра <xref:System.Messaging.MessageQueue>. Если не задать свойство <xref:System.Messaging.MessageQueue.Formatter%2A> перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию использует <xref:System.Messaging.XmlMessageFormatter>.  
  
 Свойство <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> применяется к любому объекту, кроме <xref:System.Messaging.Message>. Если указать, например, метку или приоритет с помощью члена <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, эти значения будут применяться к любому сообщению, содержащему объект, который не относится к типу <xref:System.Messaging.Message>, когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>значения свойств, заданные для <xref:System.Messaging.Message>, имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, а свойство <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> сообщения имеет приоритет над свойством <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> очереди.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="label" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="label">Метка сообщения.</param>
        <param name="transaction">Объект <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Отправляет объект в транзакционную очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, и задает метку сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для отправки сообщения, содержащего параметр `obj`, в очередь транзакций, на которую ссылается <xref:System.Messaging.MessageQueue>, используя контекст внутренней транзакции, определенный параметром `transaction`. С помощью этой перегрузки можно указать строку, определяющую сообщение. Объект, отправляемый в очередь, может быть <xref:System.Messaging.Message>, структурой, объектом данных или любым управляемым объектом. При отправке любого объекта, отличного от <xref:System.Messaging.Message>, объект сериализуется и вставляется в текст сообщения.  
  
 Метка сообщения отличается от метки очереди сообщений, но обе они зависят от приложения и не имеют значения, наследуемого очередью сообщений.  
  
 При использовании этой перегрузки для отправки сообщения в нетранзакционную очередь сообщение может быть отправлено в очередь недоставленных сообщений без возникновения исключения.  
  
 Если не задать свойство <xref:System.Messaging.MessageQueue.Formatter%2A> перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию использует <xref:System.Messaging.XmlMessageFormatter>.  
  
 Свойство <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> применяется к любому объекту, кроме <xref:System.Messaging.Message>. Если указать, например, метку или приоритет с помощью члена <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, эти значения будут применяться к любому сообщению, содержащему объект, который не относится к типу <xref:System.Messaging.Message>, когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>значения свойств, заданные для <xref:System.Messaging.Message>, имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, а свойство <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> сообщения имеет приоритет над свойством <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> очереди.  
  
 <xref:System.Messaging.MessageQueueTransaction> учитывается потоковая подразделение, поэтому, если состояние апартамента — `STA`, нельзя использовать транзакцию в нескольких потоках. Visual Basic задает для основного потока состояние `STA`, поэтому необходимо применить <xref:System.MTAThreadAttribute> в подподпрограмме `Main`. В противном случае при отправке транзакционного сообщения с помощью другого потока создастся исключение <xref:System.Messaging.MessageQueueException>. Вы применяете <xref:System.MTAThreadAttribute> с помощью следующего фрагмента.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="label" /> имеет значение <see langword="null" />.  
  
- или - 
Параметр <paramref name="transaction" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
- или - 
Приложение Message Queuing указало на неверное использование транзакции.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, отправляемый в очередь.</param>
        <param name="label">Метка сообщения.</param>
        <param name="transactionType">Одно из значений <see cref="T:System.Messaging.MessageQueueTransactionType" />, описывающее тип контекста транзакции, связываемого с сообщением.</param>
        <summary>Отправляет объект в очередь, на которую ссылается этот объект <see cref="T:System.Messaging.MessageQueue" />, и задает метку сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для отправки сообщения, содержащего параметр `obj`, в очередь, на которую ссылается <xref:System.Messaging.MessageQueue>, используя контекст транзакции, определенный параметром `transactionType`. Укажите `Automatic` для параметра `transactionType`, если к потоку, который требуется использовать для отправки сообщения, уже присоединен контекст внешней транзакции. Укажите `Single`, если вы хотите отправить сообщение как единую внутреннюю транзакцию. Можно указать `None`, если требуется отправить транзакционное сообщение в поток, не являющийся транзакционным.  
  
 Объектом, отправляемым в очередь, может быть <xref:System.Messaging.Message> или любой управляемый объект. При отправке любого объекта, отличного от <xref:System.Messaging.Message>, объект сериализуется и вставляется в текст сообщения. С помощью этой перегрузки можно указать строку, определяющую сообщение.  
  
 Метка сообщения отличается от метки очереди сообщений, но обе они зависят от приложения и не имеют значения, наследуемого очередью сообщений.  
  
 Если не задать свойство <xref:System.Messaging.MessageQueue.Formatter%2A> перед вызовом <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, модуль форматирования по умолчанию использует <xref:System.Messaging.XmlMessageFormatter>.  
  
 Свойство <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> применяется к любому объекту, кроме <xref:System.Messaging.Message>. Если указать, например, метку или приоритет с помощью члена <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, эти значения будут применяться к любому сообщению, содержащему объект, который не относится к типу <xref:System.Messaging.Message>, когда приложение отправляет его в очередь. При отправке <xref:System.Messaging.Message>значения свойств, заданные для <xref:System.Messaging.Message>, имеют приоритет над <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, а свойство <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> сообщения имеет приоритет над свойством <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> очереди.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="label" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">Приложение Message Queuing указало на неверное использование транзакции.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Параметр <paramref name="transactionType" /> не является одним из членов <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Свойство <see cref="P:System.Messaging.MessageQueue.Path" /> не установлено.  
  
- или - 
При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет разрешения в текущий набор. Это позволяет контролировать, кто имеет права доступа к свойствам очереди и сообщениям в очереди.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">Объект <see cref="T:System.Messaging.AccessControlList" />, содержащий не менее одного элемента управления доступом, в которых указаны доверенные лица и предоставляемые разрешения.</param>
        <summary>Назначает права доступа к очереди на основе содержимого списка управления доступом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, чтобы предоставить, отклонить или отозвать права с помощью коллекции записей управления доступом для указания сведений о доверенных лицах и разрешениях. Это используется, например, для предоставления разрешений нескольким пользователям одновременно.  
  
 Доверенное лицо, указываемое при создании параметра `ace`, может быть отдельным пользователем, группой пользователей или компьютером. Если доверенное лицо является отдельным, используйте формат `DOMAIN`\\`user`. Для доверенного лица можно указать ".", чтобы указать локальный компьютер.  
  
 Разрешения, назначаемые через <xref:System.Messaging.MessageQueue.SetPermissions%2A> добавляют права в существующий список. По умолчанию создатель общей или частной очереди имеет полный доступ, а группа домена Everyone имеет разрешение на получение свойств очереди, получение разрешений и запись в очередь. При вызове <xref:System.Messaging.MessageQueue.SetPermissions%2A>сведения о пользователе и разрешениях добавляются в конец существующего списка.  
  
 Система проверяет каждую <xref:System.Messaging.AccessControlEntry> в последовательности до тех пор, пока не произойдет одно из следующих событий:  
  
-   Отказ в доступе <xref:System.Messaging.AccessControlEntry> явно запрещает любые запрошенные права доступа к одному из доверенных лиц, перечисленных в маркере доступа потока.  
  
-   Один или несколько разрешенных для доступа <xref:System.Messaging.AccessControlEntry> элементов для доверенных лиц, указанных в маркере доступа потока, явным образом предоставляют все запрошенные права доступа.  
  
-   Все элементы <xref:System.Messaging.AccessControlEntry> были проверены, но по-прежнему по крайней мере одно запрошенное право доступа, которое не было явно разрешено, в этом случае доступ неявно отклоняется.  
  
 При создании параметра `dacl` в коллекцию <xref:System.Messaging.AccessControlList> добавляются <xref:System.Messaging.AccessControlEntry> экземпляры. При создании каждой записи контроля доступа можно указать общие или стандартные права доступа. Права на очередь могут быть любым сочетанием следующих прав:  
  
-   Удаление  
  
-   Чтение безопасности  
  
-   Безопасность записи  
  
-   Синхронизация  
  
-   Изменение владельца  
  
-   Чтение  
  
-   Write  
  
-   Выполнение  
  
-   Обязательно  
  
-   Все  
  
-   Отсутствуют  
  
 Эти права представляют собой набор битовых флагов, которые можно комбинировать с помощью побитового оператора или.  
  
-   Полный доступ  
  
-   Удаление сообщения  
  
-   Получение сообщения  
  
-   Просмотр сообщения  
  
-   Получение сообщения журнала  
  
-   Получение свойств очереди  
  
-   Задание свойств очереди  
  
-   Получить разрешения  
  
-   Настройка разрешений  
  
-   Получить владение очередью  
  
-   Запись сообщения  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">Объект <see cref="T:System.Messaging.MessageQueueAccessControlEntry" />, который указывает пользователя, тип доступа и тип разрешения.</param>
        <summary>Назначает права доступа к очереди на основе содержимого элемента управления доступом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку, чтобы предоставить, отклонить или отозвать права с помощью записи управления доступом для указания сведений о доверенных лицах и правах.  
  
 Доверенное лицо, указываемое при создании параметра `ace`, может быть отдельным пользователем, группой пользователей или компьютером. Если доверенное лицо является отдельным, используйте формат `DOMAIN`\\`user`. Для доверенного лица можно указать ".", чтобы указать локальный компьютер.  
  
 Разрешения, назначаемые через <xref:System.Messaging.MessageQueue.SetPermissions%2A> добавляют права в существующий список. По умолчанию создатель общей или частной очереди имеет полный доступ, а группа домена Everyone имеет разрешение на получение свойств очереди, получение разрешений и запись в очередь. При вызове <xref:System.Messaging.MessageQueue.SetPermissions%2A>сведения о пользователе и разрешениях добавляются в конец существующего списка.  
  
 Система проверяет каждую <xref:System.Messaging.AccessControlEntry> в последовательности до тех пор, пока не произойдет одно из следующих событий:  
  
-   Отказ в доступе <xref:System.Messaging.AccessControlEntry> явно запрещает любые запрошенные права доступа к одному из доверенных лиц, перечисленных в маркере доступа потока.  
  
-   Один или несколько разрешенных для доступа <xref:System.Messaging.AccessControlEntry> элементов для доверенных лиц, указанных в маркере доступа потока, явным образом предоставляют все запрошенные права доступа.  
  
-   Все элементы <xref:System.Messaging.AccessControlEntry> были проверены, но по-прежнему по крайней мере одно запрошенное право доступа, которое не было явно разрешено, в этом случае доступ неявно отклоняется.  
  
 Права на очередь, указываемые в параметре `rights` при создании <xref:System.Messaging.MessageQueueAccessControlEntry>, могут быть любым сочетанием следующих элементов:  
  
-   Полный доступ  
  
-   Удаление сообщения  
  
-   Получение сообщения  
  
-   Просмотр сообщения  
  
-   Получение сообщения журнала  
  
-   Получение свойств очереди  
  
-   Задание свойств очереди  
  
-   Получить разрешения  
  
-   Настройка разрешений  
  
-   Получить владение очередью  
  
-   Запись сообщения  
  
 Параметр `rights`, указанный в конструкторе для параметра `ace`, является флагом перечисления <xref:System.Messaging.MessageQueueAccessRights>. Он представляет набор битовых флагов, которые можно комбинировать с помощью побитового оператора или при построении параметра `rights`.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">Отдельный пользователь, группа или компьютер, которые получают дополнительные права на работу с очередью.</param>
        <param name="rights">Объект <see cref="T:System.Messaging.MessageQueueAccessRights" />, который показывает набор прав на работу с очередью, которые назначаются службой очереди сообщений параметру <paramref name="user" />.</param>
        <summary>Предоставляет компьютеру, группе или пользователю указанные права доступа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для предоставления указанных прав отдельному пользователю. Пользователь может быть любым допустимым доверенным лицом, включая отдельных пользователей, группы пользователей или компьютер. Если пользователь является отдельным пользователем, используйте формат `DOMAIN`\\`user` для параметра `user`. Можно указать "." для параметра `user`, чтобы указать локальный компьютер.  
  
 Разрешения, назначаемые через <xref:System.Messaging.MessageQueue.SetPermissions%2A> добавляют права в существующий список. По умолчанию создатель общей или частной очереди имеет полный доступ, а группа домена Everyone имеет разрешение на получение свойств очереди, получение разрешений и запись в очередь. При вызове <xref:System.Messaging.MessageQueue.SetPermissions%2A>сведения о пользователе и разрешениях добавляются в конец существующего списка.  
  
 Система проверяет каждую <xref:System.Messaging.AccessControlEntry> в последовательности до тех пор, пока не произойдет одно из следующих событий:  
  
-   Отказ в доступе <xref:System.Messaging.AccessControlEntry> явно запрещает любые запрошенные права доступа к одному из доверенных лиц, перечисленных в маркере доступа потока.  
  
-   Один или несколько разрешенных для доступа <xref:System.Messaging.AccessControlEntry> элементов для доверенных лиц, указанных в маркере доступа потока, явным образом предоставляют все запрошенные права доступа.  
  
-   Все элементы <xref:System.Messaging.AccessControlEntry> были проверены, но по-прежнему по крайней мере одно запрошенное право доступа, которое не было явно разрешено, в этом случае доступ неявно отклоняется.  
  
 Права на очередь, указанные в параметре `rights`, могут быть любым сочетанием следующих параметров:  
  
-   Полный доступ  
  
-   Удаление сообщения  
  
-   Получение сообщения  
  
-   Просмотр сообщения  
  
-   Получение сообщения журнала  
  
-   Получение свойств очереди  
  
-   Задание свойств очереди  
  
-   Получить разрешения  
  
-   Настройка разрешений  
  
-   Получить владение очередью  
  
-   Запись сообщения  
  
 Перечисление <xref:System.Messaging.MessageQueueAccessRights> представляет набор битовых флагов, которые можно комбинировать с помощью побитового оператора или для создания параметра `rights`.  
  
 Эта перегрузка позволяет предоставлять только разрешения. Вы не можете отозвать или отклонить их. Для явного предоставления любых <xref:System.Messaging.AccessControlEntryType>, кроме `Allow`, необходимо использовать другую перегрузку.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение параметра <paramref name="user" /> — <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">Отдельный пользователь, группа или компьютер, которые получают дополнительные права на работу с очередью.</param>
        <param name="rights">Объект <see cref="T:System.Messaging.MessageQueueAccessRights" />, который показывает набор прав на работу с очередью, которые назначаются службой очереди сообщений параметру <paramref name="user" />.</param>
        <param name="entryType">Объект <see cref="T:System.Messaging.AccessControlEntryType" />, который указывает, нужно ли предоставить разрешения, отказать в предоставлении разрешений или отозвать разрешения, задаваемые параметром <paramref name="rights" />.</param>
        <summary>Предоставляет компьютеру, группе или пользователю указанные права доступа указанного типа управления доступом (разрешить, отказать, отозвать или задать).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте эту перегрузку для предоставления, запрета или отзыва указанных прав для отдельного пользователя. Пользователь может быть любым допустимым доверенным лицом, включая отдельных пользователей, группы пользователей или компьютер. Если пользователь является отдельным пользователем, используйте формат `DOMAIN`\\`user` для параметра `user`. Можно указать "." для параметра `user`, чтобы указать локальный компьютер.  
  
 Разрешения, назначаемые через <xref:System.Messaging.MessageQueue.SetPermissions%2A> добавляют права в существующий список. По умолчанию создатель общей или частной очереди имеет полный доступ, а группа домена Everyone имеет разрешение на получение свойств очереди, получение разрешений и запись в очередь. При вызове <xref:System.Messaging.MessageQueue.SetPermissions%2A>сведения о пользователе и разрешениях добавляются в конец существующего списка.  
  
 Система проверяет каждую <xref:System.Messaging.AccessControlEntry> в последовательности до тех пор, пока не произойдет одно из следующих событий:  
  
-   Отказ в доступе <xref:System.Messaging.AccessControlEntry> явно запрещает любые запрошенные права доступа к одному из доверенных лиц, перечисленных в маркере доступа потока.  
  
-   Один или несколько разрешенных для доступа <xref:System.Messaging.AccessControlEntry> элементов для доверенных лиц, указанных в маркере доступа потока, явным образом предоставляют все запрошенные права доступа.  
  
-   Все элементы <xref:System.Messaging.AccessControlEntry> были проверены, но по-прежнему по крайней мере одно запрошенное право доступа, которое не было явно разрешено, в этом случае доступ неявно отклоняется.  
  
 Права на очередь, указанные в параметре `rights`, могут быть любым сочетанием следующих параметров:  
  
-   Полный доступ  
  
-   Удаление сообщения  
  
-   Получение сообщения  
  
-   Просмотр сообщения  
  
-   Получение сообщения журнала  
  
-   Получение свойств очереди  
  
-   Задание свойств очереди  
  
-   Получить разрешения  
  
-   Настройка разрешений  
  
-   Получить владение очередью  
  
-   Запись сообщения  
  
 Перечисление <xref:System.Messaging.MessageQueueAccessRights> представляет набор битовых флагов, которые можно комбинировать с помощью побитового оператора или для создания параметра `rights`.  
  
 В следующей таблице показано, доступен ли этот метод в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем коде показано использование функции <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект, который используется для маршалинга вызовов обработчика событий, возникающих в результате наступления события <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> или события <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />.</summary>
        <value>Объект <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, представляющий объект, который выполняет маршалинг вызова обработчика событий, причиной которого стало событие <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> или <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> или <xref:System.Messaging.MessageQueue.PeekCompleted> события, полученные в результате <xref:System.Messaging.MessageQueue.BeginReceive%2A> или <xref:System.Messaging.MessageQueue.BeginPeek%2A> запроса, соответственно, к определенному потоку. Как правило, <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> задается, когда связанный компонент помещается внутри элемента управления или формы, поскольку эти компоненты привязаны к определенному потоку.  
  
 Как правило, синхронизирующий объект маршалирует вызов метода в один поток.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, принимает ли очередь только транзакции.</summary>
        <value>Значение <see langword="true" />, если очередь принимает только сообщения, отправляемые как часть транзакции; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Транзакционная система обмена сообщениями относится к взаимосвязанию нескольких связанных сообщений с одной транзакцией. Отправка сообщений в рамках транзакции гарантирует, что сообщения доставляются по порядку, доставляются только один раз и успешно извлекаются из очереди назначения.  
  
 Если очередь является транзакционной, она принимает только сообщения, которые отправляются как часть транзакции. Однако нетранзакционное сообщение может быть отправлено или получено из локальной очереди транзакций без явного использования транзакционного <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>и синтаксиса <xref:System.Messaging.MessageQueueTransaction.Abort%2A>. Если нетранзакционное сообщение отправляется в транзакционную очередь, этот компонент создает для него транзакцию с одним сообщением, за исключением случая, когда в случае ссылки на очередь на удаленном компьютере используется прямое имя формата. В этом случае, если не указать контекст транзакции при отправке сообщения, одно из них не создается и сообщение будет отправлено в очередь недоставленных сообщений.  
  
 При отправке нетранзакционного сообщения в транзакционную очередь вы не сможете выполнить откат сообщения в случае возникновения исключения.  
  
 <xref:System.Messaging.MessageQueueTransaction> учитывается потоковая подразделение, поэтому, если состояние апартамента — `STA`, нельзя использовать транзакцию в нескольких потоках. Visual Basic задает для основного потока состояние `STA`, поэтому необходимо применить <xref:System.MTAThreadAttribute> в подподпрограмме `Main`. В противном случае при отправке транзакционного сообщения с помощью другого потока создастся исключение <xref:System.Messaging.MessageQueueException>. Вы применяете <xref:System.MTAThreadAttribute> с помощью следующего фрагмента.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода выводится значение свойства <xref:System.Messaging.MessageQueue.Transactional%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должны ли полученные сообщения копироваться в очередь журнала.</summary>
        <value>Значение <see langword="true" />, если сообщения, полученные из очереди, копируются в очередь журнала; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда приложение очереди сообщений создает новую очередь приложений, оно автоматически создает связанную очередь журнала в том же расположении. Очередь журнала используется для наблюдения за сообщениями, удаленными из очереди. Задание этого свойства изменяет очередь сообщений. Поэтому изменение повлияет на все другие экземпляры <xref:System.Messaging.MessageQueue>.  
  
 Очередь журнала не следит за сообщениями, удаленными из очереди, так как срок их действия истек, а также сообщения, удаленные из очереди, с помощью службы каталогов очереди сообщений (хранилище данных или Active Directory).  
  
 Приложения не могут передавать сообщения в очереди журнала; они ограничены доступом только для чтения к этим очередям. Более того, очередь сообщений никогда не удаляет сообщения из очередей журнала. Приложение, использующее очередь, должно очищать эти сообщения либо путем их получения, либо путем очистки очереди.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Нет|  
  
   
  
## Examples  
 В следующем примере кода получается и задается значение свойства <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> очереди сообщений.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">При обращении к методу службы очереди сообщений возникла ошибка.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает собственный дескриптор, который используется для отправки сообщений в очередь сообщений.</summary>
        <value>Дескриптор собственного объекта очереди, который используется для отправки сообщений в очередь.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A> предоставляет собственный обработчик Windows для объекта очереди сообщений, который используется для отправки сообщений в очередь. При изменении пути к очереди маркер закрывается и повторно открывается с новым значением.  
  
 В следующей таблице показано, доступно ли это свойство в различных режимах рабочей группы.  
  
|Режим рабочей группы|Доступно|  
|--------------------|---------------|  
|Локальный компьютер|Да|  
|Локальный компьютер и прямое имя формата|Да|  
|Удаленный компьютер|Нет|  
|Удаленный компьютер и прямое имя формата|Да|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Очередь сообщений недоступна для записи.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>
