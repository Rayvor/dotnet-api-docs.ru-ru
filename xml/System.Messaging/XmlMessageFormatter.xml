<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="58acefaa17af0e32e633170df97b4698cbc735be" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69382158" /></Metadata><TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <TypeSignature Language="F#" Value="type XmlMessageFormatter = class&#xA;    interface IMessageFormatter&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Сериализует объекты в текст сообщения или десериализует текст сообщения в объекты, используя для этого формат XML, основанный на определении схемы XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 — Это модуль форматирования по умолчанию, который <xref:System.Messaging.MessageQueue> используется экземпляром для сериализации сообщений, записанных в очередь. <xref:System.Messaging.XmlMessageFormatter> При создании экземпляра <xref:System.Messaging.MessageQueue> <xref:System.Messaging.XmlMessageFormatter> экземпляр создается для <xref:System.Messaging.MessageQueue>вас и связывается с. Можно указать другой модуль форматирования, создав его в коде и назначив его <xref:System.Messaging.MessageQueue.Formatter%2A> свойству. <xref:System.Messaging.MessageQueue>  
  
 Экземпляр очереди по умолчанию <xref:System.Messaging.XmlMessageFormatter> может быть использован для записи в очередь, но не может использоваться для чтения из очереди, пока не задано <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> свойство или <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> модуля форматирования. Можно задать одно или оба этих значения в экземпляре модуля форматирования по умолчанию или создать новый экземпляр модуля форматирования и задать значения автоматически, передав их в качестве аргументов в соответствующий <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> конструктор.  
  
 При указании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, а не, тип существование проверяется во время компиляции, а не на время чтения, уменьшая вероятность ошибки. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>требует, чтобы каждая запись была полностью квалифицирована, указывая ее имя сборки. Кроме того, при работе с несколькими параллельными версиями номер версии также должен быть добавлен к имени целевого типа.  
  
 Свойства <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и<xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают модулю форматирования, какие схемы следует пытаться сопоставить при десериализации сообщения. Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализованный в тексте сообщения, должен соответствовать одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> метода метод создает объект типа, соответствующий указанной схеме, и считывает в него текст сообщения.  
  
 При чтении из очереди необходимо задать только одно из двух свойств, но можно задать и то, и другое. Набор типов — это объединенный набор из двух свойств. Решение о том, какое свойство следует использовать, зависит от вашего приложения. Если текст сообщения содержит тип, схема которого не совпадает ни с одним из типов в массиве для любого из свойств, при считывании сообщения будет создано исключение.  
  
 <xref:System.Messaging.XmlMessageFormatter> Является важнейшим компонентом слабо связанного обмена сообщениями на основе XML. Программа XSD. exe использует формат XML для создания схемы XML, например, при использовании программы для сериализации класса, используемого приложением. Класс должен содержать конструктор без параметров.  
  
 Этот формат снова используется в обратном процессе, когда программа создает класс на основе схемы, которую вы распространяете для описания данных класса. Использование программы и создаваемой ею схемы XML позволяет избежать повторного распространения DLL-файлов при каждой перекомпиляции класса после изменения реализации класса. Пока схема не изменяется на клиенте или сервере, другие изменения на обеих сторонах не влияют на другую.  
  
   
  
## Examples  
 Следующий пример кода включает три части кода: серверный компонент, класс заказа и клиентский код. Класс Order может использоваться служебной программой XSD. exe для создания схемы, которую сервер распознает в входящих сообщениях. Схема представляет собой файл в формате XML, описывающий "форму" класса. Затем эту схему можно использовать на стороне клиента для создания класса заказов конкретного клиента, который использует ту же схему, что и серверный класс.  
  
 В следующем примере кода представлен серверный компонент, который получает заказы через очередь сообщений. Тело сообщения должно быть объектом Order, схема которого соответствует классу Order.cs ниже. Серверный процесс или приложение десериализует порядок.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 В следующем примере кода представлен класс Order, предоставляющий схему для объектов Order, которые получает и десериализует приложение на сервере.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Любое клиентское приложение, взаимодействующее с приложением на сервере, должно отсылать сообщения на сервер путем сериализации сведений в локально определенный класс Order в текст сообщения. Локально определенный класс Order должен иметь ту же схему, что и определяемый сервером порядок, в котором приложение на сервере будет пытаться десериализовать текст сообщения. Программа XSD. exe позволяет диспетчеру приложения на сервере создать и распространить схему, которую клиент должен использовать для сериализации сообщений, отправляемых на сервер.  
  
 Когда диспетчер клиентского приложения получает схему для класса Order, служебная программа XSD. exe снова используется для создания класса упорядочения, зависящего от клиента, из схемы. Этот класс используется в примере кода клиента, а не в классе порядка сервера (программа XSD. exe заставляет создаваемый схемой класс иметь то же имя, что и исходный класс). Этот новый класс Order используется для сериализации заказа в текст сообщения.  
  
 В следующем примере кода показана обработка на стороне клиента, используемая для сериализации заказа и отправки сведений, связанных с заказом, в очередь. Код связывает элементы, количество и сведения об адресе с элементами схемы, созданными для класса Order.cs служебной программой XSD. exe. Заказ отправляется в очередь заказов на локальном компьютере.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 После создания схемы из класса Order на сервере можно изменить класс. Если схема не изменяется, повторное распространение схемы не требуется. После распространения схемы и создания класса заказа на стороне клиента этот клиентский класс также может быть изменен независимо от класса порядка сервера, если сама схема не изменена. Эти два класса стали слабо связанными.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" /> без набора типов целевых объектов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка конструктора чаще всего используется при записи в очередь, так как типы целей не требуются при записи.  
  
 Для чтения сообщения из очереди с помощью экземпляра <xref:System.Messaging.XmlMessageFormatter> , созданного с помощью этого конструктора, необходимо <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> задать свойства или <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> , чтобы модуль форматирования знал, какие типы следует попытаться десериализовать.  
  
 При создании нового <xref:System.Messaging.MessageQueue>экземпляр по умолчанию <xref:System.Messaging.XmlMessageFormatter> создается без задания целевых типов. Как и при использовании модуля форматирования, созданного с помощью этого конструктора, необходимо задать типы целевых объектов для этого экземпляра модуля форматирования, если требуется считывать данные из очереди.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : string[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypeNames" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Массив типа <see cref="T:System.String" />, задающий набор возможных типов, десериализация которых будет выполняться модулем форматирования из предоставляемого сообщения. Эти значения должны быть полностью определены, например, "MyNamespace.MyOrders, MyOrdersAssemblyName".</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" />, устанавливая типы целевых объектов, передаваемых как массив (полностью определенных) строковых значений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструкторы с параметрами целевого типа чаще всего используются при чтении из очереди. При записи не нужно указывать типы целевых объектов.  
  
 Эта перегрузка <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> конструктора <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> задает для свойства `targetTypeNames` значения массива, передаваемые через параметр. Задание этого свойства позволяет <xref:System.Messaging.MessageQueue> использовать этот <xref:System.Messaging.XmlMessageFormatter> экземпляр для чтения сообщений, содержащих объекты заданных типов.  
  
 И свойства, <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> и указывают модулю форматирования, какие схемы следует пытаться сопоставить при десериализации сообщения. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализованный в тексте сообщения, должен соответствовать одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> метода метод создает объект типа, соответствующий указанной схеме, и считывает в него текст сообщения.  
  
 При чтении из очереди необходимо задать только одно из двух свойств, но можно задать и то, и другое. Набор типов — это объединенный набор из двух свойств. Решение о том, какой из них следует использовать, зависит от вашего приложения. Если текст сообщения содержит тип, схема которого не соответствует ни одному из типов в массиве для любого из свойств, то во время чтения будет создано исключение.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="targetTypeNames" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : Type[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Массив типа <see cref="T:System.Type" />, задающий набор возможных типов, десериализация которых будет выполняться модулем форматирования из предоставляемого сообщения.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" />, устанавливая типы целевых объектов, передаваемых как массив типов объектов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструкторы с параметрами целевого типа чаще всего используются при чтении из очереди. При записи не нужно указывать типы целевых объектов.  
  
 Эта перегрузка <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> конструктора <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> задает для свойства `targetTypes` значения массива, передаваемые через параметр. Задание этого свойства позволяет <xref:System.Messaging.MessageQueue> использовать этот <xref:System.Messaging.XmlMessageFormatter> экземпляр для чтения сообщений, содержащих объекты заданных типов.  
  
 И свойства, <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> и указывают модулю форматирования, какие схемы следует пытаться сопоставить при десериализации сообщения. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализованный в тексте сообщения, должен соответствовать одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> метода метод создает объект типа, соответствующий указанной схеме, и считывает в него текст сообщения.  
  
 При чтении из очереди необходимо задать только одно из двух свойств, но можно задать и то, и другое. Набор типов — это объединенный набор из двух свойств. Решение о том, какой из них следует использовать, зависит от вашего приложения. Если текст сообщения содержит тип, схема которого не соответствует ни одному из типов в массиве для любого из свойств, то во время чтения будет создано исключение.  
  
 При указании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, а не, тип существование проверяется во время компиляции, а не на время чтения, уменьшая вероятность ошибки. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>требует, чтобы каждая запись была полностью квалифицирована, указывая ее имя сборки. Кроме того, при работе с несколькими параллельными версиями номер версии также должен быть добавлен к имени целевого типа.  
  
 При использовании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>можно добавить каждый объект (например, `MyClass`) в список, как показано в следующем C# коде.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="targetTypes" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member CanRead : System.Messaging.Message -&gt; bool&#xA;override this.CanRead : System.Messaging.Message -&gt; bool" Usage="xmlMessageFormatter.CanRead message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Объект <see cref="T:System.Messaging.Message" /> для проверки.</param>
        <summary>Определяет, может ли модуль форматирования десериализовать сообщение.</summary>
        <returns>Значение <see langword="true" />, если XML-модуль форматирования может десериализовать сообщение; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> вызове модуль форматирования пытается определить, может ли содержимое сообщения быть десериализовано. Модуль форматирования может выполнить десериализацию сообщения только в том случае, если тип в теле сообщения имеет ту же схему, что <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и один из типов в массиве, представленный свойствами и. <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> <xref:System.Messaging.XmlMessageFormatter.CanRead%2A>Возвращает `false` в следующих двух случаях:  
  
-   Сообщение не было отформатировано с <xref:System.Messaging.XmlMessageFormatter>помощью.  
  
-   Схема текста сообщения не является частью, указанной в <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> свойстве или. <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>  
  
 Свойства <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и<xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> указывают модулю форматирования, какие типы объектов должны быть способны десериализовать. Если в списке отсутствует какой-либо тип, то он находится в сообщении, а <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> возвращает `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни свойство <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />, ни свойство <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> не установлены.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="message" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="xmlMessageFormatter.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает экземпляр класса <see cref="T:System.Messaging.XmlMessageFormatter" />, свойства чтения и записи (наборы типов целевых объектов) которого такие же, как и у текущего экземпляра <see cref="T:System.Messaging.XmlMessageFormatter" />.</summary>
        <returns>Объект со свойствами, идентичными свойствам данного экземпляра <see cref="T:System.Messaging.XmlMessageFormatter" />, но с метаданными, которые не определяют его как экземпляр класса модуля форматирования.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает копию модуля форматирования и инициализирует все его свойства значениями этого <xref:System.Messaging.XmlMessageFormatter> объекта.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Read : System.Messaging.Message -&gt; obj&#xA;override this.Read : System.Messaging.Message -&gt; obj" Usage="xmlMessageFormatter.Read message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">Десериализуемое сообщение <see cref="T:System.Messaging.Message" /> в XML-формате.</param>
        <summary>Читает содержимое из данного сообщения и создает объект, содержащий десериализованное сообщение.</summary>
        <returns>Десериализованное сообщение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 И свойства, <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> и указывают модулю форматирования, какие схемы следует пытаться сопоставить при десериализации сообщения. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Перед десериализациюм сообщения необходимо задать одно из этих свойств.  
  
 Экземпляр, сериализованный в тексте сообщения, должен соответствовать одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> метода метод создает объект типа, соответствующий указанной схеме, и считывает в него текст сообщения.  
  
 Для записи в очередь не обязательно указывать целевые типы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни свойство <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />, ни свойство <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> не установлены.  
  
- или - 
Экземпляр, сериализуемый в тело сообщения, не согласуется ни с одной из схем, представленных типами в свойствах <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> и <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="message" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypeNames : string[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает набор возможных типов, десериализация которых будет выполняться модулем форматирования из тела предоставляемого сообщения.</summary>
        <value>Массив типа <see cref="T:System.String" />, задающий типы объектов, десериализуемых из тела сообщения при чтении данного сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 И свойства, <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> и указывают модулю форматирования, какие схемы следует пытаться сопоставить при десериализации сообщения. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализованный в тексте сообщения, должен соответствовать одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> метода метод создает объект типа, соответствующий указанной схеме, и считывает в него текст сообщения.  
  
 При чтении из очереди необходимо задать только одно из двух свойств, но можно задать и то, и другое. Набор типов — это объединенный набор из двух свойств. Решение о том, какое свойство следует использовать, зависит от вашего приложения. Если текст сообщения содержит тип, схема которого не совпадает ни с одним из типов в массиве для любого из свойств, при считывании сообщения будет создано исключение.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>требует, чтобы каждая запись была полностью квалифицирована, указывая ее имя сборки. Кроме того, при работе с несколькими параллельными версиями номер версии также должен быть добавлен к имени целевого типа.  
  
 Типы целевых объектов требуются только при чтении из очереди. Свойства <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и<xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> не нужно задавать для записи в очередь.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение свойства <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypes : Type[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает набор возможных типов, десериализация которых будет выполняться модулем форматирования из тела предоставляемого сообщения.</summary>
        <value>Массив типа <see cref="T:System.Type" />, задающий типы объектов, десериализуемых из тела сообщения при чтении данного сообщения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 И свойства, <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> и указывают модулю форматирования, какие схемы следует пытаться сопоставить при десериализации сообщения. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Это позволяет модулю форматирования интерпретировать текст сообщения.  
  
 Экземпляр, сериализованный в тексте сообщения, должен соответствовать одной из схем, представленных в массиве типов. При чтении сообщения с помощью <xref:System.Messaging.MessageQueue.Receive%2A> метода метод создает объект типа, соответствующий указанной схеме, и считывает в него текст сообщения.  
  
 При чтении из очереди необходимо задать только одно из двух свойств, но можно задать и то, и другое. Набор типов — это объединенный набор из двух свойств. Решение о том, какое свойство следует использовать, зависит от вашего приложения. Если текст сообщения содержит тип, схема которого не совпадает ни с одним из типов в массиве для любого из свойств, при считывании сообщения будет создано исключение.  
  
 Типы целевых объектов требуются только при чтении из очереди. Свойства <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> и<xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> не нужно задавать для записи в очередь.  
  
 При указании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, а не, тип существование проверяется во время компиляции, а не на время чтения, уменьшая вероятность ошибки.  
  
 При использовании <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>можно добавить каждый объект (например, `MyClass`) в список способом, демонстрируемым в `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};` C# коде.  
  
   
  
## Examples  
 Следующий пример кода отправляет и получает сообщение, которое содержит порядок в очередь и из нее.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение свойства <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> — <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.Messaging.Message * obj -&gt; unit&#xA;override this.Write : System.Messaging.Message * obj -&gt; unit" Usage="xmlMessageFormatter.Write (message, obj)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение <see cref="T:System.Messaging.Message" />, свойство <see cref="P:System.Messaging.Message.Body" /> которого будет содержать сериализованный объект.</param>
        <param name="obj">Объект <see cref="T:System.Object" />, сериализуемый в тело сообщения.</param>
        <summary>Сериализует объект в текст сообщения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не нужно указывать типы целевых объектов для записи в очередь, так как они должны быть в процессе чтения. Свойство <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> или<xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> используется модулем форматирования только при десериализации сообщения.  
  
 Компонентиспользует<xref:System.Xml.Serialization.XmlSerializer> класс, который определяет, что можно сериализовать. <xref:System.Messaging.XmlMessageFormatter> Сериализуются могут только открытые поля и общие свойства. Структуры, структуры с массивами и массивами структур являются сериализуемыми, при условии, что они не используют закодированный стиль с протоколом SOAP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="message" /> имеет значение <see langword="null" />.  
  
- или - 
Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>
