<Type Name="ContractBasedImportDefinition" FullName="System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4f5993b9dd4e87ed0ff88cef2f4726b948dbf5c8" /><Meta Name="ms.sourcegitcommit" Value="1bb00d2f4343e73ae8d58668f02297a3cf10a4c1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="06/15/2019" /><Meta Name="ms.locfileid" Value="63906205" /></Metadata><TypeSignature Language="C#" Value="public class ContractBasedImportDefinition : System.ComponentModel.Composition.Primitives.ImportDefinition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContractBasedImportDefinition extends System.ComponentModel.Composition.Primitives.ImportDefinition" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />
  <TypeSignature Language="VB.NET" Value="Public Class ContractBasedImportDefinition&#xA;Inherits ImportDefinition" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContractBasedImportDefinition : System::ComponentModel::Composition::Primitives::ImportDefinition" />
  <TypeSignature Language="F#" Value="type ContractBasedImportDefinition = class&#xA;    inherit ImportDefinition" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.Composition</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Composition.Primitives.ImportDefinition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Представляет необходимый для объекта <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" /> импорт, который может указать и имя контракта, и метаданные.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ContractBasedImportDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ContractBasedImportDefinition();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContractBasedImportDefinition (string contractName, string requiredTypeIdentity, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,Type&gt;&gt; requiredMetadata, System.ComponentModel.Composition.Primitives.ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, System.ComponentModel.Composition.CreationPolicy requiredCreationPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string contractName, string requiredTypeIdentity, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Type&gt;&gt; requiredMetadata, valuetype System.ComponentModel.Composition.Primitives.ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, valuetype System.ComponentModel.Composition.CreationPolicy requiredCreationPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Type}},System.ComponentModel.Composition.Primitives.ImportCardinality,System.Boolean,System.Boolean,System.ComponentModel.Composition.CreationPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (contractName As String, requiredTypeIdentity As String, requiredMetadata As IEnumerable(Of KeyValuePair(Of String, Type)), cardinality As ImportCardinality, isRecomposable As Boolean, isPrerequisite As Boolean, requiredCreationPolicy As CreationPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContractBasedImportDefinition(System::String ^ contractName, System::String ^ requiredTypeIdentity, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, Type ^&gt;&gt; ^ requiredMetadata, System::ComponentModel::Composition::Primitives::ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, System::ComponentModel::Composition::CreationPolicy requiredCreationPolicy);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, Type&gt;&gt; * System.ComponentModel.Composition.Primitives.ImportCardinality * bool * bool * System.ComponentModel.Composition.CreationPolicy -&gt; System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" Usage="new System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition (contractName, requiredTypeIdentity, requiredMetadata, cardinality, isRecomposable, isPrerequisite, requiredCreationPolicy)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" />
        <Parameter Name="requiredTypeIdentity" Type="System.String" />
        <Parameter Name="requiredMetadata" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Type&gt;&gt;" />
        <Parameter Name="cardinality" Type="System.ComponentModel.Composition.Primitives.ImportCardinality" />
        <Parameter Name="isRecomposable" Type="System.Boolean" />
        <Parameter Name="isPrerequisite" Type="System.Boolean" />
        <Parameter Name="requiredCreationPolicy" Type="System.ComponentModel.Composition.CreationPolicy" />
      </Parameters>
      <Docs>
        <param name="contractName">Имя контракта объекта <see cref="T:System.ComponentModel.Composition.Primitives.Export" />, необходимое для определения импорта.</param>
        <param name="requiredTypeIdentity">Удостоверение ожидаемого типа экспорта. Для создания удостоверения заданного типа используется метод <see cref="M:System.ComponentModel.Composition.AttributedModelServices.GetTypeIdentity(System.Type)" />. Если конкретный тип не требуется, используйте значение <see langword="null" />.</param>
        <param name="requiredMetadata">Коллекция пар "ключ-значение", содержащих имена метаданных и типы, необходимые для определения импорта; или значение <see langword="null" />, чтобы задать для свойства <see cref="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredMetadata" /> пустую коллекцию <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <param name="cardinality">Одно из значений перечисления, указывающее количество элементов объектов <see cref="T:System.ComponentModel.Composition.Primitives.Export" />, необходимых для определения импорта.</param>
        <param name="isRecomposable">Значение <see langword="true" />, указывающее, что определение импорта может удовлетворяться несколько раз на протяжении времени жизни объекта <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" />; в противном случае — значение <see langword="false" />.</param>
        <param name="isPrerequisite">Значение <see langword="true" />, указывающее, что определение импорта должно удовлетворяться, прежде чем объект <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" /> сможет начать создание экспортированных объектов; в противном случае — значение <see langword="false" />.</param>
        <param name="requiredCreationPolicy">Значение, указывающее, что импортеру требуется определенная политика создания для экспортов, используемых для удовлетворения данного импорта. Если конкретное значение политики создания не требуется, используется значение по умолчанию <see cref="F:System.ComponentModel.Composition.CreationPolicy.Any" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />, используя указанные имя контракта, требуемое удостоверение типа, обязательные метаданные, количество элементов и политику создания, а также указывает, является ли определение импорта предварительным условием или разрешает рекомпозицию.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="contractName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="contractName" /> является пустой строкой ("").  
  
-или- 
 Параметр <paramref name="requiredMetadata" /> содержит элемент, равный <see langword="null" />.  
  
-или- 
 <paramref name="cardinality" /> не является одним из значений <see cref="T:System.ComponentModel.Composition.Primitives.ImportCardinality" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContractBasedImportDefinition (string contractName, string requiredTypeIdentity, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,Type&gt;&gt; requiredMetadata, System.ComponentModel.Composition.Primitives.ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, System.ComponentModel.Composition.CreationPolicy requiredCreationPolicy, System.Collections.Generic.IDictionary&lt;string,object&gt; metadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string contractName, string requiredTypeIdentity, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Type&gt;&gt; requiredMetadata, valuetype System.ComponentModel.Composition.Primitives.ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, valuetype System.ComponentModel.Composition.CreationPolicy requiredCreationPolicy, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; metadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Type}},System.ComponentModel.Composition.Primitives.ImportCardinality,System.Boolean,System.Boolean,System.ComponentModel.Composition.CreationPolicy,System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (contractName As String, requiredTypeIdentity As String, requiredMetadata As IEnumerable(Of KeyValuePair(Of String, Type)), cardinality As ImportCardinality, isRecomposable As Boolean, isPrerequisite As Boolean, requiredCreationPolicy As CreationPolicy, metadata As IDictionary(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContractBasedImportDefinition(System::String ^ contractName, System::String ^ requiredTypeIdentity, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, Type ^&gt;&gt; ^ requiredMetadata, System::ComponentModel::Composition::Primitives::ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, System::ComponentModel::Composition::CreationPolicy requiredCreationPolicy, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ metadata);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, Type&gt;&gt; * System.ComponentModel.Composition.Primitives.ImportCardinality * bool * bool * System.ComponentModel.Composition.CreationPolicy * System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" Usage="new System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition (contractName, requiredTypeIdentity, requiredMetadata, cardinality, isRecomposable, isPrerequisite, requiredCreationPolicy, metadata)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredTypeIdentity" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredMetadata" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Type&gt;&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cardinality" Type="System.ComponentModel.Composition.Primitives.ImportCardinality" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="isRecomposable" Type="System.Boolean" Index="4" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="isPrerequisite" Type="System.Boolean" Index="5" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredCreationPolicy" Type="System.ComponentModel.Composition.CreationPolicy" Index="6" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="metadata" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" Index="7" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="contractName">Имя контракта объекта <see cref="T:System.ComponentModel.Composition.Primitives.Export" />, необходимое для определения импорта.</param>
        <param name="requiredTypeIdentity">Удостоверение ожидаемого типа экспорта. Для создания удостоверения заданного типа используется метод <see cref="M:System.ComponentModel.Composition.AttributedModelServices.GetTypeIdentity(System.Type)" />. Если конкретный тип не требуется, используйте значение <see langword="null" />.</param>
        <param name="requiredMetadata">Коллекция пар "ключ-значение", содержащих имена метаданных и типы, необходимые для определения импорта; или значение <see langword="null" />, чтобы задать для свойства <see cref="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredMetadata" /> пустую коллекцию <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <param name="cardinality">Одно из значений перечисления, указывающее количество элементов объектов <see cref="T:System.ComponentModel.Composition.Primitives.Export" />, необходимых для определения импорта.</param>
        <param name="isRecomposable">Значение <see langword="true" />, указывающее, что определение импорта может удовлетворяться несколько раз на протяжении времени жизни объекта <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" />; в противном случае — значение <see langword="false" />.</param>
        <param name="isPrerequisite">Значение <see langword="true" />, указывающее, что определение импорта должно удовлетворяться, прежде чем объект <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" /> сможет начать создание экспортированных объектов; в противном случае — значение <see langword="false" />.</param>
        <param name="requiredCreationPolicy">Значение, указывающее, что импортеру требуется определенная политика создания для экспортов, используемых для удовлетворения данного импорта. Если конкретное значение политики создания не требуется, используется значение по умолчанию <see cref="F:System.ComponentModel.Composition.CreationPolicy.Any" />.</param>
        <param name="metadata">Метаданные, связанные с данным импортом.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />, используя указанные имя контракта, требуемое удостоверение типа, обязательные и необязательные метаданные, количество элементов и политику создания, а также указывает, является ли определение импорта предварительным условием или разрешает рекомпозицию.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="contractName" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="contractName" /> является пустой строкой ("").  
  
-или- 
 Параметр <paramref name="requiredMetadata" /> содержит элемент, равный <see langword="null" />.  
  
-или- 
 <paramref name="cardinality" /> не является одним из значений <see cref="T:System.ComponentModel.Composition.Primitives.ImportCardinality" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Constraint">
      <MemberSignature Language="C#" Value="public override System.Linq.Expressions.Expression&lt;Func&lt;System.ComponentModel.Composition.Primitives.ExportDefinition,bool&gt;&gt; Constraint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;class System.ComponentModel.Composition.Primitives.ExportDefinition, bool&gt;&gt; Constraint" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.Constraint" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Constraint As Expression(Of Func(Of ExportDefinition, Boolean))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::Expression&lt;Func&lt;System::ComponentModel::Composition::Primitives::ExportDefinition ^, bool&gt; ^&gt; ^ Constraint { System::Linq::Expressions::Expression&lt;Func&lt;System::ComponentModel::Composition::Primitives::ExportDefinition ^, bool&gt; ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Constraint : System.Linq.Expressions.Expression&lt;Func&lt;System.ComponentModel.Composition.Primitives.ExportDefinition, bool&gt;&gt;" Usage="System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.Constraint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;System.Func&lt;System.ComponentModel.Composition.Primitives.ExportDefinition,System.Boolean&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает выражение, которое определяет условия, которые должны удовлетворяться импортом, описанным данным определением импорта.</summary>
        <value>Выражение, содержащее объект <see cref="T:System.Func`2" />, определяющий условия, которые должны соответствовать определению <see cref="T:System.ComponentModel.Composition.Primitives.ImportDefinition" /> для их удовлетворения объектом <see cref="T:System.ComponentModel.Composition.Primitives.Export" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstraintSatisfiedBy">
      <MemberSignature Language="C#" Value="public override bool IsConstraintSatisfiedBy (System.ComponentModel.Composition.Primitives.ExportDefinition exportDefinition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsConstraintSatisfiedBy(class System.ComponentModel.Composition.Primitives.ExportDefinition exportDefinition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.IsConstraintSatisfiedBy(System.ComponentModel.Composition.Primitives.ExportDefinition)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsConstraintSatisfiedBy(System::ComponentModel::Composition::Primitives::ExportDefinition ^ exportDefinition);" />
      <MemberSignature Language="F#" Value="override this.IsConstraintSatisfiedBy : System.ComponentModel.Composition.Primitives.ExportDefinition -&gt; bool" Usage="contractBasedImportDefinition.IsConstraintSatisfiedBy exportDefinition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exportDefinition" Type="System.ComponentModel.Composition.Primitives.ExportDefinition" />
      </Parameters>
      <Docs>
        <param name="exportDefinition">Проверяемое определение экспорта.</param>
        <summary>Возвращает значение, указывающее, удовлетворяет ли экспорт, представленный заданным определением экспорта, ограничению, представленному данным объектом.</summary>
        <returns>Значение <see langword="true" />, если ограничение удовлетворяется; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequiredCreationPolicy">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.Composition.CreationPolicy RequiredCreationPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.Composition.CreationPolicy RequiredCreationPolicy" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredCreationPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RequiredCreationPolicy As CreationPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::Composition::CreationPolicy RequiredCreationPolicy { System::ComponentModel::Composition::CreationPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RequiredCreationPolicy : System.ComponentModel.Composition.CreationPolicy" Usage="System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredCreationPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Composition.CreationPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, что импортеру требуется определенная политика <see cref="T:System.ComponentModel.Composition.CreationPolicy" /> для экспортов, используемых для удовлетворения данного импорта.</summary>
        <value>Одно из следующих значений: 
 Значение <see cref="F:System.ComponentModel.Composition.CreationPolicy.Any" />, если импортеру не требуется определенная политика <see cref="T:System.ComponentModel.Composition.CreationPolicy" />.  
  
 Значение <see cref="F:System.ComponentModel.Composition.CreationPolicy.Shared" />, если необходимо, чтобы все используемые экспорты совместно использовались всеми импортерами в контейнере.  
  
 Значение <see cref="F:System.ComponentModel.Composition.CreationPolicy.NonShared" />, если необходимо не предоставлять общий доступ ко всем используемым экспортам в контейнере. В этом случае каждый импортер получает отдельный экземпляр.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequiredMetadata">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,Type&gt;&gt; RequiredMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Type&gt;&gt; RequiredMetadata" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredMetadata" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RequiredMetadata As IEnumerable(Of KeyValuePair(Of String, Type))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, Type ^&gt;&gt; ^ RequiredMetadata { System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, Type ^&gt;&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequiredMetadata : seq&lt;System.Collections.Generic.KeyValuePair&lt;string, Type&gt;&gt;" Usage="System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Type&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имена метаданных экспорта, необходимого для определения импорта.</summary>
        <value>Коллекция объектов <see cref="T:System.String" />, содержащих имена метаданных объектов <see cref="T:System.ComponentModel.Composition.Primitives.Export" />, необходимых для объекта <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />. По умолчанию используется пустая коллекция <see cref="T:System.Collections.Generic.IEnumerable`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переопределения этого свойства не должны возвращать `null` или возвращать <xref:System.Collections.Generic.IEnumerable%601> коллекцию, содержащую элемент, который является `null`. Если определение не содержит необходимые метаданные, возвращается пустой <xref:System.Collections.Generic.IEnumerable%601> коллекции вместо этого.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequiredTypeIdentity">
      <MemberSignature Language="C#" Value="public virtual string RequiredTypeIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RequiredTypeIdentity" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredTypeIdentity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RequiredTypeIdentity As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ RequiredTypeIdentity { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequiredTypeIdentity : string" Usage="System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredTypeIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает ожидаемый тип экспорта, соответствующего данному объекту <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />.</summary>
        <value>Строка, создаваемая путем вызова метода <see cref="M:System.ComponentModel.Composition.AttributedModelServices.GetTypeIdentity(System.Type)" /> для типа, ожидаемого данным импортом. Если значение равно <see langword="null" />, импорт не ожидает определенный тип.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="contractBasedImportDefinition.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строковое представление конкретного объекта <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />.</summary>
        <returns>Строковое представление конкретного объекта <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>