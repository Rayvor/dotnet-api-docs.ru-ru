<Type Name="ItemsControl" FullName="System.Windows.Controls.ItemsControl">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e8c561c3277fb886e08206f4bb72bc55cd80c771" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73397855" /></Metadata><TypeSignature Language="C#" Value="public class ItemsControl : System.Windows.Controls.Control, System.Windows.Controls.Primitives.IContainItemStorage, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ItemsControl extends System.Windows.Controls.Control implements class System.Windows.Controls.Primitives.IContainItemStorage, class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.ItemsControl" />
  <TypeSignature Language="VB.NET" Value="Public Class ItemsControl&#xA;Inherits Control&#xA;Implements IAddChild, IContainItemStorage" />
  <TypeSignature Language="C++ CLI" Value="public ref class ItemsControl : System::Windows::Controls::Control, System::Windows::Controls::Primitives::IContainItemStorage, System::Windows::Markup::IAddChild" />
  <TypeSignature Language="F#" Value="type ItemsControl = class&#xA;    inherit Control&#xA;    interface IAddChild&#xA;    interface IContainItemStorage" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Controls.Primitives.IContainItemStorage</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("OnItemsChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Items")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Items")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="ItemContainerStyle", StyleTargetType=typeof(System.Windows.FrameworkElement))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет элемент управления, который может быть использован для представления коллекции элементов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ItemsControl> — это тип <xref:System.Windows.Controls.Control>, который может содержать несколько элементов, таких как строки, объекты или другие элементы. На следующем рисунке показан элемент управления <xref:System.Windows.Controls.ListBox>, который содержит следующие различные типы элементов:  
  
-   Строка.  
  
-   Объект <xref:System.DateTime>.  
  
-   Объект <xref:System.Windows.UIElement>.  
  
-   Элемент управления <xref:System.Windows.Controls.Panel>, содержащий <xref:System.Windows.Shapes.Ellipse> и <xref:System.Windows.Controls.TextBlock>.  
  
 ![Элемент управления ListBox с четырьмя типами содержимого](~/add/media/controlcontentmodellistbox2.PNG "ListBox с четырьмя типами содержимого")  
Элемент управления ListBox, содержащий несколько типов объектов  
  
 Используйте <xref:System.Windows.Controls.ItemsControl.Items%2A> или свойство <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A>, чтобы указать коллекцию, которая будет использоваться для создания содержимого <xref:System.Windows.Controls.ItemsControl>. Можно задать для свойства <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> любой тип, реализующий <xref:System.Collections.IEnumerable>. <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> обычно используется для вывода коллекции данных или привязки <xref:System.Windows.Controls.ItemsControl> к объекту коллекции.  
  
 Если вы не хотите использовать объект, реализующий <xref:System.Collections.IEnumerable> для заполнения <xref:System.Windows.Controls.ItemsControl>, можно добавить элементы с помощью свойства <xref:System.Windows.Controls.ItemsControl.Items%2A>. Элементы в <xref:System.Windows.Controls.ItemsControl> могут иметь различные типы. Например, <xref:System.Windows.Controls.ListBox> может содержать один элемент, являющийся строкой, и другой элемент, который является <xref:System.Windows.Controls.Image>.  
  
 Если задано свойство <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A>, для коллекции <xref:System.Windows.Controls.ItemsControl.Items%2A> устанавливается значение только чтение и фиксированный размер. Это означает, что нельзя добавлять элементы непосредственно в коллекцию. Если <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> используется, задание для свойства значения `null` удаляет коллекцию и восстанавливает использование до <xref:System.Windows.Controls.ItemsControl.Items%2A>, что будет пустым <xref:System.Windows.Controls.ItemCollection>.  
  
 Каждый тип <xref:System.Windows.Controls.ItemsControl> имеет соответствующий тип контейнера элементов. Соответствующий контейнер элементов для каждого <xref:System.Windows.Controls.ItemsControl> добавляет `Item` к имени. Например, для <xref:System.Windows.Controls.ListBox>контейнеры элементов являются <xref:System.Windows.Controls.ListBoxItem> элементами управления. для <xref:System.Windows.Controls.ComboBox>они являются <xref:System.Windows.Controls.ComboBoxItem> элементами управления. Можно явно создать тип контейнера для каждого элемента в <xref:System.Windows.Controls.ItemsControl>, но это необязательно. Если тип контейнера не создается явно, он создается, который содержит элемент данных в коллекции элементов. Например, при привязке коллекции строковых объектов к свойству <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> <xref:System.Windows.Controls.ListBox>вы не создаете объекты <xref:System.Windows.Controls.ListBoxItem> явным образом, но <xref:System.Windows.Controls.ListBox> создаст их для каждой строки. Доступ к созданному контейнеру элементов можно получить с помощью свойства <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A>.  
  
> [!NOTE]
>  Некоторые функции модели автоматизации пользовательского интерфейса работают неправильно, если <xref:System.Windows.Controls.ItemsControl> содержит дублирующиеся объекты.   Если объект встречается несколько раз, в дереве автоматизации появляется только первый экземпляр.   (Два объекта **x** и **y** считаются повторяющимися, если `Object.Equals(x, y)` возвращает `true`.)  
>   
>  Хотя объект **x** используется <xref:System.Windows.Controls.ItemsControl> значение, возвращаемое **x.**`GetHashCode()` не должно изменяться.  Изменения этого значения не поддерживаются, что приводит к непредсказуемому поведению.  
  
 Свойства зависимостей для этого элемента управления могут быть установлены стилем элемента управления по умолчанию. Если свойство задано стилем по умолчанию, свойство может измениться по умолчанию, когда элемент управления появится в приложении. Стиль по умолчанию определяется тем, какая тема рабочего стола используется при запуске приложения. Дополнительные сведения см. в разделе [темы WPF по умолчанию](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 В следующих примерах демонстрируется привязка данных к <xref:System.Windows.Controls.ItemsControl>. В первом примере создается класс с именем `MyData`, который представляет собой простую коллекцию строк.  
  
 [!code-csharp[ControlContentOverviewSnippets#8](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#8)]
 [!code-vb[ControlContentOverviewSnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#8)]  
  
 В следующем примере выполняется привязка объекта <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> <xref:System.Windows.Controls.ItemsControl> к `MyData`.  
  
 [!code-xaml[ControlContentOverviewSnippets#7](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#7)]  
[!code-xaml[ControlContentOverviewSnippets#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#6)]  
  
 [!code-csharp[ControlContentOverviewSnippets#9](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#9)]
 [!code-vb[ControlContentOverviewSnippets#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#9)]  
  
 На следующем рисунке показан элемент управления <xref:System.Windows.Controls.ListBox>, созданный в предыдущем примере.  
  
 ![ListBox](~/add/media/controlcontentmodellistbox1.PNG "ListBox")  
  
 В следующем примере показано, как заполнить <xref:System.Windows.Controls.ItemsControl> с помощью свойства <xref:System.Windows.Controls.ItemsControl.Items%2A>. В этом примере в <xref:System.Windows.Controls.ListBox>добавляются следующие элементы различных типов:  
  
-   Строка.  
  
-   Объект <xref:System.DateTime>.  
  
-   Объект <xref:System.Windows.UIElement>.  
  
-   Элемент управления <xref:System.Windows.Controls.Panel>, который содержит другие объекты <xref:System.Windows.UIElement>.  
  
 [!code-xaml[ControlContentOverviewSnippets#3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#3)]  
  
 [!code-csharp[ControlContentOverviewSnippets#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#4)]
 [!code-vb[ControlContentOverviewSnippets#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#4)]  
  
 На следующем рисунке показан <xref:System.Windows.Controls.ListBox>, созданный в предыдущем примере.  
  
 ![Элемент управления ListBox с четырьмя типами содержимого](~/add/media/controlcontentmodellistbox2.PNG "ListBox с четырьмя типами содержимого")  
  
 В следующем примере показано, как использовать различные свойства, связанные со стилями и шаблонами, предоставляемые <xref:System.Windows.Controls.ItemsControl>. <xref:System.Windows.Controls.ItemsControl> в этом примере привязан к коллекции объектов `Task`. Для демонстрационных целей все стили и шаблоны в этом примере объявлены встроенными.  
  
 [!code-xaml[DataTemplatingIntro_snip#ItemsControlProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#itemscontrolproperties)]  
  
 На следующем рисунке показан снимок экрана примера при подготовке к просмотру.  
  
 ![Снимок экрана примера ItemsControl](~/add/media/databinding-itemscontrolproperties.png "Снимок экрана: пример ItemsControl")  
  
 Два других свойства <xref:System.Windows.Controls.ItemsControl>, которые не показаны здесь, <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> и <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.ItemCollection" />
    <altmember cref="T:System.Windows.Controls.ItemContainerGenerator" />
    <altmember cref="T:System.Windows.Controls.ItemsPresenter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ItemsControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ItemsControl();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="AddChild">
      <MemberSignature Language="C#" Value="protected virtual void AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddChild (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddChild(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member AddChild : obj -&gt; unit&#xA;override this.AddChild : obj -&gt; unit" Usage="itemsControl.AddChild value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект для добавления в качестве дочернего.</param>
        <summary>Добавляет заданный объект в качестве дочернего объекта <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddText">
      <MemberSignature Language="C#" Value="protected virtual void AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddText (text As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddText(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member AddText : string -&gt; unit&#xA;override this.AddText : string -&gt; unit" Usage="itemsControl.AddText text" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Строка для добавления.</param>
        <summary>Добавляет заданную текстовую строку к объекту <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationCount">
      <MemberSignature Language="C#" Value="public int AlternationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AlternationCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.AlternationCount" />
      <MemberSignature Language="VB.NET" Value="Public Property AlternationCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AlternationCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AlternationCount : int with get, set" Usage="System.Windows.Controls.ItemsControl.AlternationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает количество чередующихся контейнеров элементов в объекте <see cref="T:System.Windows.Controls.ItemsControl" />, который позволяет чередующимся контейнерам иметь уникальный внешний вид.</summary>
        <value>Количество чередующихся контейнеров элементов в <see cref="T:System.Windows.Controls.ItemsControl" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> и <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> позволяют указать внешний вид для двух или более чередующихся контейнеров элементов. Например, можно указать чередующиеся цвета фона для каждого третьего элемента в <xref:System.Windows.Controls.ItemsControl>.  <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> назначается каждому контейнеру элементов в <xref:System.Windows.Controls.ItemsControl>.  <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> начинается с 0, увеличивается до тех пор, пока не <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> минус 1, а затем перезапускается в 0. Например, если <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> имеет значение 3 и в <xref:System.Windows.Controls.ItemsControl>есть семь элементов, в следующей таблице перечислены <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> для каждого элемента.  
  
|Позиция элемента в <xref:System.Windows.Controls.ItemsControl>|<xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>|  
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|1|0|  
|2|1|  
|3|2|  
|4|0|  
|5|1|  
|6|2|  
|7|0|  
  
 Существует несколько методов, которые можно использовать для указания различных внешнего вида для чередующихся контейнеров элементов. Один из методов — привязать свойства контейнера Items к <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>. Затем можно использовать <xref:System.Windows.Controls.AlternationConverter>, чтобы указать, какое значение должно применяться к контейнеру элемента, имеющему определенное значение <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>. Можно также использовать триггеры для изменения значения свойства контейнера элемента в зависимости от значения его <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере указывается, что <xref:System.Windows.Controls.ListBox> (который наследует от <xref:System.Windows.Controls.ItemsControl>) содержит чередующиеся контейнеры элементов (которые имеют тип <xref:System.Windows.Controls.ListBoxItem>) и задает разные фон и передний план для каждого из них.  В этом примере свойства <xref:System.Windows.Controls.Control.Background%2A> и <xref:System.Windows.Controls.Control.Foreground%2A> привязываются к <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> и предоставляется <xref:System.Windows.Controls.AlternationConverter> для каждого свойства.  
  
 [!code-xaml[AlternationIndexSnippets#2](~/samples/snippets/csharp/VS_Snippets_Wpf/AlternationIndexSnippets/CS/Window1.xaml#2)]  
  
 Следующий пример делает то же, что и предыдущий пример, с помощью <xref:System.Windows.Trigger> объектов.  
  
 [!code-xaml[AlternationIndexSnippets#1](~/samples/snippets/csharp/VS_Snippets_Wpf/AlternationIndexSnippets/CS/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationCountProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AlternationCountProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AlternationCountProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.AlternationCountProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AlternationCountProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AlternationCountProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AlternationCountProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.AlternationCountProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationIndex">
      <MemberSignature Language="C#" Value="see GetAlternationIndex" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value="see GetAlternationIndex" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.AlternationIndex" />
      <MemberSignature Language="VB.NET" Value="see GetAlternationIndex" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="F#" Value="see GetAlternationIndex" Usage="see GetAlternationIndex" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C#" Value="see GetAlternationIndex, and SetAlternationIndex" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value="see GetAlternationIndex, and SetAlternationIndex" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="see GetAlternationIndex, and SetAlternationIndex" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="see GetAlternationIndex, and SetAlternationIndex" Usage="see GetAlternationIndex, and SetAlternationIndex" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает присвоенное значение контейнера элементов, если используются чередующиеся контейнеры элементов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> и <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> позволяют указать внешний вид для двух или более чередующихся контейнеров элементов. Например, можно указать чередующиеся цвета фона для каждого третьего элемента в <xref:System.Windows.Controls.ItemsControl>.  <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> назначается каждому контейнеру элементов в <xref:System.Windows.Controls.ItemsControl>.  <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> начинается с 0, увеличивается до тех пор, пока не <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> минус 1, а затем перезапускается в 0. Например, если <xref:System.Windows.Controls.ItemsControl.AlternationCount%2A> имеет значение 3 и в <xref:System.Windows.Controls.ItemsControl>есть семь элементов, в следующей таблице перечислены <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> для каждого элемента.  
  
|Позиция элемента в <xref:System.Windows.Controls.ItemsControl>|<xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>|  
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|1|0|  
|2|1|  
|3|2|  
|4|0|  
|5|1|  
|6|2|  
|7|0|  
  
 Существует несколько методов, которые можно использовать для указания различных внешнего вида для чередующихся контейнеров элементов. Один из методов — привязать свойства контейнера Items к <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>. Затем можно использовать <xref:System.Windows.Controls.AlternationConverter>, чтобы указать, какое значение должно применяться к контейнеру элемента, имеющему определенное значение <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>. Можно также использовать триггеры для изменения значения свойства контейнера элемента в зависимости от значения его <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере указывается, что <xref:System.Windows.Controls.ListBox> (который наследует от <xref:System.Windows.Controls.ItemsControl>) содержит чередующиеся контейнеры элементов (которые имеют тип <xref:System.Windows.Controls.ListBoxItem>) и задает разные фон и передний план для каждого из них.  В этом примере свойства <xref:System.Windows.Controls.Control.Background%2A> и <xref:System.Windows.Controls.Control.Foreground%2A> привязываются к <xref:System.Windows.Controls.ItemsControl.AlternationIndex%2A?displayProperty=nameWithType> и предоставляется <xref:System.Windows.Controls.AlternationConverter> для каждого свойства.  
  
 [!code-xml[AlternationIndexSnippets#2](~/samples/snippets/csharp/VS_Snippets_Wpf/AlternationIndexSnippets/CS/Window1.xaml#2)]  
  
 Следующий пример делает то же, что и предыдущий пример, с помощью <xref:System.Windows.Trigger> объектов.  
  
 [!code-xml[AlternationIndexSnippets#1](~/samples/snippets/csharp/VS_Snippets_Wpf/AlternationIndexSnippets/CS/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AlternationIndexProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AlternationIndexProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AlternationIndexProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.AlternationIndexProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AlternationIndexProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AlternationIndexProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AlternationIndexProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.AlternationIndexProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public override void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void BeginInit();" />
      <MemberSignature Language="F#" Value="override this.BeginInit : unit -&gt; unit" Usage="itemsControl.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Указывает, что скоро начнется инициализация объекта <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="ClearContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected virtual void ClearContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ClearContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ClearContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ClearContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ClearContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member ClearContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit&#xA;override this.ClearContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="itemsControl.ClearContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="element">Элемент контейнера.</param>
        <param name="item">Элемент.</param>
        <summary>При переопределении в производном классе отменяет действия метода <see cref="M:System.Windows.Controls.ItemsControl.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация ничего не делает.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ContainerFromElement">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает контейнер, который принадлежит текущему <see cref="T:System.Windows.Controls.ItemsControl" />, являющемуся владельцем данного элемента контейнера.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContainerFromElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject ContainerFromElement (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject ContainerFromElement(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ContainerFromElement(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainerFromElement (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ ContainerFromElement(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="member this.ContainerFromElement : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="itemsControl.ContainerFromElement element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Элемент для возврата контейнера.</param>
        <summary>Возвращает контейнер, принадлежащий текущему <see cref="T:System.Windows.Controls.ItemsControl" />, содержащему заданный элемент.</summary>
        <returns>Контейнер, принадлежащий текущему <see cref="T:System.Windows.Controls.ItemsControl" />, содержащему заданный элемент или <see langword="null" />, если такой контейнер существует.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="ContainerFromElement">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject ContainerFromElement (System.Windows.Controls.ItemsControl itemsControl, System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject ContainerFromElement(class System.Windows.Controls.ItemsControl itemsControl, class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ContainerFromElement(System.Windows.Controls.ItemsControl,System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ ContainerFromElement(System::Windows::Controls::ItemsControl ^ itemsControl, System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member ContainerFromElement : System.Windows.Controls.ItemsControl * System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Controls.ItemsControl.ContainerFromElement (itemsControl, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemsControl" Type="System.Windows.Controls.ItemsControl" />
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="itemsControl"><see cref="T:System.Windows.Controls.ItemsControl" /> для возврата контейнера.</param>
        <param name="element">Элемент для возврата контейнера.</param>
        <summary>Возвращает контейнер, который принадлежит указанному <see cref="T:System.Windows.Controls.ItemsControl" />, являющемуся владельцем данного элемента контейнера.</summary>
        <returns>Контейнер, который принадлежит указанному <see cref="T:System.Windows.Controls.ItemsControl" />, являющемуся владельцем данного элемента, если <paramref name="itemsControl" /> не имеет значение <see langword="null" />. Если <paramref name="itemsControl" /> имеет значение <see langword="null" />, возвращает ближайший контейнер, принадлежащий любому <see cref="T:System.Windows.Controls.ItemsControl" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMemberPath">
      <MemberSignature Language="C#" Value="public string DisplayMemberPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayMemberPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayMemberPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayMemberPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayMemberPath : string with get, set" Usage="System.Windows.Controls.ItemsControl.DisplayMemberPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает путь к значению в объекте источника в качестве визуального представления объекта.</summary>
        <value>Путь к значению исходного объекта. Это может быть любой путь или XPath, такие как "@Name". Значение по умолчанию — пустая строка ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство является простым способом определения шаблона по умолчанию, который описывает способ отображения объектов данных.  
  
<a name="dependencyPropertyInfo_DisplayMemberPath"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ItemsControl.DisplayMemberPathProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 В следующем примере статический ресурс с именем `places` определяется как коллекция объектов `Place`, в которых каждый объект `Place` имеет свойство `CityName` и свойство `State`. Префикс `src` сопоставляется с пространством имен, в котором определен `Places` источника данных. Префиксы `scm` и `dat` сопоставляются с пространствами имен <xref:System.ComponentModel> и <xref:System.Windows.Data> соответственно.  
  
 В следующем примере создается представление коллекции данных, которая сортируется по названию города и группируются по состоянию.  
  
 [!code-xaml[CollectionViewSource#1](~/samples/snippets/csharp/VS_Snippets_Wpf/CollectionViewSource/CS/window1.xaml#1)]  
  
 Представление может быть источником привязки, как показано в следующем примере. Из-за указанного <xref:System.Windows.Controls.ItemsControl.DisplayMemberPath%2A>каждый объект`Place` отображается со значением `CityName`. Если <xref:System.Windows.Controls.ItemsControl.DisplayMemberPath%2A> не указан и <xref:System.Windows.DataTemplate>, то <xref:System.Windows.Controls.ListBox> отображает строковое представление каждого объекта в базовой коллекции (в данном случае "Сдксампле. Place").  
  
 [!code-xaml[CollectionViewSource#2](~/samples/snippets/csharp/VS_Snippets_Wpf/CollectionViewSource/CS/window1.xaml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" />
      </Docs>
    </Member>
    <Member MemberName="DisplayMemberPathProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DisplayMemberPathProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DisplayMemberPathProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.DisplayMemberPathProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DisplayMemberPathProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DisplayMemberPathProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DisplayMemberPathProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.DisplayMemberPathProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public override void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndInit();" />
      <MemberSignature Language="F#" Value="override this.EndInit : unit -&gt; unit" Usage="itemsControl.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Указывает на завершение инициализации объекта <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAlternationIndex">
      <MemberSignature Language="C#" Value="public static int GetAlternationIndex (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetAlternationIndex(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.GetAlternationIndex(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAlternationIndex (element As DependencyObject) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetAlternationIndex(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetAlternationIndex : System.Windows.DependencyObject -&gt; int" Usage="System.Windows.Controls.ItemsControl.GetAlternationIndex element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Объект, из которого необходимо получить свойство <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" />.</param>
        <summary>Получает объект <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" /> для указанного объекта.</summary>
        <returns>Значение объекта <see cref="P:System.Windows.Controls.ItemsControl.AlternationIndex" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.DependencyObject GetContainerForItemOverride ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.DependencyObject GetContainerForItemOverride() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.GetContainerForItemOverride" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetContainerForItemOverride () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::DependencyObject ^ GetContainerForItemOverride();" />
      <MemberSignature Language="F#" Value="abstract member GetContainerForItemOverride : unit -&gt; System.Windows.DependencyObject&#xA;override this.GetContainerForItemOverride : unit -&gt; System.Windows.DependencyObject" Usage="itemsControl.GetContainerForItemOverride " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает или идентифицирует элемент, используемый для отображения заданного элемента.</summary>
        <returns>Элемент, используемый для отображения заданного элемента.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="GetItemsOwner">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.ItemsControl GetItemsOwner (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Controls.ItemsControl GetItemsOwner(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.GetItemsOwner(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetItemsOwner (element As DependencyObject) As ItemsControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::ItemsControl ^ GetItemsOwner(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetItemsOwner : System.Windows.DependencyObject -&gt; System.Windows.Controls.ItemsControl" Usage="System.Windows.Controls.ItemsControl.GetItemsOwner element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemsControl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Элемент-источник.</param>
        <summary>Возвращает объект <see cref="T:System.Windows.Controls.ItemsControl" />, для которого указанный элемент содержит элементы.</summary>
        <returns>Элемент <see cref="T:System.Windows.Controls.ItemsControl" />, для которого указанный элемент размещает элементы, или значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Controls.Panel.IsItemsHost%2A> имеет значение `true` на `element` в стиле или если `element` является панелью, созданной <xref:System.Windows.Controls.ItemsPresenter> для <xref:System.Windows.Controls.ItemsControl>, возвращается <xref:System.Windows.Controls.ItemsControl>. в противном случае `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupStyle">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ObservableCollection&lt;System.Windows.Controls.GroupStyle&gt; GroupStyle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ObservableCollection`1&lt;class System.Windows.Controls.GroupStyle&gt; GroupStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.GroupStyle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GroupStyle As ObservableCollection(Of GroupStyle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ObservableCollection&lt;System::Windows::Controls::GroupStyle ^&gt; ^ GroupStyle { System::Collections::ObjectModel::ObservableCollection&lt;System::Windows::Controls::GroupStyle ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GroupStyle : System.Collections.ObjectModel.ObservableCollection&lt;System.Windows.Controls.GroupStyle&gt;" Usage="System.Windows.Controls.ItemsControl.GroupStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ObservableCollection&lt;System.Windows.Controls.GroupStyle&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию объектов <see cref="T:System.Windows.Controls.GroupStyle" />, определяющих внешний вид каждого уровня групп.</summary>
        <value>Коллекция объектов <see cref="T:System.Windows.Controls.GroupStyle" />, определяющая внешний вид каждого уровня групп.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запись с индексом 0 описывает группы верхнего уровня, запись с индексом 1 описывает следующий уровень и т. д. При наличии большего количества уровней группировки, чем записей в коллекции, для дополнительных уровней используется последняя запись.  
  
<a name="xamlPropertyElementUsage_GroupStyle"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.GroupStyle>  
    OneOrMoreGroupStyleObjects  
  </object.GroupStyle>  
</object>  
  
```  
  
<a name="xamlValues_GroupStyle"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *онеормореграупстилеобжектс*  
 Один или несколько объектов <xref:System.Windows.Controls.GroupStyle>.  
  
   
  
## Examples  
 В следующих примерах показан <xref:System.Windows.Controls.ItemsControl>, привязанный к <xref:System.Windows.Data.XmlDataProvider> и содержимому кода программной части, которое содержит логику для добавления и удаления группирования. Если флажок установлен, содержимое <xref:System.Windows.Controls.ItemsControl> группируются по атрибуту `Type`.  
  
 Каждая группа имеет тип <xref:System.Windows.Data.CollectionViewGroup>. <xref:System.Windows.Controls.GroupStyle.HeaderTemplate%2A> <xref:System.Windows.Controls.GroupStyle> задается так, чтобы она отображалась как <xref:System.Windows.Controls.TextBlock>, отображающая <xref:System.Windows.Data.CollectionViewGroup.Name%2A> каждой группы. В этом случае <xref:System.Windows.Data.CollectionViewGroup.Name%2A> имеет значение `Work` или `Home`.  
  
 [!code-xaml[GroupingSample#XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml#xaml)]  
  
 [!code-csharp[GroupingSample#Code](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#code)]
 [!code-vb[GroupingSample#Code](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#code)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" />
      </Docs>
    </Member>
    <Member MemberName="GroupStyleSelector">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.GroupStyleSelector GroupStyleSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.GroupStyleSelector GroupStyleSelector" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property GroupStyleSelector As GroupStyleSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::GroupStyleSelector ^ GroupStyleSelector { System::Windows::Controls::GroupStyleSelector ^ get(); void set(System::Windows::Controls::GroupStyleSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.GroupStyleSelector : System.Windows.Controls.GroupStyleSelector with get, set" Usage="System.Windows.Controls.ItemsControl.GroupStyleSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.GroupStyleSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает метод, позволяющий предоставлять настаиваемую логику выбора для <see cref="T:System.Windows.Controls.GroupStyle" /> для применения к каждой группе в коллекции.</summary>
        <value>Метод, позволяющий предоставить пользовательскую логику выбора для <see cref="T:System.Windows.Controls.GroupStyle" /> для применения к каждой группе в коллекции.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_GroupStyleSelector"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ItemsControl.GroupStyleSelectorProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.PropertyGroupDescription" />
      </Docs>
    </Member>
    <Member MemberName="GroupStyleSelectorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty GroupStyleSelectorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty GroupStyleSelectorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.GroupStyleSelectorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GroupStyleSelectorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ GroupStyleSelectorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable GroupStyleSelectorProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.GroupStyleSelectorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasItems">
      <MemberSignature Language="C#" Value="public bool HasItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasItems" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.HasItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasItems As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasItems { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasItems : bool" Usage="System.Windows.Controls.ItemsControl.HasItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, содержит ли <see cref="T:System.Windows.Controls.ItemsControl" /> элементы.</summary>
        <value><see langword="true" />, если количество элементов больше 0; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_HasItems"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ItemsControl.HasItemsProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasItemsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HasItemsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HasItemsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.HasItemsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HasItemsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HasItemsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HasItemsProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.HasItemsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.HasItems" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGrouping">
      <MemberSignature Language="C#" Value="public bool IsGrouping { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGrouping" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.IsGrouping" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGrouping As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGrouping { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGrouping : bool" Usage="System.Windows.Controls.ItemsControl.IsGrouping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее использует ли данный элемент управления группирование.</summary>
        <value><see langword="true" />, если элемент управления использует группирование, в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsGrouping"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ItemsControl.IsGroupingProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGroupingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsGroupingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsGroupingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.IsGroupingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsGroupingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsGroupingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsGroupingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.IsGroupingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.IsGrouping" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsItemItsOwnContainer">
      <MemberSignature Language="C#" Value="public bool IsItemItsOwnContainer (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsItemItsOwnContainer(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.IsItemItsOwnContainer(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsItemItsOwnContainer (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsItemItsOwnContainer(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="member this.IsItemItsOwnContainer : obj -&gt; bool" Usage="itemsControl.IsItemItsOwnContainer item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:MS.Internal.Controls.IGeneratorHost.IsItemItsOwnContainer(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">Проверяемый элемент.</param>
        <summary>Определяет, является ли заданный элемент (или может ли являться) собственным контейнером.</summary>
        <returns>Значение <see langword="true" />, если элемент является (или может быть) собственным контейнером; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает метод <xref:System.Windows.Controls.ItemsControl.IsItemItsOwnContainerOverride%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsItemItsOwnContainerOverride">
      <MemberSignature Language="C#" Value="protected virtual bool IsItemItsOwnContainerOverride (object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsItemItsOwnContainerOverride(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.IsItemItsOwnContainerOverride(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsItemItsOwnContainerOverride (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsItemItsOwnContainerOverride(System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member IsItemItsOwnContainerOverride : obj -&gt; bool&#xA;override this.IsItemItsOwnContainerOverride : obj -&gt; bool" Usage="itemsControl.IsItemItsOwnContainerOverride item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Проверяемый элемент.</param>
        <summary>Определяет, является ли заданный элемент (или может ли являться) собственным контейнером.</summary>
        <returns>Значение <see langword="true" />, если элемент является (или может быть) собственным контейнером; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchCaseSensitive">
      <MemberSignature Language="C#" Value="public bool IsTextSearchCaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTextSearchCaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTextSearchCaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTextSearchCaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTextSearchCaseSensitive : bool with get, set" Usage="System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, учитывается ли регистр при поиске элементов.</summary>
        <value>Значение <see langword="true" />, если поиск выполняется с учетом регистра; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если свойство <xref:System.Windows.Controls.ItemsControl.IsTextSearchEnabled%2A> имеет значение `true`, свойство <xref:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive%2A> указывает, будет ли элемент выбран в <xref:System.Windows.Controls.ItemsControl>. Например, если <xref:System.Windows.Controls.ItemsControl> содержит две строки, отличающиеся только регистром, например "ITEM" и "Item", всегда будет выбрана первая строка, независимо от регистра ввода.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Windows.Controls.ComboBox>, которая содержит строки "DOG", "CAT", "Dog" и "Cat". В примере свойство <xref:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive%2A> привязывается к свойству <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A> <xref:System.Windows.Controls.CheckBox>. Если флажок установлен и пользователь вводит "Dog", выбирается третий элемент в <xref:System.Windows.Controls.ItemsControl>. Если пользователь снимает флажок и типы "Dog", первый элемент выбирается, так как регистр не является условием поиска.  
  
 [!code-xaml[ComboBoxProps_snip#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ComboBoxProps_snip/CS/pane1.xaml#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchCaseSensitiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsTextSearchCaseSensitiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsTextSearchCaseSensitiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsTextSearchCaseSensitiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsTextSearchCaseSensitiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsTextSearchCaseSensitiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.IsTextSearchCaseSensitive" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchEnabled">
      <MemberSignature Language="C#" Value="public bool IsTextSearchEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTextSearchEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.IsTextSearchEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTextSearchEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTextSearchEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTextSearchEnabled : bool with get, set" Usage="System.Windows.Controls.ItemsControl.IsTextSearchEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее включен ли <see cref="T:System.Windows.Controls.TextSearch" /> в экземпляре <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value>Значение <see langword="true" />, если параметр <see cref="T:System.Windows.Controls.TextSearch" /> включен; в противном случае — значение <see langword="true" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsTextSearchEnabled"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ItemsControl.IsTextSearchEnabledProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTextSearchEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsTextSearchEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsTextSearchEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.IsTextSearchEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsTextSearchEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsTextSearchEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsTextSearchEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.IsTextSearchEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.IsTextSearchEnabled" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemBindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup ItemBindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup ItemBindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemBindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ ItemBindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemBindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.Controls.ItemsControl.ItemBindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Windows.Data.BindingGroup" />, который копируется в каждый элемент в объекте <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value>Объект <see cref="T:System.Windows.Data.BindingGroup" />, который копируется в каждый элемент в <see cref="T:System.Windows.Controls.ItemsControl" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При задании свойства <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A> каждый контейнер элементов получает <xref:System.Windows.Data.BindingGroup> с теми же <xref:System.Windows.Controls.ValidationRule> объектами, что и <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A>, но свойства, описывающие данные в привязках, такие как <xref:System.Windows.Data.BindingGroup.Items%2A> и <xref:System.Windows.Data.BindingGroup.BindingExpressions%2A>, относятся к данным для каждого элемента в <xref:System.Windows.Controls.ItemsControl>.  Для выполнения таких операций, как проверка данных и проверка на наличие ошибок в элементе, необходимо получить доступ к <xref:System.Windows.FrameworkContentElement.BindingGroup%2A> контейнера элементов.  
  
   
  
## Examples  
 Следующий пример является частью приложения, которое предлагает пользователю ввести нескольких клиентов и назначить торгового представителя каждому клиенту, а затем проверяет, что торговый отдел и клиент принадлежат одному региону. В примере задается <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A> <xref:System.Windows.Controls.ItemsControl> поэтому <xref:System.Windows.Controls.ValidationRule>, `AreasMatch`, будет проверять каждый элемент. В примере также создается <xref:System.Windows.Controls.Label>, отображающая ошибки проверки. Обратите внимание, что <xref:System.Windows.Controls.ContentControl.Content%2A> <xref:System.Windows.Controls.Label> привязан к <xref:System.Windows.Controls.ValidationError>, который он получает из свойства <xref:System.Windows.Controls.Validation.ValidationAdornerSiteForProperty?displayProperty=nameWithType>. Значение <xref:System.Windows.Controls.Validation.ValidationAdornerSiteForProperty?displayProperty=nameWithType> — это контейнер элемента, который содержит ошибку.  
  
 [!code-xaml[BindingGroupSnippets#ItemBindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml#itembindinggroup)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSiteFor](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml#validationadornersitefor)]  
  
 В следующем примере показано получение контейнера элемента и вызов <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> на <xref:System.Windows.Data.BindingGroup> контейнера для проверки данных. Необходимо проверить данные, вызвав метод для <xref:System.Windows.FrameworkContentElement.BindingGroup%2A>контейнера элемента, а не <xref:System.Windows.Controls.ItemsControl.ItemBindingGroup%2A> <xref:System.Windows.Controls.ItemsControl>.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSources](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#updatesources)]
 [!code-vb[BindingGroupSnippets#UpdateSources](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#updatesources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemBindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemBindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemBindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemBindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemBindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemBindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemBindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemBindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerGenerator">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ItemContainerGenerator ItemContainerGenerator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ItemContainerGenerator ItemContainerGenerator" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemContainerGenerator As ItemContainerGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ItemContainerGenerator ^ ItemContainerGenerator { System::Windows::Controls::ItemContainerGenerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemContainerGenerator : System.Windows.Controls.ItemContainerGenerator" Usage="System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemContainerGenerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает <see cref="T:System.Windows.Controls.ItemContainerGenerator" />, связанный с элементом управления.</summary>
        <value><see cref="T:System.Windows.Controls.ItemContainerGenerator" />, связанный с элементом управления. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A> отвечает за создание [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] для своего узла, например <xref:System.Windows.Controls.ItemsControl>. Он поддерживает связь между элементами в представлении данных элемента управления и соответствующими объектами <xref:System.Windows.UIElement>. Каждый <xref:System.Windows.Controls.ItemsControl> имеет связанный контейнер элементов, который содержит элемент данных в коллекции элементов. Для доступа к контейнеру элемента, связанному с <xref:System.Windows.Controls.ItemsControl>, можно использовать свойство <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A>. Например, если имеется элемент управления <xref:System.Windows.Controls.TreeView> с привязкой к данным и необходимо получить <xref:System.Windows.Controls.TreeViewItem> на основе его индекса или связанного с ним элемента данных, можно использовать метод <xref:System.Windows.Controls.ItemContainerGenerator.ContainerFromIndex%2A?displayProperty=nameWithType> или <xref:System.Windows.Controls.ItemContainerGenerator.ContainerFromItem%2A?displayProperty=nameWithType>. Кроме того, можно использовать метод <xref:System.Windows.Controls.ItemContainerGenerator.IndexFromContainer%2A?displayProperty=nameWithType> или <xref:System.Windows.Controls.ItemContainerGenerator.ItemFromContainer%2A?displayProperty=nameWithType>, чтобы получить индекс или элемент данных, связанный с заданным созданным элементом контейнера.  
  
 Интерфейс <xref:System.Windows.Controls.Primitives.IItemContainerGenerator> также используется в расширенных сценариях. Как правило, расширенные приложения с собственной реализацией панели виртуализации вызывают членов интерфейса.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms750552(v=vs.90)">Получение элемента поля со списком</related>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style ItemContainerStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style ItemContainerStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemContainerStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ ItemContainerStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemContainerStyle : System.Windows.Style with get, set" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Content")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает <see cref="T:System.Windows.Style" />, применяемый к элементу контейнера, созданного для каждого элемента.</summary>
        <value>Объект <see cref="T:System.Windows.Style" />, применяемый к элементу контейнера, создаваемому для каждого элемента. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство или свойство <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A> используется для установки стиля, который влияет на внешний вид элементов, содержащих элементы данных. Например, для <xref:System.Windows.Controls.ListBox>созданные контейнеры являются <xref:System.Windows.Controls.ListBoxItem> элементами управления. для <xref:System.Windows.Controls.ComboBox>они являются <xref:System.Windows.Controls.ComboBoxItem> элементами управления.  
  
 <xref:System.Windows.Controls.ItemsControl> обеспечивает большую гибкость при визуальной настройке и предоставляет множество свойств стилизации и шаблонов. Чтобы изменить макет элементов, используйте свойство <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A>. Если вы используете группировку в элементе управления, можно использовать свойство <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> или <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A>. Чтобы указать визуализацию объектов данных, используйте свойство <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> или <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A>. Дополнительные сведения о том, когда следует указывать <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A>, см. в разделе [Общие сведения о шаблонах данных](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="xamlAttributeUsage_ItemContainerStyle"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object ItemContainerStyle="ResourceExtension StyleResourceKey"/>  
```  
  
<a name="xamlValues_ItemContainerStyle"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *ресаурцеекстенсион*  
 Один из следующих: `StaticResource`или `DynamicResource`. Если сами стили не содержат ссылки на потенциальные ссылки времени выполнения, такие как системные ресурсы или пользовательские настройки, для повышения производительности обычно рекомендуется `StaticResource` ссылку на стиль.  
  
 *стилересаурцекэй*  
 `x:Key` строковое значение, ссылающееся на стиль, запрашиваемый в качестве ресурса.  
  
<a name="dependencyPropertyInfo_ItemContainerStyle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ItemsControl.ItemContainerStyleProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 В следующем примере показано, как использовать это свойство. Рассмотрим следующие <xref:System.Windows.Controls.ListBox>, привязанные к данным:  
  
 [!code-xaml[StylingIntroSnippet#UIListBox](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSnippet/CS/window1.xaml#uilistbox)]   
  
 Чтобы создать стиль для элементов, содержащих элементы данных, создайте стиль <xref:System.Windows.Controls.ListBoxItem>, как показано в следующем примере. Стиль применяется ко всем элементам <xref:System.Windows.Controls.ListBoxItem> в пределах области, в которой определен стиль.  
  
 [!code-xaml[StylingIntroSnippet#ListBoxItemStyle](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSnippet/CS/window1.xaml#listboxitemstyle)]   
  
 <xref:System.Windows.Controls.ListBoxItem> является элементом-контейнером для элемента управления <xref:System.Windows.Controls.ListBox>. Таким образом, в качестве альтернативы предшествующей предыдущей версии для свойства <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> <xref:System.Windows.Controls.ListBox> задается определенный стиль. Для этого присвойте <xref:System.Windows.Controls.ListBoxItem> стиль `x:Key`, чтобы он был доступен в качестве ресурса:  
  
 [!code-xaml[StylingIntroSample_snippet#ContainerStyle1](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#containerstyle1)]   
  
 Затем задайте для свойства <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> ресурс, как показано в следующем примере:  
  
 [!code-xaml[StylingIntroSample_snippet#ListBox](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#listbox)]   
  
 Оба приведенных выше сценария приводят к одному и тому же результату. Однако одним из преимуществ сделать стиль доступным в качестве ресурса является возможность повторного использования стиля. Явное задание свойства <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> также может обеспечить более удобочитаемость.  
  
 Полный пример см. в разделе [Общие сведения о примерах стилей и шаблонов](https://go.microsoft.com/fwlink/?LinkID=160010).  
  
 Следующий пример предназначен для демонстрации функции различных свойств стиля и шаблонов, связанных с <xref:System.Windows.Controls.ItemsControl>. <xref:System.Windows.Controls.ItemsControl> в этом примере привязан к коллекции объектов `Task`. Для демонстрационных целей все стили и шаблоны в этом примере объявлены встроенными.  
  
 [!code-xaml[DataTemplatingIntro_snip#ItemsControlProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#itemscontrolproperties)]  
  
 Ниже приведен снимок экрана примера при его просмотре:  
  
 ![Снимок экрана примера ItemsControl](~/add/media/databinding-itemscontrolproperties.png "Снимок экрана: пример ItemsControl")  
  
 Два других свойства <xref:System.Windows.Controls.ItemsControl>, которые не показаны здесь, <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> и <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A>.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160009">Введение в пример создания шаблонов данных</related>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemContainerStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemContainerStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemContainerStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemContainerStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemContainerStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemContainerStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyleSelector">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.StyleSelector ItemContainerStyleSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.StyleSelector ItemContainerStyleSelector" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemContainerStyleSelector As StyleSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::StyleSelector ^ ItemContainerStyleSelector { System::Windows::Controls::StyleSelector ^ get(); void set(System::Windows::Controls::StyleSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemContainerStyleSelector : System.Windows.Controls.StyleSelector with get, set" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Content")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.StyleSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает пользовательскую логику выбора стиля для стиля, который может быть применен к каждому сгенерированному элементу контейнера.</summary>
        <value>Объект <see cref="T:System.Windows.Controls.StyleSelector" />, содержащий логику, выбирающую стиль для использования в качестве <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> используется для установки стиля, который влияет на внешний вид элементов, содержащих элементы данных. Например, для <xref:System.Windows.Controls.ListBox>созданные контейнеры являются <xref:System.Windows.Controls.ListBoxItem> элементами управления. для <xref:System.Windows.Controls.ComboBox>они являются <xref:System.Windows.Controls.ComboBoxItem> элементами управления. Если определено более одного стиля и необходимо предоставить логику для выбора того, какой из них следует применить, то вместо свойства <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> используется свойство <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A>. Обратите внимание, что это свойство пропускается, если задано свойство <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A>.  
  
 <xref:System.Windows.Controls.ItemsControl> обеспечивает большую гибкость при визуальной настройке и предоставляет множество свойств стилизации и шаблонов. Чтобы изменить макет элементов, используйте свойство <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A>. Если вы используете группировку в элементе управления, можно использовать свойство <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> или <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A>. Чтобы указать визуализацию объектов данных, используйте свойство <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> или <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A>. Дополнительные сведения о том, когда следует указывать <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A>, см. в разделе [Общие сведения о шаблонах данных](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="dependencyPropertyInfo_ItemContainerStyleSelector"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemContainerStyleSelectorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemContainerStyleSelectorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemContainerStyleSelectorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemContainerStyleSelectorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemContainerStyleSelectorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemContainerStyleSelectorProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemContainerStyleSelectorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ItemCollection Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ItemCollection Items" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As ItemCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ItemCollection ^ Items { System::Windows::Controls::ItemCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Windows.Controls.ItemCollection" Usage="System.Windows.Controls.ItemsControl.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию, используемую для генерирования содержимого <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value>Коллекция, используемая для генерирования содержимого <see cref="T:System.Windows.Controls.ItemsControl" />. По умолчанию является пустой коллекцией.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для добавления элементов в <xref:System.Windows.Controls.ItemsControl>. Добавление дочернего элемента к <xref:System.Windows.Controls.ItemsControl> объекту неявно добавляет его в <xref:System.Windows.Controls.ItemCollection> для объекта <xref:System.Windows.Controls.ItemsControl>.  
  
> [!NOTE]
>  Это свойство можно задать только в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] с помощью показанного синтаксиса коллекции или путем доступа к объекту коллекции и использования различных методов, таких как `Add`. Свойство для доступа к объекту коллекции доступно только для чтения, а сама коллекция доступна для чтения и записи.  
  
 Обратите внимание, что для указания коллекции, которая должна использоваться для создания содержимого <xref:System.Windows.Controls.ItemsControl>, используется свойство <xref:System.Windows.Controls.ItemsControl.Items%2A> или <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A>. Если задано свойство <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A>, <xref:System.Windows.Controls.ItemsControl.Items%2A>ная коллекция становится доступна только для чтения и имеет фиксированный размер.  
  
 Если <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> используется, установка свойства <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> в значение `null` удаляет коллекцию и восстанавливает использование в <xref:System.Windows.Controls.ItemsControl.Items%2A>, что будет пустым <xref:System.Windows.Controls.ItemCollection>.  
  
<a name="xamlPropertyElementUsage_Items"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  OneOrMoreElements  
</object>  
```  
  
<a name="xamlValues_Items"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *онеорморилементс*  
 Один или несколько объектов <xref:System.Windows.UIElement>.  
  
   
  
## Examples  
 В следующих примерах демонстрируется привязка данных к <xref:System.Windows.Controls.ItemsControl>. В первом примере создается класс с именем `MyData`, который представляет собой простую коллекцию строк.  
  
 [!code-csharp[ControlContentOverviewSnippets#8](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#8)]
 [!code-vb[ControlContentOverviewSnippets#8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#8)]  
  
 В следующем примере выполняется привязка объекта <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> <xref:System.Windows.Controls.ItemsControl> к `MyData`.  
  
 [!code-xaml[ControlContentOverviewSnippets#7](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#7)]  
[!code-xaml[ControlContentOverviewSnippets#6](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#6)]  
  
 [!code-csharp[ControlContentOverviewSnippets#9](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#9)]
 [!code-vb[ControlContentOverviewSnippets#9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#9)]  
  
 На следующем рисунке показан элемент управления <xref:System.Windows.Controls.ListBox>, созданный в предыдущем примере.  
  
 ![ListBox](~/add/media/controlcontentmodellistbox1.PNG "ListBox")  
  
 В следующем примере показано, как заполнить <xref:System.Windows.Controls.ItemsControl> с помощью свойства <xref:System.Windows.Controls.ItemsControl.Items%2A>. В этом примере в <xref:System.Windows.Controls.ListBox>добавляются следующие элементы различных типов:  
  
-   Строка.  
  
-   Объект <xref:System.DateTime>.  
  
-   Объект <xref:System.Windows.UIElement>.  
  
-   Элемент управления <xref:System.Windows.Controls.Panel>, который содержит другие объекты <xref:System.Windows.UIElement>.  
  
 [!code-xaml[ControlContentOverviewSnippets#3](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml#3)]  
  
 [!code-csharp[ControlContentOverviewSnippets#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlContentOverviewSnippets/CSharp/Window1.xaml.cs#4)]
 [!code-vb[ControlContentOverviewSnippets#4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ControlContentOverviewSnippets/VisualBasic/Window1.xaml.vb#4)]  
  
 На следующем рисунке показан <xref:System.Windows.Controls.ListBox>, созданный в предыдущем примере.  
  
 ![Элемент управления ListBox с четырьмя типами содержимого](~/add/media/controlcontentmodellistbox2.PNG "ListBox с четырьмя типами содержимого")  
  
 Обратите внимание, что <xref:System.Windows.Controls.ItemCollection> является представлением, поэтому можно использовать функции, связанные с представлением, такие как сортировка, фильтрация и группирование.  
  
 Например, если имеется экземпляр <xref:System.Windows.Controls.ListBox>, `myListBox`, можно выполнить следующие действия, чтобы отсортировать содержимое <xref:System.Windows.Controls.ListBox>. В этом примере `Content` — имя свойства, по которому выполняется сортировка.  
  
 [!code-csharp[ListBoxSort_snip#Sort](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxSort_snip/CSharp/Window1.xaml.cs#sort)]
 [!code-vb[ListBoxSort_snip#Sort](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxSort_snip/visualbasic/window1.xaml.vb#sort)]  
  
 Обратите внимание, что при этом, если элемент управления привязан к коллекции напрямую, используется представление коллекции по умолчанию, а критерии сортировки применяются ко всем остальным элементам управления, привязанным к той же коллекции напрямую. Представление не будет использоваться по умолчанию, если свойство <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> привязано к <xref:System.Windows.Data.CollectionViewSource>.  
  
 Если <xref:System.Windows.Controls.ItemsControl> привязана непосредственно к коллекции, можно выполнить следующие действия, чтобы получить представление по умолчанию:  
  
 [!code-csharp[GroupingSample#MyView](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#myview)]
 [!code-vb[GroupingSample#MyView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#myview)]  
[!code-csharp[GroupingSample#GetView](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupingSample/CSharp/Window1.xaml.cs#getview)]
[!code-vb[GroupingSample#GetView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GroupingSample/visualbasic/window1.xaml.vb#getview)]  
  
 Кроме того, можно указать критерии фильтрации, сортировки и группирования в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] или коде с помощью <xref:System.Windows.Data.CollectionViewSource>.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://github.com/Microsoft/WPF-Samples/tree/master/Data%20Binding/SortFilter">Пример сортировки и фильтрации элементов в представлении</related>
      </Docs>
    </Member>
    <Member MemberName="ItemsControlFromItemContainer">
      <MemberSignature Language="C#" Value="public static System.Windows.Controls.ItemsControl ItemsControlFromItemContainer (System.Windows.DependencyObject container);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Controls.ItemsControl ItemsControlFromItemContainer(class System.Windows.DependencyObject container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ItemsControlFromItemContainer(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ItemsControlFromItemContainer (container As DependencyObject) As ItemsControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Controls::ItemsControl ^ ItemsControlFromItemContainer(System::Windows::DependencyObject ^ container);" />
      <MemberSignature Language="F#" Value="static member ItemsControlFromItemContainer : System.Windows.DependencyObject -&gt; System.Windows.Controls.ItemsControl" Usage="System.Windows.Controls.ItemsControl.ItemsControlFromItemContainer container" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemsControl</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="container">Элемент контейнера для возврата <see cref="T:System.Windows.Controls.ItemsControl" />.</param>
        <summary>Возвращает <see cref="T:System.Windows.Controls.ItemsControl" />, содержащий заданный элемент контейнера.</summary>
        <returns><see cref="T:System.Windows.Controls.ItemsControl" />, содержащий заданный элемент контейнера.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemContainerGenerator" />
      </Docs>
    </Member>
    <Member MemberName="ItemsPanel">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ItemsPanelTemplate ItemsPanel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ItemsPanelTemplate ItemsPanel" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemsPanel" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemsPanel As ItemsPanelTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ItemsPanelTemplate ^ ItemsPanel { System::Windows::Controls::ItemsPanelTemplate ^ get(); void set(System::Windows::Controls::ItemsPanelTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemsPanel : System.Windows.Controls.ItemsPanelTemplate with get, set" Usage="System.Windows.Controls.ItemsControl.ItemsPanel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ItemsPanelTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает шаблон, определяющий панель, управляющую размещением элементов.</summary>
        <value>Объект <see cref="T:System.Windows.Controls.ItemsPanelTemplate" />, определяющий панель, используемую для размещения элементов. Значением по умолчанию для <see cref="T:System.Windows.Controls.ItemsControl" /> является объект <see cref="T:System.Windows.Controls.ItemsPanelTemplate" />, который задает <see cref="T:System.Windows.Controls.StackPanel" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для <xref:System.Windows.Controls.ListBox><xref:System.Windows.Controls.ItemsPanelTemplate> по умолчанию указывает <xref:System.Windows.Controls.VirtualizingStackPanel>. Для <xref:System.Windows.Controls.MenuItem>по умолчанию используется <xref:System.Windows.Controls.WrapPanel>. Для <xref:System.Windows.Controls.Primitives.StatusBar>по умолчанию используется <xref:System.Windows.Controls.DockPanel>.  
  
 Чтобы изменить макет элементов в <xref:System.Windows.Controls.ItemsControl>, используйте это свойство, чтобы указать <xref:System.Windows.Controls.ItemsPanelTemplate>.  
  
 <xref:System.Windows.Controls.ItemsControl> обеспечивает большую гибкость при визуальной настройке и предоставляет множество свойств стилизации и шаблонов. Чтобы задать стиль, влияющий на внешний вид элементов, содержащих элементы данных, используется свойство <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> или свойство <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A>. Например, для <xref:System.Windows.Controls.ListBox>созданные контейнеры являются <xref:System.Windows.Controls.ListBoxItem> элементами управления. для <xref:System.Windows.Controls.ComboBox>они являются <xref:System.Windows.Controls.ComboBoxItem> элементами управления. Если вы используете группировку в элементе управления, можно использовать свойство <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> или <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A>. Чтобы указать визуализацию объектов данных, используйте свойство <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> или <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A>. Более подробную информацию см. в разделе [Общие сведения о шаблонах данных](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="dependencyPropertyInfo_ItemsPanel"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ItemsControl.ItemsPanelProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 Чтобы создать горизонтальную <xref:System.Windows.Controls.ListBox>, можно создать шаблон, который задает горизонтальный <xref:System.Windows.Controls.StackPanel> и задать его в качестве свойства <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A>. В следующем примере показан <xref:System.Windows.Controls.ListBox> <xref:System.Windows.Style>, который создает горизонтальный <xref:System.Windows.Controls.ListBox>.  
  
 [!code-xaml[StylingIntroSample_snippet#ItemsPanel](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSample_snippet/CSharp/Window1.xaml#itemspanel)] 
  
 В следующем примере используется <xref:System.Windows.Controls.ControlTemplate> для создания горизонтального <xref:System.Windows.Controls.ListBox> с закругленными углами. В этом примере вместо задания свойства <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A>, как в предыдущем примере, горизонтальное <xref:System.Windows.Controls.StackPanel> указывается в <xref:System.Windows.Controls.ControlTemplate>. Для свойства <xref:System.Windows.Controls.Panel.IsItemsHost%2A> задано значение `true` на <xref:System.Windows.Controls.StackPanel>, указывающее, что созданные элементы должны переключаться на панель. При указании этого способа <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> не может быть заменен пользователем элемента управления без использования <xref:System.Windows.Controls.ControlTemplate>. Поэтому это делается только в том случае, если вы не хотите, чтобы панель заменялась без использования шаблона.  
  
 [!code-xaml[StylingIntroSnippet#ListBoxCT](~/samples/snippets/csharp/VS_Snippets_Wpf/StylingIntroSnippet/CS/window1.xaml#listboxct)]   
  
 Кроме того, можно выполнить следующие действия, чтобы получить те же результаты. В этом случае <xref:System.Windows.Controls.ItemsPresenter> создает панель для макета элементов в зависимости от того, что указано в <xref:System.Windows.Controls.ItemsPanelTemplate>.  
  
 [!code-xaml[StyleOvw01#ItemsPanelTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#itemspaneltemplate)]   
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160010">Введение в Пример стилизации и создания шаблонов</related>
      </Docs>
    </Member>
    <Member MemberName="ItemsPanelProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemsPanelProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemsPanelProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemsPanelProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemsPanelProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemsPanelProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemsPanelProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemsPanelProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsSource">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerable ItemsSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerable ItemsSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemsSource" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemsSource As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IEnumerable ^ ItemsSource { System::Collections::IEnumerable ^ get(); void set(System::Collections::IEnumerable ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemsSource : System.Collections.IEnumerable with get, set" Usage="System.Windows.Controls.ItemsControl.ItemsSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает коллекцию, используемую для создания содержимого <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value>Коллекция, используемая для генерирования содержимого <see cref="T:System.Windows.Controls.ItemsControl" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Модель содержимого:** Это свойство можно использовать для добавления элементов в <xref:System.Windows.Controls.ItemsControl>.  
  
 Распространенный сценарий заключается в использовании <xref:System.Windows.Controls.ItemsControl>, например <xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ListView>или <xref:System.Windows.Controls.TreeView> для вывода коллекции данных или привязки <xref:System.Windows.Controls.ItemsControl> к объекту коллекции. Чтобы привязать <xref:System.Windows.Controls.ItemsControl> к объекту коллекции, используйте свойство <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A>. Обратите внимание, что свойство <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> поддерживает привязку <xref:System.Windows.Data.BindingMode.OneWay> по умолчанию.  
  
 Если задано свойство <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A>, <xref:System.Windows.Controls.ItemsControl.Items%2A>ная коллекция становится доступна только для чтения и имеет фиксированный размер.  
  
 Если <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> используется, задание для свойства значения `null` удаляет коллекцию и восстанавливает использование до <xref:System.Windows.Controls.ItemsControl.Items%2A>, что будет пустым <xref:System.Windows.Controls.ItemCollection>. Если <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> не используется, значение этого свойства равно `null`и задание для него значения `null` не оказывает никакого влияния.  
  
> [!NOTE]
>  В большинстве случаев не требуется реализовывать собственные коллекции. Вместо этого рассмотрите возможность использования <xref:System.Collections.ObjectModel.ObservableCollection%601> или других существующих коллекций. Дополнительные сведения см. в разделе "объекты коллекции, используемые в качестве источника привязки" раздела [Общие сведения об источниках привязки](~/docs/framework/wpf/data/binding-sources-overview.md).  
  
<a name="xamlAttributeUsage_ItemsSource"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object ItemsSource="bindingDeclaration"/>  
```  
  
<a name="xamlValues_ItemsSource"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *биндингдекларатион*  
 Объявление <xref:System.Windows.Data.Binding>. Дополнительные сведения см. в разделе [Привязка расширения разметки](~/docs/framework/wpf/advanced/binding-markup-extension.md) .  
  
<a name="dependencyPropertyInfo_ItemsSource"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ItemsControl.ItemsSourceProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsSourceProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemsSourceProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemsSourceProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemsSourceProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemsSourceProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemsSourceProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemsSourceProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemsSourceProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemStringFormat">
      <MemberSignature Language="C#" Value="public string ItemStringFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ItemStringFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemStringFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemStringFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ItemStringFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemStringFormat : string with get, set" Usage="System.Windows.Controls.ItemsControl.ItemStringFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает составную строку, которая определяет форматирование элементов в объектах <see cref="T:System.Windows.Controls.ItemsControl" />, если они отображаются как строки.</summary>
        <value>Составная строка, которая определяет способ форматирования элементов в <see cref="T:System.Windows.Controls.ItemsControl" />, если они отображаются как строки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ItemsControl.ItemStringFormat%2A> может быть стандартным, составным или пользовательским строковым форматом. Дополнительные сведения о строковых форматах см. в разделе [Типы форматирования](~/docs/standard/base-types/formatting-types.md). Если задать <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> или <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> <xref:System.Windows.Controls.ItemsControl>, свойство <xref:System.Windows.Controls.ItemsControl.ItemStringFormat%2A> игнорируется.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Windows.Controls.ItemsControl.ItemStringFormat%2A> для указания формата списка объектов <xref:System.DateTime>.  
  
 [!code-xaml[ContentStringSnippets#ItemsControl](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentStringSnippets/CSharp/Window1.xaml#itemscontrol)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemStringFormatProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemStringFormatProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemStringFormatProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemStringFormatProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemStringFormatProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemStringFormatProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemStringFormatProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemStringFormatProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTemplate">
      <MemberSignature Language="C#" Value="public System.Windows.DataTemplate ItemTemplate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DataTemplate ItemTemplate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemTemplate As DataTemplate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DataTemplate ^ ItemTemplate { System::Windows::DataTemplate ^ get(); void set(System::Windows::DataTemplate ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemTemplate : System.Windows.DataTemplate with get, set" Usage="System.Windows.Controls.ItemsControl.ItemTemplate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DataTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект <see cref="T:System.Windows.DataTemplate" />, используемый для отображения каждого элемента.</summary>
        <value><see cref="T:System.Windows.DataTemplate" />, указывающее визуализацию объектов данных. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для указания визуализации объектов данных используется <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A>. Если <xref:System.Windows.Controls.ItemsControl> привязан к объекту коллекции и вы не предоставляете конкретные инструкции по отображению с помощью <xref:System.Windows.DataTemplate>, результирующая [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] каждого элемента представляет собой строковое представление каждого объекта в базовой коллекции.  
  
 При установке <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> на <xref:System.Windows.Controls.ItemsControl>[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] создается следующим образом (в качестве примера используется <xref:System.Windows.Controls.ListBox>):  
  
1.  Во время создания содержимого <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A> инициирует запрос на <xref:System.Windows.Controls.ItemsControl.ItemContainerGenerator%2A>, чтобы создать контейнер для каждого элемента данных. Для <xref:System.Windows.Controls.ListBox>контейнером является <xref:System.Windows.Controls.ListBoxItem>. Генератор обращается к <xref:System.Windows.Controls.ItemsControl> для подготовки контейнера.  
  
2.  В ходе подготовки предполагается копирование <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A> <xref:System.Windows.Controls.ListBox> в <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> <xref:System.Windows.Controls.ListBoxItem>.  
  
3.  Как и для всех типов <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ControlTemplate> <xref:System.Windows.Controls.ListBoxItem> содержит <xref:System.Windows.Controls.ContentPresenter>. При применении шаблона создается <xref:System.Windows.Controls.ContentPresenter>, <xref:System.Windows.Controls.ContentPresenter.ContentTemplate%2A> привязан к <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A>у <xref:System.Windows.Controls.ListBoxItem>.  
  
4.  Наконец, <xref:System.Windows.Controls.ContentPresenter> применяет этот <xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> к самому себе и создает [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  
  
 Если определено более одного <xref:System.Windows.DataTemplate> и вы хотите предоставить логику для программного выбора и применения <xref:System.Windows.DataTemplate>, используйте свойство <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A>.  
  
 <xref:System.Windows.Controls.ItemsControl> обеспечивает большую гибкость при визуальной настройке и предоставляет множество свойств стилизации и шаблонов. Используйте свойство <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> или свойство <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A>, чтобы задать стиль, влияющий на внешний вид элементов, содержащих элементы данных. Например, для <xref:System.Windows.Controls.ListBox>созданные контейнеры являются <xref:System.Windows.Controls.ListBoxItem> элементами управления. для <xref:System.Windows.Controls.ComboBox>они являются <xref:System.Windows.Controls.ComboBoxItem> элементами управления. Чтобы изменить макет элементов, используйте свойство <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A>. Если вы используете группировку в элементе управления, можно использовать свойство <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> или <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A>.  
  
 Более подробную информацию см. в разделе [Общие сведения о шаблонах данных](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="xamlAttributeUsage_ItemTemplate"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object ItemTemplate=" ResourceExtension TemplateResourceKey"/>  
```  
  
<a name="xamlValues_ItemTemplate"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *ресаурцеекстенсион*  
 Одно из следующих: [расширение разметки StaticResource](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)или [расширение разметки DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md). Если сами стили не содержат ссылки на потенциальные ссылки времени выполнения, такие как системные ресурсы или пользовательские настройки, для повышения производительности обычно рекомендуется использовать ссылку на [расширение разметки StaticResource](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) .  
  
 *темплатересаурцекэй*  
 значение строки [директивы x:Key](~/docs/framework/xaml-services/x-key-directive.md) , ссылающееся на шаблон, запрашиваемый в качестве ресурса.  
  
<a name="dependencyPropertyInfo_ItemTemplate"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ItemsControl.ItemTemplateProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 В следующем примере показано, как создать <xref:System.Windows.DataTemplate> встроенное. <xref:System.Windows.DataTemplate> указывает, что каждый элемент данных отображается в виде трех элементов <xref:System.Windows.Controls.TextBlock> в пределах <xref:System.Windows.Controls.StackPanel>. В этом примере объект данных является классом с именем `Task`. Обратите внимание, что каждый элемент <xref:System.Windows.Controls.TextBlock> в этом шаблоне привязан к свойству класса `Task`.  
  
 [!code-xaml[DataTemplatingIntro_snip#Inline](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#inline)]  
  
 Чаще всего в разделе reusables определяется <xref:System.Windows.DataTemplate>, поэтому он может быть многократно используемым объектом, как показано в следующем примере:  
  
 [!code-xaml[DataTemplatingIntro_snip#R1](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r1)]  
[!code-xaml[DataTemplatingIntro_snip#AsResource](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#asresource)]  
[!code-xaml[DataTemplatingIntro_snip#R2](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#r2)]  
  
 Теперь вы можете использовать `myTaskTemplate` в качестве ресурса, как показано в следующем примере:  
  
 [!code-xaml[DataTemplatingIntro_snip#MyTaskTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplatingIntro_snip/CSharp/Window1.xaml#mytasktemplate)]  
  
 Полный пример см. в разделе [Вводная часть примера стилизации и использования шаблонов](https://go.microsoft.com/fwlink/?LinkID=160009).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" />
        <altmember cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" />
      </Docs>
    </Member>
    <Member MemberName="ItemTemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemTemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemTemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemTemplateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemTemplateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemTemplateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemTemplateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemTemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTemplateSelector">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.DataTemplateSelector ItemTemplateSelector { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.DataTemplateSelector ItemTemplateSelector" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" />
      <MemberSignature Language="VB.NET" Value="Public Property ItemTemplateSelector As DataTemplateSelector" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::DataTemplateSelector ^ ItemTemplateSelector { System::Windows::Controls::DataTemplateSelector ^ get(); void set(System::Windows::Controls::DataTemplateSelector ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ItemTemplateSelector : System.Windows.Controls.DataTemplateSelector with get, set" Usage="System.Windows.Controls.ItemsControl.ItemTemplateSelector" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.DataTemplateSelector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает пользовательскую логику для выбора шаблона, используемого для отображения каждого элемента.</summary>
        <value>Пользовательский объект <see cref="T:System.Windows.Controls.DataTemplateSelector" /> , который предоставляет логику и возвращает <see cref="T:System.Windows.DataTemplate" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для указания визуализации объектов данных используется <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A>. Если вы определили несколько шаблонов и хотите предоставить логику для возврата шаблона, используйте это свойство. Обратите внимание, что это свойство игнорируется, если задан параметр <xref:System.Windows.Controls.ItemsControl.ItemTemplate%2A>.  
  
 <xref:System.Windows.Controls.ItemsControl> обеспечивает большую гибкость при визуальной настройке и предоставляет множество свойств стилизации и шаблонов. Используйте свойство <xref:System.Windows.Controls.ItemsControl.ItemContainerStyle%2A> или свойство <xref:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector%2A>, чтобы задать стиль, влияющий на внешний вид элементов, содержащих элементы данных. Например, для <xref:System.Windows.Controls.ListBox>созданные контейнеры являются <xref:System.Windows.Controls.ListBoxItem> элементами управления. для <xref:System.Windows.Controls.ComboBox>они являются <xref:System.Windows.Controls.ComboBoxItem> элементами управления. Чтобы изменить макет элементов, используйте свойство <xref:System.Windows.Controls.ItemsControl.ItemsPanel%2A>. Если вы используете группировку в элементе управления, можно использовать свойство <xref:System.Windows.Controls.ItemsControl.GroupStyle%2A> или <xref:System.Windows.Controls.ItemsControl.GroupStyleSelector%2A>.  
  
 Более подробную информацию см. в разделе [Общие сведения о шаблонах данных](~/docs/framework/wpf/data/data-templating-overview.md).  
  
<a name="xamlAttributeUsage_ItemTemplateSelector"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object ItemTemplateSelector="ResourceExtension SelectorResourceKey"/>  
```  
  
<a name="xamlValues_ItemTemplateSelector"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *ресаурцеекстенсион*  
 Один из следующих: `StaticResource`или `DynamicResource`. Если сами стили не содержат ссылки на потенциальные ссылки времени выполнения, такие как системные ресурсы или пользовательские настройки, для повышения производительности обычно рекомендуется `StaticResource` ссылку на стиль.  
  
 *селекторресаурцекэй*  
 `x:Key` строковое значение, ссылающееся на селектор, запрашиваемый в качестве ресурса.  
  
<a name="dependencyPropertyInfo_ItemTemplateSelector"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty>|  
|Для свойств метаданных задано значение `true`|Отсутствуют|  
  
   
  
## Examples  
 В следующем примере имя ресурса `auctionItemDataTemplateSelector` (соответствующее классу `AuctionItemDataTemplateSelector`) назначается свойству <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> <xref:System.Windows.Controls.ItemsControl>.  
  
 [!code-xaml[DataTemplateSelector#ItemTemplateSelector](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplateSelector/CSharp/Window1.xaml#itemtemplateselector)]  
  
 В следующем примере показана реализация класса `AuctionItemDataTemplateSelector` с переопределением метода <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A>:  
  
 [!code-csharp[DataTemplateSelector#DataTemplateSelector](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTemplateSelector/CSharp/AuctionItemDataTemplateSelector.cs#datatemplateselector)]
 [!code-vb[DataTemplateSelector#DataTemplateSelector](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DataTemplateSelector/visualbasic/auctionitemdatatemplateselector.vb#datatemplateselector)]  
  
 В этом случае в методе <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> класса есть логика для возврата соответствующего шаблона на основе значения свойства `SpecialFeatures` переданного объекта `item`. Возвращаемый шаблон находится в ресурсах элемента <xref:System.Windows.Window> запечатывание.  
  
 При задании свойства <xref:System.Windows.Controls.ItemsControl.ItemTemplateSelector%2A> <xref:System.Windows.Controls.ItemsControl> направляется для автоматического вызова метода <xref:System.Windows.Controls.DataTemplateSelector.SelectTemplate%2A> `AuctionItemDataTemplateSelector` для каждого из элементов в коллекции, к которой привязана <xref:System.Windows.Controls.ItemsControl>. Вызов передает элемент данных в виде объекта. Затем <xref:System.Windows.DataTemplate>, возвращаемый методом, используется для вывода этого элемента данных.  
  
 Другой пример см. в разделе [Общие сведения о шаблонах данных](~/docs/framework/wpf/data/data-templating-overview.md).  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160009">Введение в пример создания шаблонов данных</related>
      </Docs>
    </Member>
    <Member MemberName="ItemTemplateSelectorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ItemTemplateSelectorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ItemTemplateSelectorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ItemTemplateSelectorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ItemTemplateSelectorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ItemTemplateSelectorProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ItemsControl.ItemTemplateSelectorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ItemsControl.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.ItemsControl.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает перечислитель для логических дочерних объектов объекта <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <value>Перечислитель для логических дочерних объектов объекта <see cref="T:System.Windows.Controls.ItemsControl" />. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAlternationCountChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAlternationCountChanged (int oldAlternationCount, int newAlternationCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAlternationCountChanged(int32 oldAlternationCount, int32 newAlternationCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnAlternationCountChanged(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAlternationCountChanged (oldAlternationCount As Integer, newAlternationCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAlternationCountChanged(int oldAlternationCount, int newAlternationCount);" />
      <MemberSignature Language="F#" Value="abstract member OnAlternationCountChanged : int * int -&gt; unit&#xA;override this.OnAlternationCountChanged : int * int -&gt; unit" Usage="itemsControl.OnAlternationCountChanged (oldAlternationCount, newAlternationCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldAlternationCount" Type="System.Int32" />
        <Parameter Name="newAlternationCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldAlternationCount">Старое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" />.</param>
        <param name="newAlternationCount">Новое значение <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" />.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ItemsControl.AlternationCount" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayMemberPathChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayMemberPathChanged (string oldDisplayMemberPath, string newDisplayMemberPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayMemberPathChanged(string oldDisplayMemberPath, string newDisplayMemberPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnDisplayMemberPathChanged(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayMemberPathChanged (oldDisplayMemberPath As String, newDisplayMemberPath As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayMemberPathChanged(System::String ^ oldDisplayMemberPath, System::String ^ newDisplayMemberPath);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayMemberPathChanged : string * string -&gt; unit&#xA;override this.OnDisplayMemberPathChanged : string * string -&gt; unit" Usage="itemsControl.OnDisplayMemberPathChanged (oldDisplayMemberPath, newDisplayMemberPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDisplayMemberPath" Type="System.String" />
        <Parameter Name="newDisplayMemberPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldDisplayMemberPath">Старое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> .</param>
        <param name="newDisplayMemberPath">Новое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" />.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ItemsControl.DisplayMemberPath" /> .</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGroupStyleSelectorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnGroupStyleSelectorChanged (System.Windows.Controls.GroupStyleSelector oldGroupStyleSelector, System.Windows.Controls.GroupStyleSelector newGroupStyleSelector);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGroupStyleSelectorChanged(class System.Windows.Controls.GroupStyleSelector oldGroupStyleSelector, class System.Windows.Controls.GroupStyleSelector newGroupStyleSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnGroupStyleSelectorChanged(System.Windows.Controls.GroupStyleSelector,System.Windows.Controls.GroupStyleSelector)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGroupStyleSelectorChanged (oldGroupStyleSelector As GroupStyleSelector, newGroupStyleSelector As GroupStyleSelector)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGroupStyleSelectorChanged(System::Windows::Controls::GroupStyleSelector ^ oldGroupStyleSelector, System::Windows::Controls::GroupStyleSelector ^ newGroupStyleSelector);" />
      <MemberSignature Language="F#" Value="abstract member OnGroupStyleSelectorChanged : System.Windows.Controls.GroupStyleSelector * System.Windows.Controls.GroupStyleSelector -&gt; unit&#xA;override this.OnGroupStyleSelectorChanged : System.Windows.Controls.GroupStyleSelector * System.Windows.Controls.GroupStyleSelector -&gt; unit" Usage="itemsControl.OnGroupStyleSelectorChanged (oldGroupStyleSelector, newGroupStyleSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldGroupStyleSelector" Type="System.Windows.Controls.GroupStyleSelector" />
        <Parameter Name="newGroupStyleSelector" Type="System.Windows.Controls.GroupStyleSelector" />
      </Parameters>
      <Docs>
        <param name="oldGroupStyleSelector">Старое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" /> .</param>
        <param name="newGroupStyleSelector">Новое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" />.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ItemsControl.GroupStyleSelector" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemBindingGroupChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemBindingGroupChanged (System.Windows.Data.BindingGroup oldItemBindingGroup, System.Windows.Data.BindingGroup newItemBindingGroup);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemBindingGroupChanged(class System.Windows.Data.BindingGroup oldItemBindingGroup, class System.Windows.Data.BindingGroup newItemBindingGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemBindingGroupChanged(System.Windows.Data.BindingGroup,System.Windows.Data.BindingGroup)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemBindingGroupChanged (oldItemBindingGroup As BindingGroup, newItemBindingGroup As BindingGroup)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemBindingGroupChanged(System::Windows::Data::BindingGroup ^ oldItemBindingGroup, System::Windows::Data::BindingGroup ^ newItemBindingGroup);" />
      <MemberSignature Language="F#" Value="abstract member OnItemBindingGroupChanged : System.Windows.Data.BindingGroup * System.Windows.Data.BindingGroup -&gt; unit&#xA;override this.OnItemBindingGroupChanged : System.Windows.Data.BindingGroup * System.Windows.Data.BindingGroup -&gt; unit" Usage="itemsControl.OnItemBindingGroupChanged (oldItemBindingGroup, newItemBindingGroup)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemBindingGroup" Type="System.Windows.Data.BindingGroup" />
        <Parameter Name="newItemBindingGroup" Type="System.Windows.Data.BindingGroup" />
      </Parameters>
      <Docs>
        <param name="oldItemBindingGroup">Старое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />.</param>
        <param name="newItemBindingGroup">Новое значение объекта <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemBindingGroup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemContainerStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemContainerStyleChanged (System.Windows.Style oldItemContainerStyle, System.Windows.Style newItemContainerStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemContainerStyleChanged(class System.Windows.Style oldItemContainerStyle, class System.Windows.Style newItemContainerStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemContainerStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemContainerStyleChanged (oldItemContainerStyle As Style, newItemContainerStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemContainerStyleChanged(System::Windows::Style ^ oldItemContainerStyle, System::Windows::Style ^ newItemContainerStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnItemContainerStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnItemContainerStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="itemsControl.OnItemContainerStyleChanged (oldItemContainerStyle, newItemContainerStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemContainerStyle" Type="System.Windows.Style" />
        <Parameter Name="newItemContainerStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldItemContainerStyle">Старое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> .</param>
        <param name="newItemContainerStyle">Новое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" />.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> .</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemContainerStyleSelectorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemContainerStyleSelectorChanged (System.Windows.Controls.StyleSelector oldItemContainerStyleSelector, System.Windows.Controls.StyleSelector newItemContainerStyleSelector);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemContainerStyleSelectorChanged(class System.Windows.Controls.StyleSelector oldItemContainerStyleSelector, class System.Windows.Controls.StyleSelector newItemContainerStyleSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemContainerStyleSelectorChanged(System.Windows.Controls.StyleSelector,System.Windows.Controls.StyleSelector)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemContainerStyleSelectorChanged (oldItemContainerStyleSelector As StyleSelector, newItemContainerStyleSelector As StyleSelector)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemContainerStyleSelectorChanged(System::Windows::Controls::StyleSelector ^ oldItemContainerStyleSelector, System::Windows::Controls::StyleSelector ^ newItemContainerStyleSelector);" />
      <MemberSignature Language="F#" Value="abstract member OnItemContainerStyleSelectorChanged : System.Windows.Controls.StyleSelector * System.Windows.Controls.StyleSelector -&gt; unit&#xA;override this.OnItemContainerStyleSelectorChanged : System.Windows.Controls.StyleSelector * System.Windows.Controls.StyleSelector -&gt; unit" Usage="itemsControl.OnItemContainerStyleSelectorChanged (oldItemContainerStyleSelector, newItemContainerStyleSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemContainerStyleSelector" Type="System.Windows.Controls.StyleSelector" />
        <Parameter Name="newItemContainerStyleSelector" Type="System.Windows.Controls.StyleSelector" />
      </Parameters>
      <Docs>
        <param name="oldItemContainerStyleSelector">Старое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> .</param>
        <param name="newItemContainerStyleSelector">Новое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" />.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemsChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemsChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemsChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemsChanged (e As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemsChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnItemsChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit&#xA;override this.OnItemsChanged : System.Collections.Specialized.NotifyCollectionChangedEventArgs -&gt; unit" Usage="itemsControl.OnItemsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Сведения об изменении.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ItemsControl.Items" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsPanelChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemsPanelChanged (System.Windows.Controls.ItemsPanelTemplate oldItemsPanel, System.Windows.Controls.ItemsPanelTemplate newItemsPanel);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemsPanelChanged(class System.Windows.Controls.ItemsPanelTemplate oldItemsPanel, class System.Windows.Controls.ItemsPanelTemplate newItemsPanel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemsPanelChanged(System.Windows.Controls.ItemsPanelTemplate,System.Windows.Controls.ItemsPanelTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemsPanelChanged (oldItemsPanel As ItemsPanelTemplate, newItemsPanel As ItemsPanelTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemsPanelChanged(System::Windows::Controls::ItemsPanelTemplate ^ oldItemsPanel, System::Windows::Controls::ItemsPanelTemplate ^ newItemsPanel);" />
      <MemberSignature Language="F#" Value="abstract member OnItemsPanelChanged : System.Windows.Controls.ItemsPanelTemplate * System.Windows.Controls.ItemsPanelTemplate -&gt; unit&#xA;override this.OnItemsPanelChanged : System.Windows.Controls.ItemsPanelTemplate * System.Windows.Controls.ItemsPanelTemplate -&gt; unit" Usage="itemsControl.OnItemsPanelChanged (oldItemsPanel, newItemsPanel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemsPanel" Type="System.Windows.Controls.ItemsPanelTemplate" />
        <Parameter Name="newItemsPanel" Type="System.Windows.Controls.ItemsPanelTemplate" />
      </Parameters>
      <Docs>
        <param name="oldItemsPanel">Старое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> .</param>
        <param name="newItemsPanel">Новое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" />.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemsPanel" /> .</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemsSourceChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemsSourceChanged (System.Collections.IEnumerable oldValue, System.Collections.IEnumerable newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemsSourceChanged(class System.Collections.IEnumerable oldValue, class System.Collections.IEnumerable newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemsSourceChanged(System.Collections.IEnumerable,System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemsSourceChanged (oldValue As IEnumerable, newValue As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemsSourceChanged(System::Collections::IEnumerable ^ oldValue, System::Collections::IEnumerable ^ newValue);" />
      <MemberSignature Language="F#" Value="abstract member OnItemsSourceChanged : System.Collections.IEnumerable * System.Collections.IEnumerable -&gt; unit&#xA;override this.OnItemsSourceChanged : System.Collections.IEnumerable * System.Collections.IEnumerable -&gt; unit" Usage="itemsControl.OnItemsSourceChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Collections.IEnumerable" />
        <Parameter Name="newValue" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="oldValue">Старое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" /> .</param>
        <param name="newValue">Новое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" />.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemsSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemStringFormatChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemStringFormatChanged (string oldItemStringFormat, string newItemStringFormat);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemStringFormatChanged(string oldItemStringFormat, string newItemStringFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemStringFormatChanged(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemStringFormatChanged (oldItemStringFormat As String, newItemStringFormat As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemStringFormatChanged(System::String ^ oldItemStringFormat, System::String ^ newItemStringFormat);" />
      <MemberSignature Language="F#" Value="abstract member OnItemStringFormatChanged : string * string -&gt; unit&#xA;override this.OnItemStringFormatChanged : string * string -&gt; unit" Usage="itemsControl.OnItemStringFormatChanged (oldItemStringFormat, newItemStringFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemStringFormat" Type="System.String" />
        <Parameter Name="newItemStringFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldItemStringFormat">Старое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" />.</param>
        <param name="newItemStringFormat">Новое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" /> .</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemStringFormat" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemTemplateChanged (System.Windows.DataTemplate oldItemTemplate, System.Windows.DataTemplate newItemTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemTemplateChanged(class System.Windows.DataTemplate oldItemTemplate, class System.Windows.DataTemplate newItemTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemTemplateChanged(System.Windows.DataTemplate,System.Windows.DataTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemTemplateChanged (oldItemTemplate As DataTemplate, newItemTemplate As DataTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemTemplateChanged(System::Windows::DataTemplate ^ oldItemTemplate, System::Windows::DataTemplate ^ newItemTemplate);" />
      <MemberSignature Language="F#" Value="abstract member OnItemTemplateChanged : System.Windows.DataTemplate * System.Windows.DataTemplate -&gt; unit&#xA;override this.OnItemTemplateChanged : System.Windows.DataTemplate * System.Windows.DataTemplate -&gt; unit" Usage="itemsControl.OnItemTemplateChanged (oldItemTemplate, newItemTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemTemplate" Type="System.Windows.DataTemplate" />
        <Parameter Name="newItemTemplate" Type="System.Windows.DataTemplate" />
      </Parameters>
      <Docs>
        <param name="oldItemTemplate">Старое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" />.</param>
        <param name="newItemTemplate">Новое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" />.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnItemTemplateSelectorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemTemplateSelectorChanged (System.Windows.Controls.DataTemplateSelector oldItemTemplateSelector, System.Windows.Controls.DataTemplateSelector newItemTemplateSelector);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemTemplateSelectorChanged(class System.Windows.Controls.DataTemplateSelector oldItemTemplateSelector, class System.Windows.Controls.DataTemplateSelector newItemTemplateSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnItemTemplateSelectorChanged(System.Windows.Controls.DataTemplateSelector,System.Windows.Controls.DataTemplateSelector)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemTemplateSelectorChanged (oldItemTemplateSelector As DataTemplateSelector, newItemTemplateSelector As DataTemplateSelector)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemTemplateSelectorChanged(System::Windows::Controls::DataTemplateSelector ^ oldItemTemplateSelector, System::Windows::Controls::DataTemplateSelector ^ newItemTemplateSelector);" />
      <MemberSignature Language="F#" Value="abstract member OnItemTemplateSelectorChanged : System.Windows.Controls.DataTemplateSelector * System.Windows.Controls.DataTemplateSelector -&gt; unit&#xA;override this.OnItemTemplateSelectorChanged : System.Windows.Controls.DataTemplateSelector * System.Windows.Controls.DataTemplateSelector -&gt; unit" Usage="itemsControl.OnItemTemplateSelectorChanged (oldItemTemplateSelector, newItemTemplateSelector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldItemTemplateSelector" Type="System.Windows.Controls.DataTemplateSelector" />
        <Parameter Name="newItemTemplateSelector" Type="System.Windows.Controls.DataTemplateSelector" />
      </Parameters>
      <Docs>
        <param name="oldItemTemplateSelector">Старое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" /> .</param>
        <param name="newItemTemplateSelector">Новое значение свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" />.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemTemplateSelector" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="itemsControl.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Сведения о событии.</param>
        <summary>Вызывается при получении события <see cref="E:System.Windows.UIElement.KeyDown" /> .</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected override void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="itemsControl.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Сведения о событии.</param>
        <summary>Вызывается при получении события <see cref="E:System.Windows.UIElement.TextInput" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected virtual void PrepareContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void PrepareContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub PrepareContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void PrepareContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member PrepareContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit&#xA;override this.PrepareContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="itemsControl.PrepareContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, используемый для отображения указанного элемента.</param>
        <param name="item">Указанный элемент.</param>
        <summary>Подготавливает заданный элемент для отображения указанного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подготовка элемента может привести к применению стилей, настройке привязок и т. д.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldApplyItemContainerStyle">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldApplyItemContainerStyle (System.Windows.DependencyObject container, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldApplyItemContainerStyle(class System.Windows.DependencyObject container, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ShouldApplyItemContainerStyle(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldApplyItemContainerStyle (container As DependencyObject, item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldApplyItemContainerStyle(System::Windows::DependencyObject ^ container, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="abstract member ShouldApplyItemContainerStyle : System.Windows.DependencyObject * obj -&gt; bool&#xA;override this.ShouldApplyItemContainerStyle : System.Windows.DependencyObject * obj -&gt; bool" Usage="itemsControl.ShouldApplyItemContainerStyle (container, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="container">Элемент контейнера.</param>
        <param name="item">Интересующий элемент.</param>
        <summary>Возвращает значение, указывающее применение стиля из свойства <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyle" /> или <see cref="P:System.Windows.Controls.ItemsControl.ItemContainerStyleSelector" /> к элементу контейнера указанного элемента.</summary>
        <returns>Всегда <see langword="true" /> для базовой реализации.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeGroupStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeGroupStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeGroupStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ShouldSerializeGroupStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeGroupStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeGroupStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeGroupStyle : unit -&gt; bool" Usage="itemsControl.ShouldSerializeGroupStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, должны ли процессы сериализации сериализовать действующее значение свойства <see cref="P:System.Windows.Controls.ItemsControl.GroupStyle" />.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.Controls.ItemsControl.GroupStyle" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeItems">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeItems ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ShouldSerializeItems" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeItems () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeItems();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeItems : unit -&gt; bool" Usage="itemsControl.ShouldSerializeItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее должны ли процессы сериализации сериализовать эффективное значение свойства <see cref="P:System.Windows.Controls.ItemsControl.Items" />.</summary>
        <returns>Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.Controls.ItemsControl.Items" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.Clear">
      <MemberSignature Language="C#" Value="void IContainItemStorage.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IContainItemStorage.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.Clear() = System::Windows::Controls::Primitives::IContainItemStorage::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все связи свойств.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue">
      <MemberSignature Language="C#" Value="void IContainItemStorage.ClearItemValue (object item, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(object item, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#ClearItemValue(System.Object,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Sub ClearItemValue (item As Object, dp As DependencyProperty) Implements IContainItemStorage.ClearItemValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(System::Object ^ item, System::Windows::DependencyProperty ^ dp) = System::Windows::Controls::Primitives::IContainItemStorage::ClearItemValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(System.Object,System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">Связанный элемент.</param>
        <param name="dp">Связанное свойство.</param>
        <summary>Удаляет связь между указанным элементом и свойством.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.ClearValue">
      <MemberSignature Language="C#" Value="void IContainItemStorage.ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Sub ClearValue (dp As DependencyProperty) Implements IContainItemStorage.ClearValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(System::Windows::DependencyProperty ^ dp) = System::Windows::Controls::Primitives::IContainItemStorage::ClearValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="dp">Удаляемое свойство.</param>
        <summary>Удаляет указанное свойство из всех списков свойств.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue">
      <MemberSignature Language="C#" Value="object IContainItemStorage.ReadItemValue (object item, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(object item, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#ReadItemValue(System.Object,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Function ReadItemValue (item As Object, dp As DependencyProperty) As Object Implements IContainItemStorage.ReadItemValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(System::Object ^ item, System::Windows::DependencyProperty ^ dp) = System::Windows::Controls::Primitives::IContainItemStorage::ReadItemValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(System.Object,System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">Элемент, который содержит связанное с ним указанное свойство.</param>
        <param name="dp">Свойство, значение которого требуется вернуть.</param>
        <summary>Возвращает значение указанного свойства, связанного с указанным элементом.</summary>
        <returns>Значение указанного свойства, связанного с указанным элементом.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue">
      <MemberSignature Language="C#" Value="void IContainItemStorage.StoreItemValue (object item, System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(object item, class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Controls#Primitives#IContainItemStorage#StoreItemValue(System.Object,System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub StoreItemValue (item As Object, dp As DependencyProperty, value As Object) Implements IContainItemStorage.StoreItemValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(System::Object ^ item, System::Windows::DependencyProperty ^ dp, System::Object ^ value) = System::Windows::Controls::Primitives::IContainItemStorage::StoreItemValue;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(System.Object,System.Windows.DependencyProperty,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">Элемент, с которым требуется связать значение и свойство.</param>
        <param name="dp">Свойство, связанное с заданным элементом.</param>
        <param name="value">Значение связанного свойства.</param>
        <summary>Сохраняет указанное свойство и значение и связывает их с указанным элементом.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект для добавления в качестве дочернего объекта.</param>
        <summary>Этот член поддерживает инфраструктуру [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] и не предназначен для непосредственного использования из кода.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Добавляемый текст.</param>
        <summary>Этот член поддерживает инфраструктуру [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] и не предназначен для непосредственного использования из кода.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ItemsControl.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="itemsControl.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Предоставляет строковое представление объекта <see cref="T:System.Windows.Controls.ItemsControl" />.</summary>
        <returns>Строковое представление объекта.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
