<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0916cb8d2d62ec042e4b67e3db168ea990979805" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75015161" /></Metadata><TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет объекты <see cref="T:Microsoft.Win32.RegistryKey" />, представляющие корневые разделы в реестре Windows, и методы <see langword="static" /> для доступа к парам "раздел-значение".</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс предоставляет набор стандартных корневых ключей, которые находятся в реестре на компьютерах под Windows. Реестр — это средство хранения сведений о приложениях, пользователях и системных параметрах по умолчанию. Например, приложения могут использовать реестр для хранения сведений, которые необходимо сохранить после закрытия приложения, и получить доступ к той же информации при повторной загрузке приложения. Например, можно сохранять настройки цвета, расположения экрана или размер окна. Эти данные можно контролировать для каждого пользователя, сохраняя их в другом месте реестра.  
  
 Экземпляры базового или корневого <xref:Microsoft.Win32.RegistryKey>, предоставляемые классом `Registry`, обделяют базовый механизм хранения подразделов и значений в реестре. Все ключи доступны только для чтения, так как реестр зависит от их существования. Ключи, предоставляемые `Registry`:  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 Хранит сведения о предпочтениях пользователя.  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 Хранит сведения о конфигурации для локального компьютера.  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 Хранит сведения о типах (и классах) и их свойствах.  
  
 <xref:Microsoft.Win32.Registry.Users>  
 Хранит сведения о пользовательской конфигурации по умолчанию.  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 Хранит сведения о производительности компонентов программного обеспечения.  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 Хранит сведения об оборудовании, не относящемся к пользователю.  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 Хранит динамические данные.  
  
 Определив корневой ключ, в котором необходимо хранить или извлекать сведения из реестра, можно использовать класс <xref:Microsoft.Win32.RegistryKey> для добавления и удаления подразделов и управления значениями для данного ключа.  
  
 Аппаратные устройства могут автоматически размещать данные в реестре с помощью интерфейса Plug and Play. Программное обеспечение для установки драйверов устройств может размещать сведения в реестре, записывая их в стандартные API.  
  
## <a name="static-methods-for-getting-and-setting-values"></a>Статические методы для получения и установки значений  
 В .NET Framework версии 2,0 класс <xref:Microsoft.Win32.Registry> также содержит `static`<xref:Microsoft.Win32.Registry.GetValue%2A> и <xref:Microsoft.Win32.Registry.SetValue%2A> методы для установки и получения значений из разделов реестра. Эти методы открывают и закрывают разделы реестра при каждом использовании, поэтому они не выполняют, а также аналогичные методы в <xref:Microsoft.Win32.RegistryKey> классе при доступе к большому количеству значений.  
  
 Класс <xref:Microsoft.Win32.RegistryKey> также предоставляет методы, позволяющие задать параметры безопасности управления доступом Windows для разделов реестра, чтобы проверить тип данных значения перед их получением и удалить ключи.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. В первом примере показаны корневые ключи, а во втором примере демонстрируются методы `static`<xref:Microsoft.Win32.Registry.GetValue%2A> и <xref:Microsoft.Win32.Registry.SetValue%2A>.  
  
 Пример 1  
  
 В следующем примере кода показано, как получить подразделы ключа HKEY_USERS и распечатать их имена на экране. Используйте метод <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>, чтобы создать экземпляр определенного подраздела, представляющего интерес. Затем можно использовать другие операции в `RegistryKey` для управления этим ключом.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 Пример 2  
  
 Следующий пример кода сохраняет значения нескольких типов данных в примере ключа, создавая ключ, как это делает, а затем извлекает и отображает значения. В примере показано хранение и извлечение пары "имя-значение" по умолчанию (без имени) и использование `defaultValue`, если пара "имя-значение" не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет типы (или классы) документов и свойства, связанные с этими типами. Это поле считывает базовый раздел реестра Windows HKEY_CLASSES_ROOT.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как обычные приложения, так и приложения OLE используют данные, хранящиеся в этом разделе. Этот ключ также обеспечивает обратную совместимость с базой данных регистрации Windows 3,1, сохраняя сведения для поддержки DDE и OLE. Средства просмотра файлов и расширения пользовательского интерфейса хранят идентификаторы классов OLE в этом ключе, а серверы обработки регистрируются в этом разделе.  
  
   
  
## Examples  
 В следующем примере показано, как получить подразделы этого раздела и выводит на экран их имена. Используйте метод <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>, чтобы создать экземпляр определенного подраздела, представляющего интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления этим ключом.  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит сведения о конфигурации, относящиеся к оборудованию, не связанному с конкретным пользователем. Это поле считывает базовый раздел реестра Windows HKEY_CURRENT_CONFIG.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот элемент сопоставляется с подразделом в <xref:Microsoft.Win32.Registry.LocalMachine>.  
  
 Примером использования этого члена является приложение, в котором хранится другое имя сервера для своих данных в зависимости от того, подключена ли система к сети.  
  
   
  
## Examples  
 В следующем примере показано, как получить подразделы этого раздела и выводит на экран их имена. Используйте метод <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>, чтобы создать экземпляр определенного подраздела, представляющего интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления этим ключом.  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит сведения о текущих пользовательских параметрах. Это поле считывает базовый раздел реестра Windows HKEY_CURRENT_USER.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сведения, хранящиеся в этом разделе, включают параметры переменных среды и данные о группах программ, цветах, принтерах, сетевых подключениях и предпочтениях приложений. Этот ключ упрощает установку параметров текущего пользователя. В этом разделе поставщики программного обеспечения хранят текущие предпочтения пользователя для использования в своих приложениях. Корпорация Майкрософт, например, создает HKEY_CURRENT_USER ключ \Софтваре\микрософт для используемых приложений, при этом каждое приложение создается в собственном подразделе в разделе Microsoft Key.  
  
   
  
## Examples  
 В следующем примере показано, как получить подразделы этого раздела и выводит на экран их имена. Используйте метод <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>, чтобы создать экземпляр определенного подраздела, представляющего интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления этим ключом.  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит динамические данные реестра. Это поле считывает базовый раздел реестра Windows HKEY_DYN_DATA.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реестр Windows 98/Windows Me поддерживает как статические данные (которые хранятся на диске в реестре), так и динамические данные (которые часто меняются, например статистика о производительности). Эта область динамических данных — это механизм, позволяющий драйверам виртуальных устройств (VxD) предоставлять данные в режиме реального времени приложениям Win32, которые могут выполняться удаленно, а также локально. Он также позволяет системному монитору предоставлять статистику производительности для удаленных систем Windows 98/Windows Me.  
  
 VxD не ограничиваются данными производительности. Они могут предоставить любые данные, которые они хотят передать из кольца 0 в кольцо 3, без монопольного использования ЦП. Реестр поддерживает динамические данные, сохраняя указатель на функцию, которая возвращает значение (или несколько значений). Когда вызов реестра запрашивает значения, связанные с динамическим ключом, вызывается эта функция для возврата желаемого значения или значений.  
  
> [!NOTE]
>  Динамические ключи появились в Microsoft Windows 95 для управления динамическими данными реестра. Они поддерживаются только в Windows 98 и Windows Me.  
  
   
  
## Examples  
 В следующем примере показано, как получить подразделы этого раздела и выводит на экран их имена. Используйте метод <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>, чтобы создать экземпляр определенного подраздела, представляющего интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления этим ключом. Обратите внимание, что этот пример может не возвращать результатов, так как динамические данные могут быть недоступны или вы не работаете с Windows 98/ME. Использование этого ключа может вызвать ошибку в других системах.  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Операционная система не поддерживает платформу динамических данных, то есть она не может быть Windows 98, Windows 98 Second Edition или Windows Millennium Edition (Windows Me).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">Полный путь к разделу реестра, начинающийся с правильного корневого раздела реестра, такого как HKEY_CURRENT_USER.</param>
        <param name="valueName">Имя в паре "имя-значение".</param>
        <param name="defaultValue">Возвращаемое значение, если параметр <paramref name="valueName" /> не существует.</param>
        <summary>Извлекает значение, связанное с указанным именем, в указанном разделе реестра. Если имя не найдено в указанном разделе, возвращает предоставленное значение по умолчанию или значение <see langword="null" />, если указанный раздел не существует.</summary>
        <returns>Значение <see langword="null" />, если вложенный раздел, заданный параметром <paramref name="keyName" />, не существует; в противном случае — значение, связанное с параметром <paramref name="valueName" />, или <paramref name="defaultValue" />, если значение параметра <paramref name="valueName" /> не найдено.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строка `valueName` не учитывает регистр.  
  
> [!NOTE]
>  Раздел реестра может содержать одно значение, не связанное ни с одним именем. Если это неименованное значение отображается в редакторе реестра, вместо имени отображается строка "(по умолчанию)". Чтобы получить это безымянное значение, укажите либо `null`, либо пустую строку ("") для `valueName`.  
  
 Допустимые корневые имена: HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG и HKEY_DYN_DATA. Например, в Visual Basic строка "HKEY_CURRENT_USER \Митесткэй" получает доступ к парам "ключ-значение" для подраздела "Митесткэй" в корневом HKEY_CURRENT_USER.  
  
 Когда метод <xref:Microsoft.Win32.RegistryKey.GetValue%2A> получает расширяемые строковые значения (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), он расширяет строки среды, используя данные из локальной среды. Если значение, содержащее расширяемые ссылки на переменные среды, сохранено как строка (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>), а не как расширяемая строка (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), <xref:Microsoft.Win32.RegistryKey.GetValue%2A> не расширяет ее. Можно развернуть такую строку после получения, вызвав метод <xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Рекомендуемый способ извлечения данных из HKEY_PERFORMANCE_DATA — использовать класс <xref:System.Diagnostics.PerformanceCounter>, а не метод <xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType>.  
  
 Методы <xref:Microsoft.Win32.Registry.GetValue%2A> и <xref:Microsoft.Win32.Registry.SetValue%2A> открывают и закрывают разделы реестра при каждом использовании, поэтому они не выполняются, а также методы класса <xref:Microsoft.Win32.RegistryKey> при доступе к большому количеству значений.  
  
 <xref:Microsoft.Win32.RegistryKey> также предоставляет методы, позволяющие добавить список управления доступом (ACL) к разделу реестра, чтобы проверить тип данных значения перед его получением и удалить ключи.  
  
   
  
## Examples  
 Следующий пример кода сохраняет значения нескольких типов данных в примере ключа, создавая ключ, как это делает, а затем извлекает и отображает значения. В примере показано хранение и извлечение пары "имя-значение" по умолчанию (без имени) и использование `defaultValue`, если пара "имя-значение" не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют разрешения, необходимые для чтения из раздела реестра.</exception>
        <exception cref="T:System.IO.IOException">Раздел <see cref="T:Microsoft.Win32.RegistryKey" />, содержащий заданное значение, был помечен для удаления.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="keyName" /> не начинается с правильного корневого раздела реестра.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">для чтения из реестра. Связанное перечисление: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для чтения раздела реестра типа REG_EXPAND_SZ. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит данные о конфигурации для локального компьютера. Это поле считывает базовый раздел реестра Windows HKEY_LOCAL_MACHINE.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` содержит пять ключей:  
  
 Оборудование  
 Описывает физическое оборудование компьютера, способ, которым драйверы устройств используют это оборудование, а также сопоставления и связанные данные, связывающие драйверы режима ядра с кодом пользовательского режима. Все данные в этом ключе создаются заново при каждом запуске системы. Подраздел Description описывает фактическое оборудование компьютера. Подраздел Девицемап содержит различные данные в форматах, характерных для определенных классов драйверов. Подраздел Ресаурцемап описывает, какие драйверы устройств заявляют, какие аппаратные ресурсы. Программа диагностики Windows NT (Винмсдп. exe) может сообщать о ее содержимом в удобной для чтения форме.  
  
 SAM  
 База данных служб каталогов сведений о безопасности для учетных записей пользователей и групп, а также для доменов в Windows 2000 Server (SAM является диспетчером учетных записей безопасности, называемым базой данных служб каталогов).  
  
 Безопасность  
 Содержит локальную политику безопасности, например специальные права пользователя. Этот ключ используется только подсистемой безопасности Windows 2000.  
  
 Программное обеспечение  
 База данных программного обеспечения для компьютера. Этот раздел содержит данные о программном обеспечении, установленном на локальном компьютере, а также различные элементы различных данных конфигурации.  
  
 Система  
 Управляет запуском системы, загрузкой драйверов устройств, службами Windows 2000 и поведением операционной системы.  
  
 По соглашению, если аналогичные данные существуют в разделе <xref:Microsoft.Win32.Registry.CurrentUser> и в <xref:Microsoft.Win32.Registry.LocalMachine>, то данные в <xref:Microsoft.Win32.Registry.CurrentUser> имеют приоритет. Однако значения в этом ключе также могут расширять (а не заменить) данные в Registry. LocalMachine. Кроме того, некоторые элементы (например, записи загрузки драйвера устройства) не имеют смысла, если они происходят вне Registry. LocalMachine.  
  
   
  
## Examples  
 В следующем примере показано, как получить подразделы этого раздела и выводит на экран их имена. Используйте метод <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>, чтобы создать экземпляр определенного подраздела, представляющего интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления этим ключом.  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит сведения о производительности для компонентов программного обеспечения. Это поле считывает базовый раздел реестра Windows HKEY_PERFORMANCE_DATA.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый программный компонент создает ключи для своих объектов, счетчики при установке и записывает данные счетчика во время выполнения. Доступ к этим данным можно получить так же, как к любым другим данным реестра, с помощью функций <xref:Microsoft.Win32.RegistryKey>.  
  
 Несмотря на то, что для получения данных о производительности используется реестр, данные не хранятся в базе данных реестра. Вместо этого доступ к реестру с помощью этого ключа приводит к тому, что система соберет данные из соответствующих диспетчеров системных объектов.  
  
 Чтобы получить данные о производительности из локальной системы, используйте метод <xref:Microsoft.Win32.RegistryKey.GetValue%2A> с ключом Registry. PerformanceData. Первый вызов открывает ключ (вам не нужно явно открывать этот ключ). Однако не забудьте использовать метод <xref:Microsoft.Win32.RegistryKey.Close%2A>, чтобы закрыть маркер ключа по завершении получения данных о производительности. Пользователь не может установить или удалить программный компонент, пока используются его данные о производительности.  
  
 Для получения данных о производительности из удаленной системы необходимо использовать метод <xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A> с именем компьютера удаленной системы и ключом реестра. PerformanceData. Этот вызов извлекает ключ, представляющий данные о производительности для удаленной системы. Чтобы получить данные, вызовите <xref:Microsoft.Win32.RegistryKey.GetValue%2A> с помощью этого ключа, а не ключа Registry. PerformanceData.  
  
> [!NOTE]
>  В Windows Server 2003 пользователь должен по крайней мере принадлежать к группе пользователей системного монитора, чтобы получить доступ к подразделам этого базового ключа.  
  
   
  
## Examples  
 В следующем примере показано, как получить подразделы этого раздела и выводит на экран их имена. Используйте метод <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>, чтобы создать экземпляр определенного подраздела, представляющего интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления этим ключом. Обратите внимание, что этот пример часто не возвращает результатов, так как могут отсутствовать данные о производительности.  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает значение пары "имя-значение" в разделе реестра.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример кода сохраняет значения нескольких типов данных в примере ключа, создавая ключ, как это делает, а затем извлекает и отображает значения. В примере показано хранение и извлечение пары "имя-значение" по умолчанию (без имени) и использование `defaultValue`, если пара "имя-значение" не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">Полный путь к разделу реестра, начинающийся с правильного корневого раздела реестра, такого как HKEY_CURRENT_USER.</param>
        <param name="valueName">Имя в паре "имя-значение".</param>
        <param name="value">Сохраняемое значение.</param>
        <summary>Задает указанное значение пары "имя-значение" для указанного раздела реестра. Если указанный раздел не существует, он будет создан.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]параметр `valueName` больше не ограничивается длиной 255 символов. Однако параметр `keyName` сохраняет ограничение в 255 символов.  
  
 Так как многие значения могут храниться в каждом ключе реестра, необходимо использовать параметр `valueName`, чтобы указать конкретное значение, которое необходимо задать.  
  
> [!NOTE]
>  Раздел реестра может содержать одно значение, не связанное ни с одним именем. Если это неименованное значение отображается в редакторе реестра, вместо имени отображается строка "(по умолчанию)". Чтобы задать это безымянное значение, укажите либо `null`, либо пустую строку ("") для `valueName`.  
  
 Если `valueName` не существует в ключе, он создается, а связанное значение устанавливается в `value`.  
  
 Если `keyName` указывает, что подраздел не существует, подраздел создается в указанном корне. Например, в Visual Basic строка "HKEY_CURRENT_USER \Митесткэй" создает подраздел "Митесткэй" в корневом HKEY_CURRENT_USER. Строка "HKEY_CURRENT_USER \MyTestKey\Key2\Key3" создает вложенные подразделы "Митесткэй", "MyTestKey\Key2" и "MyTestKey\Key2\Key3".  
  
 Допустимые корневые имена включают HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG и HKEY_DYN_DATA.  
  
> [!NOTE]
>  Метод <xref:Microsoft.Win32.Registry.SetValue%2A> открывает раздел реестра, устанавливает значение и закрывает ключ каждый раз, когда он вызывается. Если необходимо изменить большое количество значений, метод <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> может обеспечить лучшую производительность. Класс <xref:Microsoft.Win32.RegistryKey> также предоставляет методы, позволяющие добавить список управления доступом (ACL) к разделу реестра, чтобы проверить тип данных значения перед его получением и удалить ключи.  
  
 Эта перегрузка <xref:Microsoft.Win32.Registry.SetValue%2A> сохраняет 64-разрядные целые числа в виде строк (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>). Чтобы хранить 64-разрядные числа в виде <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType> значений, используйте перегрузку метода <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>.  
  
 Эта перегрузка <xref:Microsoft.Win32.Registry.SetValue%2A> сохраняет все строковые значения как объекты <xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>, даже если они содержат расширяемые ссылки на переменные среды. Чтобы сохранить строковые значения в виде расширяемых строк (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>), используйте перегрузку метода <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>.  
  
 Эта перегрузка эквивалентна вызову перегрузки метода <xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29> с <xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>.  
  
> [!NOTE]
>  В Windows 98 и Windows Millennium Edition (Windows Me) Реестр не является Юникодом, а не все символы Юникода допустимы для всех кодовых страниц. Символ Юникода, недопустимый для текущей кодовой страницы, заменяется лучшим доступным совпадением. Исключение не возникает.  
  
   
  
## Examples  
 Следующий пример кода сохраняет значения нескольких типов данных в примере ключа, создавая ключ, как это делает, а затем извлекает и отображает значения. В примере показано хранение и извлечение пары "имя-значение" по умолчанию (без имени) и использование `defaultValue`, если пара "имя-значение" не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="keyName" /> не начинается с правильного корневого раздела реестра.  
  
- или - 
 Значение параметра <paramref name="keyName" /> длиннее максимально допустимой длины (255 знаков).</exception>
        <exception cref="T:System.UnauthorizedAccessException">Раздел <see cref="T:Microsoft.Win32.RegistryKey" /> является разделом только для чтения и запись в него невозможна, например, если это узел корневого уровня.</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют разрешения, необходимые для изменения разделов реестра.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">для изменения указанного раздела реестра, если он существует, или для создания раздела реестра, если он еще не существует. Связанные перечисления: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">Полный путь к разделу реестра, начинающийся с правильного корневого раздела реестра, такого как HKEY_CURRENT_USER.</param>
        <param name="valueName">Имя в паре "имя-значение".</param>
        <param name="value">Сохраняемое значение.</param>
        <param name="valueKind">Тип данных реестра, используемый при сохранении данных.</param>
        <summary>Задает пару "имя-значение" для указанного раздела реестра, используя указанный тип данных реестра. Если указанный раздел не существует, он будет создан.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]параметр `valueName` больше не ограничивается длиной 255 символов. Однако в `keyName` параметре остается ограничение в 255 символов.  
  
 Так как многие значения могут храниться в каждом ключе реестра, необходимо использовать параметр `valueName`, чтобы указать конкретное значение, которое необходимо задать.  
  
> [!NOTE]
>  Раздел реестра может содержать одно значение, не связанное ни с одним именем. Если это неименованное значение отображается в редакторе реестра, вместо имени отображается строка "(по умолчанию)". Чтобы задать это безымянное значение, укажите либо `null`, либо пустую строку ("") для `valueName`.  
  
 Если `valueName` не существует в ключе, он создается, а связанное значение устанавливается в `value`.  
  
 Если `keyName` указывает, что подраздел не существует, подраздел создается в указанном корне. Например, в Visual Basic строка "HKEY_CURRENT_USER \Митесткэй" создает подраздел "Митесткэй" в корневом HKEY_CURRENT_USER. Строка "HKEY_CURRENT_USER \MyTestKey\Key2\Key3" создает вложенные подразделы "Митесткэй", "MyTestKey\Key2" и "MyTestKey\Key2\Key3".  
  
 Допустимые корневые имена включают HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG и HKEY_DYN_DATA.  
  
> [!NOTE]
>  Метод <xref:Microsoft.Win32.Registry.SetValue%2A> открывает раздел реестра, устанавливает значение и закрывает ключ каждый раз, когда он вызывается. Если необходимо изменить большое количество значений, метод <xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType> может обеспечить лучшую производительность. Класс <xref:Microsoft.Win32.RegistryKey> также предоставляет методы, позволяющие добавить список управления доступом (ACL) к разделу реестра, чтобы проверить тип данных значения перед его получением и удалить ключи.  
  
 Если тип указанного `value` не соответствует указанному `valueKind`и данные не могут быть преобразованы, выдается <xref:System.ArgumentException>. Например, можно сохранить <xref:System.Int64?displayProperty=nameWithType> как <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>, но только в том случае, если его значение меньше максимального значения <xref:System.Int32?displayProperty=nameWithType>. Нельзя хранить одно строковое значение как <xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Если упакованные значения передаются для <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType> или <xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>, преобразование выполняется с использованием инвариантного языка и региональных параметров.  
  
> [!NOTE]
>  В Windows 98 и Windows Millennium Edition (Windows Me) Реестр не является Юникодом, а не все символы Юникода допустимы для всех кодовых страниц. Символ Юникода, недопустимый для текущей кодовой страницы, заменяется лучшим доступным совпадением. Исключение не возникает.  
  
   
  
## Examples  
 Следующий пример кода сохраняет значения нескольких типов данных в примере ключа, создавая ключ, как это делает, а затем извлекает и отображает значения. В примере показано хранение и извлечение пары "имя-значение" по умолчанию (без имени) и использование `defaultValue`, если пара "имя-значение" не существует.  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="keyName" /> не начинается с правильного корневого раздела реестра.  
  
- или - 
 Значение параметра <paramref name="keyName" /> длиннее максимально допустимой длины (255 знаков).  
  
- или - 
Тип параметра <paramref name="value" /> не соответствует типу данных реестра, заданному параметром <paramref name="valueKind" />, поэтому данные не удалось правильно преобразовать.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Раздел <see cref="T:Microsoft.Win32.RegistryKey" /> доступен только для чтения, и, следовательно, запись в него невозможна (например, это узел корневого уровня или раздел не был открыт с доступом для записи).</exception>
        <exception cref="T:System.Security.SecurityException">У пользователя отсутствуют разрешения, необходимые для изменения разделов реестра.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">для изменения указанного раздела реестра, если он существует, или для создания раздела реестра, если он еще не существует. Связанные перечисления: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />, <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Содержит сведения о стандартной пользовательской конфигурации. Это поле считывает базовый раздел реестра Windows HKEY_USERS.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот раздел содержит ветвь для каждого пользователя компьютера. Конфигурация по умолчанию предоставляется для новых пользователей на локальном компьютере и для текущего пользователя по умолчанию, если пользователь не изменил настройки. Поскольку Windows 98/ME также поддерживает Registry. Users, приложения могут обращаться к сведениям о пользователе так же, как и в Windows 2000. Сведения о каждом пользователе хранятся в отдельном файле, который может храниться локально или на сетевом сервере. Windows 98/ME может скопировать этот файл в текущую систему пользователя, чтобы параметры можно было перемещать с одного компьютера на другой с помощью пользователя.  
  
   
  
## Examples  
 В следующем примере показано, как получить подразделы этого раздела и выводит на экран их имена. Используйте метод <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>, чтобы создать экземпляр определенного подраздела, представляющего интерес. Затем можно использовать другие операции в <xref:Microsoft.Win32.RegistryKey> для управления этим ключом.  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
