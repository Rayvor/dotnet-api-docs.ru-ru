<Type Name="DataSet" FullName="System.Data.DataSet">
  <Metadata><Meta Name="ms.openlocfilehash" Value="991ae75e2068a12dc1b0602f20608a40b0355b62" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73341983" /></Metadata><TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <TypeSignature Language="VB.NET" Value="Public Class DataSet&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataSet : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataSet = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-3.0">
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.0;netstandard-2.1">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет кэш данных в памяти.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet>, который представляет собой кэш данных, получаемый из источника данных в памяти, является основным компонентом архитектуры ADO.NET. <xref:System.Data.DataSet> состоит из коллекции объектов <xref:System.Data.DataTable>, которые можно связать друг с другом с <xref:System.Data.DataRelation>ными объектами. Можно также обеспечить целостность данных в <xref:System.Data.DataSet> с помощью объектов <xref:System.Data.UniqueConstraint> и <xref:System.Data.ForeignKeyConstraint>. Дополнительные сведения о работе с объектами <xref:System.Data.DataSet> см. в разделе [наборы данных, DataTables и DataSets](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md).  
  
 В то время как <xref:System.Data.DataTable> объекты содержат данные, <xref:System.Data.DataRelationCollection> позволяет перемещаться по иерархии таблиц. Таблицы содержатся в <xref:System.Data.DataTableCollection> доступе через свойство <xref:System.Data.DataSet.Tables%2A>. При доступе к <xref:System.Data.DataTable> объектам Обратите внимание, что они чувствительны к регистру. Например, если один <xref:System.Data.DataTable> имеет имя «Mydatatable», а другой — «Mydatatable», то строка, используемая для поиска одной из таблиц, рассматривается с учетом регистра. Однако если "Mydatatable" существует, а "Mydatatable" — нет, то строка поиска считается нечувствительной к регистру. Дополнительные сведения о работе с объектами <xref:System.Data.DataTable> см. [в разделе Создание таблицы](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md)данных.  
  
 <xref:System.Data.DataSet> может считывать и записывать данные и схему в виде XML-документов. Затем данные и схема можно переносить по протоколу HTTP и использовать в любом приложении на любой платформе, поддерживающей XML. Схему можно сохранить в виде XML-схемы с помощью метода <xref:System.Data.DataSet.WriteXmlSchema%2A>, и схему и данные можно сохранить с помощью метода <xref:System.Data.DataSet.WriteXml%2A>. Для чтения XML-документа, включающего как схему, так и данные, используйте метод <xref:System.Data.DataSet.ReadXml%2A>.  
  
 В типичной многоуровневой реализации действия по созданию и обновлению <xref:System.Data.DataSet>, в свою очередь, обновляют исходные данные:  
  
1.  Сборка и заполнение каждого <xref:System.Data.DataTable> в <xref:System.Data.DataSet> с данными из источника данных с помощью <xref:System.Data.Common.DataAdapter>.  
  
2.  Изменение данных отдельных <xref:System.Data.DataTable> объектов путем добавления, обновления или удаления объектов <xref:System.Data.DataRow>.  
  
3.  Вызовите метод <xref:System.Data.DataSet.GetChanges%2A>, чтобы создать второй <xref:System.Data.DataSet>, который содержит только изменения данных.  
  
4.  Вызовите метод <xref:System.Data.Common.DataAdapter.Update%2A> <xref:System.Data.Common.DataAdapter>, передав второй <xref:System.Data.DataSet> в качестве аргумента.  
  
5.  Вызовите метод <xref:System.Data.DataSet.Merge%2A>, чтобы объединить изменения из второго <xref:System.Data.DataSet> в первый.  
  
6.  Вызовите <xref:System.Data.DataSet.AcceptChanges%2A> в <xref:System.Data.DataSet>. Кроме того, можно вызвать <xref:System.Data.DataSet.RejectChanges%2A>, чтобы отменить изменения.  
  
> [!NOTE]
>  Объекты <xref:System.Data.DataSet> и <xref:System.Data.DataTable> наследуются от <xref:System.ComponentModel.MarshalByValueComponent>и поддерживают интерфейс <xref:System.Runtime.Serialization.ISerializable> для удаленного взаимодействия. Это единственные объекты ADO.NET, которые разрешают удаленное взаимодействие.  
  
> [!NOTE]
>  Классы, унаследованные от <xref:System.Data.DataSet>, не завершаются сборщиком мусора, так как метод завершения был подавлен в <xref:System.Data.DataSet>. Производный класс может вызвать метод <xref:System.GC.ReRegisterForFinalize%2A> в своем конструкторе, чтобы класс мог быть завершен сборщиком мусора.  
  
   
  
## Examples  
 Следующий пример состоит из нескольких методов, которые объединены, создают и заполняют <xref:System.Data.DataSet> из базы данных **Northwind** .  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Этот тип является надежным для многопоточных операций чтения. Необходимо синхронизировать любые операции записи.</threadsafe>
    <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация конструктора <xref:System.Data.DataSet> не принимает параметров и создает имя по умолчанию ("Невдатасет") для нового экземпляра.  
  
 Имя <xref:System.Data.DataSet> требуется для того, чтобы в XML-представлении <xref:System.Data.DataSet> всегда было указано имя элемента документа, которое является элементом самого высокого уровня в определении схемы.  
  
   
  
## Examples  
 В следующем примере создается новый <xref:System.Data.DataSet>и в него добавляются два объекта <xref:System.Data.DataTable>.  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet(System::String ^ dataSetName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : string -&gt; System.Data.DataSet" Usage="new System.Data.DataSet dataSetName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName">Имя <see cref="T:System.Data.DataSet" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.DataSet" /> с заданным именем.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имя <xref:System.Data.DataSet> требуется для того, чтобы в XML-представлении <xref:System.Data.DataSet> всегда было указано имя элемента документа, которое является элементом самого высокого уровня в определении схемы.  
  
   
  
## Examples  
 В следующем примере создается новый <xref:System.Data.DataSet>, в который добавляются два объекта <xref:System.Data.DataTable>.  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Данные, необходимые для сериализации или десериализации объекта.</param>
        <param name="context">Источник и назначение данного сериализованного потока.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.DataSet" />, содержащего заданные сведения о сериализации и контекст.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext, ConstructSchema As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext * bool -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context, ConstructSchema)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <param name="ConstructSchema">Логическое значение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataSet.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сохраняет все изменения, внесенные в класс <see cref="T:System.Data.DataSet" /> после его загрузки или после последнего вызова метода <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Классы <xref:System.Data.DataRow> и <xref:System.Data.DataTable> имеют методы <xref:System.Data.DataSet.AcceptChanges%2A>. Вызов <xref:System.Data.DataTable.AcceptChanges%2A> на уровне <xref:System.Data.DataTable> приводит к вызову метода <xref:System.Data.DataRow.AcceptChanges%2A> для каждого <xref:System.Data.DataRow>. Аналогичным образом, вызов <xref:System.Data.DataSet.AcceptChanges%2A> в <xref:System.Data.DataSet> приводит к вызову <xref:System.Data.DataTable.AcceptChanges%2A> для каждой таблицы в <xref:System.Data.DataSet>. Таким образом, у вас есть несколько уровней, на которых можно вызвать метод. Вызов <xref:System.Data.DataSet.AcceptChanges%2A> <xref:System.Data.DataSet> позволяет вызывать метод для всех подчиненных объектов (например, таблиц и строк) с одним вызовом.  
  
 При вызове `AcceptChanges` в `DataSet`все объекты <xref:System.Data.DataRow>, по-прежнему находясь в режиме правки, завершаются успешно. Свойство <xref:System.Data.DataRow.RowState%2A> каждого <xref:System.Data.DataRow> также изменяется; строки `Added` и `Modified` становятся `Unchanged`, а `Deleted` строки удаляются.  
  
 Если `DataSet` содержит объекты <xref:System.Data.ForeignKeyConstraint>, вызов метода `AcceptChanges` также приводит к принудительному применению <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A>.  
  
> [!NOTE]
>  `AcceptChanges` и `RejectChanges` применяются только к `DataRow` связанным изменениям (т. е. добавлять, удалять, удалять и изменять). Они неприменимы к изменениям схемы или структурной структуры.  
>   
>  Вызов метода AcceptChanges не позволит реплицировать эти изменения обратно в источник данных, если набор данных заполнен с помощью DataAdapter. В этом случае следует вызвать <xref:System.Data.Common.DataAdapter.Update%2A>. Дополнительные сведения см. [в разделе Обновление источников данных с помощью DataAdapter](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md) .  
  
   
  
## Examples  
 В следующем примере <xref:System.Data.DataRow> добавляется в <xref:System.Data.DataTable> в <xref:System.Data.DataSet>. Затем метод <xref:System.Data.DataSet.AcceptChanges%2A> вызывается в <xref:System.Data.DataSet>, который каскадным по отношению ко всем <xref:System.Data.DataTable> объектам, которые он содержит.  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataSet.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Начинает инициализацию <see cref="T:System.Data.DataSet" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда разработки Visual Studio .NET использует этот метод для запуска инициализации компонента, используемого в форме или другим компонентом. Метод <xref:System.Data.DataSet.EndInit%2A> завершает инициализацию. Использование методов <xref:System.Data.DataSet.BeginInit%2A> и <xref:System.Data.DataSet.EndInit%2A> предотвращает использование элемента управления до полной инициализации.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataSet.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, учитывается ли регистр при сравнении строк в объектах <see cref="T:System.Data.DataTable" />.</summary>
        <value><see langword="true" />, если при сравнении строк учитывается регистр; в противном случае <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Data.DataSet.CaseSensitive%2A> влияет на порядок выполнения операций сортировки, поиска и фильтрации для каждого объекта <xref:System.Data.DataTable>, содержащегося в <xref:System.Data.DataSet> при использовании метода <xref:System.Data.DataTable.Select%2A>.  
  
 По умолчанию установка свойства <xref:System.Data.DataSet.CaseSensitive%2A> для <xref:System.Data.DataSet> также задает для свойства <xref:System.Data.DataTable.CaseSensitive%2A> каждого связанного <xref:System.Data.DataTable> одно и то же значение.  
  
   
  
## Examples  
 В следующем примере переключается свойство <xref:System.Data.DataSet.CaseSensitive%2A>.  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataSet.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет из класса <see cref="T:System.Data.DataSet" /> любые данные путем удаления всех строк во всех таблицах.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Data.DataSet> привязан к <xref:System.Xml.XmlDataDocument>, вызов <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> или <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> вызывает <xref:System.NotSupportedException>. Чтобы избежать такой ситуации, просматривает каждую таблицу, удаляя каждую из них за раз.  
  
   
  
## Examples  
 В следующем примере очищается <xref:System.Data.DataSet> всех строк во всех таблицах.  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataSet ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataSet&#xA;override this.Clone : unit -&gt; System.Data.DataSet" Usage="dataSet.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Копирует структуру класса <see cref="T:System.Data.DataSet" />, включая все схемы, соотношения и ограничения объекта <see cref="T:System.Data.DataTable" />. Данные не копируются.</summary>
        <returns>Новый класс <see cref="T:System.Data.DataSet" />, имеющий ту же схему, что и текущий класс <see cref="T:System.Data.DataSet" />, но не содержащий данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если эти классы были подклассами, клон также будет иметь один и тот же подкласс.  
  
   
  
## Examples  
 В следующем примере создается клон схемы объекта <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataSet" Usage="dataSet.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Копирует структуру и данные для <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Новый класс <see cref="T:System.Data.DataSet" />, имеющий ту же структуру (схемы таблиц, отношения и ограничения) и данные, что и класс <see cref="T:System.Data.DataSet" />.  
  
 <block subset="none" type="note"><para>  
 Если эти классы являются подклассами, то и копия любого из них будет принадлежать соответствующему подклассу.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере используется метод <xref:System.Data.DataSet.Copy%2A> для создания копии исходного <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Data.DataTableReader" /> с одним результирующим набором для каждой последовательности <see cref="T:System.Data.DataTable" /> в той же последовательности, в которой таблицы отображаются в коллекции <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить порядок результирующих наборов в возвращаемом <xref:System.Data.DataTableReader>, если <xref:System.Data.DataTable> в <xref:System.Data.DataSet> пустой, он будет представлен пустым результирующим набором в возвращаемом `DataTableReader`.  
  
   
  
## Examples  
 В этом примере консольное приложение создает три экземпляра <xref:System.Data.DataTable> и добавляет их в <xref:System.Data.DataSet>. В примере вызывается метод <xref:System.Data.DataSet.CreateDataReader%2A> и отображается содержимое возвращаемого <xref:System.Data.DataTableReader>. Обратите внимание, что порядок результирующих наборов в `DataTableReader` управляется порядком `DataTable` экземпляров, передаваемых в качестве параметров.  
  
> [!NOTE]
>  В этом примере показано, как использовать одну из перегруженных версий `CreateDataReader`. Другие примеры, которые могут быть доступны, см. в разделах по отдельным перегрузкам.  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 В этом примере в окне консоли отображается следующий код:  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Data.DataTableReader" /> с одним результирующим набором для каждой последовательности <see cref="T:System.Data.DataTable" /> в той же последовательности, в которой таблицы отображаются в коллекции <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <returns>Объект <see cref="T:System.Data.DataTableReader" />, содержащий один или несколько результирующих наборов, соответствующих экземплярам <see cref="T:System.Data.DataTable" />, содержащимся в исходном наборе данных <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить порядок результирующих наборов в возвращаемом <xref:System.Data.DataTableReader>, если <xref:System.Data.DataTable> в <xref:System.Data.DataSet> пустой, он представляется пустым результирующим набором в возвращаемом `DataTableReader`.  
  
   
  
## Examples  
 В следующем примере создаются три экземпляра <xref:System.Data.DataTable> и каждый из них добавляется в <xref:System.Data.DataSet>. Затем в примере закрашенный `DataSet` передается в процедуру, которая вызывает метод <xref:System.Data.DataSet.CreateDataReader%2A>, и переходит к итерации всех результирующих наборов, содержащихся в <xref:System.Data.DataTableReader>. В этом примере результаты отображаются в окне консоли.  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader (ParamArray dataTables As DataTable()) As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader(... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader dataTables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">Массив таблиц DataTables, обеспечивающий последовательность результирующих наборов, которые будут возвращены в средстве чтения <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Возвращает объект <see cref="T:System.Data.DataTableReader" /> с одним результирующим набором для каждой таблицы <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Объект <see cref="T:System.Data.DataTableReader" />, содержащий один или несколько результирующих наборов, соответствующих экземплярам <see cref="T:System.Data.DataTable" />, содержащимся в исходном наборе данных <see cref="T:System.Data.DataSet" />. Возвращенные результирующие наборы находятся в последовательности, определенной в параметре <paramref name="dataTables" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы обеспечить порядок результирующих наборов в возвращаемом <xref:System.Data.DataTableReader>, если <xref:System.Data.DataTable> в <xref:System.Data.DataSet> пустой, он представляется пустым результирующим набором в возвращаемом `DataTableReader`. Так как эта перегруженная версия позволяет предоставить список `DataTable` экземпляров в качестве параметров, можно указать порядок, в котором результирующие наборы будут отображаться в возвращаемом `DataTableReader`.  
  
   
  
## Examples  
 В этом примере консольное приложение создает три экземпляра <xref:System.Data.DataTable> и добавляет их в <xref:System.Data.DataSet>. В примере вызывается метод <xref:System.Data.DataSet.CreateDataReader%2A> и отображается содержимое возвращаемого <xref:System.Data.DataTableReader>. Обратите внимание, что порядок результирующих наборов в `DataTableReader` управляется порядком `DataTable` экземпляров, передаваемых в качестве параметров. В этом примере результаты отображаются в окне консоли.  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataSetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSetName : string with get, set" Usage="System.Data.DataSet.DataSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDataSetNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя текущего <see cref="T:System.Data.DataSet" />.</summary>
        <value>Имя <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается новый <xref:System.Data.DataSet> с заданным <xref:System.Data.DataSet.DataSetName%2A>.  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultViewManager As DataViewManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataViewManager ^ DefaultViewManager { System::Data::DataViewManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultViewManager : System.Data.DataViewManager" Usage="System.Data.DataSet.DefaultViewManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает новое представление данных класса <see cref="T:System.Data.DataSet" /> для осуществления фильтрации, поиска или перехода с помощью настраиваемого класса <see cref="T:System.Data.DataViewManager" />.</summary>
        <value>Объект <see cref="T:System.Data.DataViewManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataViewManager>, возвращаемое свойством <xref:System.Data.DataSet.DefaultViewManager%2A>, позволяет создавать пользовательские параметры для каждого <xref:System.Data.DataTable> в <xref:System.Data.DataSet>.  
  
 При получении <xref:System.Data.DataView> из <xref:System.Data.DataTable>порядок сортировки, фильтрация и <xref:System.Data.DataViewRowState> настраиваются в соответствии с параметрами свойства <xref:System.Data.DataSet.DefaultViewManager%2A>.  
  
   
  
## Examples  
 В следующем примере возвращается <xref:System.Data.DataViewManager> по умолчанию для <xref:System.Data.DataSet>и добавляется <xref:System.Data.DataTable> в <xref:System.Data.DataTableCollection>.  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> для <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть вызван при десериализации типизированного <xref:System.Data.DataSet> для определения его <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (reader As XmlReader) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Xml.XmlReader -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reader">Экземпляр <see cref="T:System.Xml.XmlReader" />, который передается во время десериализации набора данных <see cref="T:System.Data.DataSet" />.</param>
        <summary>Определяет <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> для <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Перечисление <see cref="T:System.Data.SchemaSerializationMode" />, которое указывает, следует ли исключать из передаваемых данных сведения о схеме.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть вызван при десериализации типизированного <xref:System.Data.DataSet> для определения его <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (info As SerializationInfo, context As StreamingContext) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, вместе с которым вызывается защищенный конструктор <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> набора данных <see langword="DataSet" /> во время десериализации в удаленных сценариях.</param>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, вместе с которым вызывается защищенный конструктор <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> набора данных <see langword="DataSet" /> во время десериализации в удаленных сценариях.</param>
        <summary>Определяет <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> для <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Перечисление <see cref="T:System.Data.SchemaSerializationMode" />, которое указывает, следует ли исключать из передаваемых данных сведения о схеме.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть вызван при десериализации типизированного <xref:System.Data.DataSet> для определения его <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataSet.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает инициализацию <see cref="T:System.Data.DataSet" />, используемого в форме или другим компонентом. Инициализация происходит во время выполнения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда разработки Visual Studio .NET использует этот метод для завершения инициализации компонента, используемого в форме или другим компонентом. Метод <xref:System.Data.DataSet.BeginInit%2A> запускает инициализацию. Использование методов <xref:System.Data.DataSet.BeginInit%2A> и <xref:System.Data.DataSet.EndInit%2A> предотвращает использование элемента управления до полной инициализации.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Property EnforceConstraints As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnforceConstraints { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnforceConstraints : bool with get, set" Usage="System.Data.DataSet.EnforceConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetEnforceConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее соблюдение правил ограничения при попытке совершения операции обновления.</summary>
        <value><see langword="true" />, если применяются правила; в противном случае <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ограничения задаются на уровне <xref:System.Data.DataTable> (свойство<xref:System.Data.DataTable.Constraints%2A>). Дополнительные сведения о создании ограничений см. в разделе [ограничения DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Data.DataSet> с одной таблицей, одним столбцом, пятью строками и одним <xref:System.Data.UniqueConstraint>. Свойству <xref:System.Data.DataSet.EnforceConstraints%2A> присвоено значение `false`, а значения каждой строки задаются одинаковым значением. Когда свойство <xref:System.Data.DataSet.EnforceConstraints%2A> сбрасывается в `true`, создается <xref:System.Data.ConstraintException>.  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Невозможно наложить одно или несколько ограничений.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataSet.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию настраиваемых данных пользователя, связанных с <see langword="DataSet" />.</summary>
        <value>Класс <see cref="T:System.Data.PropertyCollection" />, содержащий все настраиваемые данные пользователя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Data.DataSet.ExtendedProperties%2A> позволяет хранить пользовательские данные в `DataSet`. Например, вы можете хранить время обновления данных.  
  
 Расширенные свойства должны иметь тип <xref:System.String>, если они должны сохраняться, когда <xref:System.Data.DataSet> записывается как XML.  
  
   
  
## Examples  
 В следующем примере пользовательское свойство добавляется в <xref:System.Data.PropertyCollection>, возвращаемое свойством <xref:System.Data.DataColumn.ExtendedProperties%2A>. Во втором примере извлекается пользовательское свойство.  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает копию таблицы <see cref="T:System.Data.DataSet" />, содержащую все изменения, внесенные после ее последней загрузки или после вызова метода <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataSet" Usage="dataSet.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает копию класса <see cref="T:System.Data.DataSet" />, содержащую все изменения, внесенные после его загрузки или после последнего вызова метода <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
        <returns>Копия изменений из данного <see cref="T:System.Data.DataSet" />, с которой можно выполнять различные операции и позднее объединить с данными таблицы, используя метод <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Если никакие строки не менялись, метод возвращает <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Создает новый <xref:System.Data.DataSet>, содержащий копию всех строк в исходном <xref:System.Data.DataSet> с ожидающими изменениями. Ограничения отношений могут привести к добавлению дополнительных неизмененных строк в новый <xref:System.Data.DataSet>, если неизмененные строки содержат первичные ключи, соответствующие внешним ключам в измененных строках. Метод возвращает `null`, если в исходной <xref:System.Data.DataSet> нет строк с ожидающими изменениями.  
  
   
  
## Examples  
 В следующем примере создается простой <xref:System.Data.DataSet> с одной таблицей, двумя столбцами и десятью строками. Два значения изменяются и добавляется одна строка. Подмножество измененных данных создается с помощью метода <xref:System.Data.DataSet.GetChanges%2A>. После согласования ошибок новый столбец добавляется в подмножество, изменяя схему. При вызове метода <xref:System.Data.DataSet.Merge%2A> с `missingSchemaAction`, для которого задано значение `MissingSchemaAction.Add`, новый столбец добавляется в схему исходного объекта <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataSet" Usage="dataSet.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Одно из значений <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Получает копию таблицы <see cref="T:System.Data.DataSet" />, содержащую все изменения, внесенные после ее последней загрузки или после вызова метода <see cref="M:System.Data.DataSet.AcceptChanges" /> и отфильтрованные по параметру <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Отфильтрованная копия класса <see cref="T:System.Data.DataSet" />, с которой можно работать, а затем вернуть в исходный класс с помощью метода <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Если строки с требуемым типом <see cref="T:System.Data.DataRowState" /> отсутствуют, метод вернет значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.GetChanges%2A> используется для создания второго объекта <xref:System.Data.DataSet>, который содержит только изменения, появившиеся в исходном объекте. Используйте аргумент `rowStates`, чтобы указать тип изменений, которые должен включать новый объект.  
  
 Эта возвращенная копия предназначена для обратного слияния в этот исходный <xref:System.Data.DataSet>. Ограничения отношений могут привести к добавлению родительских строк, помеченных `Unchanged`. Если строки требуемого <xref:System.Data.DataRowState> не найдены, метод <xref:System.Data.DataSet.GetChanges%2A> возвращает `null`.  
  
   
  
## Examples  
 В следующем примере метод <xref:System.Data.DataSet.GetChanges%2A> используется для создания второго <xref:System.Data.DataSet> объекта, который затем используется для обновления источника данных.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataSetSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataSetSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataSetSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataSet.GetDataSetSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Указанный набор схем.</param>
        <summary>Получает копию <see cref="T:System.Xml.Schema.XmlSchemaSet" /> для DataSet.</summary>
        <returns>Копия <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, содержащий сериализуемые данные, связанные с исключением <see cref="T:System.Data.DataSet" />.</param>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий источник и назначение сериализуемого потока, связанного с объектом <see cref="T:System.Data.DataSet" />.</param>
        <summary>Заполняет объект сведений о сериализации данными, необходимыми для сериализации <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="info" /> имеет значение <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchemaSerializable () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchemaSerializable();" />
      <MemberSignature Language="F#" Value="abstract member GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataSet.GetSchemaSerializable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает сериализуемый экземпляр <see cref="T:System.Xml.Schema.XmlSchema" />.</summary>
        <returns>Экземпляр класса <see cref="T:System.Xml.Schema.XmlSchema" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetSerializationData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetSerializationData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.GetSerializationData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetSerializationData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Экземпляр класса <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Контекст потоковой передачи.</param>
        <summary>Десериализует данные таблицы из двоичного потока или XML-потока.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXml();" />
      <MemberSignature Language="F#" Value="member this.GetXml : unit -&gt; string" Usage="dataSet.GetXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает XML-представление данных, хранящихся в классе <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Строка, являющаяся представлением данных, хранящихся в классе <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода идентичен вызову <xref:System.Data.DataSet.WriteXml%2A> с <xref:System.Data.XmlWriteMode>, для которого задано значение <xref:System.Data.XmlWriteMode.IgnoreSchema>.  
  
 <xref:System.Data.DataSet.GetXml%2A> возвращает XML в виде строки и, следовательно, требует дополнительных затрат, чем <xref:System.Data.DataSet.WriteXml%2A> для записи XML в файл.  
  
 Если вы создаете <xref:System.Data.DataSet> с помощью вывода схемы и сериализуете его с помощью XML или веб-служб, порядок столбцов может измениться.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Data.DataSet> и <xref:System.Data.DataTable>, добавляются образцы данных, а затем данные отображаются в формате XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 В этом примере показано, как записывать данные в XML-файл из набора данных и считывать данные в набор данных из XML. В этом примере создается один набор данных с двумя таблицами: два способа экспорта набора данных в XML-файлы (WriteXml и GetXml) и использование двух способов (ReadXml и Инферксмлсчема) для импорта набора данных из XML-файлов.  
  
 Перед компиляцией и запуском образца необходимо создать четыре XML-файла в каталоге примеров. Сначала создайте Елементсвисаттрибутес. XML:  
  
```xml  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 Затем создайте файл Елементсвисчилделементсксмл. XML.  
  
```xml  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 Теперь создайте Елементсвисонляттрибутес. XML:  
  
```xml
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 И, наконец, создайте файл Репеатинжелементс. XML.  
  
```xml
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 Теперь можно скомпилировать и запустить следующий исходный код.  [Сохранение данных из набора данных в XML-файл](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) содержит Visual Basic и C# проектов для этого примера.  
  
```csharp
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXmlSchema () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXmlSchema();" />
      <MemberSignature Language="F#" Value="member this.GetXmlSchema : unit -&gt; string" Usage="dataSet.GetXmlSchema " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает XML-схему для XML-представления данных, хранящихся в классе <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Строка, которая является XML-схемой для XML-представления данных, хранящихся в классе <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода идентичен вызову <xref:System.Data.DataSet.WriteXmlSchema%2A>, за исключением того, что записывается только основная схема.  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A> возвращает XML в виде строки и, следовательно, требует дополнительных затрат, чем <xref:System.Data.DataSet.WriteXmlSchema%2A> для записи XML в файл.  
  
 Если вы создаете <xref:System.Data.DataSet> с помощью вывода схемы и сериализуете его с помощью XML или веб-служб, порядок столбцов может измениться.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Data.DataSet> и <xref:System.Data.DataTable>, а затем схема отображается в формате XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает значение, определяющее наличие изменений в классе <see cref="T:System.Data.DataSet" />, включая добавление, удаление или изменение строк.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges();" />
      <MemberSignature Language="F#" Value="member this.HasChanges : unit -&gt; bool" Usage="dataSet.HasChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает значение, определяющее наличие изменений в классе <see cref="T:System.Data.DataSet" />, включая добавление, удаление или изменение строк.</summary>
        <returns>Значение <see langword="true" />, если класс <see cref="T:System.Data.DataSet" /> был изменен, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере метод <xref:System.Data.DataSet.GetChanges%2A> используется для создания второго <xref:System.Data.DataSet> объекта, который затем используется для обновления источника данных.  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges (rowStates As DataRowState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.HasChanges : System.Data.DataRowState -&gt; bool" Usage="dataSet.HasChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Одно из значений перечисления <see cref="T:System.Data.DataRowState" />.</param>
        <summary>Получает значение, определяющее наличие изменений в классе <see cref="T:System.Data.DataSet" />, включая добавление, удаление или изменение строк, отфильтрованных по типу <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Значение <see langword="true" />, если класс <see cref="T:System.Data.DataSet" /> был изменен, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед вызовом метода <xref:System.Data.DataSet.GetChanges%2A> изучите свойство <xref:System.Data.DataSet.HasChanges%2A> `DataSet`.  
  
   
  
## Examples  
 В следующем примере метод <xref:System.Data.DataSet.GetChanges%2A> используется для создания второго <xref:System.Data.DataSet> объекта, который затем используется для обновления источника данных.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataSet.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее наличие ошибок в любом из объектов <see cref="T:System.Data.DataTable" /> в классе <see cref="T:System.Data.DataSet" />.</summary>
        <value><see langword="true" />, если какая либо таблица содержит ошибку; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый <xref:System.Data.DataTable> в <xref:System.Data.DataSet> также имеет свойство <xref:System.Data.DataTable.HasErrors%2A>. Сначала используйте свойство `HasErrors` `DataSet`, чтобы определить, есть ли в таблице ошибки, прежде чем проверять отдельные объекты <xref:System.Data.DataTable>. Если `DataTable` содержит ошибки, метод <xref:System.Data.DataTable.GetErrors%2A> возвращает массив объектов <xref:System.Data.DataRow>, содержащих ошибки.  
  
   
  
## Examples  
 В следующем примере используется свойство <xref:System.Data.DataSet.HasErrors%2A>, чтобы определить, содержит ли объект <xref:System.Data.DataSet> ошибки. В этом случае выводятся ошибки для каждого <xref:System.Data.DataRow> в каждой <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Применяет XML-схему к классу <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::Stream ^ stream, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.Stream * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (stream, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream">Объект <see langword="Stream" />, из которого считывается схема.</param>
        <param name="nsArray">Массив строк URI пространства имен, исключаемый из интерфейса схемы.</param>
        <summary>Применяет XML-схему из указанного объекта <see cref="T:System.IO.Stream" /> к объекту <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As TextReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::TextReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.TextReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">Объект <see langword="TextReader" />, из которого считывается схема.</param>
        <param name="nsArray">Массив строк URI пространства имен, исключаемый из интерфейса схемы.</param>
        <summary>Применяет XML-схему из указанного объекта <see cref="T:System.IO.TextReader" /> к объекту <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (fileName As String, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::String ^ fileName, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : string * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (fileName, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла (включая путь), из которого считывается схема.</param>
        <param name="nsArray">Массив строк URI пространства имен, исключаемый из интерфейса схемы.</param>
        <summary>Применяет XML-схему из указанного файла к классу <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Для поля <see cref="T:System.Security.Permissions.FileIOPermission" /> не задан класс <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанное перечисление: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As XmlReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::Xml::XmlReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.Xml.XmlReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">Объект <see langword="XMLReader" />, из которого считывается схема.</param>
        <param name="nsArray">Массив строк URI пространства имен, исключаемый из интерфейса схемы.</param>
        <summary>Применяет XML-схему из указанного объекта <see cref="T:System.Xml.XmlReader" /> к объекту <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.ISupportInitializeNotification.Initialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после инициализации таблицы <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для получения дополнительной информации см. <xref:System.Data.DataSet.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeDerivedDataSet ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeDerivedDataSet();" />
      <MemberSignature Language="F#" Value="abstract member InitializeDerivedDataSet : unit -&gt; unit&#xA;override this.InitializeDerivedDataSet : unit -&gt; unit" Usage="dataSet.InitializeDerivedDataSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Десериализует все данные таблицы DataSet из двоичного потока или XML-потока.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsBinarySerialized (info As SerializationInfo, context As StreamingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsBinarySerialized(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.IsBinarySerialized : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; bool" Usage="dataSet.IsBinarySerialized (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <summary>Анализирует формат сериализованного представления набора данных <see langword="DataSet" />.</summary>
        <returns>Значение <see langword="true" />, если указанный объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> представляет набор данных <see langword="DataSet" />, сериализованному в двоичном формате; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный член предназначен для поддержки платформы .NET Framework и не должен вызываться напрямую из кода приложения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataSet.IsInitialized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ISupportInitializeNotification.IsInitialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, инициализирована ли таблица <see cref="T:System.Data.DataSet" />.</summary>
        <value>Значение <see langword="true" /> указывает, что компонент завершил инициализацию; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращает состояние <xref:System.Data.DataSet> при его создании, например в Visual Studio. Метод <xref:System.Data.DataSet.BeginInit%2A> задает для него значение `false` и метод <xref:System.Data.DataSet.EndInit%2A> задает для него значение `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Заполняет таблицу <see cref="T:System.Data.DataSet" /> значениями из источника данных с помощью предоставляемого объекта <see cref="T:System.Data.IDataReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataTable.Load%2A> предоставляет метод для заполнения одного <xref:System.Data.DataTable> данными, полученными из экземпляра <xref:System.Data.IDataReader>. Этот метод предоставляет те же функциональные возможности, но позволяет загружать несколько результирующих наборов из `IDataReader` в несколько таблиц в `DataSet`.  
  
 Если объект `DataSet` уже содержит строки, входящие данные из источника данных объединяются с существующими строками.  
  
 Метод `Load` можно использовать в нескольких распространенных сценариях, по центру вокруг получения данных из указанного источника данных и добавления их в текущий контейнер данных (в данном случае `DataSet`). В этих сценариях описывается стандартное использование `DataSet`, описывающее поведение обновления и слияния.  
  
 `DataSet` синхронизирует или обновляет с одним первичным источником данных. `DataSet` отслеживает изменения, обеспечивая синхронизацию с первичным источником данных. Кроме того, `DataSet` может принимать добавочные данные из одного или нескольких вторичных источников данных. `DataSet` не отвечает за отслеживание изменений, чтобы разрешить синхронизацию с дополнительным источником данных.  
  
 Учитывая эти два гипотетических источника данных, пользователю, скорее всего, потребуется одно из следующих поведений:  
  
-   Инициализация `DataSet` из первичного источника данных. В этом сценарии пользователь хочет инициализировать пустой `DataSet` со значениями из первичного источника данных. Изменилось одно или несколько содержимого DataTable. Позже пользователь намеревается распространить изменения обратно на основной источник данных.  
  
-   Сохранение изменений и повторная синхронизация из первичного источника данных. В этом сценарии пользователь хочет взять `DataSet`, заполненный предыдущим сценарием, и выполнить добавочную синхронизацию с первичным источником данных, сохранив изменения, внесенные в `DataSet`.  
  
-   Добавочный поток данных из дополнительных источников данных. В этом сценарии пользователь хочет объединить изменения из одного или нескольких вторичных источников данных и распространить эти изменения обратно в первичный источник данных.  
  
 Метод `Load` делает возможными все эти сценарии. Этот метод позволяет указать параметр Load, указывающий, как строки, которые уже находятся в <xref:System.Data.DataTable>, объединяются с загружаемыми строками. В следующей таблице описаны три параметра загрузки, предоставляемые перечислением <xref:System.Data.LoadOption>. В каждом случае описание показывает поведение, когда первичный ключ строки во входящих данных соответствует первичному ключу существующей строки.  
  
|Параметр Load|Описание|  
|-----------------|-----------------|  
|`PreserveChanges` (по умолчанию)|Обновляет исходную версию строки значением входящей строки.|  
|`OverwriteChanges`|Обновляет текущую и исходную версии строки значением входящей строки.|  
|`Upsert`|Обновляет текущую версию строки значением входящей строки.|  
  
 В общем случае параметры `PreserveChanges` и `OverwriteChanges` предназначены для сценариев, в которых пользователю нужно синхронизировать `DataSet` и его изменения с первичным источником данных. Параметр `Upsert` упрощает статистическую обработку изменений из одного или нескольких вторичных источников данных.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tables" Type="System.Data.DataTable[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Объект <see cref="T:System.Data.IDataReader" />, предоставляющий один или несколько наборов результатов.</param>
        <param name="loadOption">Значение из перечисления <see cref="T:System.Data.LoadOption" />, которое указывает, как строки, уже находящиеся в экземплярах <see cref="T:System.Data.DataTable" /> набора данных <see cref="T:System.Data.DataSet" />, должны объединяться со входящими строками, имеющими общий первичный ключ.</param>
        <param name="tables">Массив экземпляров <see cref="T:System.Data.DataTable" />, из которых метод <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /> получает сведения об имени и пространстве имен. Каждая из этих таблиц должна являться членом коллекции <see cref="T:System.Data.DataTableCollection" />, находящейся в этом наборе данных <see cref="T:System.Data.DataSet" />.</param>
        <summary>Заполняет набор данных <see cref="T:System.Data.DataSet" /> значениями из источника данных с помощью предоставляемого объекта <see cref="T:System.Data.IDataReader" />, использующего массив экземпляров <see cref="T:System.Data.DataTable" /> для предоставления сведений о схеме и пространстве имен.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataTable.Load%2A> предоставляет метод для заполнения одного <xref:System.Data.DataTable> данными, полученными из экземпляра <xref:System.Data.IDataReader>. Этот метод предоставляет те же функциональные возможности, но позволяет загружать несколько результирующих наборов из <xref:System.Data.IDataReader> в несколько таблиц в <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Операция загрузки завершится с ошибкой <xref:System.InvalidOperationException> если любой из столбцов источника данных во входящем `reader` является вычисленным столбцом.  
  
 Параметр `loadOption` позволяет указать, каким образом импортируемые данные должны взаимодействовать с существующими данными, и могут быть любыми значениями из перечисления <xref:System.Data.LoadOption>. Дополнительные сведения об использовании этого параметра см. в документации по методу <xref:System.Data.DataTable><xref:System.Data.DataTable.Load%2A>.  
  
 Параметр `tables` позволяет указать массив экземпляров <xref:System.Data.DataTable>, указывающий порядок таблиц, соответствующих каждому результирующему набору, загруженному из модуля чтения. Метод <xref:System.Data.DataSet.Load%2A> заполняет каждый переданный экземпляр <xref:System.Data.DataTable> данными из одного результирующего набора из модуля чтения исходных данных. После каждого результирующего набора метод <xref:System.Data.DataSet.Load%2A> переходит к следующему результирующему набору в модуле чтения, пока больше нет результирующих наборов.  
  
 Схема разрешения имен для этого метода совпадает с той, за которой следует метод <xref:System.Data.Common.DbDataAdapter.Fill%2A> класса <xref:System.Data.Common.DbDataAdapter>.  
  
   
  
## Examples  
 В следующем примере создается новый <xref:System.Data.DataSet>, добавляются два экземпляра <xref:System.Data.DataTable> в <xref:System.Data.DataSet>, а затем заполняется <xref:System.Data.DataSet> с помощью метода <xref:System.Data.DataSet.Load%2A>, в результате чего извлекаются данные из <xref:System.Data.DataTableReader>, содержащего два результирующих набора. Наконец, в примере выводится содержимое таблиц в окне консоли.  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::String ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * string[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tables" Type="System.String[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Объект <see cref="T:System.Data.IDataReader" />, предоставляющий один или несколько наборов результатов.</param>
        <param name="loadOption">Значение из перечисления <see cref="T:System.Data.LoadOption" />, которое указывает, как строки, уже находящиеся в экземплярах <see cref="T:System.Data.DataTable" /> набора данных <see langword="DataSet" />, должны объединяться со входящими строками, имеющими общий первичный ключ.</param>
        <param name="tables">Массив строк, из которого метод <see langword="Load" /> получает сведения об именах таблиц.</param>
        <summary>Заполняет набор данных <see cref="T:System.Data.DataSet" /> значениями из источника данных с помощью предоставляемого объекта <see cref="T:System.Data.IDataReader" />, используя массив строк для предоставления имен таблиц в наборе данных <see langword="DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataTable.Load%2A> предоставляет метод для заполнения одного <xref:System.Data.DataTable> данными, полученными из экземпляра <xref:System.Data.IDataReader>. Этот метод предоставляет те же функциональные возможности, но позволяет загружать несколько результирующих наборов из `IDataReader` в несколько таблиц в `DataSet`.  
  
> [!NOTE]
>  Операция загрузки завершится с ошибкой <xref:System.InvalidOperationException> если любой из столбцов источника данных во входящем `reader` является вычисленным столбцом.  
  
 Параметр `loadOption` позволяет указать, каким образом импортируемые данные должны взаимодействовать с существующими данными, и могут быть любыми значениями из перечисления <xref:System.Data.LoadOption>. Дополнительные сведения об использовании этого параметра см. в документации по методу <xref:System.Data.DataTable.Load%2A>.  
  
 Параметр `tables` позволяет указать массив имен таблиц, указывающий порядок таблиц, соответствующих каждому результирующему набору, загруженному из модуля чтения. Метод `Load` пытается найти таблицу в `DataSet`, совпадающую с именем, найденным в массиве имен таблиц по порядку. Если найдена соответствующая таблица, то эта таблица загружается с содержимым текущего результирующего набора. Если совпадающая таблица не найдена, создается таблица с использованием имени, заданного в массиве имен таблиц, а схема новой таблицы выводится из результирующего набора. После каждого результирующего набора метод `Load` переходит к следующему результирующему набору в модуле чтения, пока больше нет результирующих наборов.  
  
 Пространство имен по умолчанию, связанное с `DataSet`, если таковое имеется, связано с каждым вновь созданным `DataTable`. Схема разрешения имен для этого метода совпадает с той, за которой следует метод <xref:System.Data.Common.DbDataAdapter.Fill%2A> класса <xref:System.Data.Common.DbDataAdapter>.  
  
   
  
## Examples  
 В следующем примере консольного приложения сначала создаются таблицы и загружаются данные из модуля чтения в <xref:System.Data.DataSet>с помощью метода `Load`. Затем пример добавляет таблицы в <xref:System.Data.DataSet> и пытается заполнить таблицы данными из <xref:System.Data.DataTableReader>. В этом примере, поскольку параметры, передаваемые в метод `Load`, указывают на несуществующее имя таблицы, метод `Load` создает новую таблицу в соответствии с именем, переданным в качестве параметра. После загрузки данных в примере отображается содержимое всех таблиц в окне консоли.  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, errorHandler, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tables" Type="System.Data.DataTable[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Объект <see cref="T:System.Data.IDataReader" />, предоставляющий один или несколько наборов результатов.</param>
        <param name="loadOption">Значение из перечисления <see cref="T:System.Data.LoadOption" />, которое указывает, как строки, уже находящиеся в экземплярах <see cref="T:System.Data.DataTable" /> набора данных <see cref="T:System.Data.DataSet" />, должны объединяться со входящими строками, имеющими общий первичный ключ.</param>
        <param name="errorHandler">Делегат <see cref="T:System.Data.FillErrorEventHandler" />, вызываемый при возникновении ошибки во время загрузки данных.</param>
        <param name="tables">Массив экземпляров <see cref="T:System.Data.DataTable" />, из которых метод <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /> получает сведения об имени и пространстве имен.</param>
        <summary>Заполняет набор данных <see cref="T:System.Data.DataSet" /> значениями из источника данных с помощью предоставляемого объекта <see cref="T:System.Data.IDataReader" />, использующего массив экземпляров <see cref="T:System.Data.DataTable" /> для предоставления сведений о схеме и пространстве имен.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataTable.Load%2A> предоставляет метод для заполнения одного <xref:System.Data.DataTable> данными, полученными из экземпляра <xref:System.Data.IDataReader>. Этот метод предоставляет те же функциональные возможности, но позволяет загружать несколько результирующих наборов из <xref:System.Data.IDataReader> в несколько таблиц в <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Операция загрузки завершится с ошибкой <xref:System.InvalidOperationException> если любой из столбцов источника данных во входящем `reader` является вычисленным столбцом.  
  
 Параметр `loadOption` позволяет указать, каким образом импортируемые данные должны взаимодействовать с существующими данными, и могут быть любыми значениями из перечисления <xref:System.Data.LoadOption>. Дополнительные сведения об использовании этого параметра см. в документации по методу <xref:System.Data.DataTable><xref:System.Data.DataTable.Load%2A>.  
  
 Параметр `errorHandler` — это делегат <xref:System.Data.FillErrorEventHandler>, который ссылается на процедуру, вызываемую при возникновении ошибки при загрузке данных. Параметр <xref:System.Data.FillErrorEventArgs>, передаваемый в процедуру, предоставляет свойства, позволяющие получить сведения о произошедшей ошибке, текущей строке данных и заполняемом <xref:System.Data.DataTable>. Использование этого механизма делегирования, а не более простого блока try/catch, позволяет определить ошибку, обработать ситуацию и продолжить обработку при необходимости. Параметр <xref:System.Data.FillErrorEventArgs> предоставляет свойство <xref:System.Data.FillErrorEventArgs.Continue%2A>. Задайте для этого свойства значение `true`, чтобы указать, что вы обработали ошибку и хотите продолжить обработку. Задайте для свойства значение `false`, чтобы указать, что вы хотите остановить обработку. Имейте в виду, что присвоение свойству значения `false` приводит к созданию исключения кодом, вызвавшим проблему.  
  
 Параметр `tables` позволяет указать массив экземпляров <xref:System.Data.DataTable>, указывающий порядок таблиц, соответствующих каждому результирующему набору, загруженному из модуля чтения. Метод <xref:System.Data.DataSet.Load%2A> заполняет каждый переданный экземпляр <xref:System.Data.DataTable> данными из одного результирующего набора из модуля чтения исходных данных. После каждого результирующего набора метод <xref:System.Data.DataSet.Load%2A> переходит к следующему результирующему набору в модуле чтения, пока больше нет результирующих наборов.  
  
 Схема разрешения имен для этого метода совпадает с той, за которой следует метод <xref:System.Data.Common.DbDataAdapter.Fill%2A> класса <xref:System.Data.Common.DbDataAdapter>.  
  
   
  
## Examples  
 В следующем примере таблица добавляется в <xref:System.Data.DataSet>, а затем пытается использовать метод <xref:System.Data.DataSet.Load%2A> для загрузки данных из <xref:System.Data.DataTableReader>, содержащего несовместимую схему. Вместо перехвата ошибки в этом примере используется делегат <xref:System.Data.FillErrorEventHandler> для изучения и обработки ошибки. Выходные данные отображаются в окне консоли.  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataSet.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о языке, используемые для сравнения строк таблицы.</summary>
        <value>Класс <see cref="T:System.Globalization.CultureInfo" />, содержащий данные о языковом стандарте, используемом пользователем на компьютере. Значение по умолчанию — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Data.DataSet.Locale%2A> указывает языковой стандарт, для которого применяется сортировка.  
  
 По умолчанию установка <xref:System.Data.DataSet.Locale%2A> для <xref:System.Data.DataSet> также задает <xref:System.Data.DataSet.Locale%2A> для каждого объекта <xref:System.Data.DataTable> в этом `DataSet`е с тем же значением.  
  
> [!NOTE]
>  В столбцах, содержащих выражения, используется <xref:System.StringComparison.InvariantCulture>. <xref:System.StringComparison.CurrentCulture> игнорируется.  
  
   
  
## Examples  
 В следующем примере возвращается <xref:System.Globalization.CultureInfo> для <xref:System.Data.DataSet> и выводятся свойства <xref:System.Globalization.CultureInfo.DisplayName%2A> и <xref:System.Globalization.CultureInfo.EnglishName%2A>.  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Осуществляет слияние указанного класса <see cref="T:System.Data.DataSet" />, <see cref="T:System.Data.DataTable" /> или массива объектов <see cref="T:System.Data.DataRow" /> с текущим объектом <see langword="DataSet" /> или <see langword="DataTable" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] -&gt; unit" Usage="dataSet.Merge rows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">Массив объектов <see langword="DataRow" />, добавляемый в <see langword="DataSet" />.</param>
        <summary>Осуществляет слияние массива объектов <see cref="T:System.Data.DataRow" /> и текущего класса <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.Merge%2A> используется для слияния двух <xref:System.Data.DataSet> объектов, имеющих почти похожие схемы. Слияние обычно используется в клиентском приложении для включения последних изменений из источника данных в существующий <xref:System.Data.DataSet>. Это позволяет клиентскому приложению обновить <xref:System.Data.DataSet> с последними данными из источника данных.  
  
 Метод <xref:System.Data.DataSet.Merge%2A> обычно вызывается в конце последовательности процедур, которые подразумевают проверку изменений, согласование ошибок, обновление источника данных с учетом изменений и, наконец, обновление существующих <xref:System.Data.DataSet>.  
  
 В клиентском приложении обычно есть одна кнопка, которую пользователь может щелкнуть, чтобы собрать измененные данные и проверить их перед отправкой в компонент среднего уровня. В этом сценарии сначала вызывается метод <xref:System.Data.DataSet.GetChanges%2A>. Этот метод возвращает второй <xref:System.Data.DataSet>, оптимизированный для проверки и слияния. Этот второй <xref:System.Data.DataSet> объект содержит только объекты <xref:System.Data.DataTable> и <xref:System.Data.DataRow>, которые были изменены, что привело к подмножеству исходного <xref:System.Data.DataSet>. Это подмножество обычно меньше и, следовательно, более эффективно передается обратно в компонент среднего уровня. Затем компонент среднего уровня обновляет исходный источник данных изменениями с помощью хранимых процедур. После этого средний уровень может отправить обратно новое <xref:System.Data.DataSet>, включающее исходные данные и последние данные из источника данных (путем повторного запуска исходного запроса), или отправить обратное подмножество с любыми изменениями, внесенными в него из источника данных. (Например, если источник данных автоматически создает уникальные значения первичного ключа, эти значения можно распространить обратно в клиентское приложение.) В любом случае возвращаемый <xref:System.Data.DataSet> можно вернуть обратно в исходное <xref:System.Data.DataSet> клиентского приложения с помощью метода <xref:System.Data.DataSet.Merge%2A>.  
  
 При вызове метода <xref:System.Data.DataSet.Merge%2A> сравниваются схемы двух <xref:System.Data.DataSet> объектов, так как возможно, схемы были изменены. Например, в сценарии "бизнес — бизнес" новые столбцы могут быть добавлены в схему XML автоматическим процессом. Если источник <xref:System.Data.DataSet> содержит элементы схемы (добавленные <xref:System.Data.DataColumn> объекты), отсутствующие в целевом объекте, элементы схемы можно добавить в целевой объект, задав для аргумента `missingSchemaAction` значение `MissingSchemaAction.Add`. В этом случае объединенный <xref:System.Data.DataSet> содержит добавленную схему и данные.  
  
 После слияния схем данные объединяются.  
  
 При объединении нового <xref:System.Data.DataSet> источника в целевой объект все строки источника с <xref:System.Data.DataRowState> значением `Unchanged`, `Modified`или `Deleted` сопоставляются с целевыми строками с теми же значениями первичного ключа. Исходные строки с <xref:System.Data.DataRowState> значением `Added` сопоставляются с новыми целевыми строками с теми же значениями первичного ключа, что и в новых строках источника.  
  
 Во время слияния ограничения отключены. Если какие-либо ограничения не могут быть включены в конце слияния, создается <xref:System.Data.ConstraintException>, а Объединенные данные сохраняются, пока ограничения отключены. В этом случае свойство <xref:System.Data.DataSet.EnforceConstraints%2A> имеет значение `false`, а все строки, которые являются недопустимыми, помечаются как ошибочные. Ошибки необходимо устранить перед попыткой сброса свойства <xref:System.Data.DataSet.EnforceConstraints%2A> в `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet -&gt; unit" Usage="dataSet.Merge dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">Объект <see langword="DataSet" />, данные и схема которого подлежат слиянию.</param>
        <summary>Осуществляет слияние указанного объекта <see cref="T:System.Data.DataSet" /> и его схемы с текущим объектом <see langword="DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.Merge%2A> используется для слияния двух <xref:System.Data.DataSet> объектов, имеющих почти похожие схемы. Слияние обычно используется в клиентском приложении для включения последних изменений из источника данных в существующий <xref:System.Data.DataSet>. Это позволяет клиентскому приложению обновить <xref:System.Data.DataSet> с последними данными из источника данных.  
  
 Метод <xref:System.Data.DataSet.Merge%2A> обычно вызывается в конце последовательности процедур, которые подразумевают проверку изменений, согласование ошибок, обновление источника данных с учетом изменений и, наконец, обновление существующих <xref:System.Data.DataSet>.  
  
 В клиентском приложении обычно есть одна кнопка, которую пользователь может щелкнуть, чтобы собрать измененные данные и проверить их перед отправкой в компонент среднего уровня. В этом сценарии сначала вызывается метод <xref:System.Data.DataSet.GetChanges%2A>. Этот метод возвращает второй <xref:System.Data.DataSet>, оптимизированный для проверки и слияния. Этот второй <xref:System.Data.DataSet> объект содержит только объекты <xref:System.Data.DataTable> и <xref:System.Data.DataRow>, которые были изменены, что привело к подмножеству исходного <xref:System.Data.DataSet>. Это подмножество обычно меньше и, следовательно, более эффективно передается обратно в компонент среднего уровня. Затем компонент среднего уровня обновляет исходный источник данных изменениями с помощью хранимых процедур. После этого средний уровень может отправить обратно новое <xref:System.Data.DataSet>, включающее исходные данные и последние данные из источника данных (путем повторного запуска исходного запроса), или отправить обратное подмножество с любыми изменениями, внесенными в него из источника данных. (Например, если источник данных автоматически создает уникальные значения первичного ключа, эти значения можно распространить обратно в клиентское приложение.) В любом случае возвращаемый <xref:System.Data.DataSet> можно вернуть обратно в исходное <xref:System.Data.DataSet> клиентского приложения с помощью метода <xref:System.Data.DataSet.Merge%2A>.  
  
 При вызове метода <xref:System.Data.DataSet.Merge%2A> сравниваются схемы двух <xref:System.Data.DataSet> объектов, так как возможно, схемы были изменены. Например, в сценарии "бизнес — бизнес" новые столбцы могут быть добавлены в схему XML автоматическим процессом. Если источник <xref:System.Data.DataSet> содержит элементы схемы (добавленные <xref:System.Data.DataColumn> объекты), отсутствующие в целевом объекте, элементы схемы можно добавить в целевой объект, задав для аргумента `missingSchemaAction` значение `MissingSchemaAction.Add`. В этом случае объединенный <xref:System.Data.DataSet> содержит добавленную схему и данные.  
  
 После слияния схем данные объединяются.  
  
 При объединении нового <xref:System.Data.DataSet> источника в целевой объект все строки источника с <xref:System.Data.DataRowState> значением `Unchanged`, `Modified`или `Deleted` сопоставляются с целевыми строками с теми же значениями первичного ключа. Исходные строки с `DataRowState` значением `Added` сопоставляются с новыми целевыми строками с теми же значениями первичного ключа, что и в новых строках источника.  
  
 Во время слияния ограничения отключены. Если в конце слияния не могут быть включены какие-либо ограничения, создается <xref:System.Data.ConstraintException>, а Объединенные данные сохраняются, пока ограничения отключены. В этом случае свойство <xref:System.Data.DataSet.EnforceConstraints%2A> имеет значение `false`, а все строки, которые являются недопустимыми, помечаются как ошибочные. Ошибки необходимо устранить перед попыткой сброса свойства <xref:System.Data.DataSet.EnforceConstraints%2A> в `true`.  
  
   
  
## Examples  
 В следующем примере методы <xref:System.Data.DataSet.GetChanges%2A>, Update и <xref:System.Data.DataSet.Merge%2A> используются в <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Невозможно включить одно или более ограничений.</exception>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="dataSet" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataSet.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">Объект <see cref="T:System.Data.DataTable" />, данные и схема которого подлежат слиянию.</param>
        <summary>Осуществляет слияние указанного объекта <see cref="T:System.Data.DataTable" /> и его схемы с текущим объектом <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.Merge%2A> используется для слияния двух <xref:System.Data.DataSet> объектов, имеющих почти похожие схемы. Слияние обычно используется в клиентском приложении для включения последних изменений из источника данных в существующий <xref:System.Data.DataSet>. Это позволяет клиентскому приложению обновить <xref:System.Data.DataSet> с последними данными из источника данных.  
  
 Метод <xref:System.Data.DataSet.Merge%2A> обычно вызывается в конце последовательности процедур, которые подразумевают проверку изменений, согласование ошибок, обновление источника данных с учетом изменений и, наконец, обновление существующих <xref:System.Data.DataSet>.  
  
 В клиентском приложении обычно есть одна кнопка, которую пользователь может щелкнуть, чтобы собрать измененные данные и проверить их перед отправкой в компонент среднего уровня. В этом сценарии сначала вызывается метод <xref:System.Data.DataSet.GetChanges%2A>. Этот метод возвращает второй <xref:System.Data.DataSet>, оптимизированный для проверки и слияния. Этот второй <xref:System.Data.DataSet> объект содержит только объекты <xref:System.Data.DataTable> и <xref:System.Data.DataRow>, которые были изменены, что привело к подмножеству исходного <xref:System.Data.DataSet>. Это подмножество обычно меньше и, следовательно, более эффективно передается обратно в компонент среднего уровня. Затем компонент среднего уровня обновляет исходный источник данных изменениями с помощью хранимых процедур. После этого средний уровень может отправить обратно новое <xref:System.Data.DataSet>, включающее исходные данные и последние данные из источника данных (путем повторного запуска исходного запроса), или отправить обратное подмножество с любыми изменениями, внесенными в него из источника данных. (Например, если источник данных автоматически создает уникальные значения первичного ключа, эти значения можно распространить обратно в клиентское приложение.) В любом случае возвращаемый <xref:System.Data.DataSet> можно вернуть обратно в исходное <xref:System.Data.DataSet> клиентского приложения с помощью метода <xref:System.Data.DataSet.Merge%2A>.  
  
 При вызове метода <xref:System.Data.DataSet.Merge%2A> сравниваются схемы двух <xref:System.Data.DataSet> объектов, так как возможно, схемы были изменены. Например, в сценарии "бизнес — бизнес" новые столбцы могут быть добавлены в схему XML автоматическим процессом. Если источник <xref:System.Data.DataSet> содержит элементы схемы (добавленные <xref:System.Data.DataColumn> объекты), отсутствующие в целевом объекте, элементы схемы можно добавить в целевой объект, задав для аргумента `missingSchemaAction` значение `MissingSchemaAction.Add`. В этом случае объединенный <xref:System.Data.DataSet> содержит добавленную схему и данные.  
  
 После слияния схем данные объединяются.  
  
 При объединении нового <xref:System.Data.DataSet> источника в целевой объект все строки источника с <xref:System.Data.DataRowState> значением `Unchanged`, `Modified`или `Deleted` сопоставляются с целевыми строками с теми же значениями первичного ключа. Исходные строки с `DataRowState` значением `Added` сопоставляются с новыми целевыми строками с теми же значениями первичного ключа, что и в новых строках источника.  
  
 Во время слияния ограничения отключены. Если в конце слияния не могут быть включены какие-либо ограничения, создается <xref:System.Data.ConstraintException>, а Объединенные данные сохраняются, пока ограничения отключены. В этом случае свойство <xref:System.Data.DataSet.EnforceConstraints%2A> имеет значение `false`, а все строки, которые являются недопустимыми, помечаются как ошибочные. Ошибки необходимо устранить перед попыткой сброса свойства <xref:System.Data.DataSet.EnforceConstraints%2A> в `true`.  
  
   
  
## Examples  
 В следующем примере создается простой <xref:System.Data.DataSet> с одной таблицей, двумя столбцами и десятью строками. Создается вторая <xref:System.Data.DataTable>, идентичная первой. Во вторую таблицу добавляются две строки, которые затем объединяются в <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="table" /> — <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet">Объект <see langword="DataSet" />, данные и схема которого подлежат слиянию.</param>
        <param name="preserveChanges">Значение <see langword="true" />, если необходимо сохранить изменения в текущем объекте <see langword="DataSet" />; в противном случае — значение <see langword="false" />.</param>
        <summary>Осуществляет слияние указанного класса <see cref="T:System.Data.DataSet" /> и его схемы с текущим объектом <see langword="DataSet" />, сохраняя или удаляя любые изменения в этом объекте <see langword="DataSet" /> в соответствии с заданным аргументом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.Merge%2A> используется для слияния двух <xref:System.Data.DataSet> объектов, имеющих почти похожие схемы. Слияние обычно используется в клиентском приложении для включения последних изменений из источника данных в существующий <xref:System.Data.DataSet>. Это позволяет клиентскому приложению обновить <xref:System.Data.DataSet> с последними данными из источника данных.  
  
 Метод <xref:System.Data.DataSet.Merge%2A> обычно вызывается в конце последовательности процедур, которые подразумевают проверку изменений, согласование ошибок, обновление источника данных с учетом изменений и, наконец, обновление существующих <xref:System.Data.DataSet>.  
  
 В клиентском приложении обычно есть одна кнопка, которую пользователь может щелкнуть, чтобы собрать измененные данные и проверить их перед отправкой в компонент среднего уровня. В этом сценарии сначала вызывается метод <xref:System.Data.DataSet.GetChanges%2A>. Этот метод возвращает второй <xref:System.Data.DataSet>, оптимизированный для проверки и слияния. Этот второй <xref:System.Data.DataSet> объект содержит только объекты <xref:System.Data.DataTable> и <xref:System.Data.DataRow>, которые были изменены, что привело к подмножеству исходного <xref:System.Data.DataSet>. Это подмножество обычно меньше и, следовательно, более эффективно передается обратно в компонент среднего уровня. Затем компонент среднего уровня обновляет исходный источник данных изменениями с помощью хранимых процедур. После этого средний уровень может отправить обратно новое <xref:System.Data.DataSet>, включающее исходные данные и последние данные из источника данных (путем повторного запуска исходного запроса), или отправить обратное подмножество с любыми изменениями, внесенными в него из источника данных. (Например, если источник данных автоматически создает уникальные значения первичного ключа, эти значения можно распространить обратно в клиентское приложение.) В любом случае возвращаемый <xref:System.Data.DataSet> можно вернуть обратно в исходное <xref:System.Data.DataSet> клиентского приложения с помощью метода <xref:System.Data.DataSet.Merge%2A>.  
  
 При вызове метода <xref:System.Data.DataSet.Merge%2A> сравниваются схемы двух <xref:System.Data.DataSet> объектов, так как возможно, схемы были изменены. Например, в сценарии "бизнес — бизнес" новые столбцы могут быть добавлены в схему XML автоматическим процессом. Если источник <xref:System.Data.DataSet> содержит элементы схемы (добавленные <xref:System.Data.DataColumn> объекты), отсутствующие в целевом объекте, элементы схемы можно добавить в целевой объект, задав для аргумента `missingSchemaAction` значение `MissingSchemaAction.Add`. В этом случае объединенный <xref:System.Data.DataSet> содержит добавленную схему и данные.  
  
 После слияния схем данные объединяются.  
  
 При объединении нового <xref:System.Data.DataSet> источника в целевой объект все строки источника с <xref:System.Data.DataRowState> значением `Unchanged`, `Modified`или `Deleted` сопоставляются с целевыми строками с теми же значениями первичного ключа. Исходные строки с `DataRowState` значением `Added` сопоставляются с новыми целевыми строками с теми же значениями первичного ключа, что и в новых строках источника.  
  
 Во время слияния ограничения отключены. Если в конце слияния не могут быть включены какие-либо ограничения, создается <xref:System.Data.ConstraintException>, а Объединенные данные сохраняются, пока ограничения отключены. В этом случае свойство <xref:System.Data.DataSet.EnforceConstraints%2A> имеет значение `false`, а все строки, которые являются недопустимыми, помечаются как ошибочные. Ошибки необходимо устранить перед попыткой сброса свойства <xref:System.Data.DataSet.EnforceConstraints%2A> в `true`.  
  
   
  
## Examples  
 В следующем примере создается простой <xref:System.Data.DataSet> с одной таблицей, двумя столбцами и десятью строками. После добавления десяти строк изменяются два значения и добавляется одна строка. Подмножество измененных данных создается с помощью метода <xref:System.Data.DataSet.GetChanges%2A>. После согласования ошибок данные подмножества объединяются в исходный <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (rows, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows">Массив объектов <see cref="T:System.Data.DataRow" />, добавляемый в <see langword="DataSet" />.</param>
        <param name="preserveChanges">Значение <see langword="true" />, если необходимо сохранить изменения в объекте <see langword="DataSet" />; в противном случае — значение <see langword="false" />.</param>
        <param name="missingSchemaAction">Одно из значений <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Осуществляет слияние массива объектов <see cref="T:System.Data.DataRow" /> и текущего объекта <see cref="T:System.Data.DataSet" />, сохраняя или удаляя любые изменения в этом объекте <see langword="DataSet" /> и обрабатывая несовместимую схему в соответствии с заданными аргументами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.Merge%2A> используется для слияния двух <xref:System.Data.DataSet> объектов, имеющих почти похожие схемы. Слияние обычно используется в клиентском приложении для включения последних изменений из источника данных в существующий <xref:System.Data.DataSet>. Это позволяет клиентскому приложению обновить <xref:System.Data.DataSet> с последними данными из источника данных.  
  
 Метод <xref:System.Data.DataSet.Merge%2A> обычно вызывается в конце последовательности процедур, которые подразумевают проверку изменений, согласование ошибок, обновление источника данных с учетом изменений и, наконец, обновление существующих <xref:System.Data.DataSet>.  
  
 В клиентском приложении обычно есть одна кнопка, которую пользователь может щелкнуть, чтобы собрать измененные данные и проверить их перед отправкой в компонент среднего уровня. В этом сценарии сначала вызывается метод <xref:System.Data.DataSet.GetChanges%2A>. Этот метод возвращает второй <xref:System.Data.DataSet>, оптимизированный для проверки и слияния. Этот второй <xref:System.Data.DataSet> объект содержит только объекты <xref:System.Data.DataTable> и <xref:System.Data.DataRow>, которые были изменены, что привело к подмножеству исходного <xref:System.Data.DataSet>. Это подмножество обычно меньше и, следовательно, более эффективно передается обратно в компонент среднего уровня. Затем компонент среднего уровня обновляет исходный источник данных изменениями с помощью хранимых процедур. После этого средний уровень может отправить обратно новое <xref:System.Data.DataSet>, включающее исходные данные и последние данные из источника данных (путем повторного запуска исходного запроса), или отправить обратное подмножество с любыми изменениями, внесенными в него из источника данных. (Например, если источник данных автоматически создает уникальные значения первичного ключа, эти значения можно распространить обратно в клиентское приложение.) В любом случае возвращаемый <xref:System.Data.DataSet> можно вернуть обратно в исходное <xref:System.Data.DataSet> клиентского приложения с помощью метода <xref:System.Data.DataSet.Merge%2A>.  
  
 Чтобы упростить объяснение метода <xref:System.Data.DataSet.Merge%2A>, мы используем "Target" для обозначения текущего <xref:System.Data.DataSet>, а "Source" — на имя второго (Parameter) <xref:System.Data.DataSet>. Целевой <xref:System.Data.DataSet> имеет имя, так как это объект, на котором происходит действие (слияние). Второй <xref:System.Data.DataSet> называется "источником", поскольку содержащиеся в нем сведения не изменяются, а объединяются в текущую <xref:System.Data.DataSet>.  
  
 При вызове метода <xref:System.Data.DataSet.Merge%2A> сравниваются схемы двух <xref:System.Data.DataSet> объектов, так как возможно, схемы были изменены. Например, в сценарии "бизнес — бизнес" новые столбцы могут быть добавлены в схему XML автоматическим процессом. Если источник <xref:System.Data.DataSet> содержит элементы схемы (добавленные <xref:System.Data.DataColumn> объекты), отсутствующие в целевом объекте, элементы схемы можно добавить в целевой объект, задав для аргумента `missingSchemaAction` значение `MissingSchemaAction.Add`. В этом случае объединенный <xref:System.Data.DataSet> содержит добавленную схему и данные.  
  
 После слияния схем данные объединяются.  
  
 При объединении нового <xref:System.Data.DataSet> источника в целевой объект все строки источника с <xref:System.Data.DataRowState> значением `Unchanged`, `Modified`или `Deleted` сопоставляются с целевыми строками с теми же значениями первичного ключа. Исходные строки с `DataRowState` значением `Added` сопоставляются с новыми целевыми строками с теми же значениями первичного ключа, что и в новых строках источника.  
  
 Во время слияния ограничения отключены. Если в конце слияния не могут быть включены какие-либо ограничения, создается <xref:System.Data.ConstraintException>, а Объединенные данные сохраняются, пока ограничения отключены. В этом случае свойство <xref:System.Data.DataSet.EnforceConstraints%2A> имеет значение `false`, а все строки, которые являются недопустимыми, помечаются как ошибочные. Ошибки необходимо устранить перед попыткой сброса свойства <xref:System.Data.DataSet.EnforceConstraints%2A> в `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet">Объект <see langword="DataSet" />, данные и схема которого подлежат слиянию.</param>
        <param name="preserveChanges">Значение <see langword="true" />, если необходимо сохранить изменения в текущем объекте <see langword="DataSet" />; в противном случае — значение <see langword="false" />.</param>
        <param name="missingSchemaAction">Одно из значений перечисления <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <summary>Осуществляет слияние указанного класса <see cref="T:System.Data.DataSet" /> и его схемы с текущим набором данных <see langword="DataSet" />, сохраняя или удаляя любые изменения в текущем наборе данных <see langword="DataSet" /> и обрабатывая несовместимую схему в соответствии с заданными аргументами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.Merge%2A> используется для слияния двух <xref:System.Data.DataSet> объектов, имеющих почти похожие схемы. Слияние обычно используется в клиентском приложении для включения последних изменений из источника данных в существующий <xref:System.Data.DataSet>. Это позволяет клиентскому приложению обновить <xref:System.Data.DataSet> с последними данными из источника данных.  
  
 Метод <xref:System.Data.DataSet.Merge%2A> обычно вызывается в конце последовательности процедур, которые подразумевают проверку изменений, согласование ошибок, обновление источника данных с учетом изменений и, наконец, обновление существующих <xref:System.Data.DataSet>.  
  
 В клиентском приложении обычно есть одна кнопка, которую пользователь может щелкнуть, чтобы собрать измененные данные и проверить их перед отправкой в компонент среднего уровня. В этом сценарии сначала вызывается метод <xref:System.Data.DataSet.GetChanges%2A>. Этот метод возвращает второй <xref:System.Data.DataSet>, оптимизированный для проверки и слияния. Этот второй <xref:System.Data.DataSet> объект содержит только объекты <xref:System.Data.DataTable> и <xref:System.Data.DataRow>, которые были изменены, что привело к подмножеству исходного <xref:System.Data.DataSet>. Это подмножество обычно меньше и, следовательно, более эффективно передается обратно в компонент среднего уровня. Затем компонент среднего уровня обновляет исходный источник данных изменениями с помощью хранимых процедур. После этого средний уровень может отправить обратно новое <xref:System.Data.DataSet>, включающее исходные данные и последние данные из источника данных (путем повторного запуска исходного запроса), или отправить обратное подмножество с любыми изменениями, внесенными в него из источника данных. (Например, если источник данных автоматически создает уникальные значения первичного ключа, эти значения можно распространить обратно в клиентское приложение.) В любом случае возвращаемый <xref:System.Data.DataSet> можно вернуть обратно в исходное <xref:System.Data.DataSet> клиентского приложения с помощью метода <xref:System.Data.DataSet.Merge%2A>.  
  
 Чтобы упростить объяснение метода <xref:System.Data.DataSet.Merge%2A>, мы используем "Target" для обозначения текущего <xref:System.Data.DataSet>, а "Source" — на имя второго (Parameter) <xref:System.Data.DataSet>. Целевой <xref:System.Data.DataSet> имеет имя, так как это объект, на котором происходит действие (слияние). Второй <xref:System.Data.DataSet> называется "источником", поскольку содержащиеся в нем сведения не изменяются, а объединяются в текущую <xref:System.Data.DataSet>.  
  
 При вызове метода <xref:System.Data.DataSet.Merge%2A> сравниваются схемы двух <xref:System.Data.DataSet> объектов, так как возможно, схемы были изменены. Например, в сценарии "бизнес — бизнес" новые столбцы могут быть добавлены в схему XML автоматическим процессом. Если источник <xref:System.Data.DataSet> содержит элементы схемы (добавленные <xref:System.Data.DataColumn> объекты), отсутствующие в целевом объекте, элементы схемы можно добавить в целевой объект, задав для аргумента `missingSchemaAction` значение `MissingSchemaAction.Add`. В этом случае объединенный <xref:System.Data.DataSet> содержит добавленную схему и данные.  
  
 После слияния схем данные объединяются.  
  
 При объединении нового <xref:System.Data.DataSet> источника в целевой объект все строки источника с <xref:System.Data.DataRowState> значением `Unchanged`, `Modified`или `Deleted` сопоставляются с целевыми строками с теми же значениями первичного ключа. Исходные строки с `DataRowState` значением `Added` сопоставляются с новыми целевыми строками с теми же значениями первичного ключа, что и в новых строках источника.  
  
 Во время слияния ограничения отключены. Если в конце слияния не могут быть включены какие-либо ограничения, создается <xref:System.Data.ConstraintException>, а Объединенные данные сохраняются, пока ограничения отключены. В этом случае свойство <xref:System.Data.DataSet.EnforceConstraints%2A> имеет значение `false`, а все строки, которые являются недопустимыми, помечаются как ошибочные. Ошибки необходимо устранить перед попыткой сброса свойства <xref:System.Data.DataSet.EnforceConstraints%2A> в `true`.  
  
   
  
## Examples  
 В следующем примере создается простой <xref:System.Data.DataSet> с одной таблицей, двумя столбцами и десятью строками. Два значения изменяются и добавляется одна строка. Подмножество измененных данных создается с помощью метода <xref:System.Data.DataSet.GetChanges%2A>. После согласования ошибок новый столбец добавляется в подмножество, изменяя схему. При вызове метода <xref:System.Data.DataSet.Merge%2A> с `missingSchemaAction`, для которого задано значение `MissingSchemaAction.Add`, новый столбец добавляется в схему исходного объекта <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="dataSet" /> — <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">Объект <see langword="DataTable" />, данные и схема которого подлежат слиянию.</param>
        <param name="preserveChanges">Одно из значений перечисления <see cref="T:System.Data.MissingSchemaAction" />.</param>
        <param name="missingSchemaAction">Значение <see langword="true" />, если необходимо сохранить изменения в объекте <see langword="DataSet" />; в противном случае — значение <see langword="false" />.</param>
        <summary>Осуществляет слияние указанного класса <see cref="T:System.Data.DataTable" /> и его схемы с текущим объектом <see langword="DataSet" />, сохраняя или удаляя любые изменения в этом объекте <see langword="DataSet" /> и обрабатывая несовместимую схему в соответствии с заданными аргументами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.Merge%2A> используется для слияния двух <xref:System.Data.DataSet> объектов, имеющих почти похожие схемы. Слияние обычно используется в клиентском приложении для включения последних изменений из источника данных в существующий <xref:System.Data.DataSet>. Это позволяет клиентскому приложению обновить <xref:System.Data.DataSet> с последними данными из источника данных.  
  
 Метод <xref:System.Data.DataSet.Merge%2A> обычно вызывается в конце последовательности процедур, которые подразумевают проверку изменений, согласование ошибок, обновление источника данных с учетом изменений и, наконец, обновление существующих <xref:System.Data.DataSet>.  
  
 к клиентскому приложению часто применяется одна кнопка, которую пользователь может щелкнуть, чтобы собрать измененные данные и проверить их перед отправкой в компонент среднего уровня. В этом сценарии сначала вызывается метод <xref:System.Data.DataSet.GetChanges%2A>. Этот метод возвращает второй <xref:System.Data.DataSet>, оптимизированный для проверки и слияния. Этот второй <xref:System.Data.DataSet> объект содержит только объекты <xref:System.Data.DataTable> и <xref:System.Data.DataRow>, которые были изменены, что привело к подмножеству исходного <xref:System.Data.DataSet>. Это подмножество обычно меньше и, следовательно, более эффективно передается обратно в компонент среднего уровня. Затем компонент среднего уровня обновляет исходный источник данных изменениями с помощью хранимых процедур. После этого средний уровень может отправить обратно новое <xref:System.Data.DataSet>, включающее исходные данные и последние данные из источника данных (путем повторного запуска исходного запроса), или отправить обратное подмножество с любыми изменениями, внесенными в него из источника данных. (Например, если источник данных автоматически создает уникальные значения первичного ключа, эти значения можно распространить обратно в клиентское приложение.) В любом случае возвращаемый <xref:System.Data.DataSet> можно вернуть обратно в исходное <xref:System.Data.DataSet> клиентского приложения с помощью метода <xref:System.Data.DataSet.Merge%2A>.  
  
 При вызове метода <xref:System.Data.DataSet.Merge%2A> сравниваются схемы двух <xref:System.Data.DataSet> объектов, так как возможно, схемы были изменены. Например, в сценарии "бизнес — бизнес" новые столбцы могут быть добавлены в схему XML автоматическим процессом. Если источник <xref:System.Data.DataSet> содержит элементы схемы (добавленные <xref:System.Data.DataColumn> объекты), отсутствующие в целевом объекте, элементы схемы можно добавить в целевой объект, задав для аргумента `missingSchemaAction` значение `MissingSchemaAction.Add`. В этом случае объединенный <xref:System.Data.DataSet> содержит добавленную схему и данные.  
  
 После слияния схем данные объединяются.  
  
 При объединении нового <xref:System.Data.DataSet> источника в целевой объект все строки источника с <xref:System.Data.DataRowState> значением `Unchanged`, `Modified`или `Deleted` сопоставляются с целевыми строками с теми же значениями первичного ключа. Исходные строки с `DataRowState` значением `Added` сопоставляются с новыми целевыми строками с теми же значениями первичного ключа, что и в новых строках источника.  
  
 Во время слияния ограничения отключены. Если в конце слияния не могут быть включены какие-либо ограничения, создается <xref:System.Data.ConstraintException>, а Объединенные данные сохраняются, пока ограничения отключены. В этом случае свойство <xref:System.Data.DataSet.EnforceConstraints%2A> имеет значение `false`, а все строки, которые являются недопустимыми, помечаются как ошибочные. Ошибки необходимо устранить перед попыткой сброса свойства <xref:System.Data.DataSet.EnforceConstraints%2A> в `true`.  
  
   
  
## Examples  
 В следующем примере создается простой <xref:System.Data.DataSet> с одной таблицей, двумя столбцами и десятью строками. Создается вторая <xref:System.Data.DataTable>, которая почти идентична первой, за исключением того, что в таблицу добавляется новый `DataColumn`. В вторую таблицу добавляются две строки, которые затем объединяются в <xref:System.Data.DataSet> с аргументом `preserveChanges`, для которого задано значение `false`, а для аргумента `missingSchemaAction` задано значение `MissingSchemaAction.Add`.  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="dataSet" /> — <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MergeFailed As MergeFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::MergeFailedEventHandler ^ MergeFailed;" />
      <MemberSignature Language="F#" Value="member this.MergeFailed : System.Data.MergeFailedEventHandler " Usage="member this.MergeFailed : System.Data.MergeFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetMergeFailedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, если значения первичного ключа конечного и основного объектов <see cref="T:System.Data.DataRow" /> совпадают, а свойство <see cref="P:System.Data.DataSet.EnforceConstraints" /> имеет значение true.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере демонстрируется использование события <xref:System.Data.DataSet.MergeFailed>.  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataSet.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает пространство имен <see cref="T:System.Data.DataSet" />.</summary>
        <value>Пространство имен <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Data.DataSet.Namespace%2A> используется при чтении и записи XML-документа в <xref:System.Data.DataSet> с помощью методов <xref:System.Data.DataSet.ReadXml%2A>, <xref:System.Data.DataSet.WriteXml%2A>, <xref:System.Data.DataSet.ReadXmlSchema%2A>или <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 Пространство имен XML-документа используется для определения области атрибутов и элементов XML при чтении в <xref:System.Data.DataSet>. Например, если <xref:System.Data.DataSet> содержит схему, которая была считана из документа с пространством имен myCompany, и предпринята попытка чтения данных только из документа с другим пространством имен, все данные, не соответствующие существующей схеме, игнорируются.  
  
   
  
## Examples  
 В следующем примере задается <xref:System.Data.DataSet.Prefix%2A> перед вызовом метода <xref:System.Data.DataSet.ReadXml%2A>.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Пространство имен уже содержит данные.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataSet.OnPropertyChanging pcevent" />
      <MemberSignature Language="C#" Value="protected internal virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">Объект <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Общие сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>При переопределении <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> в производном классе обязательно вызовите метод базового класса "<see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />.</para></block>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveRelation (relation As DataRelation)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveRelation(System::Data::DataRelation ^ relation);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveRelation : System.Data.DataRelation -&gt; unit&#xA;override this.OnRemoveRelation : System.Data.DataRelation -&gt; unit" Usage="dataSet.OnRemoveRelation relation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation">Удаляемый объект <see cref="T:System.Data.DataRelation" />.</param>
        <summary>Происходит при удалении объекта <see cref="T:System.Data.DataRelation" /> из <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен быть переопределен подклассами для ограничения удаляемых таблиц  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRemoveTable (System.Data.DataTable table);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRemoveTable (table As DataTable)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveTable : System.Data.DataTable -&gt; unit&#xA;override this.OnRemoveTable : System.Data.DataTable -&gt; unit" Usage="dataSet.OnRemoveTable table" />
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveTable (System.Data.DataTable table);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveTable (table As DataTable)" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">Удаляемый объект <see cref="T:System.Data.DataTable" />.</param>
        <summary>Происходит при удалении объекта <see cref="T:System.Data.DataTable" /> из <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен подклассами для ограничения удаления таблиц.  
  
   
  
## Examples  
 В следующем примере показан класс, производный от <xref:System.Data.DataSet> с переопределением метода <xref:System.Data.DataSet.OnRemoveTable%2A>.  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataSet.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetPrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает префикс XML, который является псевдонимом пространства имен класса <see cref="T:System.Data.DataSet" />.</summary>
        <value>Префикс XML для пространства имен <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство <xref:System.Data.DataSet.Prefix%2A> используется по всему документу XML для обнаружения элементов, принадлежащих пространству имен объекта <xref:System.Data.DataSet> (как задано свойством <xref:System.Data.DataSet.Namespace%2A>).  
  
   
  
## Examples  
 В следующем примере задается <xref:System.Data.DataSet.Prefix%2A> перед вызовом метода <xref:System.Data.DataSet.ReadXml%2A>.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected internal void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RaisePropertyChanging (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RaisePropertyChanging(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RaisePropertyChanging : string -&gt; unit" Usage="dataSet.RaisePropertyChanging name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя свойства, которое нужно изменить.</param>
        <summary>Посылает уведомление об изменении указанного свойства <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Считывает XML-схему и данные в <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Производный объект от класса <see cref="T:System.IO.Stream" />.</param>
        <summary>Считывает XML-схему и данные в <see cref="T:System.Data.DataSet" />, используя указанный класс <see cref="T:System.IO.Stream" />.</summary>
        <returns><see cref="T:System.Data.XmlReadMode" /> служит для чтения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.ReadXml%2A> предоставляет способ чтения только данных либо данных и схемы в <xref:System.Data.DataSet> из XML-документа, в то время как метод <xref:System.Data.DataSet.ReadXmlSchema%2A> считывает только схему. Чтобы считать данные и схему, используйте один из `ReadXML` перегрузок, включающих параметр `mode`, и задайте для него значение `ReadSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.WriteXml%2A> и <xref:System.Data.DataSet.WriteXmlSchema%2A> соответственно. Для записи XML-данных или схемы и данных из `DataSet`используется метод `WriteXml`. Чтобы записать только схему, используйте метод `WriteXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Если указана встроенная схема, то встроенная схема используется для расширения существующей реляционной структуры до загрузки данных. При наличии конфликтов (например, одного столбца в той же таблице, определенной с разными типами данных) возникает исключение.  
  
 Если встроенная схема не указана, то при необходимости реляционная структура расширяется посредством вывода в соответствии со структурой XML-документа. Если схема не может быть расширена посредством вывода, чтобы предоставить все данные, возникает исключение.  
  
> [!NOTE]
>  `DataSet` не связывает XML-элемент с соответствующим `DataColumn` или `DataTable` при экранировании допустимых символов XML, таких как ("_"), в сериализованном XML. Сам по себе `DataSet` не содержит недопустимые символы XML в именах XML-элементов и, следовательно, может использовать только одно и то же. Если допустимые символы в имени XML-элемента экранированы, во время обработки элемент пропускается.  
  
 Если XML-схема для <xref:System.Data.DataSet> включает `targetNamespace`, данные могут быть не считаны, и при вызове <xref:System.Data.DataSet.ReadXml%2A> для загрузки <xref:System.Data.DataSet> с XML, содержащим элементы без соответствующего пространства имен, могут возникнуть исключения. Для чтения неквалифицированных элементов установите `elementFormDefault` равным "квалифицированному" в XML-схеме, как показано в следующем примере.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Если схема <xref:System.Data.DataSet> содержит элементы с одинаковыми именами, но разные типы в одном пространстве имен, при попытке чтения схемы в <xref:System.Data.DataSet> с помощью <xref:System.Data.DataSet.ReadXml%2A> указывается `XmlReadMode.ReadSchema`. Это исключение не происходит при использовании .NET Framework версии 1,0.  
  
   
  
## Examples  
 В следующем примере сначала создается простой <xref:System.Data.DataSet> с одним <xref:System.Data.DataTable>, двумя столбцами и десятью строками. Схема <xref:System.Data.DataSet> и данные записываются на диск путем вызова метода <xref:System.Data.DataSet.WriteXml%2A>. Создается вторая <xref:System.Data.DataSet> и метод <xref:System.Data.DataSet.ReadXml%2A> используется для его заполнения схемой и данными.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Объект <see langword="TextReader" />, из которого считывается схема и данные.</param>
        <summary>Считывает XML-схему и данные в <see cref="T:System.Data.DataSet" />, используя указанный класс <see cref="T:System.IO.TextReader" />.</summary>
        <returns><see cref="T:System.Data.XmlReadMode" /> служит для чтения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.ReadXml%2A> предоставляет способ чтения только данных либо данных и схемы в <xref:System.Data.DataSet> из XML-документа, в то время как метод <xref:System.Data.DataSet.ReadXmlSchema%2A> считывает только схему. Чтобы считать данные и схему, используйте один из `ReadXML` перегрузок, включающих параметр `mode`, и задайте для него значение `ReadSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.WriteXml%2A> и <xref:System.Data.DataSet.WriteXmlSchema%2A> соответственно. Для записи XML-данных или схемы и данных из `DataSet`используется метод `WriteXml`. Чтобы записать только схему, используйте метод `WriteXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Если указана встроенная схема, то встроенная схема используется для расширения существующей реляционной структуры до загрузки данных. При наличии конфликтов (например, одного столбца в той же таблице, определенной с разными типами данных) возникает исключение.  
  
 Если встроенная схема не указана, то при необходимости реляционная структура расширяется посредством вывода в соответствии со структурой XML-документа. Если схема не может быть расширена посредством вывода, чтобы предоставить все данные, возникает исключение.  
  
> [!NOTE]
>  `DataSet` не связывает XML-элемент с соответствующим `DataColumn` или `DataTable` при экранировании допустимых символов XML, таких как ("_"), в сериализованном XML. Сам по себе `DataSet` не содержит недопустимые символы XML в именах XML-элементов и, следовательно, может использовать только одно и то же. Если допустимые символы в имени XML-элемента экранированы, во время обработки элемент пропускается.  
  
 Если XML-схема для <xref:System.Data.DataSet> включает `targetNamespace`, данные могут быть не считаны, и при вызове <xref:System.Data.DataSet.ReadXml%2A> для загрузки <xref:System.Data.DataSet> с XML, содержащим элементы без соответствующего пространства имен, могут возникнуть исключения. Для чтения неквалифицированных элементов установите `elementFormDefault` равным "квалифицированному" в схеме XML, как показано в следующем примере.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 Классы, которые наследуют от класса <xref:System.IO.TextReader>, включают классы <xref:System.IO.StreamReader> и <xref:System.IO.StringReader>.  
  
> [!NOTE]
>  Если схема <xref:System.Data.DataSet> содержит элементы с одинаковыми именами, но разные типы в одном пространстве имен, при попытке чтения схемы в <xref:System.Data.DataSet> с помощью <xref:System.Data.DataSet.ReadXml%2A> указывается `XmlReadMode.ReadSchema`. Это исключение не происходит при использовании .NET Framework версии 1,0.  
  
   
  
## Examples  
 В следующем примере сначала создается простой <xref:System.Data.DataSet> с одним <xref:System.Data.DataTable>, двумя столбцами и десятью строками. Схема <xref:System.Data.DataSet> и данные записываются на диск путем вызова метода <xref:System.Data.DataSet.WriteXml%2A>. Создается вторая <xref:System.Data.DataSet> и метод <xref:System.Data.DataSet.ReadXml%2A> используется для его заполнения схемой и данными.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла (включая путь), из которого производится чтение.</param>
        <summary>Считывает XML-схему и данные в <see cref="T:System.Data.DataSet" />, используя указанный файл.</summary>
        <returns><see langword="XmlReadMode" /> служит для чтения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.ReadXml%2A> предоставляет способ чтения только данных либо данных и схемы в <xref:System.Data.DataSet> из XML-документа, в то время как метод <xref:System.Data.DataSet.ReadXmlSchema%2A> считывает только схему. Чтобы считать данные и схему, используйте один из `ReadXML` перегрузок, включающих параметр `mode`, и задайте для него значение `ReadSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.WriteXml%2A> и <xref:System.Data.DataSet.WriteXmlSchema%2A> соответственно. Для записи XML-данных или схемы и данных из `DataSet`используется метод `WriteXml`. Чтобы записать только схему, используйте метод `WriteXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Если указана встроенная схема, то встроенная схема используется для расширения существующей реляционной структуры до загрузки данных. При наличии конфликтов (например, одного столбца в той же таблице, определенной с разными типами данных) возникает исключение.  
  
 Если встроенная схема не указана, то при необходимости реляционная структура расширяется посредством вывода в соответствии со структурой XML-документа. Если схема не может быть расширена посредством вывода, чтобы предоставить все данные, возникает исключение.  
  
> [!NOTE]
>  `DataSet` не связывает XML-элемент с соответствующим `DataColumn` или `DataTable` при экранировании допустимых символов XML, таких как ("_"), в сериализованном XML. Сам по себе `DataSet` не содержит недопустимые символы XML в именах XML-элементов и, следовательно, может использовать только одно и то же. Если допустимые символы в имени XML-элемента экранированы, во время обработки элемент пропускается.  
  
 Если XML-схема для <xref:System.Data.DataSet> включает `targetNamespace`, то данные могут быть не считаны, и при вызове <xref:System.Data.DataSet.ReadXml%2A> для загрузки <xref:System.Data.DataSet> с XML, содержащим элементы без подходящих пространств имен, могут возникнуть исключения. Для чтения неквалифицированных элементов установите `elementFormDefault` равным "квалифицированному" в схеме XML, как показано в следующем примере.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Если схема <xref:System.Data.DataSet> содержит элементы с одинаковыми именами, но разные типы в одном пространстве имен, при попытке чтения схемы в <xref:System.Data.DataSet> с помощью <xref:System.Data.DataSet.ReadXml%2A> указывается `XmlReadMode.ReadSchema`. Это исключение не происходит при использовании .NET Framework версии 1,0.  
  
   
  
## Examples  
 В следующем примере сначала создается простой <xref:System.Data.DataSet> с одним <xref:System.Data.DataTable>, двумя столбцами и десятью строками. Схема <xref:System.Data.DataSet> и данные записываются на диск путем вызова метода <xref:System.Data.DataSet.WriteXml%2A>. Создается вторая <xref:System.Data.DataSet> и метод <xref:System.Data.DataSet.ReadXml%2A> используется для его заполнения схемой и данными.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Для поля <see cref="T:System.Security.Permissions.FileIOPermission" /> не задан класс <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанное перечисление: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Класс <see cref="T:System.Xml.XmlReader" />, из которого выполняется чтение.</param>
        <summary>Считывает XML-схему и данные в <see cref="T:System.Data.DataSet" />, используя указанный класс <see cref="T:System.Xml.XmlReader" />.</summary>
        <returns><see langword="XmlReadMode" /> служит для чтения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.ReadXml%2A> предоставляет способ чтения только данных либо данных и схемы в <xref:System.Data.DataSet> из XML-документа, в то время как метод <xref:System.Data.DataSet.ReadXmlSchema%2A> считывает только схему. Чтобы считать данные и схему, используйте один из `ReadXML` перегрузок, включающих параметр `mode`, и задайте для него значение `ReadSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.WriteXml%2A> и <xref:System.Data.DataSet.WriteXmlSchema%2A> соответственно. Для записи XML-данных или схемы и данных из `DataSet`используется метод `WriteXml`. Чтобы записать только схему, используйте метод `WriteXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Если указана встроенная схема, то встроенная схема используется для расширения существующей реляционной структуры до загрузки данных. При наличии конфликтов (например, одного столбца в той же таблице, определенной с разными типами данных) возникает исключение.  
  
 Если встроенная схема не указана, то при необходимости реляционная структура расширяется посредством вывода в соответствии со структурой XML-документа. Если схема не может быть расширена посредством вывода, чтобы предоставить все данные, возникает исключение.  
  
> [!NOTE]
>  `DataSet` не связывает XML-элемент с соответствующим `DataColumn` или `DataTable` при экранировании допустимых символов XML, таких как ("_"), в сериализованном XML. Сам по себе `DataSet` не содержит недопустимые символы XML в именах XML-элементов и, следовательно, может использовать только одно и то же. Если допустимые символы в имени XML-элемента экранированы, во время обработки элемент пропускается.  
  
 Если XML-схема для <xref:System.Data.DataSet> включает `targetNamespace`, то данные могут быть не считаны, и при вызове <xref:System.Data.DataSet.ReadXml%2A> для загрузки <xref:System.Data.DataSet> с XML, содержащим элементы без подходящих пространств имен, могут возникнуть исключения. Для чтения неквалифицированных элементов установите `elementFormDefault` равным "квалифицированному" в схеме XML, как показано в следующем примере.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 Тип<xref:System.Xml.XmlTextReader?displayProperty=nameWithType> наследуется от типа <xref:System.Xml.XmlReader>.  
  
> [!NOTE]
>  Если схема <xref:System.Data.DataSet> содержит элементы с одинаковыми именами, но разные типы в одном пространстве имен, при попытке чтения схемы в <xref:System.Data.DataSet> с помощью <xref:System.Data.DataSet.ReadXml%2A> указывается `XmlReadMode.ReadSchema`. Это исключение не происходит при использовании .NET Framework версии 1,0.  
  
   
  
## Examples  
 В следующем примере сначала создается простой <xref:System.Data.DataSet> с одним <xref:System.Data.DataTable>, двумя столбцами и десятью строками. Схема <xref:System.Data.DataSet> и данные записываются на диск путем вызова метода <xref:System.Data.DataSet.WriteXml%2A>. Создается вторая <xref:System.Data.DataSet> и метод <xref:System.Data.DataSet.ReadXml%2A> используется для его заполнения схемой и данными.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">Класс <see cref="T:System.IO.Stream" />, из которого выполняется чтение.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Считывает XML-схему и данные в <see cref="T:System.Data.DataSet" />, используя указанные объекты <see cref="T:System.IO.Stream" /> и <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns><see langword="XmlReadMode" /> служит для чтения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.ReadXml%2A> предоставляет способ чтения только данных либо данных и схемы в <xref:System.Data.DataSet> из XML-документа, в то время как метод <xref:System.Data.DataSet.ReadXmlSchema%2A> считывает только схему. Чтобы считать данные и схему, используйте один из `ReadXML` перегрузок, включающих параметр `mode`, и задайте для него значение `ReadSchema`.  
  
 То же самое относится к методам <xref:System.Data.DataSet.WriteXml%2A> и <xref:System.Data.DataSet.WriteXmlSchema%2A> соответственно. Для записи XML-данных или схемы и данных из `DataSet`используется метод `WriteXml`. Чтобы записать только схему, используйте метод `WriteXmlSchema`.  
  
> [!NOTE]
>  При использовании <xref:System.Data.DataSet.ReadXml%2A> и задании <xref:System.Data.XmlReadMode> для `Diffgram`, содержимое целевого `DataSet` и исходного `DataSet` может отличаться из-за создания и обработки DiffGram. Дополнительные сведения о дельтами см. в разделе [дельтами](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md).  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Если указана встроенная схема, то встроенная схема используется для расширения существующей реляционной структуры до загрузки данных. При наличии конфликтов (например, одного столбца в той же таблице, определенной с разными типами данных) возникает исключение.  
  
 Если встроенная схема не указана, то при необходимости реляционная структура расширяется посредством вывода в соответствии со структурой XML-документа. Если схема не может быть расширена посредством вывода, чтобы предоставить все данные, возникает исключение.  
  
> [!NOTE]
>  `DataSet` не связывает XML-элемент с соответствующим `DataColumn` или `DataTable` при экранировании допустимых символов XML, таких как ("_"), в сериализованном XML. Сам по себе `DataSet` не содержит недопустимые символы XML в именах XML-элементов и, следовательно, может использовать только одно и то же. Если допустимые символы в имени XML-элемента экранированы, во время обработки элемент пропускается.  
  
 Если XML-схема для <xref:System.Data.DataSet> включает `targetNamespace`, данные могут быть не считаны, и при вызове <xref:System.Data.DataSet.ReadXml%2A> для загрузки <xref:System.Data.DataSet> с XML, содержащим элементы без соответствующего пространства имен, могут возникнуть исключения. Для чтения неквалифицированных элементов установите `elementFormDefault` равным "квалифицированному" в схеме XML, как показано в следующем примере.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Если схема <xref:System.Data.DataSet> содержит элементы с одинаковыми именами, но разные типы в одном пространстве имен, при попытке чтения схемы в <xref:System.Data.DataSet> с помощью <xref:System.Data.DataSet.ReadXml%2A> указывается `XmlReadMode.ReadSchema`. Это исключение не происходит при использовании .NET Framework версии 1,0.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">Класс <see cref="T:System.IO.TextReader" />, из которого выполняется чтение.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Считывает XML-схему и данные в <see cref="T:System.Data.DataSet" />, используя указанные объекты <see cref="T:System.IO.TextReader" /> и <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns><see langword="XmlReadMode" /> служит для чтения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.ReadXml%2A> предоставляет способ чтения только данных либо данных и схемы в <xref:System.Data.DataSet> из XML-документа, в то время как метод <xref:System.Data.DataSet.ReadXmlSchema%2A> считывает только схему. Чтобы считать данные и схему, используйте один из `ReadXML` перегрузок, включающих параметр `mode`, и задайте для него значение `ReadSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.WriteXml%2A> и <xref:System.Data.DataSet.WriteXmlSchema%2A> соответственно. Для записи XML-данных или схемы и данных из `DataSet`используется метод `WriteXml`. Чтобы записать только схему, используйте метод `WriteXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Если указана встроенная схема, то встроенная схема используется для расширения существующей реляционной структуры до загрузки данных. При наличии конфликтов (например, одного столбца в той же таблице, определенной с разными типами данных) возникает исключение.  
  
 Если встроенная схема не указана, то при необходимости реляционная структура расширяется посредством вывода в соответствии со структурой XML-документа. Если схема не может быть расширена посредством вывода, чтобы предоставить все данные, возникает исключение.  
  
> [!NOTE]
>  `DataSet` не связывает XML-элемент с соответствующим `DataColumn` или `DataTable` при экранировании допустимых символов XML, таких как ("_"), в сериализованном XML. Сам по себе `DataSet` не содержит недопустимые символы XML в именах XML-элементов и, следовательно, может использовать только одно и то же. Если допустимые символы в имени XML-элемента экранированы, во время обработки элемент пропускается.  
  
 Если XML-схема для <xref:System.Data.DataSet> включает `targetNamespace`, данные могут быть не считаны, и при вызове <xref:System.Data.DataSet.ReadXml%2A> для загрузки <xref:System.Data.DataSet> с XML, содержащим элементы без соответствующего пространства имен, могут возникнуть исключения. Для чтения неквалифицированных элементов установите `elementFormDefault` равным "квалифицированному" в схеме XML, как показано в следующем примере.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Если схема <xref:System.Data.DataSet> содержит элементы с одинаковыми именами, но разные типы в одном пространстве имен, при попытке чтения схемы в <xref:System.Data.DataSet> с помощью <xref:System.Data.DataSet.ReadXml%2A> указывается `XmlReadMode.ReadSchema`. Это исключение не происходит при использовании .NET Framework версии 1,0.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла (включая путь), из которого производится чтение.</param>
        <param name="mode">Одно из значений <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Считывает XML-схему и данные в <see cref="T:System.Data.DataSet" />, используя указанный файл и <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns><see langword="XmlReadMode" /> служит для чтения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.ReadXml%2A> предоставляет способ чтения только данных либо данных и схемы в <xref:System.Data.DataSet> из XML-документа, в то время как метод <xref:System.Data.DataSet.ReadXmlSchema%2A> считывает только схему. Чтобы считать данные и схему, используйте один из `ReadXML` перегрузок, включающих параметр `mode`, и задайте для него значение `ReadSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.WriteXml%2A> и <xref:System.Data.DataSet.WriteXmlSchema%2A> соответственно. Для записи XML-данных или схемы и данных из `DataSet`используется метод `WriteXml`. Чтобы записать только схему, используйте метод `WriteXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Если указана встроенная схема, то встроенная схема используется для расширения существующей реляционной структуры до загрузки данных. При наличии конфликтов (например, одного столбца в той же таблице, определенной с разными типами данных) возникает исключение.  
  
 Если встроенная схема не указана, то при необходимости реляционная структура расширяется посредством вывода в соответствии со структурой XML-документа. Если схема не может быть расширена посредством вывода, чтобы предоставить все данные, возникает исключение.  
  
> [!NOTE]
>  `DataSet` не связывает XML-элемент с соответствующим `DataColumn` или `DataTable` при экранировании допустимых символов XML, таких как ("_"), в сериализованном XML. Сам по себе `DataSet` не содержит недопустимые символы XML в именах XML-элементов и, следовательно, может использовать только одно и то же. Если допустимые символы в имени XML-элемента экранированы, во время обработки элемент пропускается.  
  
 Если XML-схема для <xref:System.Data.DataSet> включает `targetNamespace`, то данные могут быть не считаны, и при вызове <xref:System.Data.DataSet.ReadXml%2A> для загрузки <xref:System.Data.DataSet> с XML, содержащим элементы без подходящих пространств имен, могут возникнуть исключения. Для чтения неквалифицированных элементов установите `elementFormDefault` равным "квалифицированному" в схеме XML, как показано в следующем примере.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Если схема <xref:System.Data.DataSet> содержит элементы с одинаковыми именами, но разные типы в одном пространстве имен, при попытке чтения схемы в <xref:System.Data.DataSet> с помощью <xref:System.Data.DataSet.ReadXml%2A> указывается `XmlReadMode.ReadSchema`. Это исключение не происходит при использовании .NET Framework версии 1,0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Для поля <see cref="T:System.Security.Permissions.FileIOPermission" /> не задан класс <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанное перечисление: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">Класс <see cref="T:System.Xml.XmlReader" />, из которого выполняется чтение.</param>
        <param name="mode">Одно из значений <see cref="T:System.Data.XmlReadMode" />.</param>
        <summary>Считывает XML-схему и данные в <see cref="T:System.Data.DataSet" />, используя указанные объекты <see cref="T:System.Xml.XmlReader" /> и <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns><see langword="XmlReadMode" /> служит для чтения данных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Data.DataSet.ReadXml%2A> предоставляет способ чтения только данных либо данных и схемы в <xref:System.Data.DataSet> из XML-документа, в то время как метод <xref:System.Data.DataSet.ReadXmlSchema%2A> считывает только схему. Чтобы считать данные и схему, используйте один из `ReadXML` перегрузок, включающих параметр `mode`, и задайте для него значение `ReadSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.WriteXml%2A> и <xref:System.Data.DataSet.WriteXmlSchema%2A> соответственно. Для записи XML-данных или схемы и данных из `DataSet`используется метод `WriteXml`. Чтобы записать только схему, используйте метод `WriteXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Если указана встроенная схема, то встроенная схема используется для расширения существующей реляционной структуры до загрузки данных. При наличии конфликтов (например, одного столбца в той же таблице, определенной с разными типами данных) возникает исключение.  
  
 Если встроенная схема не указана, то при необходимости реляционная структура расширяется посредством вывода в соответствии со структурой XML-документа. Если схема не может быть расширена посредством вывода, чтобы предоставить все данные, возникает исключение.  
  
> [!NOTE]
>  `DataSet` не связывает XML-элемент с соответствующим `DataColumn` или `DataTable` при экранировании допустимых символов XML, таких как ("_"), в сериализованном XML. Сам по себе `DataSet` не содержит недопустимые символы XML в именах XML-элементов и, следовательно, может использовать только одно и то же. Если допустимые символы в имени XML-элемента экранированы, во время обработки элемент пропускается.  
  
 Если XML-схема для <xref:System.Data.DataSet> включает `targetNamespace`, то данные могут быть не считаны, и при вызове <xref:System.Data.DataSet.ReadXml%2A> для загрузки <xref:System.Data.DataSet> с XML, содержащим элементы без подходящих пространств имен, могут возникнуть исключения. Для чтения неквалифицированных элементов установите `elementFormDefault` равным "квалифицированному" в схеме XML, как показано в следующем примере.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Если схема <xref:System.Data.DataSet> содержит элементы с одинаковыми именами, но разные типы в одном пространстве имен, при попытке чтения схемы в <xref:System.Data.DataSet> с помощью <xref:System.Data.DataSet.ReadXml%2A> указывается `XmlReadMode.ReadSchema`. Это исключение не происходит при использовании .NET Framework версии 1,0.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Считывает схему XML в таблицу <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Класс <see cref="T:System.IO.Stream" />, из которого выполняется чтение.</param>
        <summary>Считывает XML-схему из указанного класса <see cref="T:System.IO.Stream" /> в класс <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.Data.DataSet.ReadXmlSchema%2A>, чтобы создать схему для <xref:System.Data.DataSet>. Схема включает определения таблиц, связей и ограничений. Чтобы записать схему в XML-документ, используйте метод <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 Схема XML написана с использованием стандарта XSD.  
  
> [!NOTE]
>  Повреждение данных может возникать, если типы msdata: DataType и xs: Type не совпадают. Исключение не создается.  
  
 Метод <xref:System.Data.DataSet.ReadXmlSchema%2A> обычно вызывается перед вызовом метода <xref:System.Data.DataSet.ReadXml%2A>, который используется для заполнения <xref:System.Data.DataSet>.  
  
 Классы, производные от класса <xref:System.IO.Stream>, включают <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>и <xref:System.Net.Sockets.NetworkStream>.  
  
> [!NOTE]
>  Если схема <xref:System.Data.DataSet> содержит элементы с одинаковыми именами, но разные типы в одном пространстве имен, при попытке чтения схемы в <xref:System.Data.DataSet> с помощью <xref:System.Data.DataSet.ReadXmlSchema%2A>возникает исключение. Это исключение не происходит при использовании .NET Framework версии 1,0.  
  
   
  
## Examples  
 В следующем примере создается объект <xref:System.IO.FileStream> для чтения схемы XML с помощью и вызывается метод <xref:System.Data.DataSet.ReadXmlSchema%2A> с объектом.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Класс <see cref="T:System.IO.TextReader" />, из которого выполняется чтение.</param>
        <summary>Считывает XML-схему из указанного класса <see cref="T:System.IO.TextReader" /> в класс <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.Data.DataSet.ReadXmlSchema%2A>, чтобы создать схему для <xref:System.Data.DataSet>. Схема включает определения таблиц, связей и ограничений. Чтобы записать схему в XML-документ, используйте метод <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 Схема XML написана с использованием стандарта XSD.  
  
> [!NOTE]
>  Повреждение данных может возникать, если типы msdata: DataType и xs: Type не совпадают. Исключение не создается.  
  
 Метод <xref:System.Data.DataSet.ReadXmlSchema%2A> обычно вызывается перед вызовом метода <xref:System.Data.DataSet.ReadXml%2A>, который используется для заполнения <xref:System.Data.DataSet>.  
  
 Классы, которые наследуют от класса <xref:System.IO.TextReader>, включают классы <xref:System.IO.StreamReader> и <xref:System.IO.StringReader>.  
  
> [!NOTE]
>  Если схема <xref:System.Data.DataSet> содержит элементы с одинаковыми именами, но разные типы в одном пространстве имен, при попытке чтения схемы в <xref:System.Data.DataSet> с помощью <xref:System.Data.DataSet.ReadXmlSchema%2A>возникает исключение. Это исключение не происходит при использовании .NET Framework версии 1,0.  
  
   
  
## Examples  
 В следующем примере создается объект <xref:System.IO.StreamReader> для чтения схемы с помощью и вызывается метод <xref:System.Data.DataSet.ReadXmlSchema%2A> с объектом.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataSet.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла (включая путь), из которого производится чтение.</param>
        <summary>Считывает XML-схему из указанного файла в класс <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.Data.DataSet.ReadXmlSchema%2A>, чтобы создать схему для <xref:System.Data.DataSet>. Схема включает определения таблиц, связей и ограничений. Чтобы записать схему в XML-документ, используйте метод <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 Схема XML написана с использованием стандарта XSD.  
  
> [!NOTE]
>  Повреждение данных может возникать, если типы msdata: DataType и xs: Type не совпадают. Исключение не создается.  
  
 Метод <xref:System.Data.DataSet.ReadXmlSchema%2A> обычно вызывается перед вызовом метода <xref:System.Data.DataSet.ReadXml%2A>, который используется для заполнения <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Если схема <xref:System.Data.DataSet> содержит элементы с одинаковыми именами, но разные типы в одном пространстве имен, при попытке чтения схемы в <xref:System.Data.DataSet> с помощью <xref:System.Data.DataSet.ReadXmlSchema%2A>возникает исключение. Это исключение не происходит при использовании .NET Framework версии 1,0.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Для поля <see cref="T:System.Security.Permissions.FileIOPermission" /> не задан класс <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанное перечисление: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Класс <see cref="T:System.Xml.XmlReader" />, из которого выполняется чтение.</param>
        <summary>Считывает XML-схему из указанного класса <see cref="T:System.Xml.XmlReader" /> в класс <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.Data.DataSet.ReadXmlSchema%2A>, чтобы создать схему для <xref:System.Data.DataSet>. Схема включает определения таблиц, связей и ограничений.  
  
 Схема XML написана с использованием стандарта XSD.  
  
> [!NOTE]
>  Повреждение данных может возникать, если типы msdata: DataType и xs: Type не совпадают. Исключение не создается.  
  
 Метод <xref:System.Data.DataSet.ReadXmlSchema%2A> обычно вызывается перед вызовом метода <xref:System.Data.DataSet.ReadXml%2A>, который используется для заполнения <xref:System.Data.DataSet>.  
  
 Класс <xref:System.Xml.XmlReader?displayProperty=nameWithType> является абстрактным. Класс, наследующий от `XmlReader`, является классом <xref:System.Xml.XmlTextReader?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Если схема <xref:System.Data.DataSet> содержит элементы с одинаковыми именами, но разные типы в одном пространстве имен, при попытке чтения схемы в <xref:System.Data.DataSet> с помощью <xref:System.Data.DataSet.ReadXmlSchema%2A>возникает исключение. Это исключение не происходит при использовании .NET Framework версии 1,0.  
  
   
  
## Examples  
 В следующем примере создается новый объект <xref:System.Data.DataSet> и <xref:System.IO.FileStream?displayProperty=nameWithType>. Объект <xref:System.IO.FileStream>, созданный с помощью пути к файлу и имени файла, используется для создания <xref:System.Xml.XmlTextReader?displayProperty=nameWithType>, который передается в качестве аргумента методу <xref:System.Data.DataSet.ReadXmlSchema%2A>.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Указанное средство чтения XML.</param>
        <summary>Игнорирует атрибуты и возвращает пустой DataSet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RejectChanges();" />
      <MemberSignature Language="F#" Value="abstract member RejectChanges : unit -&gt; unit&#xA;override this.RejectChanges : unit -&gt; unit" Usage="dataSet.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет все изменения, внесенные в класс <see cref="T:System.Data.DataSet" /> после его создания или после последнего вызова метода <see cref="M:System.Data.DataSet.AcceptChanges" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите <xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType>, чтобы вызвать метод <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> для всех <xref:System.Data.DataTable> объектов, содержащихся в <xref:System.Data.DataSet>.  
  
 <xref:System.Data.DataRow> объекты, содержащиеся в <xref:System.Data.DataSet>, можно задать в режиме редактирования, вызвав метод <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType>. После вызова метода <xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType> изменения могут быть отклонены путем вызова <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> на <xref:System.Data.DataTable>, к которому относятся объекты <xref:System.Data.DataRow>.  
  
 При вызове метода <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> все строки, находясь в режиме правки, отменяют свои изменения. Новые строки удаляются. Измененные и удаленные строки возвращаются в исходное состояние (`DataRowState.Unchanged`).  
  
 Метод AcceptChanges и RejectChanges применим только к <xref:System.Data.DataRow> связанным изменениям (то есть `Add`, `Remove`, `Delete`и `Modify`). Они неприменимы к изменениям схемы или структурной структуры.  
  
   
  
## Examples  
 В следующем примере показан класс, производный от класса <xref:System.Data.DataSet>. Событие <xref:System.Data.DataSet.RejectChanges%2A> вызывается в функции.  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Relations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ Relations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Relations : System.Data.DataRelationCollection" Usage="System.Data.DataSet.Relations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию соотношений, связывающих таблицы и позволяющих переходить от родительских таблиц к дочерним.</summary>
        <value>Объект <see cref="T:System.Data.DataRelationCollection" />, содержащий коллекцию объектов <see cref="T:System.Data.DataRelation" />. Если отсутствуют объекты <see cref="T:System.Data.DataRelation" /> возвращается пустая коллекция.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере выводится имя столбца всех дочерних таблиц с помощью свойства <xref:System.Data.DataSet.Relations%2A>.  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataSet.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Data.SerializationFormat" /> для набора данных <see cref="T:System.Data.DataSet" />, который используется для удаленного взаимодействия.</summary>
        <value>Объект <see cref="T:System.Data.SerializationFormat" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataSet.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Очищает все таблицы и удаляет все связи, внешние ограничения и таблицы из <see cref="T:System.Data.DataSet" />. Для восстановления исходного состояния класса <see cref="M:System.Data.DataSet.Reset" /> необходимо переопределить метод <see cref="T:System.Data.DataSet" /> в подклассах.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SchemaSerializationMode As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::SchemaSerializationMode SchemaSerializationMode { System::Data::SchemaSerializationMode get(); void set(System::Data::SchemaSerializationMode value); };" />
      <MemberSignature Language="F#" Value="member this.SchemaSerializationMode : System.Data.SchemaSerializationMode with get, set" Usage="System.Data.DataSet.SchemaSerializationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает объект <see cref="T:System.Data.SchemaSerializationMode" /> для <see cref="T:System.Data.DataSet" />.</summary>
        <value>Объект <see cref="T:System.Data.SchemaSerializationMode" /> для <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet> сериализует свою схему и данные экземпляра по умолчанию в веб-службах и сценариях удаленного взаимодействия. Установка свойства <xref:System.Data.DataSet.SchemaSerializationMode%2A> типизированного `DataSet` в <xref:System.Data.SchemaSerializationMode.ExcludeSchema> приводит к исключению сведений о схеме из полезных данных сериализации.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> поддерживается только для типизированных `DataSet`. Для нетипизированного `DataSet` этому свойству можно присвоить только значение <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> следует использовать только в тех случаях, когда сведения о схеме базового типизированного `DataTables`, `DataRelations` и `Constraints` не были изменены. Если произошли изменения, полные сведения о схеме должны быть сериализованы с помощью <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> поддерживается в версии 2,0 .NET Framework или более поздней версии.  
  
 Если задан параметр <xref:System.Data.SchemaSerializationMode.ExcludeSchema>, сериализуются только свойства среды выполнения верхнего уровня, имеющиеся в <xref:System.Data.DataSet>. Кроме того, они сериализуются только в том случае, если они отличаются от значений по умолчанию. Ни один из `Tables`не сериализуется `Relations` или `Constraints`. Сериализованные свойства среды выполнения включают <xref:System.Data.DataSet.DataSetName%2A>, <xref:System.Data.DataSet.Namespace%2A>, <xref:System.Data.DataSet.Prefix%2A>, <xref:System.Data.DataSet.Locale%2A>, <xref:System.Data.DataSet.EnforceConstraints%2A>и <xref:System.Data.DataSet.CaseSensitive%2A>. Эти свойства сериализуются, чтобы обеспечить сохранение общей целостности данных среды выполнения.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeRelations () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeRelations();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeRelations : unit -&gt; bool&#xA;override this.ShouldSerializeRelations : unit -&gt; bool" Usage="dataSet.ShouldSerializeRelations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает значение, определяющее необходимость сохранения значения свойства <see cref="P:System.Data.DataSet.Relations" />.</summary>
        <returns>Значение <see langword="true" />, если значение свойства было изменено (относительно своего значения по умолчанию); в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обычно используется при создании конструктора для <xref:System.Data.DataSet>или при создании собственного элемента управления, включающего <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 В следующих примерах показан класс, производный от класса <xref:System.Data.DataSet>. Методы <xref:System.Data.DataSet.Reset%2A> и <xref:System.Data.DataSet.ShouldSerializeRelations%2A> вызываются из функций в производном классе.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTables () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTables();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeTables : unit -&gt; bool&#xA;override this.ShouldSerializeTables : unit -&gt; bool" Usage="dataSet.ShouldSerializeTables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает значение, определяющее необходимость сохранения значения свойства <see cref="P:System.Data.DataSet.Tables" />.</summary>
        <returns>Значение <see langword="true" />, если значение свойства было изменено (относительно своего значения по умолчанию); в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обычно используется, только если вы создаете конструктор для <xref:System.Data.DataSet> или создаете собственный элемент управления, включающий <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 В следующем примере показан класс, производный от класса <xref:System.Data.DataSet>. Метод <xref:System.Data.DataSet.ShouldSerializeTables%2A> вызывается из функций в производном классе.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataSet.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает тип <see cref="T:System.ComponentModel.ISite" /> для объекта <see cref="T:System.Data.DataSet" />.</summary>
        <value>Интерфейс <see cref="T:System.ComponentModel.ISite" /> для <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сайты привязывают <xref:System.ComponentModel.Component> к <xref:System.ComponentModel.Container> и обеспечивают обмен данными между ними, а также предоставляют контейнеру способ управления его компонентами.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IListSource.ContainsListCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Описание этого члена см. в разделе <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>Описание этого члена см. в разделе <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Data.DataSet> приведен к типу интерфейса <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IListSource.GetList</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Описание этого члена см. в разделе <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Описание этого члена см. в разделе <see cref="M:System.ComponentModel.IListSource.GetList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Data.DataSet> приведен к типу интерфейса <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> для заполнения данными.</param>
        <param name="context">Конечный объект (см. <see cref="T:System.Runtime.Serialization.StreamingContext" />) для этой сериализации.</param>
        <summary>Заполняет объект сведений о сериализации данными, необходимыми для сериализации <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Описание этого члена см. в разделе <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Описание этого члена см. в разделе <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Data.DataSet> приведен к типу интерфейса <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Объект <see cref="T:System.Xml.XmlReader" />.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Data.DataSet> приведен к типу интерфейса <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Xml.XmlWriter" />.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Data.DataSet> приведен к типу интерфейса <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tables As DataTableCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataTableCollection ^ Tables { System::Data::DataTableCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Tables : System.Data.DataTableCollection" Usage="System.Data.DataSet.Tables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetTablesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию таблиц класса <see cref="T:System.Data.DataSet" />.</summary>
        <value>Коллекция <see cref="T:System.Data.DataTableCollection" />, содержащаяся в этом наборе данных <see cref="T:System.Data.DataSet" />. Если отсутствуют объекты <see cref="T:System.Data.DataTable" /> возвращается пустая коллекция.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы добавить таблицы в коллекцию, используйте метод <xref:System.Data.DataTableCollection.Add%2A> <xref:System.Data.DataTableCollection>. Чтобы удалить таблицы, используйте метод <xref:System.Data.DataTableCollection.Remove%2A>.  
  
   
  
## Examples  
 В следующем примере возвращается <xref:System.Data.DataTableCollection>объекта <xref:System.Data.DataSet> и выводятся столбцы и строки в каждой таблице.  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает XML-данные и по возможности схемы из <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Объект <see cref="T:System.IO.Stream" />, используемый для записи в файл.</param>
        <summary>Записывает текущие данные для <see cref="T:System.Data.DataSet" /> с помощью указанного объекта <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `WriteXml` предоставляет способ записи либо данных, либо схемы из <xref:System.Data.DataSet> в XML-документ, в то время как метод <xref:System.Data.DataSet.WriteXmlSchema%2A> записывает только схему. Чтобы записать данные и схему, используйте одну из перегрузок, которая включает параметр `mode`, и присвойте ей значение `WriteSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.ReadXml%2A> и <xref:System.Data.DataSet.ReadXmlSchema%2A> соответственно. Для чтения XML-данных или схемы и данных в `DataSet`используйте метод `ReadXml`. Чтобы прочитать только схему, используйте метод `ReadXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 В следующем примере создается объект <xref:System.IO.FileStream?displayProperty=nameWithType>. Затем объект используется с методом <xref:System.Data.DataSet.WriteXml%2A> для записи XML-документа.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, используемый для записи.</param>
        <summary>Записывает текущие данные для <see cref="T:System.Data.DataSet" /> с помощью указанного объекта <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `WriteXml` предоставляет способ записи либо данных, либо схемы из <xref:System.Data.DataSet> в XML-документ, в то время как метод <xref:System.Data.DataSet.WriteXmlSchema%2A> записывает только схему. Чтобы записать данные и схему, используйте одну из перегрузок, которая включает параметр `mode`, и присвойте ей значение `WriteSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.ReadXml%2A> и <xref:System.Data.DataSet.ReadXmlSchema%2A> соответственно. Для чтения XML-данных или схемы и данных в `DataSet`используйте метод `ReadXml`. Чтобы прочитать только схему, используйте метод `ReadXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataSet.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла (включая путь), в который производится запись.</param>
        <summary>Записывает текущие данные для <see cref="T:System.Data.DataSet" /> в указанный файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `WriteXml` предоставляет способ записи либо данных, либо схемы из <xref:System.Data.DataSet> в XML-документ, в то время как метод <xref:System.Data.DataSet.WriteXmlSchema%2A> записывает только схему. Чтобы записать данные и схему, используйте одну из перегрузок, которая включает параметр `mode`, и присвойте ей значение `WriteSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.ReadXml%2A> и <xref:System.Data.DataSet.ReadXmlSchema%2A> соответственно. Для чтения XML-данных или схемы и данных в `DataSet`используйте метод `ReadXml`. Чтобы прочитать только схему, используйте метод `ReadXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Для поля <see cref="T:System.Security.Permissions.FileIOPermission" /> не задан класс <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанное перечисление: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Класс <see cref="T:System.Xml.XmlWriter" />, с помощью которого осуществляется запись.</param>
        <summary>Записывает текущие данные для <see cref="T:System.Data.DataSet" /> в указанный класс <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `WriteXml` предоставляет способ записи либо данных, либо схемы из <xref:System.Data.DataSet> в XML-документ, в то время как метод <xref:System.Data.DataSet.WriteXmlSchema%2A> записывает только схему. Чтобы записать данные и схему, используйте одну из перегрузок, которая включает параметр `mode`, и присвойте ей значение `WriteSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.ReadXml%2A> и <xref:System.Data.DataSet.ReadXmlSchema%2A> соответственно. Для чтения XML-данных или схемы и данных в `DataSet`используйте метод `ReadXml`. Чтобы прочитать только схему, используйте метод `ReadXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Объект <see cref="T:System.IO.Stream" />, используемый для записи в файл.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Записывает текущие данные и по возможности схему для <see cref="T:System.Data.DataSet" /> с помощью указанных <see cref="T:System.IO.Stream" /> и  <see cref="T:System.Data.XmlWriteMode" />. Чтобы записать схему, задайте в параметре <paramref name="mode" /> значение <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `WriteXml` предоставляет способ записи либо данных, либо схемы из <xref:System.Data.DataSet> в XML-документ, в то время как метод <xref:System.Data.DataSet.WriteXmlSchema%2A> записывает только схему. Чтобы записать данные и схему, задайте для параметра `mode` значение `WriteSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.ReadXml%2A> и <xref:System.Data.DataSet.ReadXmlSchema%2A> соответственно. Для чтения XML-данных или схемы и данных в `DataSet`используйте метод `ReadXml`. Чтобы прочитать только схему, используйте метод `ReadXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, используемый для записи документа.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Записывает текущие данные и по возможности схему для <see cref="T:System.Data.DataSet" /> с помощью указанных <see cref="T:System.IO.TextWriter" /> и  <see cref="T:System.Data.XmlWriteMode" />. Чтобы записать схему, задайте в параметре <paramref name="mode" /> значение <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `WriteXml` предоставляет способ записи либо данных, либо схемы из <xref:System.Data.DataSet> в XML-документ, в то время как метод <xref:System.Data.DataSet.WriteXmlSchema%2A> записывает только схему. Чтобы записать данные и схему, задайте для параметра `mode` значение `WriteSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.ReadXml%2A> и <xref:System.Data.DataSet.ReadXmlSchema%2A> соответственно. Для чтения XML-данных или схемы и данных в `DataSet`используйте метод `ReadXml`. Чтобы прочитать только схему, используйте метод `ReadXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 В следующем примере сначала создается простой <xref:System.Data.DataSet> с одним <xref:System.Data.DataTable>, двумя столбцами и десятью строками. Схема <xref:System.Data.DataSet> и данные записываются на диск путем вызова метода <xref:System.Data.DataSet.WriteXml%2A>. Создается вторая <xref:System.Data.DataSet> и метод <xref:System.Data.DataSet.ReadXml%2A> используется для его заполнения схемой и данными.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла (включая путь), в который производится запись.</param>
        <param name="mode">Одно из значений <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Записывает текущие данные и по возможности схему для <see cref="T:System.Data.DataSet" /> в указанный файл с помощью заданного объекта <see cref="T:System.Data.XmlWriteMode" />. Чтобы записать схему, задайте в параметре <paramref name="mode" /> значение <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `WriteXml` предоставляет способ записи либо данных, либо схемы из <xref:System.Data.DataSet> в XML-документ, в то время как метод <xref:System.Data.DataSet.WriteXmlSchema%2A> записывает только схему. Чтобы записать данные и схему, задайте для параметра `mode` значение `WriteSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.ReadXml%2A> и <xref:System.Data.DataSet.ReadXmlSchema%2A> соответственно. Для чтения XML-данных или схемы и данных в `DataSet`используйте метод `ReadXml`. Чтобы прочитать только схему, используйте метод `ReadXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 В следующем примере используется метод <xref:System.Data.DataSet.WriteXml%2A> для записи XML-документа.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Для поля <see cref="T:System.Security.Permissions.FileIOPermission" /> не задан класс <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанное перечисление: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Класс <see cref="T:System.Xml.XmlWriter" />, с помощью которого осуществляется запись.</param>
        <param name="mode">Одно из значений перечисления <see cref="T:System.Data.XmlWriteMode" />.</param>
        <summary>Записывает текущие данные и по возможности схему для <see cref="T:System.Data.DataSet" /> с помощью указанных <see cref="T:System.Xml.XmlWriter" /> и  <see cref="T:System.Data.XmlWriteMode" />. Чтобы записать схему, задайте в параметре <paramref name="mode" /> значение <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод `WriteXml` предоставляет способ записи либо данных, либо схемы из <xref:System.Data.DataSet> в XML-документ, в то время как метод <xref:System.Data.DataSet.WriteXmlSchema%2A> записывает только схему. Чтобы записать данные и схему, задайте для параметра `mode` значение `WriteSchema`.  
  
 Обратите внимание, что это справедливо и для методов <xref:System.Data.DataSet.ReadXml%2A> и <xref:System.Data.DataSet.ReadXmlSchema%2A> соответственно. Для чтения XML-данных или схемы и данных в `DataSet`используйте метод `ReadXml`. Чтобы прочитать только схему, используйте метод `ReadXmlSchema`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> будет выдаваться, если тип столбца в `DataRow`, из которого считываются или записываются, реализует <xref:System.Dynamic.IDynamicMetaObjectProvider> и не реализует <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 В следующем примере создается объект <xref:System.IO.FileStream?displayProperty=nameWithType>, который используется для создания нового <xref:System.Xml.XmlTextWriter>. Объект <xref:System.Xml.XmlTextWriter> используется с методом <xref:System.Data.DataSet.WriteXml%2A> для записи XML-документа.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает структуру класса <see cref="T:System.Data.DataSet" /> в виде XML-схемы.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Объект <see cref="T:System.IO.Stream" />, используемый для записи в файл.</param>
        <summary>Записывает структуру <see cref="T:System.Data.DataSet" /> в качестве XML-схемы для указанного объекта <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.Data.DataSet.WriteXmlSchema%2A> для записи схемы <xref:System.Data.DataSet> в XML-документ. Схема включает определения таблиц, связей и ограничений. Чтобы записать схему в XML-документ, используйте метод <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 Схема XML написана с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте метод <xref:System.Data.DataSet.WriteXml%2A>.  
  
 Классы, производные от класса <xref:System.IO.Stream>, включают <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>и <xref:System.Net.Sockets.NetworkStream>.  
  
   
  
## Examples  
 В следующем примере создается новый объект <xref:System.IO.FileStream>, который передается методу <xref:System.Data.DataSet.WriteXmlSchema%2A> для записи схемы на диск.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, используемый для записи.</param>
        <summary>Записывает структуру <see cref="T:System.Data.DataSet" /> в качестве XML-схемы для указанного объекта <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.Data.DataSet.WriteXmlSchema%2A> для записи схемы <xref:System.Data.DataSet> в XML-документ. Схема включает определения таблиц, связей и ограничений. Чтобы записать схему в XML-документ, используйте метод <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 Схема XML написана с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте метод <xref:System.Data.DataSet.WriteXml%2A>.  
  
 Классы, производные от класса <xref:System.IO.TextWriter?displayProperty=nameWithType>, включают <xref:System.Web.HttpWriter?displayProperty=nameWithType>, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType>, <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>, <xref:System.IO.StreamWriter?displayProperty=nameWithType>и <xref:System.IO.StringWriter?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере создается объект <xref:System.Text.StringBuilder?displayProperty=nameWithType>, который используется для создания нового <xref:System.IO.StringWriter?displayProperty=nameWithType>. <xref:System.IO.StringWriter> передается методу <xref:System.Data.DataSet.WriteXmlSchema%2A>, а полученная строка выводится в окне консоли.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataSet.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла (включая путь), в который производится запись.</param>
        <summary>Записывает структуру класса <see cref="T:System.Data.DataSet" /> в виде XML-схемы в файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.Data.DataSet.WriteXmlSchema%2A> для записи схемы <xref:System.Data.DataSet> в XML-документ. Схема включает определения таблиц, связей и ограничений. Чтобы записать схему в XML-документ, используйте метод <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 Схема XML написана с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте метод <xref:System.Data.DataSet.WriteXml%2A>.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Для поля <see cref="T:System.Security.Permissions.FileIOPermission" /> не задан класс <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для чтения и записи файлов. Связанное перечисление: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Экземпляр <see cref="T:System.Xml.XmlWriter" />, в который выполняется запись.</param>
        <summary>Записывает структуру класса <see cref="T:System.Data.DataSet" /> в виде XML-схемы в объект <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте метод <xref:System.Data.DataSet.WriteXmlSchema%2A> для записи схемы <xref:System.Data.DataSet> в XML-документ. Схема включает определения таблиц, связей и ограничений. Чтобы записать схему в XML-документ, используйте метод <xref:System.Data.DataSet.WriteXmlSchema%2A>.  
  
 Схема XML написана с использованием стандарта XSD.  
  
 Чтобы записать данные в XML-документ, используйте метод <xref:System.Data.DataSet.WriteXml%2A>.  
  
 Класс, который наследует от класса <xref:System.Xml.XmlWriter?displayProperty=nameWithType>, является <xref:System.Xml.XmlTextWriter>.  
  
   
  
## Examples  
 В следующем примере создается новый объект <xref:System.IO.FileStream?displayProperty=nameWithType> с указанным путем. Объект <xref:System.IO.FileStream> используется для создания объекта <xref:System.Xml.XmlTextWriter>. Затем метод <xref:System.Data.DataSet.WriteXmlSchema%2A> вызывается с объектом <xref:System.Xml.XmlTextWriter> для записи схемы на диск.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Использование наборов данных в ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (stream, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream">Объект <see cref="T:System.IO.Stream" />, в который осуществляется запись.</param>
        <param name="multipleTargetConverter">Делегат, используемый для преобразования <see cref="T:System.Type" /> в строковый формат.</param>
        <summary>Записывает структуру <see cref="T:System.Data.DataSet" /> в качестве XML-схемы для указанного объекта <see cref="T:System.IO.Stream" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, в который осуществляется запись.</param>
        <param name="multipleTargetConverter">Делегат, используемый для преобразования <see cref="T:System.Type" /> в строковый формат.</param>
        <summary>Записывает структуру <see cref="T:System.Data.DataSet" /> в виде схемы XML для указанного объекта <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (fileName, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">Имя файла для записи.</param>
        <param name="multipleTargetConverter">Делегат, используемый для преобразования <see cref="T:System.Type" /> в строковый формат.</param>
        <summary>Записывает структуру класса <see cref="T:System.Data.DataSet" /> в виде XML-схемы в файл.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.Xml.XmlWriter" />, в который осуществляется запись.</param>
        <param name="multipleTargetConverter">Делегат, используемый для преобразования <see cref="T:System.Type" /> в строковый формат.</param>
        <summary>Записывает структуру <see cref="T:System.Data.DataSet" /> в виде схемы XML для указанного объекта <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
