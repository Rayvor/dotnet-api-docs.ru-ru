<Type Name="ReaderWriterLock" FullName="System.Threading.ReaderWriterLock">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bd429f03843f931a0285a89a893ee1aa7ced9ae2" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75116076" /></Metadata><TypeSignature Language="C#" Value="public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLock" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReaderWriterLock&#xA;Inherits CriticalFinalizerObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLock sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject" />
  <TypeSignature Language="F#" Value="type ReaderWriterLock = class&#xA;    inherit CriticalFinalizerObject" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="17d0f-101">Определяет блокировку, которая поддерживает один пишущий поток и несколько читающих.</span><span class="sxs-lookup"><span data-stu-id="17d0f-101">Defines a lock that supports single writers and multiple readers.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="17d0f-102">Класс [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] использует две блокировки чтения и записи: <xref:System.Threading.ReaderWriterLockSlim> и <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-102">The [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] has two reader-writer locks, <xref:System.Threading.ReaderWriterLockSlim> and <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="17d0f-103">Мы рекомендуем применять <xref:System.Threading.ReaderWriterLockSlim> при любых новых разработках.</span><span class="sxs-lookup"><span data-stu-id="17d0f-103"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span> <span data-ttu-id="17d0f-104"><xref:System.Threading.ReaderWriterLockSlim> действует так же, как и <xref:System.Threading.ReaderWriterLock>, но с более простыми правилами рекурсии и изменения состояния блокировки.</span><span class="sxs-lookup"><span data-stu-id="17d0f-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="17d0f-105"><xref:System.Threading.ReaderWriterLockSlim> позволяет избежать многих ситуаций взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="17d0f-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="17d0f-106">Кроме того, производительность <xref:System.Threading.ReaderWriterLockSlim> значительно выше, чем у <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 <span data-ttu-id="17d0f-107"><xref:System.Threading.ReaderWriterLock> используется для синхронизации доступа к ресурсу.</span><span class="sxs-lookup"><span data-stu-id="17d0f-107"><xref:System.Threading.ReaderWriterLock> is used to synchronize access to a resource.</span></span> <span data-ttu-id="17d0f-108">В любой момент времени он допускает одновременный доступ на чтение для нескольких потоков или доступ для записи для одного потока.</span><span class="sxs-lookup"><span data-stu-id="17d0f-108">At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread.</span></span> <span data-ttu-id="17d0f-109">В ситуации, когда ресурс изменяется редко, `ReaderWriterLock` обеспечивает лучшую пропускную способность, чем простая одновременная блокировка, например <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-109">In a situation where a resource is changed infrequently, a `ReaderWriterLock` provides better throughput than a simple one-at-a-time lock, such as <xref:System.Threading.Monitor>.</span></span>  
  
 <span data-ttu-id="17d0f-110">`ReaderWriterLock` работает наилучшим образом при чтении большинства обращений, а операции записи происходят редко и имеют короткий промежуток времени.</span><span class="sxs-lookup"><span data-stu-id="17d0f-110">`ReaderWriterLock` works best where most accesses are reads, while writes are infrequent and of short duration.</span></span> <span data-ttu-id="17d0f-111">Несколько модулей чтения могут быть альтернативными для одного модуля записи, чтобы ни читатели, ни модули записи не блокировались в течение длительных периодов.</span><span class="sxs-lookup"><span data-stu-id="17d0f-111">Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="17d0f-112">Хранение блокировок чтения или записи в течение длительных периодов приведет к нехватки других потоков.</span><span class="sxs-lookup"><span data-stu-id="17d0f-112">Holding reader locks or writer locks for long periods will starve other threads.</span></span> <span data-ttu-id="17d0f-113">Для достижения оптимальной производительности рассмотрите возможность реструктуризации приложения, чтобы максимально сокращать продолжительность операций записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-113">For best performance, consider restructuring your application to minimize the duration of writes.</span></span>  
  
 <span data-ttu-id="17d0f-114">Поток может содержать блокировку чтения или пишущую блокировку, но не оба одновременно.</span><span class="sxs-lookup"><span data-stu-id="17d0f-114">A thread can hold a reader lock or a writer lock, but not both at the same time.</span></span> <span data-ttu-id="17d0f-115">Вместо освобождения блокировки чтения для получения блокировки записи можно использовать <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> и <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-115">Instead of releasing a reader lock in order to acquire the writer lock, you can use <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> and <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.</span></span>  
  
 <span data-ttu-id="17d0f-116">Рекурсивные запросы на блокировку увеличивают счетчик блокировок для блокировки.</span><span class="sxs-lookup"><span data-stu-id="17d0f-116">Recursive lock requests increase the lock count on a lock.</span></span>  
  
 <span data-ttu-id="17d0f-117">Читатели и модули записи помещаются в очередь отдельно.</span><span class="sxs-lookup"><span data-stu-id="17d0f-117">Readers and writers are queued separately.</span></span> <span data-ttu-id="17d0f-118">Когда поток освобождает блокировку записи, все потоки, ожидающие в очереди чтения на этом мгновенных, получают блокировки чтения. когда все эти блокировки чтения были освобождены, следующий поток, ожидающий в очереди модуля записи (если таковой имеется), получит блокировку записи и т. д.</span><span class="sxs-lookup"><span data-stu-id="17d0f-118">When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on.</span></span> <span data-ttu-id="17d0f-119">Иными словами, `ReaderWriterLock` варианты между набором читателей и одним модулем записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-119">In other words, `ReaderWriterLock` alternates between a collection of readers, and one writer.</span></span>  
  
 <span data-ttu-id="17d0f-120">Пока поток в очереди модуля записи ожидает освобождения активных блокировок модуля чтения, потоки, запрашивающие новые блокировки модуля чтения, накапливаются в очереди чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-120">While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue.</span></span> <span data-ttu-id="17d0f-121">Их запросы не предоставляются, несмотря на то, что они могут совместно использовать параллельный доступ с существующими держателями блокировки чтения. Это помогает защитить модули записи от неопределенной блокировки читателями.</span><span class="sxs-lookup"><span data-stu-id="17d0f-121">Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.</span></span>  
  
 <span data-ttu-id="17d0f-122">Большинство методов для получения блокировок на `ReaderWriterLock` принимать значения времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="17d0f-122">Most methods for acquiring locks on a `ReaderWriterLock` accept time-out values.</span></span> <span data-ttu-id="17d0f-123">Используйте время ожидания, чтобы избежать взаимоблокировок в приложении.</span><span class="sxs-lookup"><span data-stu-id="17d0f-123">Use time-outs to avoid deadlocks in your application.</span></span> <span data-ttu-id="17d0f-124">Например, поток может получить блокировку записи на один ресурс, а затем запросить блокировку чтения на втором ресурсе. в то же время другой поток может получить блокировку записи на второй ресурс и запросить блокировку чтения на первом.</span><span class="sxs-lookup"><span data-stu-id="17d0f-124">For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first.</span></span> <span data-ttu-id="17d0f-125">Если время ожидания не используется, потоки взаимоблокируются.</span><span class="sxs-lookup"><span data-stu-id="17d0f-125">Unless time-outs are used, the threads deadlock.</span></span>  
  
 <span data-ttu-id="17d0f-126">Если интервал времени ожидания истекает и запрос блокировки не был предоставлен, метод возвращает управление вызывающему потоку, вызывая <xref:System.ApplicationException>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-126">If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an <xref:System.ApplicationException>.</span></span> <span data-ttu-id="17d0f-127">Поток может перехватить это исключение и определить, какое действие следует предпринять далее.</span><span class="sxs-lookup"><span data-stu-id="17d0f-127">A thread can catch this exception and determine what action to take next.</span></span>  
  
 <span data-ttu-id="17d0f-128">Время ожидания выражается в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="17d0f-128">Time-outs are expressed in milliseconds.</span></span> <span data-ttu-id="17d0f-129">Если для указания времени ожидания используется <xref:System.TimeSpan?displayProperty=nameWithType>, то используемое значение — это общее число миллисекунд, представленных <xref:System.TimeSpan>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-129">If you use a <xref:System.TimeSpan?displayProperty=nameWithType> to specify the time-out, the value used is the total number of whole milliseconds represented by the <xref:System.TimeSpan>.</span></span> <span data-ttu-id="17d0f-130">В следующей таблице показаны допустимые значения времени ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="17d0f-130">The following table shows the valid time-out values in milliseconds.</span></span>  
  
|<span data-ttu-id="17d0f-131">Значение</span><span class="sxs-lookup"><span data-stu-id="17d0f-131">Value</span></span>|<span data-ttu-id="17d0f-132">Описание</span><span class="sxs-lookup"><span data-stu-id="17d0f-132">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="17d0f-133">-1</span><span class="sxs-lookup"><span data-stu-id="17d0f-133">-1</span></span>|<span data-ttu-id="17d0f-134">Поток ожидает, пока блокировка не будет получена, независимо от того, сколько времени занимает.</span><span class="sxs-lookup"><span data-stu-id="17d0f-134">The thread waits until the lock is acquired, regardless of how long it takes.</span></span> <span data-ttu-id="17d0f-135">Для методов, которые задают целочисленные значения времени ожидания, можно использовать константную <xref:System.Threading.Timeout.Infinite>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-135">For methods that specify integer time-outs, the constant <xref:System.Threading.Timeout.Infinite> can be used.</span></span>|  
|<span data-ttu-id="17d0f-136">0</span><span class="sxs-lookup"><span data-stu-id="17d0f-136">0</span></span>|<span data-ttu-id="17d0f-137">Поток не ждет получения блокировки.</span><span class="sxs-lookup"><span data-stu-id="17d0f-137">The thread does not wait to acquire the lock.</span></span> <span data-ttu-id="17d0f-138">Если блокировка не может быть получена немедленно, метод возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="17d0f-138">If the lock cannot be acquired immediately, the method returns.</span></span>|  
|<span data-ttu-id="17d0f-139">>0</span><span class="sxs-lookup"><span data-stu-id="17d0f-139">>0</span></span>|<span data-ttu-id="17d0f-140">Время ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="17d0f-140">The number of milliseconds to wait.</span></span>|  
  
 <span data-ttu-id="17d0f-141">За исключением-1, отрицательные значения времени ожидания не допускаются.</span><span class="sxs-lookup"><span data-stu-id="17d0f-141">With the exception of -1, negative time-out values are not allowed.</span></span> <span data-ttu-id="17d0f-142">Если указать отрицательное целое число, отличное от-1, вместо него будет использоваться нулевое значение времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="17d0f-142">If you specify a negative integer other than -1, a time-out value of zero is used instead.</span></span> <span data-ttu-id="17d0f-143">(То есть метод возвращается без ожидания, если блокировка не может быть получена немедленно.) При указании <xref:System.TimeSpan>, представляющего отрицательное число миллисекунд, отличных от-1, выдается <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-143">(That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a <xref:System.TimeSpan> that represents a negative number of milliseconds other than -1, <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17d0f-144">В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLock> для защиты общего ресурса, целочисленное значение с именем `resource`, которое считывается параллельно и записывается в монопольном режиме несколькими потоками.</span><span class="sxs-lookup"><span data-stu-id="17d0f-144">The following example demonstrates how to use a <xref:System.Threading.ReaderWriterLock> to protect a shared resource, an integer value named `resource`, that is read concurrently and written exclusively by multiple threads.</span></span> <span data-ttu-id="17d0f-145">Обратите внимание, что <xref:System.Threading.ReaderWriterLock> объявляется на уровне класса, чтобы он был виден всем потокам.</span><span class="sxs-lookup"><span data-stu-id="17d0f-145">Note that the <xref:System.Threading.ReaderWriterLock> is declared at the class level so that it is visible to all threads.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="17d0f-146">Данный тип потокобезопасен.</span><span class="sxs-lookup"><span data-stu-id="17d0f-146">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-147">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-147">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-148">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-148">ReaderWriterLock</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17d0f-149">Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLock" />.</span><span class="sxs-lookup"><span data-stu-id="17d0f-149">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLock" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="17d0f-150">В следующем примере кода показано создание нового экземпляра класса <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-150">The following code example demonstrates how to create a new instance of the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 <span data-ttu-id="17d0f-151">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-151">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-152">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-152">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-153">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-153">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireReaderLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="17d0f-154">Получает блокировку чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-154">Acquires a reader lock.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : int -&gt; unit" Usage="readerWriterLock.AcquireReaderLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="17d0f-155">Время ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="17d0f-155">The time-out in milliseconds.</span></span></param>
        <summary><span data-ttu-id="17d0f-156">Получает блокировку чтения, используя значение <see cref="T:System.Int32" /> для задания времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="17d0f-156">Acquires a reader lock, using an <see cref="T:System.Int32" /> value for the time-out.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-157"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> блокируется, если другой поток имеет блокировку записи или если хотя бы один поток ожидает блокировки записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-157"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="17d0f-158">Если текущий поток уже имеет блокировку записи, блокировка модуля чтения не производится.</span><span class="sxs-lookup"><span data-stu-id="17d0f-158">If the current thread already has the writer lock, no reader lock is acquired.</span></span> <span data-ttu-id="17d0f-159">Вместо этого увеличивается число блокировок для блокировки записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-159">Instead, the lock count on the writer lock is incremented.</span></span> <span data-ttu-id="17d0f-160">Это предотвращает блокировку потока в собственной блокировке записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-160">This prevents a thread from blocking on its own writer lock.</span></span> <span data-ttu-id="17d0f-161">Результат точно такой же, как и при вызове <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, и при освобождении блокировки записи требуется дополнительный вызов <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-161">The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock.</span></span>  
  
 <span data-ttu-id="17d0f-162">`AcquireReaderLock` поддерживает рекурсивные запросы на блокировку чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-162">`AcquireReaderLock` supports recursive reader-lock requests.</span></span> <span data-ttu-id="17d0f-163">Это значит, что поток может вызывать Аккуиререадерлокк несколько раз, что увеличивает число блокировок каждый раз.</span><span class="sxs-lookup"><span data-stu-id="17d0f-163">That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="17d0f-164">Необходимо вызвать <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> один раз для каждого вызова `AcquireReaderLock`.</span><span class="sxs-lookup"><span data-stu-id="17d0f-164">You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`.</span></span> <span data-ttu-id="17d0f-165">Кроме того, можно вызвать <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>, чтобы немедленно уменьшить число блокировок до нуля.</span><span class="sxs-lookup"><span data-stu-id="17d0f-165">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="17d0f-166">Рекурсивные запросы на блокировку всегда предоставляются немедленно, без помещения запрашивающего потока в очередь чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-166">Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</span></span> <span data-ttu-id="17d0f-167">Используйте рекурсивные блокировки с осторожностью, чтобы не блокировать запросы на блокировку модуля записи в течение длительных периодов.</span><span class="sxs-lookup"><span data-stu-id="17d0f-167">Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</span></span>  
  
 <span data-ttu-id="17d0f-168">Допустимые значения времени ожидания см. в разделе <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-168">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17d0f-169">В следующем примере кода показано, как получить и освободить блокировку чтения, а также как выполнить обработку исключения, возникающего при истечении времени ожидания запроса.</span><span class="sxs-lookup"><span data-stu-id="17d0f-169">The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="17d0f-170">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-170">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="17d0f-171">Время ожидания, заданное параметром <paramref name="millisecondsTimeout" />, истекло до удовлетворения запроса на блокировку.</span><span class="sxs-lookup"><span data-stu-id="17d0f-171"><paramref name="millisecondsTimeout" /> expires before the lock request is granted.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-172">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-172">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-173">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-173">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireReaderLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="17d0f-174">Период <see langword="TimeSpan" />, задающий время ожидания.</span><span class="sxs-lookup"><span data-stu-id="17d0f-174">A <see langword="TimeSpan" /> specifying the time-out period.</span></span></param>
        <summary><span data-ttu-id="17d0f-175">Получает блокировку чтения, используя значение <see cref="T:System.TimeSpan" /> для задания времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="17d0f-175">Acquires a reader lock, using a <see cref="T:System.TimeSpan" /> value for the time-out.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-176"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> блокируется, если другой поток имеет блокировку записи или если хотя бы один поток ожидает блокировки записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-176"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="17d0f-177">Если текущий поток уже имеет блокировку записи, блокировка модуля чтения не производится.</span><span class="sxs-lookup"><span data-stu-id="17d0f-177">If the current thread already has the writer lock, no reader lock is acquired.</span></span> <span data-ttu-id="17d0f-178">Вместо этого увеличивается число блокировок для блокировки записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-178">Instead, the lock count on the writer lock is incremented.</span></span> <span data-ttu-id="17d0f-179">Это предотвращает блокировку потока в собственной блокировке записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-179">This prevents a thread from blocking on its own writer lock.</span></span> <span data-ttu-id="17d0f-180">Результат точно такой же, как и при вызове <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, и при освобождении блокировки записи требуется дополнительный вызов <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-180">The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock.</span></span>  
  
 <span data-ttu-id="17d0f-181">`AcquireReaderLock` поддерживает рекурсивные запросы на блокировку чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-181">`AcquireReaderLock` supports recursive reader-lock requests.</span></span> <span data-ttu-id="17d0f-182">Это значит, что поток может вызывать Аккуиререадерлокк несколько раз, что увеличивает число блокировок каждый раз.</span><span class="sxs-lookup"><span data-stu-id="17d0f-182">That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="17d0f-183">Необходимо вызвать <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> один раз для каждого вызова `AcquireReaderLock`.</span><span class="sxs-lookup"><span data-stu-id="17d0f-183">You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`.</span></span> <span data-ttu-id="17d0f-184">Кроме того, можно вызвать <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>, чтобы немедленно уменьшить число блокировок до нуля.</span><span class="sxs-lookup"><span data-stu-id="17d0f-184">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="17d0f-185">Рекурсивные запросы на блокировку всегда предоставляются немедленно, без помещения запрашивающего потока в очередь чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-185">Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</span></span> <span data-ttu-id="17d0f-186">Используйте рекурсивные блокировки с осторожностью, чтобы не блокировать запросы на блокировку модуля записи в течение длительных периодов.</span><span class="sxs-lookup"><span data-stu-id="17d0f-186">Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</span></span>  
  
 <span data-ttu-id="17d0f-187">Допустимые значения времени ожидания см. в разделе <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-187">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="17d0f-188">Время ожидания, заданное параметром <paramref name="timeout" />, истекло до удовлетворения запроса на блокировку.</span><span class="sxs-lookup"><span data-stu-id="17d0f-188"><paramref name="timeout" /> expires before the lock request is granted.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="17d0f-189">Параметр <paramref name="timeout" /> содержит отрицательное значение, отличное от -1.</span><span class="sxs-lookup"><span data-stu-id="17d0f-189"><paramref name="timeout" /> specifies a negative value other than -1 milliseconds.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-190">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-190">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-191">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-191">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="17d0f-192">Получает блокировку записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-192">Acquires the writer lock.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : int -&gt; unit" Usage="readerWriterLock.AcquireWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="17d0f-193">Время ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="17d0f-193">The time-out in milliseconds.</span></span></param>
        <summary><span data-ttu-id="17d0f-194">Получает блокировку записи, используя значение <see cref="T:System.Int32" /> для задания времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="17d0f-194">Acquires the writer lock, using an <see cref="T:System.Int32" /> value for the time-out.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-195">Этот метод блокируется, если другой поток имеет блокировку чтения или записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-195">This method blocks if another thread has a reader lock or writer lock.</span></span> <span data-ttu-id="17d0f-196">Описание способа блокировки модуля записи с несколькими параллельными блокировками чтения см. в разделе класс <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-196">For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 <span data-ttu-id="17d0f-197">Поток, который уже имеет блокировку чтения, может получить блокировку записи одним из двух способов: путем освобождения читающей блокировки перед вызовом <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>или путем вызова <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-197">A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="17d0f-198">Если поток вызывает `AcquireWriterLock`, пока он все еще имеет блокировку чтения, он блокируется для собственной блокировки чтения. Если задано бесконечное время ожидания, поток будет взаимоблокировками.</span><span class="sxs-lookup"><span data-stu-id="17d0f-198">If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</span></span> <span data-ttu-id="17d0f-199">Чтобы избежать подобных взаимоблокировок, используйте <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>, чтобы определить, имеет ли текущий поток блокировку чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-199">To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock.</span></span>  
  
 <span data-ttu-id="17d0f-200">`AcquireWriterLock` поддерживает рекурсивные запросы на блокировку записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-200">`AcquireWriterLock` supports recursive writer-lock requests.</span></span> <span data-ttu-id="17d0f-201">Это значит, что поток может вызывать `AcquireWriterLock` несколько раз, что увеличивает число блокировок каждый раз.</span><span class="sxs-lookup"><span data-stu-id="17d0f-201">That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="17d0f-202">Необходимо вызвать <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> один раз для каждого вызова `AcquireWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="17d0f-202">You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`.</span></span> <span data-ttu-id="17d0f-203">Кроме того, можно вызвать <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>, чтобы немедленно уменьшить число блокировок до нуля.</span><span class="sxs-lookup"><span data-stu-id="17d0f-203">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="17d0f-204">Рекурсивные запросы на блокировку всегда предоставляются немедленно, без помещения запрашивающего потока в очередь модуля записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-204">Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</span></span>  
  
 <span data-ttu-id="17d0f-205">Допустимые значения времени ожидания см. в разделе <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-205">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17d0f-206">В следующем примере кода показано, как получить и освободить блокировку записи и как обрабатывалось исключение, возникающее при истечении времени ожидания запроса.</span><span class="sxs-lookup"><span data-stu-id="17d0f-206">The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="17d0f-207">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-207">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="17d0f-208">Время ожидания, заданное параметром <paramref name="timeout" />, истекло до удовлетворения запроса на блокировку.</span><span class="sxs-lookup"><span data-stu-id="17d0f-208"><paramref name="timeout" /> expires before the lock request is granted.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-209">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-209">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-210">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-210">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="17d0f-211">Период <see langword="TimeSpan" />, задающий время ожидания.</span><span class="sxs-lookup"><span data-stu-id="17d0f-211">The <see langword="TimeSpan" /> specifying the time-out period.</span></span></param>
        <summary><span data-ttu-id="17d0f-212">Получает блокировку записи, используя значение <see cref="T:System.TimeSpan" /> для задания времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="17d0f-212">Acquires the writer lock, using a <see cref="T:System.TimeSpan" /> value for the time-out.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-213">Этот метод блокируется, если другой поток имеет блокировку чтения или записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-213">This method blocks if another thread has a reader lock or writer lock.</span></span> <span data-ttu-id="17d0f-214">Описание способа блокировки модуля записи с несколькими параллельными блокировками чтения см. в разделе класс <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-214">For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 <span data-ttu-id="17d0f-215">Поток, который уже имеет блокировку чтения, может получить блокировку записи одним из двух способов: путем освобождения читающей блокировки перед вызовом <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>или путем вызова <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-215">A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="17d0f-216">Если поток вызывает `AcquireWriterLock`, пока он все еще имеет блокировку чтения, он блокируется для собственной блокировки чтения. Если задано бесконечное время ожидания, поток будет взаимоблокировками.</span><span class="sxs-lookup"><span data-stu-id="17d0f-216">If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</span></span> <span data-ttu-id="17d0f-217">Чтобы избежать подобных взаимоблокировок, используйте <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A>, чтобы определить, имеет ли текущий поток блокировку чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-217">To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock.</span></span>  
  
 <span data-ttu-id="17d0f-218">`AcquireWriterLock` поддерживает рекурсивные запросы на блокировку записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-218">`AcquireWriterLock` supports recursive writer-lock requests.</span></span> <span data-ttu-id="17d0f-219">Это значит, что поток может вызывать `AcquireWriterLock` несколько раз, что увеличивает число блокировок каждый раз.</span><span class="sxs-lookup"><span data-stu-id="17d0f-219">That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="17d0f-220">Необходимо вызвать <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> один раз для каждого вызова `AcquireWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="17d0f-220">You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`.</span></span> <span data-ttu-id="17d0f-221">Кроме того, можно вызвать <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>, чтобы немедленно уменьшить число блокировок до нуля.</span><span class="sxs-lookup"><span data-stu-id="17d0f-221">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="17d0f-222">Рекурсивные запросы на блокировку всегда предоставляются немедленно, без помещения запрашивающего потока в очередь модуля записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-222">Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</span></span>  
  
 <span data-ttu-id="17d0f-223">Допустимые значения времени ожидания см. в разделе <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-223">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="17d0f-224">Время ожидания, заданное параметром <paramref name="timeout" />, истекло до удовлетворения запроса на блокировку.</span><span class="sxs-lookup"><span data-stu-id="17d0f-224"><paramref name="timeout" /> expires before the lock request is granted.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="17d0f-225">Параметр <paramref name="timeout" /> содержит отрицательное значение, отличное от -1.</span><span class="sxs-lookup"><span data-stu-id="17d0f-225"><paramref name="timeout" /> specifies a negative value other than -1 milliseconds.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-226">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-226">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-227">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-227">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AnyWritersSince">
      <MemberSignature Language="C#" Value="public bool AnyWritersSince (int seqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AnyWritersSince(int32 seqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AnyWritersSince (seqNum As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AnyWritersSince(int seqNum);" />
      <MemberSignature Language="F#" Value="member this.AnyWritersSince : int -&gt; bool" Usage="readerWriterLock.AnyWritersSince seqNum" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seqNum" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="seqNum"><span data-ttu-id="17d0f-228">Порядковый номер.</span><span class="sxs-lookup"><span data-stu-id="17d0f-228">The sequence number.</span></span></param>
        <summary><span data-ttu-id="17d0f-229">Показывает, была ли предоставлена блокировка записи какому-либо потоку со времени получения последовательного номера.</span><span class="sxs-lookup"><span data-stu-id="17d0f-229">Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.</span></span></summary>
        <returns><span data-ttu-id="17d0f-230">Значение <see langword="true" />, если блокировка записи была предоставлена какому-либо потоку с момента получения порядкового номера; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="17d0f-230"><see langword="true" /> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-231">Для повышения производительности приложения можно использовать <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> и `AnyWritersSince`.</span><span class="sxs-lookup"><span data-stu-id="17d0f-231">You can use <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> and `AnyWritersSince` to improve application performance.</span></span> <span data-ttu-id="17d0f-232">Например, поток может кэшировать сведения, которые он получает, при удержании блокировки чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-232">For example, a thread might cache the information it obtains while holding a reader lock.</span></span> <span data-ttu-id="17d0f-233">После освобождения и последующего повторного получения блокировки поток может использовать `AnyWritersSince`, чтобы определить, были ли другие потоки записаны в ресурс в промежуточном виде. в противном случае можно использовать кэшированные данные.</span><span class="sxs-lookup"><span data-stu-id="17d0f-233">After releasing and later reacquiring the lock, the thread can use `AnyWritersSince` to determine whether other threads have written to the resource in the interim; if not, the cached information can be used.</span></span> <span data-ttu-id="17d0f-234">Эта методика полезна, когда чтение информации, защищенной блокировкой, является дорогостоящей. Например, выполнение запроса к базе данных.</span><span class="sxs-lookup"><span data-stu-id="17d0f-234">This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.</span></span>  
  
 <span data-ttu-id="17d0f-235">Вызывающий объект должен удерживать блокировку чтения или записи, чтобы порядковый номер был полезен.</span><span class="sxs-lookup"><span data-stu-id="17d0f-235">The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17d0f-236">В следующем примере кода показано, как использовать метод <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> и свойство <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A>, чтобы определить, получил ли другой поток блокировку записи на защищенный ресурс, начиная с текущего потока, который последним удерживал блокировку записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-236">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method and the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.</span></span>  
  
 <span data-ttu-id="17d0f-237">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-237">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-238">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-238">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-239">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-239">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DowngradeFromWriterLock">
      <MemberSignature Language="C#" Value="public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DowngradeFromWriterLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DowngradeFromWriterLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DowngradeFromWriterLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.DowngradeFromWriterLock : LockCookie -&gt; unit" Usage="readerWriterLock.DowngradeFromWriterLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie"><span data-ttu-id="17d0f-240">Объект <see cref="T:System.Threading.LockCookie" />, возвращаемый <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="17d0f-240">A <see cref="T:System.Threading.LockCookie" /> returned by <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</span></span></param>
        <summary><span data-ttu-id="17d0f-241">Возвращает состояние блокировки потока к тому, которое было до вызова метода <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</span><span class="sxs-lookup"><span data-stu-id="17d0f-241">Restores the lock status of the thread to what it was before <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> was called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-242"><xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> освобождает блокировку записи, независимо от счетчика рекурсивных блокировок, и восстанавливает читающую блокировку, удерживаемую потоком перед обновлением до блокировки записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-242"><xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock.</span></span> <span data-ttu-id="17d0f-243">Восстанавливается счетчик блокировок для блокировки чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-243">The lock count on the reader lock is restored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="17d0f-244">`DowngradeFromWriterLock` принимает <xref:System.Threading.LockCookie>, полученный путем вызова <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-244">`DowngradeFromWriterLock` accepts a <xref:System.Threading.LockCookie> obtained by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span> <span data-ttu-id="17d0f-245">Не используйте `LockCookie`, возвращенные <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-245">Do not use a `LockCookie` returned by <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span></span>  
  
 <span data-ttu-id="17d0f-246">Поток не блокируется при понижении уровня блокировки записи, даже если другие потоки ожидают блокировку записи, так как все запросы на блокировку чтения предоставляются при освобождении блокировки записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-246">A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17d0f-247">В следующем примере кода показано, как запросить блокировку чтения, обновить блокировку чтения до блокировки записи и вернуться к блокировке чтения снова.</span><span class="sxs-lookup"><span data-stu-id="17d0f-247">The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.</span></span>  
  
 <span data-ttu-id="17d0f-248">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-248">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="17d0f-249">Поток не владеет блокировкой записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-249">The thread does not have the writer lock.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="17d0f-250">Адрес <paramref name="lockCookie" /> является пустым указателем.</span><span class="sxs-lookup"><span data-stu-id="17d0f-250">The address of <paramref name="lockCookie" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-251">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-251">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-252">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-252">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReaderWriterLock ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="readerWriterLock.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17d0f-253">Обеспечивает освобождение ресурсов и выполнение других завершающих операций, когда сборщик мусора восстанавливает объект <see cref="T:System.Threading.ReaderWriterLock" />.</span><span class="sxs-lookup"><span data-stu-id="17d0f-253">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.ReaderWriterLock" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-254">Сборщик мусора вызывает <xref:System.Threading.ReaderWriterLock.Finalize%2A>, когда текущий объект <xref:System.Threading.ReaderWriterLock> готов к завершению.</span><span class="sxs-lookup"><span data-stu-id="17d0f-254">The garbage collector calls <xref:System.Threading.ReaderWriterLock.Finalize%2A> when the current <xref:System.Threading.ReaderWriterLock> object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReaderLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReaderLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReaderLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReaderLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReaderLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReaderLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17d0f-255">Возвращает значение, указывающее, владеет ли текущий поток блокировкой чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-255">Gets a value indicating whether the current thread holds a reader lock.</span></span></summary>
        <value><span data-ttu-id="17d0f-256">Значение <see langword="true" />, если текущий поток владеет блокировкой чтения; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="17d0f-256"><see langword="true" /> if the current thread holds a reader lock; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="17d0f-257">В следующем примере кода показано, как использовать `IsReaderLockHeld`, чтобы избежать взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="17d0f-257">The following code example demonstrates how to use `IsReaderLockHeld` to avoid deadlocks.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-258">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-258">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-259">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-259">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsWriterLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriterLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriterLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriterLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriterLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriterLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17d0f-260">Возвращает значение, указывающее, владеет ли текущий поток блокировкой записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-260">Gets a value indicating whether the current thread holds the writer lock.</span></span></summary>
        <value><span data-ttu-id="17d0f-261">Значение <see langword="true" />, если текущий поток владеет блокировкой записи; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="17d0f-261"><see langword="true" /> if the current thread holds the writer lock; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="17d0f-262">В следующем примере кода показано, что при попытке получить блокировку чтения для потока с блокировкой записи `ReaderWriterLock` не предоставляет блокировку чтения, а вместо этого увеличивает счетчик блокировок для блокировки записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-262">The following code example demonstrates that when an attempt is made to acquire a reader lock on a thread that has a writer lock, `ReaderWriterLock` does not grant the reader lock but instead increments the lock count on the writer lock.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-263">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-263">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-264">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-264">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReleaseLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie ReleaseLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie ReleaseLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseLock" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseLock () As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie ReleaseLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseLock : unit -&gt; System.Threading.LockCookie" Usage="readerWriterLock.ReleaseLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17d0f-265">Освобождает блокировку, независимо от количества ее получений потоком.</span><span class="sxs-lookup"><span data-stu-id="17d0f-265">Releases the lock, regardless of the number of times the thread acquired the lock.</span></span></summary>
        <returns><span data-ttu-id="17d0f-266">Объект <see cref="T:System.Threading.LockCookie" />, представляющий освобожденную блокировку.</span><span class="sxs-lookup"><span data-stu-id="17d0f-266">A <see cref="T:System.Threading.LockCookie" /> value representing the released lock.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-267"><xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> освобождает блокировку чтения или записи, независимо от счетчика рекурсивных блокировок.</span><span class="sxs-lookup"><span data-stu-id="17d0f-267"><xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> releases the reader lock or writer lock, regardless of the recursive lock count.</span></span> <span data-ttu-id="17d0f-268">Чтобы восстановить состояние блокировки, включая счетчик блокировок, передайте <xref:System.Threading.LockCookie> <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-268">To restore the state of the lock, including the lock count, pass the <xref:System.Threading.LockCookie> to <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17d0f-269">В следующем примере кода показано, как использовать метод <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> для освобождения блокировки, независимо от того, сколько раз она была получена потоком, а также как восстановить состояние блокировки позже.</span><span class="sxs-lookup"><span data-stu-id="17d0f-269">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.</span></span>  
  
 <span data-ttu-id="17d0f-270">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-270">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-271">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-271">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-272">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-272">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReleaseReaderLock">
      <MemberSignature Language="C#" Value="public void ReleaseReaderLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseReaderLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseReaderLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseReaderLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseReaderLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseReaderLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseReaderLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17d0f-273">Уменьшает на единицу счетчик блокировок.</span><span class="sxs-lookup"><span data-stu-id="17d0f-273">Decrements the lock count.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-274"><xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> уменьшает число блокировок.</span><span class="sxs-lookup"><span data-stu-id="17d0f-274"><xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> decrements the lock count.</span></span> <span data-ttu-id="17d0f-275">Когда счетчик достигнет нуля, блокировка снимается.</span><span class="sxs-lookup"><span data-stu-id="17d0f-275">When the count reaches zero, the lock is released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="17d0f-276">Если поток имеет блокировку записи, вызов `ReleaseReaderLock` имеет тот же результат, что и вызов <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-276">If a thread has the writer lock, calling `ReleaseReaderLock` has the same effect as calling <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</span></span> <span data-ttu-id="17d0f-277">Если поток не имеет блокировок, вызов `ReleaseReaderLock` создает исключение <xref:System.ApplicationException>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-277">If a thread has no locks, calling `ReleaseReaderLock` throws an <xref:System.ApplicationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17d0f-278">В следующем примере кода показано, как получить и освободить блокировку чтения, а также как выполнить обработку исключения, возникающего при истечении времени ожидания запроса.</span><span class="sxs-lookup"><span data-stu-id="17d0f-278">The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="17d0f-279">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-279">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="17d0f-280">Поток не владеет блокировкой чтения или записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-280">The thread does not have any reader or writer locks.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-281">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-281">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-282">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-282">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReleaseWriterLock">
      <MemberSignature Language="C#" Value="public void ReleaseWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseWriterLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseWriterLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseWriterLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseWriterLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseWriterLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseWriterLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="17d0f-283">Уменьшает на единицу счетчик блокировок данной блокировки записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-283">Decrements the lock count on the writer lock.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-284"><xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> уменьшает число блокировок модуля записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-284"><xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> decrements the writer lock count.</span></span> <span data-ttu-id="17d0f-285">Когда счетчик достигнет нуля, блокировка записи освобождается.</span><span class="sxs-lookup"><span data-stu-id="17d0f-285">When the count reaches zero, the writer lock is released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="17d0f-286">Если поток имеет блокировку чтения или не имеет блокировок, вызов `ReleaseWriterLock` создает <xref:System.ApplicationException>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-286">If a thread has a reader lock, or no locks, calling `ReleaseWriterLock` throws an <xref:System.ApplicationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17d0f-287">В следующем примере кода показано, как получить и освободить блокировку записи и как обрабатывалось исключение, возникающее при истечении времени ожидания запроса.</span><span class="sxs-lookup"><span data-stu-id="17d0f-287">The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="17d0f-288">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-288">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="17d0f-289">Поток не владеет блокировкой записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-289">The thread does not have the writer lock.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-290">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-290">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-291">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-291">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RestoreLock">
      <MemberSignature Language="C#" Value="public void RestoreLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RestoreLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RestoreLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RestoreLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.RestoreLock : LockCookie -&gt; unit" Usage="readerWriterLock.RestoreLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie"><span data-ttu-id="17d0f-292">Объект <see cref="T:System.Threading.LockCookie" />, возвращаемый <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span><span class="sxs-lookup"><span data-stu-id="17d0f-292">A <see cref="T:System.Threading.LockCookie" /> returned by <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span></span></param>
        <summary><span data-ttu-id="17d0f-293">Возвращает состояние блокировки потока к тому, которое было до вызова метода <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span><span class="sxs-lookup"><span data-stu-id="17d0f-293">Restores the lock status of the thread to what it was before calling <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-294">Состояние, восстановленное `RestoreLock`, включает счетчик рекурсивных блокировок.</span><span class="sxs-lookup"><span data-stu-id="17d0f-294">The state restored by `RestoreLock` includes the recursive lock count.</span></span>  
  
 <span data-ttu-id="17d0f-295">Поток блокируется, если пытается восстановить блокировку модуля чтения после того, как другой поток получит блокировку записи, или если она попытается восстановить блокировку записи после того, как другой поток получит блокировку чтения или записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-295">A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock.</span></span> <span data-ttu-id="17d0f-296">Поскольку `RestoreLock` не принимает время ожидания, следует избегать возможных взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="17d0f-296">Because `RestoreLock` does not accept a time-out, you should take care to avoid possible deadlocks.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="17d0f-297">Перед вызовом `RestoreLock`убедитесь, что были освобождены все блокировки, полученные с момента вызова <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-297">Before calling `RestoreLock`, make sure you have released all locks acquired since the call to <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span></span> <span data-ttu-id="17d0f-298">Например, поток взаимоблокируется, если он получает блокировку чтения, а затем пытается восстановить более раннюю блокировку записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-298">For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock.</span></span> <span data-ttu-id="17d0f-299">Для обнаружения таких дополнительных блокировок используйте <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> и <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-299">Use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> and <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> to detect such additional locks.</span></span>  
  
 <span data-ttu-id="17d0f-300">Не используйте <xref:System.Threading.LockCookie>, возвращенные из <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-300">Do not use a <xref:System.Threading.LockCookie> returned from <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17d0f-301">В следующем примере кода показано, как использовать метод <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> для освобождения блокировки, независимо от того, сколько раз она была получена потоком, а также как восстановить состояние блокировки позже.</span><span class="sxs-lookup"><span data-stu-id="17d0f-301">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.</span></span>  
  
 <span data-ttu-id="17d0f-302">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-302">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="17d0f-303">Адрес <paramref name="lockCookie" /> является пустым указателем.</span><span class="sxs-lookup"><span data-stu-id="17d0f-303">The address of <paramref name="lockCookie" /> is a null pointer.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-304">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-304">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-305">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-305">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpgradeToWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="17d0f-306">Повышает уровень блокировки чтения до блокировки записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-306">Upgrades a reader lock to the writer lock.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (millisecondsTimeout As Integer) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : int -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="17d0f-307">Время ожидания в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="17d0f-307">The time-out in milliseconds.</span></span></param>
        <summary><span data-ttu-id="17d0f-308">Повышает уровень блокировки чтения до блокировки записи, используя значение <see langword="Int32" /> для задания времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="17d0f-308">Upgrades a reader lock to the writer lock, using an <see langword="Int32" /> value for the time-out.</span></span></summary>
        <returns><span data-ttu-id="17d0f-309">Значение <see cref="T:System.Threading.LockCookie" />.</span><span class="sxs-lookup"><span data-stu-id="17d0f-309">A <see cref="T:System.Threading.LockCookie" /> value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-310">Когда поток вызывает `UpgradeToWriterLock` освобождается блокировка чтения, независимо от счетчика блокировок, и поток переходит в конец очереди для блокировки записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-310">When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</span></span> <span data-ttu-id="17d0f-311">Таким же, другие потоки могут записывать данные в ресурс до того, как поток, запрашивающий обновление, получит блокировку записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-311">Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="17d0f-312">Исключение времени ожидания не создается, пока поток, вызвавший метод <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>, не сможет повторно получить блокировку чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-312">The time-out exception is not thrown until the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method can reacquire the reader lock.</span></span> <span data-ttu-id="17d0f-313">Если других потоков, ожидающих блокировки записи, нет, это происходит немедленно.</span><span class="sxs-lookup"><span data-stu-id="17d0f-313">If there are no other threads waiting for the writer lock, this happens immediately.</span></span> <span data-ttu-id="17d0f-314">Однако если другой поток помещается в очередь для блокировки записи, то поток, вызвавший метод <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>, не может повторно получить блокировку чтения, пока все текущие модули чтения не освободят свои блокировки, а один поток получил и освободил блокировку записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-314">However, if another thread is queued for the writer lock, the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</span></span> <span data-ttu-id="17d0f-315">Это справедливо, даже если другой поток, запрашивающий блокировку записи, запросил его после текущего потока, который вызвал метод <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-315">This is true even if the other thread that requested the writer lock requested it after the current thread called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method.</span></span>  
  
 <span data-ttu-id="17d0f-316">Чтобы восстановить состояние блокировки, вызовите <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> с помощью <xref:System.Threading.LockCookie>, возвращаемого `UpgradeToWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="17d0f-316">To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`.</span></span> <span data-ttu-id="17d0f-317">Не используйте этот `LockCookie` с <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-317">Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span></span>  
  
 <span data-ttu-id="17d0f-318">Если поток не имеет блокировки чтения, не используйте `UpgradeToWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="17d0f-318">When a thread has no reader lock, do not use `UpgradeToWriterLock`.</span></span> <span data-ttu-id="17d0f-319">Взамен рекомендуется использовать <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-319">Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead.</span></span>  
  
 <span data-ttu-id="17d0f-320">Допустимые значения времени ожидания см. в разделе <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-320">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17d0f-321">В следующем примере кода показано, как запросить блокировку чтения, обновить блокировку чтения до блокировки записи и вернуться к блокировке чтения снова.</span><span class="sxs-lookup"><span data-stu-id="17d0f-321">The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.</span></span>  
  
 <span data-ttu-id="17d0f-322">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-322">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="17d0f-323">Время ожидания, заданное параметром <paramref name="millisecondsTimeout" />, истекло до удовлетворения запроса на блокировку.</span><span class="sxs-lookup"><span data-stu-id="17d0f-323"><paramref name="millisecondsTimeout" /> expires before the lock request is granted.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-324">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-324">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-325">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-325">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (timeout As TimeSpan) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : TimeSpan -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="17d0f-326">Период <see langword="TimeSpan" />, задающий время ожидания.</span><span class="sxs-lookup"><span data-stu-id="17d0f-326">The <see langword="TimeSpan" /> specifying the time-out period.</span></span></param>
        <summary><span data-ttu-id="17d0f-327">Повышает уровень блокировки чтения до блокировки записи, используя значение <see langword="TimeSpan" /> для задания времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="17d0f-327">Upgrades a reader lock to the writer lock, using a <see langword="TimeSpan" /> value for the time-out.</span></span></summary>
        <returns><span data-ttu-id="17d0f-328">Значение <see cref="T:System.Threading.LockCookie" />.</span><span class="sxs-lookup"><span data-stu-id="17d0f-328">A <see cref="T:System.Threading.LockCookie" /> value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-329">Когда поток вызывает `UpgradeToWriterLock` освобождается блокировка чтения, независимо от счетчика блокировок, и поток переходит в конец очереди для блокировки записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-329">When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</span></span> <span data-ttu-id="17d0f-330">Таким же, другие потоки могут записывать данные в ресурс до того, как поток, запрашивающий обновление, получит блокировку записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-330">Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="17d0f-331">Исключение времени ожидания не создается, пока поток, вызвавший метод <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>, не сможет повторно получить блокировку чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-331">The time-out exception is not thrown until the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method can reacquire the reader lock.</span></span> <span data-ttu-id="17d0f-332">Если других потоков, ожидающих блокировки записи, нет, это происходит немедленно.</span><span class="sxs-lookup"><span data-stu-id="17d0f-332">If there are no other threads waiting for the writer lock, this happens immediately.</span></span> <span data-ttu-id="17d0f-333">Однако если другой поток помещается в очередь для блокировки записи, то поток, вызвавший метод <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>, не может повторно получить блокировку чтения, пока все текущие модули чтения не освободят свои блокировки, а один поток получил и освободил блокировку записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-333">However, if another thread is queued for the writer lock, the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</span></span> <span data-ttu-id="17d0f-334">Это справедливо, даже если другой поток, запрашивающий блокировку записи, запросил его после текущего потока, который вызвал метод <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-334">This is true even if the other thread that requested the writer lock requested it after the current thread called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method.</span></span>  
  
 <span data-ttu-id="17d0f-335">Чтобы восстановить состояние блокировки, вызовите <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> с помощью <xref:System.Threading.LockCookie>, возвращаемого `UpgradeToWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="17d0f-335">To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`.</span></span> <span data-ttu-id="17d0f-336">Не используйте этот `LockCookie` с <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-336">Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span></span>  
  
 <span data-ttu-id="17d0f-337">Если поток не имеет блокировки чтения, не используйте `UpgradeToWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="17d0f-337">When a thread has no reader lock, do not use `UpgradeToWriterLock`.</span></span> <span data-ttu-id="17d0f-338">Взамен рекомендуется использовать <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-338">Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead.</span></span>  
  
 <span data-ttu-id="17d0f-339">Допустимые значения времени ожидания см. в разделе <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-339">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="17d0f-340">Время ожидания, заданное параметром <paramref name="timeout" />, истекло до удовлетворения запроса на блокировку.</span><span class="sxs-lookup"><span data-stu-id="17d0f-340"><paramref name="timeout" /> expires before the lock request is granted.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="17d0f-341">Параметр <paramref name="timeout" /> содержит отрицательное значение, отличное от -1.</span><span class="sxs-lookup"><span data-stu-id="17d0f-341"><paramref name="timeout" /> specifies a negative value other than -1 milliseconds.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-342">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-342">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-343">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-343">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriterSeqNum">
      <MemberSignature Language="C#" Value="public int WriterSeqNum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriterSeqNum" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriterSeqNum As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriterSeqNum { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WriterSeqNum : int" Usage="System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="17d0f-344">Возвращает текущий последовательный номер.</span><span class="sxs-lookup"><span data-stu-id="17d0f-344">Gets the current sequence number.</span></span></summary>
        <value><span data-ttu-id="17d0f-345">Текущий последовательный номер.</span><span class="sxs-lookup"><span data-stu-id="17d0f-345">The current sequence number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="17d0f-346">Порядковый номер увеличивается каждый раз, когда поток получает блокировку записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-346">The sequence number increases whenever a thread acquires the writer lock.</span></span> <span data-ttu-id="17d0f-347">Вы можете сохранить порядковый номер и передать его в <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> позже, если вы хотите определить, получали ли другие потоки блокировку записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-347">You can save the sequence number and pass it to <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.</span></span>  
  
 <span data-ttu-id="17d0f-348">Для повышения производительности приложения можно использовать `WriterSeqNum`.</span><span class="sxs-lookup"><span data-stu-id="17d0f-348">You can use `WriterSeqNum` to improve application performance.</span></span> <span data-ttu-id="17d0f-349">Например, поток может кэшировать сведения, которые он получает, при удержании блокировки чтения.</span><span class="sxs-lookup"><span data-stu-id="17d0f-349">For example, a thread might cache the information it obtains while holding a reader lock.</span></span> <span data-ttu-id="17d0f-350">После освобождения и последующего повторного получения блокировки поток может определить, были ли другие потоки записаны в ресурс путем вызова `AnyWritersSince`; в противном случае можно использовать кэшированные данные.</span><span class="sxs-lookup"><span data-stu-id="17d0f-350">After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling `AnyWritersSince`; if not, the cached information can be used.</span></span> <span data-ttu-id="17d0f-351">Этот метод полезен при чтении информации, защищенной блокировкой, дорогостоящей; Например, выполнение запроса к базе данных.</span><span class="sxs-lookup"><span data-stu-id="17d0f-351">This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.</span></span>  
  
 <span data-ttu-id="17d0f-352">Вызывающий объект должен удерживать блокировку чтения или записи, чтобы порядковый номер был полезен.</span><span class="sxs-lookup"><span data-stu-id="17d0f-352">The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="17d0f-353">В следующем примере кода показано, как использовать свойство <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> и метод <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A>, чтобы определить, получил ли другой поток блокировку записи на защищенный ресурс, начиная с текущего потока, который последним удерживал блокировку записи.</span><span class="sxs-lookup"><span data-stu-id="17d0f-353">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property and the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.</span></span>  
  
 <span data-ttu-id="17d0f-354">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="17d0f-354">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="17d0f-355">Управляемая поточность</span><span class="sxs-lookup"><span data-stu-id="17d0f-355">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/reader-writer-locks.md"><span data-ttu-id="17d0f-356">ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="17d0f-356">ReaderWriterLock</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
