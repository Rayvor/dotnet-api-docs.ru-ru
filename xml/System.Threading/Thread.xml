<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="03474c2dd83426304c56b648a829bf125aa2443c" /><Meta Name="ms.sourcegitcommit" Value="a6c4dae9c1ba2cfbc4452907ef5697ad1f870c0d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/30/2019" /><Meta Name="ms.locfileid" Value="73082364" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="546fd-101">Создает и контролирует поток, задает приоритет и возвращает статус.</span><span class="sxs-lookup"><span data-stu-id="546fd-101">Creates and controls a thread, sets its priority, and gets its status.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-102">При запуске процесса среда CLR автоматически создает один передний поток для выполнения кода приложения.</span><span class="sxs-lookup"><span data-stu-id="546fd-102">When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</span></span> <span data-ttu-id="546fd-103">Вместе с основным потоком переднего плана процесс может создать один или несколько потоков для выполнения части программного кода, связанного с процессом.</span><span class="sxs-lookup"><span data-stu-id="546fd-103">Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</span></span> <span data-ttu-id="546fd-104">Эти потоки могут выполняться как на переднем плане, так и в фоновом режиме.</span><span class="sxs-lookup"><span data-stu-id="546fd-104">These threads can execute either in the foreground or in the background.</span></span> <span data-ttu-id="546fd-105">Кроме того, можно использовать класс <xref:System.Threading.ThreadPool> для выполнения кода в рабочих потоках, управляемых средой CLR.</span><span class="sxs-lookup"><span data-stu-id="546fd-105">In addition, you can use the <xref:System.Threading.ThreadPool> class to execute code on worker threads that are managed by the common language runtime.</span></span>  
  
 <span data-ttu-id="546fd-106">Содержание раздела</span><span class="sxs-lookup"><span data-stu-id="546fd-106">In this section</span></span>  
  
 <span data-ttu-id="546fd-107">[Запуск потока](#Starting) </span><span class="sxs-lookup"><span data-stu-id="546fd-107">[Starting a thread](#Starting) </span></span>  
 <span data-ttu-id="546fd-108">[Получение объектов потока](#Retrieving) </span><span class="sxs-lookup"><span data-stu-id="546fd-108">[Retrieving Thread objects](#Retrieving) </span></span>  
 <span data-ttu-id="546fd-109">[Передний и фоновый потоки](#Foreground) </span><span class="sxs-lookup"><span data-stu-id="546fd-109">[Foreground and background threads](#Foreground) </span></span>  
 <span data-ttu-id="546fd-110">[Культура и потоки](#Culture) </span><span class="sxs-lookup"><span data-stu-id="546fd-110">[Culture and threads](#Culture) </span></span>  
 [<span data-ttu-id="546fd-111">Получение сведений о потоках и управление ими</span><span class="sxs-lookup"><span data-stu-id="546fd-111">Getting information about and controlling threads</span></span>](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a><span data-ttu-id="546fd-112">Запуск потока</span><span class="sxs-lookup"><span data-stu-id="546fd-112">Starting a thread</span></span>  
 <span data-ttu-id="546fd-113">Чтобы запустить поток, укажите делегат, представляющий метод, который поток должен выполнить в своем конструкторе класса.</span><span class="sxs-lookup"><span data-stu-id="546fd-113">You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</span></span> <span data-ttu-id="546fd-114">Затем вызывается метод <xref:System.Threading.Thread.Start%2A>, чтобы начать выполнение.</span><span class="sxs-lookup"><span data-stu-id="546fd-114">You then call the <xref:System.Threading.Thread.Start%2A> method to begin execution.</span></span>  
  
 <span data-ttu-id="546fd-115">Конструкторы <xref:System.Threading.Thread> могут принимать один из двух типов делегатов в зависимости от того, можно ли передать аргумент в метод для выполнения:</span><span class="sxs-lookup"><span data-stu-id="546fd-115">The <xref:System.Threading.Thread> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</span></span>  
  
-   <span data-ttu-id="546fd-116">Если метод не имеет аргументов, в конструктор передается делегат <xref:System.Threading.ThreadStart>.</span><span class="sxs-lookup"><span data-stu-id="546fd-116">If the method has no arguments, you pass a <xref:System.Threading.ThreadStart> delegate to  the constructor.</span></span> <span data-ttu-id="546fd-117">Он имеет подпись:</span><span class="sxs-lookup"><span data-stu-id="546fd-117">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     <span data-ttu-id="546fd-118">В следующем примере создается и запускается поток, который выполняет метод `ExecuteInForeground`.</span><span class="sxs-lookup"><span data-stu-id="546fd-118">The following example creates and starts a thread that executes the `ExecuteInForeground` method.</span></span> <span data-ttu-id="546fd-119">Метод отображает сведения о некоторых свойствах потока, затем выполняет цикл, в котором он приостанавливается на половину секунды и отображает прошедшее количество секунд.</span><span class="sxs-lookup"><span data-stu-id="546fd-119">The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</span></span> <span data-ttu-id="546fd-120">Когда поток выполнялся по крайней мере в течение пяти секунд, цикл завершается, и поток завершает выполнение.</span><span class="sxs-lookup"><span data-stu-id="546fd-120">When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</span></span>  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   <span data-ttu-id="546fd-121">Если метод имеет аргумент, в конструктор передается делегат <xref:System.Threading.ParameterizedThreadStart>.</span><span class="sxs-lookup"><span data-stu-id="546fd-121">If the method has an argument, you pass a <xref:System.Threading.ParameterizedThreadStart> delegate to the constructor.</span></span> <span data-ttu-id="546fd-122">Он имеет подпись:</span><span class="sxs-lookup"><span data-stu-id="546fd-122">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     <span data-ttu-id="546fd-123">Затем метод, выполняемый делегатом, может привести ( C#в) или преобразовать (в Visual Basic) параметр к соответствующему типу.</span><span class="sxs-lookup"><span data-stu-id="546fd-123">The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</span></span>  
  
     <span data-ttu-id="546fd-124">Следующий пример идентичен предыдущему, за исключением того, что он вызывает конструктор <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>.</span><span class="sxs-lookup"><span data-stu-id="546fd-124">The following example is identical to the previous one, except that it calls the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor.</span></span> <span data-ttu-id="546fd-125">Эта версия метода `ExecuteInForeground` имеет один параметр, который представляет приблизительное количество миллисекунд, которое должен выполнить цикл.</span><span class="sxs-lookup"><span data-stu-id="546fd-125">This version of the `ExecuteInForeground` method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</span></span>  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 <span data-ttu-id="546fd-126">Не обязательно хранить ссылку на объект <xref:System.Threading.Thread> после запуска потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-126">It is not necessary to retain a reference to a <xref:System.Threading.Thread> object once you have started the thread.</span></span> <span data-ttu-id="546fd-127">Поток продолжит выполняться до завершения процедуры потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-127">The thread continues to execute until the thread procedure is complete.</span></span>  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a><span data-ttu-id="546fd-128">Получение объектов потока</span><span class="sxs-lookup"><span data-stu-id="546fd-128">Retrieving Thread objects</span></span>  
 <span data-ttu-id="546fd-129">Свойство static (`Shared` в Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> можно использовать для получения ссылки на выполняющийся в данный момент поток из кода, выполняемого потоком.</span><span class="sxs-lookup"><span data-stu-id="546fd-129">You can use the static (`Shared` in Visual Basic)  <xref:System.Threading.Thread.CurrentThread%2A> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</span></span> <span data-ttu-id="546fd-130">В следующем примере свойство <xref:System.Threading.Thread.CurrentThread%2A> используется для вывода сведений о главном потоке приложения, другом основном потоке, фоновом потоке и потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-130">The following example uses the <xref:System.Threading.Thread.CurrentThread%2A> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</span></span>  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a><span data-ttu-id="546fd-131">Передний и фоновый потоки</span><span class="sxs-lookup"><span data-stu-id="546fd-131">Foreground and background threads</span></span>  
 <span data-ttu-id="546fd-132">Экземпляры класса <xref:System.Threading.Thread> представляют либо потоки переднего плана, либо фоновые потоки.</span><span class="sxs-lookup"><span data-stu-id="546fd-132">Instances of the <xref:System.Threading.Thread> class represent either foreground threads or background threads.</span></span> <span data-ttu-id="546fd-133">Фоновые потоки идентичны потокам переднего плана с одним исключением: фоновый поток не сохраняет выполнение процесса, если все потоки переднего плана завершаются.</span><span class="sxs-lookup"><span data-stu-id="546fd-133">Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</span></span> <span data-ttu-id="546fd-134">После остановки всех активных потоков среда выполнения останавливает все фоновые потоки и завершает работу.</span><span class="sxs-lookup"><span data-stu-id="546fd-134">Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</span></span>  
  
 <span data-ttu-id="546fd-135">По умолчанию следующие потоки выполняются на переднем плане:</span><span class="sxs-lookup"><span data-stu-id="546fd-135">By default, the following threads execute in the foreground:</span></span>  
  
-   <span data-ttu-id="546fd-136">Главный поток приложения.</span><span class="sxs-lookup"><span data-stu-id="546fd-136">The main application thread.</span></span>  
  
-   <span data-ttu-id="546fd-137">Все потоки, созданные путем вызова конструктора класса <xref:System.Threading.Thread>.</span><span class="sxs-lookup"><span data-stu-id="546fd-137">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="546fd-138">Следующие потоки по умолчанию выполняются в фоновом режиме:</span><span class="sxs-lookup"><span data-stu-id="546fd-138">The following threads execute in the background by default:</span></span>  
  
-   <span data-ttu-id="546fd-139">Потоки пула потоков, которые являются пулом рабочих потоков, обслуживаемых средой выполнения.</span><span class="sxs-lookup"><span data-stu-id="546fd-139">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span>  <span data-ttu-id="546fd-140">Пул потоков и расписание работы можно настроить в потоках пула потоков с помощью класса <xref:System.Threading.ThreadPool>.</span><span class="sxs-lookup"><span data-stu-id="546fd-140">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="546fd-141">Асинхронные операции на основе задач автоматически выполняются в потоках пула потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-141">Task-based asynchronous operations automatically execute on thread pool threads.</span></span> <span data-ttu-id="546fd-142">Асинхронные операции на основе задач используют классы <xref:System.Threading.Tasks.Task> и <xref:System.Threading.Tasks.Task%601> для реализации [асинхронной модели на основе задач](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span><span class="sxs-lookup"><span data-stu-id="546fd-142">Task-based asynchronous operations use the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes to implement the [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span></span>  
  
-   <span data-ttu-id="546fd-143">Все потоки, которые вводят управляемую среду выполнения из неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-143">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
 <span data-ttu-id="546fd-144">Можно изменить поток для выполнения в фоновом режиме, задав свойство <xref:System.Threading.Thread.IsBackground%2A> в любое время.</span><span class="sxs-lookup"><span data-stu-id="546fd-144">You can change a thread to execute in the background by setting the <xref:System.Threading.Thread.IsBackground%2A> property at any time.</span></span>  <span data-ttu-id="546fd-145">Фоновые потоки полезны для любой операции, которая должна продолжаться при условии, что приложение выполняется, но не должно препятствовать его завершению, например отслеживать изменения файловой системы или входящие подключения через сокет.</span><span class="sxs-lookup"><span data-stu-id="546fd-145">Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</span></span>  
  
 <span data-ttu-id="546fd-146">В следующем примере показано различие между передним и фоновым потоками.</span><span class="sxs-lookup"><span data-stu-id="546fd-146">The following example illustrates the difference between foreground and background threads.</span></span> <span data-ttu-id="546fd-147">Он похож на первый пример в разделе [starting of Thread](#Starting) , за исключением того, что он задает выполнение потока в фоновом режиме перед его запуском.</span><span class="sxs-lookup"><span data-stu-id="546fd-147">It is like the first example in the [Starting a thread](#Starting) section, except that it sets the thread to execute in the background before starting it.</span></span> <span data-ttu-id="546fd-148">Как видно из выходных данных, цикл прерывается до его выполнения в течение пяти секунд.</span><span class="sxs-lookup"><span data-stu-id="546fd-148">As the output shows, the loop is interrupted before it executes for five seconds.</span></span>  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a><span data-ttu-id="546fd-149">Культура и потоки</span><span class="sxs-lookup"><span data-stu-id="546fd-149">Culture and threads</span></span>  
 <span data-ttu-id="546fd-150">Каждый поток имеет язык и региональные параметры, представленные свойством <xref:System.Threading.Thread.CurrentCulture%2A>, и языком и региональными параметрами пользовательского интерфейса, представленными свойством <xref:System.Threading.Thread.CurrentUICulture%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-150">Each thread has a culture, represented by the <xref:System.Threading.Thread.CurrentCulture%2A> property, and a UI culture, represented by the <xref:System.Threading.Thread.CurrentUICulture%2A> property.</span></span>  <span data-ttu-id="546fd-151">Текущий язык и региональные параметры поддерживают такие операции с учетом языка и региональных параметров, как синтаксический анализ и форматирование, сравнение строк и сортировка, а также управление системой записи и календарем, используемыми потоком.</span><span class="sxs-lookup"><span data-stu-id="546fd-151">The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</span></span> <span data-ttu-id="546fd-152">Текущий язык и региональные параметры пользовательского интерфейса обеспечивают извлечение ресурсов в файлах ресурсов с учетом языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="546fd-152">The current UI culture provides for culture-sensitive retrieval of resources in resource files.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="546fd-153">Свойства <xref:System.Threading.Thread.CurrentCulture> и <xref:System.Threading.Thread.CurrentUICulture> не работают надежно при использовании в любом потоке, отличном от текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-153">The <xref:System.Threading.Thread.CurrentCulture> and <xref:System.Threading.Thread.CurrentUICulture> properties don't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="546fd-154">В .NET Framework чтение этих свойств является надежным, хотя установка этих свойств для потока, отличного от текущего потока, — нет.</span><span class="sxs-lookup"><span data-stu-id="546fd-154">In .NET Framework, reading these properties is reliable, although setting these properties for a thread other than the current thread is not.</span></span> <span data-ttu-id="546fd-155">В .NET Core создается <xref:System.InvalidOperationException>, если поток пытается прочитать или записать эти свойства в другом потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-155">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write these properties on a different thread.</span></span>
> <span data-ttu-id="546fd-156">Для получения и задания текущего языка и региональных параметров рекомендуется использовать свойства <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> и <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-156">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> properties to retrieve and set the current culture.</span></span>

 <span data-ttu-id="546fd-157">При создании экземпляра нового потока его язык и региональные параметры и региональные параметры пользовательского интерфейса определяются текущими языковыми параметрами и региональными параметрами пользовательского интерфейса, а не культурой и культурой пользовательского интерфейса потока, из которого создается новый поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-157">When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</span></span> <span data-ttu-id="546fd-158">Это означает, например, что если текущей культурной средой системы является английский (США), а текущим языком и региональными параметрами основного потока приложения является французский (Франция), то язык и региональные параметры нового потока, созданного путем вызова конструктора <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> из основного потока, — это Английский (США), а не французский (Франция).</span><span class="sxs-lookup"><span data-stu-id="546fd-158">This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor from the primary thread is English (United States), and not French (France).</span></span> <span data-ttu-id="546fd-159">Дополнительные сведения см. в разделе "Культура и потоки" раздела <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="546fd-159">For more information, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="546fd-160">Это неверно для потоков, выполняющих асинхронные операции для приложений, предназначенных для [!INCLUDE[net_v46](~/includes/net-v46-md.md)] и более поздних версий. в этом случае язык и региональные параметры пользовательского интерфейса являются частью контекста асинхронных операций. поток, в котором асинхронная операция выполняется по умолчанию, наследует язык и региональные параметры пользовательского интерфейса потока, из которого была запущена асинхронная операция.</span><span class="sxs-lookup"><span data-stu-id="546fd-160">This is not true of threads that execute asynchronous operations for apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)] and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</span></span> <span data-ttu-id="546fd-161">Дополнительные сведения см. в подразделе "Язык и региональные параметры в асинхронных операциях на основе задач" раздела, посвященного классу <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="546fd-161">For more information, see the "Culture and task-based asynchronous operations" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
 <span data-ttu-id="546fd-162">Можно выполнить одно из следующих действий, чтобы убедиться, что все потоки, выполняющиеся в приложении, совместно используют один и тот же язык и региональные параметры пользовательского интерфейса:</span><span class="sxs-lookup"><span data-stu-id="546fd-162">You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</span></span>  
  
-   <span data-ttu-id="546fd-163">Можно передать объект <xref:System.Globalization.CultureInfo>, представляющий этот язык и региональные параметры, в делегат <xref:System.Threading.ParameterizedThreadStart> или метод <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-163">You can pass a <xref:System.Globalization.CultureInfo> object that represents that culture to the <xref:System.Threading.ParameterizedThreadStart> delegate or the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="546fd-164">Для приложений, работающих на [!INCLUDE[net_v45](~/includes/net-v45-md.md)] и более поздних версиях, можно определить культуру и язык и региональные параметры пользовательского интерфейса, которые будут назначены всем потокам, созданным в домене приложения, задав значения свойств <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> и <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-164">For apps running on the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="546fd-165">Обратите внимание, что это параметр домена для каждого приложения.</span><span class="sxs-lookup"><span data-stu-id="546fd-165">Note that this is a per-application domain setting.</span></span>  

 <span data-ttu-id="546fd-166">Дополнительные сведения и примеры см. в разделе "Культура и потоки" статьи о классе <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="546fd-166">For more information and examples, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a><span data-ttu-id="546fd-167">Получение сведений о потоках и управление ими</span><span class="sxs-lookup"><span data-stu-id="546fd-167">Getting information about and controlling threads</span></span>  
 <span data-ttu-id="546fd-168">Можно получить несколько значений свойств, которые предоставляют сведения о потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-168">You can retrieve a number of property values that provide information about a thread.</span></span> <span data-ttu-id="546fd-169">В некоторых случаях можно также задать значения этих свойств для управления работой потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-169">In some cases, you can also set these property values to control the operation of the thread.</span></span> <span data-ttu-id="546fd-170">Ниже перечислены эти свойства потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-170">These thread properties include:</span></span>  
  
-   <span data-ttu-id="546fd-171">Имя.</span><span class="sxs-lookup"><span data-stu-id="546fd-171">A name.</span></span> <span data-ttu-id="546fd-172"><xref:System.Threading.Thread.Name%2A> — это свойство однократной записи, которое можно использовать для определения потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-172"><xref:System.Threading.Thread.Name%2A> is a write-once property that you can use to identify a thread.</span></span>  <span data-ttu-id="546fd-173">Значение по умолчанию — `null`.</span><span class="sxs-lookup"><span data-stu-id="546fd-173">Its default value is `null`.</span></span>  
  
-   <span data-ttu-id="546fd-174">Хэш-код, который можно получить, вызвав метод <xref:System.Threading.Thread.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-174">A hash code, which you can retrieve by calling the <xref:System.Threading.Thread.GetHashCode%2A> method.</span></span> <span data-ttu-id="546fd-175">Хэш-код можно использовать для уникальной идентификации потока; в течение времени существования потока его хэш-код не будет конфликтовать со значением из любого другого потока, независимо от домена приложения, из которого получено значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-175">The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</span></span>  
  
-   <span data-ttu-id="546fd-176">Идентификатор потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-176">A thread ID.</span></span> <span data-ttu-id="546fd-177">Значение свойства <xref:System.Threading.Thread.ManagedThreadId%2A>, доступное только для чтения, назначается средой выполнения и уникально идентифицирует поток в своем процессе.</span><span class="sxs-lookup"><span data-stu-id="546fd-177">The value of the read-only <xref:System.Threading.Thread.ManagedThreadId%2A> property is assigned by the runtime and uniquely identifies a thread within its process.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="546fd-178">[ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) операционной системы не имеет фиксированного отношения с управляемым потоком, так как неуправляемый узел может управлять отношением между управляемым и неуправляемым потоками.</span><span class="sxs-lookup"><span data-stu-id="546fd-178">An operating-system [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="546fd-179">В частности, сложный узел может использовать [API размещения CLR](https://msdn.microsoft.com/library/ms404385.aspx) для планирования большого количества управляемых потоков в одном потоке операционной системы или для перемещения управляемого потока между различными потоками операционной системы.</span><span class="sxs-lookup"><span data-stu-id="546fd-179">Specifically, a sophisticated host can use the [CLR Hosting API](https://msdn.microsoft.com/library/ms404385.aspx) to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</span></span>  
  
-   <span data-ttu-id="546fd-180">Текущее состояние потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-180">The thread's current state.</span></span> <span data-ttu-id="546fd-181">В течение срока существования поток всегда находится в одном или нескольких состояниях, определенных свойством <xref:System.Threading.ThreadState>.</span><span class="sxs-lookup"><span data-stu-id="546fd-181">For the duration of its existence, a thread is always in one or more of the states defined by the <xref:System.Threading.ThreadState> property.</span></span>  
  
-   <span data-ttu-id="546fd-182">Уровень приоритета планирования, определяемый свойством <xref:System.Threading.ThreadPriority>.</span><span class="sxs-lookup"><span data-stu-id="546fd-182">A scheduling priority level, which is defined by the <xref:System.Threading.ThreadPriority> property.</span></span> <span data-ttu-id="546fd-183">Хотя это значение можно задать для запроса приоритета потока, операционная система не гарантирует его соблюдение.</span><span class="sxs-lookup"><span data-stu-id="546fd-183">Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</span></span>  
  
-   <span data-ttu-id="546fd-184">Свойство <xref:System.Threading.Thread.IsThreadPoolThread%2A> только для чтения, которое указывает, является ли поток потоком пула потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-184">The read-only <xref:System.Threading.Thread.IsThreadPoolThread%2A> property, which indicates whether a thread is  a thread pool thread.</span></span>  
  
-   <span data-ttu-id="546fd-185">Свойство <xref:System.Threading.Thread.IsBackground%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-185">The <xref:System.Threading.Thread.IsBackground%2A> property.</span></span> <span data-ttu-id="546fd-186">Дополнительные сведения см. в разделе [основной и фоновый потоки](#Foreground) .</span><span class="sxs-lookup"><span data-stu-id="546fd-186">For more information, see the [Foreground and background threads](#Foreground) section.</span></span>  
  
## Examples  
 <span data-ttu-id="546fd-187">В следующем примере демонстрируются простые функции работы с потоками.</span><span class="sxs-lookup"><span data-stu-id="546fd-187">The following example demonstrates simple threading functionality.</span></span>  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 <span data-ttu-id="546fd-188">Этот код выдает результат, аналогичный приведенному ниже:</span><span class="sxs-lookup"><span data-stu-id="546fd-188">This code produces output similar to the following:</span></span>  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="546fd-189">Данный тип потокобезопасен.</span><span class="sxs-lookup"><span data-stu-id="546fd-189">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="546fd-190">Потоки и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="546fd-190">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="546fd-191">Использование потоков и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="546fd-191">Using Threads and Threading</span></span></related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96"><span data-ttu-id="546fd-192">Эталонный источник для класса потока</span><span class="sxs-lookup"><span data-stu-id="546fd-192">Reference Source for the Thread Class</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="546fd-193">Инициализирует новый экземпляр класса <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-193">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="546fd-194">Делегат, указывающий на методы, которые вызываются при запуске потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-194">A delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="546fd-195">Инициализирует новый экземпляр класса <see cref="T:System.Threading.Thread" />, при этом указывается делегат, позволяющий объекту быть переданным в поток при запуске потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-195">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-196">Поток не начинает выполняться при его создании.</span><span class="sxs-lookup"><span data-stu-id="546fd-196">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="546fd-197">Чтобы запланировать выполнение потока, вызовите метод <xref:System.Threading.Thread.Start%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-197">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span> <span data-ttu-id="546fd-198">Чтобы передать объект данных в поток, используйте перегрузку метода <xref:System.Threading.Thread.Start%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="546fd-198">To pass a data object to the thread, use the <xref:System.Threading.Thread.Start%28System.Object%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-199">Visual Basic пользователи могут опустить конструктор <xref:System.Threading.ThreadStart> при создании потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-199">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="546fd-200">Используйте оператор `AddressOf` при передаче метода, например `Dim t As New Thread(AddressOf ThreadProc)`.</span><span class="sxs-lookup"><span data-stu-id="546fd-200">Use the `AddressOf` operator when passing your method, for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="546fd-201">Visual Basic автоматически вызывает конструктор <xref:System.Threading.ThreadStart>.</span><span class="sxs-lookup"><span data-stu-id="546fd-201">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-202">В следующем примере показан синтаксис для создания и использования делегата <xref:System.Threading.ParameterizedThreadStart> с статическим методом и методом экземпляра.</span><span class="sxs-lookup"><span data-stu-id="546fd-202">The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="546fd-203"><paramref name="start" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-203"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="546fd-204">Создание потоков</span><span class="sxs-lookup"><span data-stu-id="546fd-204">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="546fd-205">Делегат <see cref="T:System.Threading.ThreadStart" />, указывающий на методы, которые вызываются при запуске потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-205">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="546fd-206">Инициализирует новый экземпляр класса <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-206">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-207">Поток не начинает выполняться при его создании.</span><span class="sxs-lookup"><span data-stu-id="546fd-207">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="546fd-208">Чтобы запланировать выполнение потока, вызовите метод <xref:System.Threading.Thread.Start%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-208">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-209">Visual Basic пользователи могут опустить конструктор <xref:System.Threading.ThreadStart> при создании потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-209">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="546fd-210">Используйте оператор `AddressOf` при передаче метода, например `Dim t As New Thread(AddressOf ThreadProc)`.</span><span class="sxs-lookup"><span data-stu-id="546fd-210">Use the `AddressOf` operator when passing your method for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="546fd-211">Visual Basic автоматически вызывает конструктор <xref:System.Threading.ThreadStart>.</span><span class="sxs-lookup"><span data-stu-id="546fd-211">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-212">В следующем примере кода показано, как создать поток, выполняющий статический метод.</span><span class="sxs-lookup"><span data-stu-id="546fd-212">The following code example shows how to create a thread that executes a static method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 <span data-ttu-id="546fd-213">В следующем примере кода показано, как создать поток, выполняющий метод экземпляра.</span><span class="sxs-lookup"><span data-stu-id="546fd-213">The following code example shows how to create a thread that executes an instance method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="546fd-214">Параметр <paramref name="start" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-214">The <paramref name="start" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="546fd-215">Создание потоков</span><span class="sxs-lookup"><span data-stu-id="546fd-215">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="546fd-216">Делегат <see cref="T:System.Threading.ParameterizedThreadStart" />, указывающий на методы, которые вызываются при запуске потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-216">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="546fd-217">Максимальный размер стека в байтах, используемый потоком, или же 0 для использования максимального размера по умолчанию, указывается в заголовке исполняемого файла.</span><span class="sxs-lookup"><span data-stu-id="546fd-217">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="546fd-218">Внимание! Для частично доверенного кода значение параметра <paramref name="maxStackSize" /> игнорируется, если оно превышает размер стека по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="546fd-218">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="546fd-219">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="546fd-219">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="546fd-220">Инициализирует новый экземпляр класса <see cref="T:System.Threading.Thread" />, при этом указывается делегат, позволяющий объекту быть переданным в поток при запуске потока с указанием максимального размера стека для потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-220">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-221">Старайтесь не использовать эту перегрузку конструктора.</span><span class="sxs-lookup"><span data-stu-id="546fd-221">Avoid using this constructor overload.</span></span> <span data-ttu-id="546fd-222">Размер стека по умолчанию, используемый перегрузкой конструктора <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>, является рекомендуемым размером стека для потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-222">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="546fd-223">Если в потоке имеются проблемы с памятью, наиболее вероятной причиной является ошибка программирования, например бесконечная рекурсия.</span><span class="sxs-lookup"><span data-stu-id="546fd-223">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="546fd-224">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], только полностью доверенный код может установить `maxStackSize` в значение, превышающее размер стека по умолчанию (1 МБ).</span><span class="sxs-lookup"><span data-stu-id="546fd-224">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="546fd-225">Если для `maxStackSize` задано большее значение, если код работает с частичным доверием, `maxStackSize` игнорируется и используется размер стека по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="546fd-225">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="546fd-226">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="546fd-226">No exception is thrown.</span></span> <span data-ttu-id="546fd-227">Код на любом уровне доверия может установить `maxStackSize` в значение, меньшее, чем размер стека по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="546fd-227">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-228">Если вы разрабатываете полностью доверенную библиотеку, которая будет использоваться частично доверенным кодом, и вам нужно запустить поток, требующий большого стека, перед созданием потока необходимо подтвердить полное доверие, иначе будет использоваться размер стека по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="546fd-228">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="546fd-229">Не выполняя это действие, если не полностью контролируется код, выполняемый в потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-229">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="546fd-230">Если `maxStackSize` меньше, чем минимальный размер стека, используется минимальный размер стека.</span><span class="sxs-lookup"><span data-stu-id="546fd-230">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="546fd-231">Если `maxStackSize` не кратен размеру страницы, он округляется до следующего большего размера, кратного размеру страницы.</span><span class="sxs-lookup"><span data-stu-id="546fd-231">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="546fd-232">Например, если вы используете .NET Framework версии 2,0 в Windows Vista, минимальный размер стека (262 144 байт) — 64 КБ (65 536 байт).</span><span class="sxs-lookup"><span data-stu-id="546fd-232">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-233">В версиях Microsoft Windows, предшествовавших Windows XP и Windows Server 2003, `maxStackSize` игнорируется, и используется размер стека, указанный в заголовке исполняемого файла.</span><span class="sxs-lookup"><span data-stu-id="546fd-233">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="546fd-234">Если указан очень малый размер стека, может потребоваться отключить проверку переполнения стека.</span><span class="sxs-lookup"><span data-stu-id="546fd-234">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="546fd-235">Если стек сильно ограничен, проверка может привести к переполнению стека.</span><span class="sxs-lookup"><span data-stu-id="546fd-235">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="546fd-236">Чтобы отключить проверку переполнения стека, добавьте следующий фрагмент в файл конфигурации приложения.</span><span class="sxs-lookup"><span data-stu-id="546fd-236">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="546fd-237">Свойство <paramref name="start" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-237"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="546fd-238">Значение параметра <paramref name="maxStackSize" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="546fd-238"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="maxStackSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="546fd-239">Делегат <see cref="T:System.Threading.ThreadStart" />, указывающий на методы, которые вызываются при запуске потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-239">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="546fd-240">Максимальный размер стека в байтах, используемый потоком, или же 0 для использования максимального размера по умолчанию, указывается в заголовке исполняемого файла.</span><span class="sxs-lookup"><span data-stu-id="546fd-240">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="546fd-241">Внимание! Для частично доверенного кода значение параметра <paramref name="maxStackSize" /> игнорируется, если оно превышает размер стека по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="546fd-241">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="546fd-242">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="546fd-242">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="546fd-243">Инициализирует новый экземпляр класса <see cref="T:System.Threading.Thread" />, указывая максимальный размер стека для потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-243">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-244">Старайтесь не использовать эту перегрузку конструктора.</span><span class="sxs-lookup"><span data-stu-id="546fd-244">Avoid using this constructor overload.</span></span> <span data-ttu-id="546fd-245">Размер стека по умолчанию, используемый перегрузкой конструктора <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>, является рекомендуемым размером стека для потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-245">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="546fd-246">Если в потоке имеются проблемы с памятью, наиболее вероятной причиной является ошибка программирования, например бесконечная рекурсия.</span><span class="sxs-lookup"><span data-stu-id="546fd-246">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="546fd-247">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], только полностью доверенный код может установить `maxStackSize` в значение, превышающее размер стека по умолчанию (1 МБ).</span><span class="sxs-lookup"><span data-stu-id="546fd-247">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="546fd-248">Если для `maxStackSize` задано большее значение, если код работает с частичным доверием, `maxStackSize` игнорируется и используется размер стека по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="546fd-248">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="546fd-249">Исключение не возникает.</span><span class="sxs-lookup"><span data-stu-id="546fd-249">No exception is thrown.</span></span> <span data-ttu-id="546fd-250">Код на любом уровне доверия может установить `maxStackSize` в значение, меньшее, чем размер стека по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="546fd-250">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-251">Если вы разрабатываете полностью доверенную библиотеку, которая будет использоваться частично доверенным кодом, и вам нужно запустить поток, требующий большого стека, перед созданием потока необходимо подтвердить полное доверие, иначе будет использоваться размер стека по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="546fd-251">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="546fd-252">Не выполняя это действие, если не полностью контролируется код, выполняемый в потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-252">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="546fd-253">Если `maxStackSize` меньше, чем минимальный размер стека, используется минимальный размер стека.</span><span class="sxs-lookup"><span data-stu-id="546fd-253">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="546fd-254">Если `maxStackSize` не кратен размеру страницы, он округляется до следующего большего размера, кратного размеру страницы.</span><span class="sxs-lookup"><span data-stu-id="546fd-254">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="546fd-255">Например, если вы используете .NET Framework версии 2,0 в Windows Vista, минимальный размер стека (262 144 байт) — 64 КБ (65 536 байт).</span><span class="sxs-lookup"><span data-stu-id="546fd-255">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-256">В версиях Microsoft Windows, предшествовавших Windows XP и Windows Server 2003, `maxStackSize` игнорируется, и используется размер стека, указанный в заголовке исполняемого файла.</span><span class="sxs-lookup"><span data-stu-id="546fd-256">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="546fd-257">Если указан очень малый размер стека, может потребоваться отключить проверку переполнения стека.</span><span class="sxs-lookup"><span data-stu-id="546fd-257">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="546fd-258">Если стек сильно ограничен, проверка может привести к переполнению стека.</span><span class="sxs-lookup"><span data-stu-id="546fd-258">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="546fd-259">Чтобы отключить проверку переполнения стека, добавьте следующий фрагмент в файл конфигурации приложения.</span><span class="sxs-lookup"><span data-stu-id="546fd-259">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="546fd-260">Свойство <paramref name="start" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-260"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="546fd-261">Значение параметра <paramref name="maxStackSize" /> меньше нуля.</span><span class="sxs-lookup"><span data-stu-id="546fd-261"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="546fd-262">Вызывает исключение <see cref="T:System.Threading.ThreadAbortException" /> в вызвавшем его потоке для того, чтобы начать процесс завершения потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-262">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="546fd-263">Вызов данного метода обычно завершает поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-263">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> <span data-ttu-id="546fd-264">Метод `Thread.Abort` следует использовать с осторожностью.</span><span class="sxs-lookup"><span data-stu-id="546fd-264">The `Thread.Abort` method should be used with caution.</span></span> <span data-ttu-id="546fd-265">Особенно при вызове метода для прерывания потока, отличного от текущего потока, неизвестно, какой код выполнялся или не удалось выполнить при возникновении <xref:System.Threading.ThreadAbortException>, а также не может быть уверенным в состоянии приложения, а также о том, какое приложение и состояние пользователя респон сибле для сохранения.</span><span class="sxs-lookup"><span data-stu-id="546fd-265">Particularly when you call it to abort a thread other than the current thread, you do not know what code has executed or failed to execute when the <xref:System.Threading.ThreadAbortException> is thrown, nor can you be certain of the state of your application or any application and user state that it is responsible for preserving.</span></span> <span data-ttu-id="546fd-266">Например, вызов `Thread.Abort` может препятствовать выполнению статических конструкторов или помешать выпуску неуправляемых ресурсов.</span><span class="sxs-lookup"><span data-stu-id="546fd-266">For example, calling `Thread.Abort` may prevent static constructors from executing or prevent the release of unmanaged resources.</span></span> 
>
> <span data-ttu-id="546fd-267">Обратите внимание, что метод `Thread.Abort` не поддерживается в .NET Core.</span><span class="sxs-lookup"><span data-stu-id="546fd-267">Note that the `Thread.Abort` method is not supported on .NET Core.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-268">Вызывает исключение <see cref="T:System.Threading.ThreadAbortException" /> в вызвавшем его потоке для того, чтобы начать процесс завершения потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-268">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="546fd-269">Вызов данного метода обычно завершает поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-269">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-270">При вызове этого метода для потока система создает исключение <xref:System.Threading.ThreadAbortException> в потоке для его прерывания.</span><span class="sxs-lookup"><span data-stu-id="546fd-270">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="546fd-271">`ThreadAbortException` — это специальное исключение, которое может быть перехвачено кодом приложения, но повторно создается в конце блока `catch`, если не вызывается <xref:System.Threading.Thread.ResetAbort%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-271">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="546fd-272">`ResetAbort` отменяет запрос на прерывание и предотвращает остановку потока `ThreadAbortException`.</span><span class="sxs-lookup"><span data-stu-id="546fd-272">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="546fd-273">Невыполненные блоки `finally` выполняются до отмены потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-273">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-274">Когда поток вызывает `Abort` на самом себе, этот результат похож на создание исключения. <xref:System.Threading.ThreadAbortException> происходит немедленно, и результат является прогнозируемым.</span><span class="sxs-lookup"><span data-stu-id="546fd-274">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="546fd-275">Однако если один поток вызывает `Abort` в другом потоке, прерывание прерывает выполнение любого кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-275">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="546fd-276">Существует также вероятность прерывания статического конструктора.</span><span class="sxs-lookup"><span data-stu-id="546fd-276">There is also a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="546fd-277">В редких случаях это может препятствовать созданию экземпляров этого класса в этом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="546fd-277">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="546fd-278">В .NET Framework версиях 1,0 и 1,1 существует шанс, что поток может прерваться, пока выполняется блок `finally`, в этом случае блок `finally` будет прерван.</span><span class="sxs-lookup"><span data-stu-id="546fd-278">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="546fd-279">Поток не гарантирует немедленное прерывание или вообще.</span><span class="sxs-lookup"><span data-stu-id="546fd-279">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="546fd-280">Такая ситуация может возникнуть, если поток выполняет неограниченное количество вычислений в блоках `finally`, которые вызываются как часть процедуры прерывания, тем самым бесконечно откладывая прерывание.</span><span class="sxs-lookup"><span data-stu-id="546fd-280">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="546fd-281">Чтобы подождать, пока поток не будет прерван, можно вызвать метод <xref:System.Threading.Thread.Join%2A> в потоке после вызова метода <xref:System.Threading.Thread.Abort%2A>, но не гарантируется, что ожидание завершится.</span><span class="sxs-lookup"><span data-stu-id="546fd-281">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-282">Поток, вызывающий <xref:System.Threading.Thread.Abort%2A>, может блокироваться, если поток, для которого выполняется прерывание, находится в защищенной области кода, например блок `catch`, блок `finally` или область ограниченного выполнения.</span><span class="sxs-lookup"><span data-stu-id="546fd-282">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="546fd-283">Если поток, вызывающий <xref:System.Threading.Thread.Abort%2A>, удерживает блокировку, требуемую для прерванного потока, может возникнуть взаимоблокировка.</span><span class="sxs-lookup"><span data-stu-id="546fd-283">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="546fd-284">Если `Abort` вызывается в потоке, который не был запущен, поток будет прерван при вызове <xref:System.Threading.Thread.Start%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-284">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="546fd-285">Если `Abort` вызывается в потоке, который заблокирован или находится в режиме ожидания, поток прерывается, а затем прерывается.</span><span class="sxs-lookup"><span data-stu-id="546fd-285">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="546fd-286">Если для приостановленного потока вызывается `Abort`, в потоке, вызвавшем <xref:System.Threading.Thread.Abort%2A>, выдается <xref:System.Threading.ThreadStateException>, а <xref:System.Threading.ThreadState.AbortRequested> добавляется в свойство <xref:System.Threading.Thread.ThreadState%2A> потока, для которого выполняется прерывание.</span><span class="sxs-lookup"><span data-stu-id="546fd-286">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="546fd-287"><xref:System.Threading.ThreadAbortException> не создается в приостановленном потоке до вызова <xref:System.Threading.Thread.Resume%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-287">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="546fd-288">Если `Abort` вызывается в управляемом потоке во время выполнения неуправляемого кода, `ThreadAbortException` не создается, пока поток не вернется в управляемый код.</span><span class="sxs-lookup"><span data-stu-id="546fd-288">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="546fd-289">Если два вызова `Abort` приходят в одно и то же время, один вызов может установить сведения о состоянии и другой вызов для выполнения `Abort`.</span><span class="sxs-lookup"><span data-stu-id="546fd-289">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="546fd-290">Однако приложение не может обнаружить такую ситуацию.</span><span class="sxs-lookup"><span data-stu-id="546fd-290">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="546fd-291">После вызова `Abort` в потоке состояние потока включает <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="546fd-291">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="546fd-292">После того как поток завершился в результате успешного вызова `Abort`, состояние потока изменяется на <xref:System.Threading.ThreadState.Stopped>.</span><span class="sxs-lookup"><span data-stu-id="546fd-292">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="546fd-293">При наличии достаточных разрешений поток, являющийся целью `Abort`, может отменить прерывание с помощью метода `ResetAbort`.</span><span class="sxs-lookup"><span data-stu-id="546fd-293">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="546fd-294">Пример, демонстрирующий вызов метода `ResetAbort`, см. в разделе класс `ThreadAbortException`.</span><span class="sxs-lookup"><span data-stu-id="546fd-294">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="546fd-295">Только в .NET Core: этот элемент не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="546fd-295">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="546fd-296">У вызывающего объекта отсутствует необходимое разрешение.</span><span class="sxs-lookup"><span data-stu-id="546fd-296">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-297">Поток, который прерывается, в настоящий момент приостановлен.</span><span class="sxs-lookup"><span data-stu-id="546fd-297">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="546fd-298">для расширенных операций с потоками.</span><span class="sxs-lookup"><span data-stu-id="546fd-298">for advanced operations on threads.</span></span> <span data-ttu-id="546fd-299">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-299">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="546fd-300">Потоки и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="546fd-300">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="546fd-301">Использование потоков и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="546fd-301">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="546fd-302">Удаление потоков</span><span class="sxs-lookup"><span data-stu-id="546fd-302">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="stateInfo"><span data-ttu-id="546fd-303">Объект, который содержит информацию об определенном приложении, например состояние, которое может использоваться аварийно завершающимся потоком.</span><span class="sxs-lookup"><span data-stu-id="546fd-303">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</span></span></param>
        <summary><span data-ttu-id="546fd-304">Вызывает исключение <see cref="T:System.Threading.ThreadAbortException" /> в вызвавшем его потоке для того, чтобы начать процесс завершения потока, в то же время предоставляя сведения об исключении касательно исключения завершения потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-304">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</span></span> <span data-ttu-id="546fd-305">Вызов данного метода обычно завершает поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-305">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-306">При вызове этого метода для потока система создает исключение <xref:System.Threading.ThreadAbortException> в потоке для его прерывания.</span><span class="sxs-lookup"><span data-stu-id="546fd-306">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="546fd-307">`ThreadAbortException` — это специальное исключение, которое может быть перехвачено кодом приложения, но повторно создается в конце блока `catch`, если не вызывается <xref:System.Threading.Thread.ResetAbort%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-307">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="546fd-308">`ResetAbort` отменяет запрос на прерывание и предотвращает остановку потока `ThreadAbortException`.</span><span class="sxs-lookup"><span data-stu-id="546fd-308">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="546fd-309">Невыполненные блоки `finally` выполняются до отмены потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-309">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-310">Когда поток вызывает `Abort` на самом себе, этот результат похож на создание исключения. <xref:System.Threading.ThreadAbortException> происходит немедленно, и результат является прогнозируемым.</span><span class="sxs-lookup"><span data-stu-id="546fd-310">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="546fd-311">Однако если один поток вызывает `Abort` в другом потоке, прерывание прерывает выполнение любого кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-311">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="546fd-312">Существует вероятность прерывания статического конструктора.</span><span class="sxs-lookup"><span data-stu-id="546fd-312">There is a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="546fd-313">В редких случаях это может препятствовать созданию экземпляров этого класса в этом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="546fd-313">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="546fd-314">В .NET Framework версиях 1,0 и 1,1 существует шанс, что поток может прерваться, пока выполняется блок `finally`, в этом случае блок `finally` будет прерван.</span><span class="sxs-lookup"><span data-stu-id="546fd-314">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="546fd-315">Поток не гарантирует немедленное прерывание или вообще.</span><span class="sxs-lookup"><span data-stu-id="546fd-315">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="546fd-316">Такая ситуация может возникнуть, если поток выполняет неограниченное количество вычислений в блоках `finally`, которые вызываются как часть процедуры прерывания, тем самым бесконечно откладывая прерывание.</span><span class="sxs-lookup"><span data-stu-id="546fd-316">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="546fd-317">Чтобы подождать, пока поток не будет прерван, можно вызвать метод <xref:System.Threading.Thread.Join%2A> в потоке после вызова метода <xref:System.Threading.Thread.Abort%2A>, но нет никакой гарантии, что ожидание завершится.</span><span class="sxs-lookup"><span data-stu-id="546fd-317">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee that the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-318">Поток, вызывающий <xref:System.Threading.Thread.Abort%2A>, может блокироваться, если поток, для которого выполняется прерывание, находится в защищенной области кода, например блок `catch`, блок `finally` или область ограниченного выполнения.</span><span class="sxs-lookup"><span data-stu-id="546fd-318">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="546fd-319">Если поток, вызывающий <xref:System.Threading.Thread.Abort%2A>, удерживает блокировку, требуемую для прерванного потока, может возникнуть взаимоблокировка.</span><span class="sxs-lookup"><span data-stu-id="546fd-319">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="546fd-320">Если `Abort` вызывается в потоке, который не был запущен, поток будет прерван при вызове <xref:System.Threading.Thread.Start%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-320">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="546fd-321">Если `Abort` вызывается в потоке, который заблокирован или находится в режиме ожидания, поток прерывается, а затем прерывается.</span><span class="sxs-lookup"><span data-stu-id="546fd-321">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="546fd-322">Если для приостановленного потока вызывается `Abort`, в потоке, вызвавшем <xref:System.Threading.Thread.Abort%2A>, выдается <xref:System.Threading.ThreadStateException>, а <xref:System.Threading.ThreadState.AbortRequested> добавляется в свойство <xref:System.Threading.Thread.ThreadState%2A> потока, для которого выполняется прерывание.</span><span class="sxs-lookup"><span data-stu-id="546fd-322">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="546fd-323"><xref:System.Threading.ThreadAbortException> не создается в приостановленном потоке до вызова <xref:System.Threading.Thread.Resume%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-323">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="546fd-324">Если `Abort` вызывается в управляемом потоке во время выполнения неуправляемого кода, `ThreadAbortException` не создается, пока поток не вернется в управляемый код.</span><span class="sxs-lookup"><span data-stu-id="546fd-324">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="546fd-325">Если два вызова `Abort` приходят в одно и то же время, один вызов может установить сведения о состоянии и другой вызов для выполнения `Abort`.</span><span class="sxs-lookup"><span data-stu-id="546fd-325">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="546fd-326">Однако приложение не может обнаружить такую ситуацию.</span><span class="sxs-lookup"><span data-stu-id="546fd-326">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="546fd-327">После вызова `Abort` в потоке состояние потока включает <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="546fd-327">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="546fd-328">После того как поток завершился в результате успешного вызова `Abort`, состояние потока изменяется на <xref:System.Threading.ThreadState.Stopped>.</span><span class="sxs-lookup"><span data-stu-id="546fd-328">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="546fd-329">При наличии достаточных разрешений поток, являющийся целью `Abort`, может отменить прерывание с помощью метода `ResetAbort`.</span><span class="sxs-lookup"><span data-stu-id="546fd-329">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="546fd-330">Пример, демонстрирующий вызов метода `ResetAbort`, см. в разделе класс `ThreadAbortException`.</span><span class="sxs-lookup"><span data-stu-id="546fd-330">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-331">В следующем примере кода показано, как передать сведения в поток, который будет прерван.</span><span class="sxs-lookup"><span data-stu-id="546fd-331">The following code example shows how to pass information to a thread that is being aborted.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="546fd-332">Только в .NET Core: этот элемент не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="546fd-332">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="546fd-333">У вызывающего объекта отсутствует необходимое разрешение.</span><span class="sxs-lookup"><span data-stu-id="546fd-333">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-334">Поток, который прерывается, в настоящий момент приостановлен.</span><span class="sxs-lookup"><span data-stu-id="546fd-334">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="546fd-335">для расширенных операций с потоками.</span><span class="sxs-lookup"><span data-stu-id="546fd-335">for advanced operations on threads.</span></span> <span data-ttu-id="546fd-336">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-336">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="546fd-337">Потоки и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="546fd-337">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="546fd-338">Использование потоков и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="546fd-338">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="546fd-339">Удаление потоков</span><span class="sxs-lookup"><span data-stu-id="546fd-339">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-340">Выделяет неименованную область данных всем потокам.</span><span class="sxs-lookup"><span data-stu-id="546fd-340">Allocates an unnamed data slot on all the threads.</span></span> <span data-ttu-id="546fd-341">Для улучшения производительности используйте поля, отмеченные атрибутом <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-341">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="546fd-342">Выделенная именованная область данных всем потокам.</span><span class="sxs-lookup"><span data-stu-id="546fd-342">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="546fd-343">.NET Framework предоставляет два механизма использования локального хранилища потока (TLS): поля, относительные для потоков (то есть поля, помеченные атрибутом <xref:System.ThreadStaticAttribute>) и области данных.</span><span class="sxs-lookup"><span data-stu-id="546fd-343">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="546fd-344">Статические поля потоков обеспечивают гораздо лучшую производительность, чем области данных, и обеспечивают проверку типов во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="546fd-344">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="546fd-345">Дополнительные сведения об использовании протокола TLS см. в разделе [Thread локальное хранилище: Статические поля и области данных, относительные для потоков,](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="546fd-345">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="546fd-346">Область выделена для всех потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-346">The slot is allocated on all threads.</span></span>  
  
 <span data-ttu-id="546fd-347">Потоки используют механизм локальной памяти хранилища для хранения данных конкретного потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-347">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="546fd-348">Среда CLR выделяет массив хранилища данных с несколькими слотами каждому процессу при его создании.</span><span class="sxs-lookup"><span data-stu-id="546fd-348">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="546fd-349">Поток может выделить область данных в хранилище данных, сохранить и извлечь значение данных в слоте и освободить слот для повторного использования после истечения срока действия потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-349">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="546fd-350">Области данных являются уникальными для каждого потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-350">Data slots are unique per thread.</span></span> <span data-ttu-id="546fd-351">Ни один другой поток (даже не дочерний поток) не может получить эти данные.</span><span class="sxs-lookup"><span data-stu-id="546fd-351">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-352">Этот раздел содержит два примера кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-352">This section contains two code examples.</span></span> <span data-ttu-id="546fd-353">В первом примере показано, как использовать поле, помеченное атрибутом <xref:System.ThreadStaticAttribute>, чтобы вместить сведения о конкретном потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-353">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="546fd-354">Во втором примере показано, как использовать область данных для того, чтобы сделать то же самое.</span><span class="sxs-lookup"><span data-stu-id="546fd-354">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="546fd-355">**Первый пример**</span><span class="sxs-lookup"><span data-stu-id="546fd-355">**First Example**</span></span>  
  
 <span data-ttu-id="546fd-356">В следующем примере показано, как использовать поле, помеченное <xref:System.ThreadStaticAttribute>, для хранения информации, относящейся к конкретному потоку.</span><span class="sxs-lookup"><span data-stu-id="546fd-356">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="546fd-357">Этот метод обеспечивает лучшую производительность, чем метод, показанный во втором примере.</span><span class="sxs-lookup"><span data-stu-id="546fd-357">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="546fd-358">**Второй пример**</span><span class="sxs-lookup"><span data-stu-id="546fd-358">**Second Example**</span></span>  
  
 <span data-ttu-id="546fd-359">В следующем примере кода показано, как использовать область данных для хранения информации, относящейся к конкретному потоку.</span><span class="sxs-lookup"><span data-stu-id="546fd-359">The following code example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="546fd-360">Потоки и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="546fd-360">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="546fd-361">Локальное хранилище потока: статические поля потока и области данных</span><span class="sxs-lookup"><span data-stu-id="546fd-361">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="546fd-362">Имя выделяемой области данных.</span><span class="sxs-lookup"><span data-stu-id="546fd-362">The name of the data slot to be allocated.</span></span></param>
        <summary><span data-ttu-id="546fd-363">Выделяет именованную область данных всем потокам.</span><span class="sxs-lookup"><span data-stu-id="546fd-363">Allocates a named data slot on all threads.</span></span> <span data-ttu-id="546fd-364">Для улучшения производительности используйте поля, отмеченные атрибутом <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-364">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="546fd-365">Выделенная именованная область данных всем потокам.</span><span class="sxs-lookup"><span data-stu-id="546fd-365">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="546fd-366">.NET Framework предоставляет два механизма использования локального хранилища потока (TLS): поля, относительные для потоков (то есть поля, помеченные атрибутом <xref:System.ThreadStaticAttribute>) и области данных.</span><span class="sxs-lookup"><span data-stu-id="546fd-366">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="546fd-367">Статические поля потоков обеспечивают гораздо лучшую производительность, чем области данных, и обеспечивают проверку типов во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="546fd-367">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="546fd-368">Дополнительные сведения об использовании протокола TLS см. в разделе [Thread локальное хранилище: Статические поля и области данных, относительные для потоков,](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="546fd-368">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="546fd-369">Потоки используют механизм локальной памяти хранилища для хранения данных конкретного потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-369">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="546fd-370">Среда CLR выделяет массив хранилища данных с несколькими слотами каждому процессу при его создании.</span><span class="sxs-lookup"><span data-stu-id="546fd-370">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="546fd-371">Поток может выделить область данных в хранилище данных, сохранить и извлечь значение данных в слоте и освободить слот для повторного использования после истечения срока действия потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-371">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="546fd-372">Области данных являются уникальными для каждого потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-372">Data slots are unique per thread.</span></span> <span data-ttu-id="546fd-373">Ни один другой поток (даже не дочерний поток) не может получить эти данные.</span><span class="sxs-lookup"><span data-stu-id="546fd-373">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="546fd-374">Необязательно использовать метод <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> для выделения именованной области данных, так как метод <xref:System.Threading.Thread.GetNamedDataSlot%2A> выделяет область, если она еще не была выделена.</span><span class="sxs-lookup"><span data-stu-id="546fd-374">It is not necessary to use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method to allocate a named data slot, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-375">Если используется метод <xref:System.Threading.Thread.AllocateNamedDataSlot%2A>, он должен вызываться в основном потоке при запуске программы, так как он создает исключение, если слот с указанным именем уже был выделен.</span><span class="sxs-lookup"><span data-stu-id="546fd-375">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</span></span> <span data-ttu-id="546fd-376">Нет способа проверить, был ли уже выделен слот.</span><span class="sxs-lookup"><span data-stu-id="546fd-376">There is no way to test whether a slot has already been allocated.</span></span>  
  
 <span data-ttu-id="546fd-377">Слоты, выделенные с помощью этого метода, должны быть освобождены с <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-377">Slots allocated with this method must be freed with <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-378">Этот раздел содержит два примера кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-378">This section contains two code examples.</span></span> <span data-ttu-id="546fd-379">В первом примере показано, как использовать поле, помеченное атрибутом <xref:System.ThreadStaticAttribute>, чтобы вместить сведения о конкретном потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-379">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="546fd-380">Во втором примере показано, как использовать область данных для того, чтобы сделать то же самое.</span><span class="sxs-lookup"><span data-stu-id="546fd-380">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="546fd-381">**Первый пример**</span><span class="sxs-lookup"><span data-stu-id="546fd-381">**First Example**</span></span>  
  
 <span data-ttu-id="546fd-382">В следующем примере показано, как использовать поле, помеченное <xref:System.ThreadStaticAttribute>, для хранения информации, относящейся к конкретному потоку.</span><span class="sxs-lookup"><span data-stu-id="546fd-382">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="546fd-383">Этот метод обеспечивает лучшую производительность, чем метод, показанный во втором примере.</span><span class="sxs-lookup"><span data-stu-id="546fd-383">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="546fd-384">**Второй пример**</span><span class="sxs-lookup"><span data-stu-id="546fd-384">**Second Example**</span></span>  
  
 <span data-ttu-id="546fd-385">В следующем примере показано, как использовать именованную область данных для хранения сведений о конкретном потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-385">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-386">В примере кода не используется метод <xref:System.Threading.Thread.AllocateNamedDataSlot%2A>, так как метод <xref:System.Threading.Thread.GetNamedDataSlot%2A> выделяет область, если она еще не была выделена.</span><span class="sxs-lookup"><span data-stu-id="546fd-386">The example code does not use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span> <span data-ttu-id="546fd-387">Если используется метод <xref:System.Threading.Thread.AllocateNamedDataSlot%2A>, он должен вызываться в основном потоке при запуске программы.</span><span class="sxs-lookup"><span data-stu-id="546fd-387">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="546fd-388">Именованная область данных с указанным именем уже существует.</span><span class="sxs-lookup"><span data-stu-id="546fd-388">A named data slot with the specified name already exists.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="546fd-389">Потоки и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="546fd-389">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="546fd-390">Локальное хранилище потока: статические поля потока и области данных</span><span class="sxs-lookup"><span data-stu-id="546fd-390">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-391">Возвращает или задает модель "apartment" для данного потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-391">Gets or sets the apartment state of this thread.</span></span></summary>
        <value><span data-ttu-id="546fd-392">Одно из значений <see cref="T:System.Threading.ApartmentState" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-392">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span></span> <span data-ttu-id="546fd-393">Начальное значение — <see langword="Unknown" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-393">The initial value is <see langword="Unknown" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-394">**Свойство <xref:System.Threading.Thread.ApartmentState%2A> устарело.**</span><span class="sxs-lookup"><span data-stu-id="546fd-394">**The <xref:System.Threading.Thread.ApartmentState%2A> property is obsolete.**</span></span>  <span data-ttu-id="546fd-395">Неустаревшие альтернативы — это метод <xref:System.Threading.Thread.GetApartmentState%2A> для получения состояния апартамента и метод <xref:System.Threading.Thread.SetApartmentState%2A> для задания состояния апартамента.</span><span class="sxs-lookup"><span data-stu-id="546fd-395">The non-obsolete alternatives are the <xref:System.Threading.Thread.GetApartmentState%2A> method to retrieve the apartment state and the   <xref:System.Threading.Thread.SetApartmentState%2A> method to set the apartment state.</span></span>  
  
 <span data-ttu-id="546fd-396">В .NET Framework версиях 1,0 и 1,1 свойство `ApartmentState` помечает поток, чтобы указать, что он будет выполняться в однопотоковой или многопоточной подразделении.</span><span class="sxs-lookup"><span data-stu-id="546fd-396">In the .NET Framework versions 1.0 and 1.1, the `ApartmentState` property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</span></span> <span data-ttu-id="546fd-397">Это свойство может быть задано, когда поток находится в состоянии потока `Unstarted` или `Running`; Однако его можно задать только один раз для потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-397">This property can be set when the thread is in the `Unstarted` or `Running` thread state; however, it can be set only once for a thread.</span></span> <span data-ttu-id="546fd-398">Если свойство не задано, возвращается значение `Unknown`.</span><span class="sxs-lookup"><span data-stu-id="546fd-398">If the property has not been set, it returns `Unknown`.</span></span>  
  
 <span data-ttu-id="546fd-399">Попытка использовать свойство <xref:System.Threading.Thread.ApartmentState%2A> для установки состояния подразделения потока, состояние которого уже задано, игнорируется.</span><span class="sxs-lookup"><span data-stu-id="546fd-399">An attempt to use the <xref:System.Threading.Thread.ApartmentState%2A> property to set the apartment state of a thread whose apartment state has already been set is ignored.</span></span> <span data-ttu-id="546fd-400">Однако метод <xref:System.Threading.Thread.SetApartmentState%2A> выдает в этом случае <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="546fd-400">However, the <xref:System.Threading.Thread.SetApartmentState%2A> method throws a <xref:System.InvalidOperationException> in this case.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="546fd-401">В .NET Framework версии 2,0 новые потоки инициализируются как <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>, если их состояние апартамента не было задано до запуска.</span><span class="sxs-lookup"><span data-stu-id="546fd-401">In the .NET Framework version 2.0, new threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="546fd-402">Основной поток приложения инициализируется значением по умолчанию <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-402">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="546fd-403">Вы больше не можете задать для основного потока приложения значение <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>, установив свойство <xref:System.Threading.ApartmentState?displayProperty=nameWithType> в первой строке кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-403">You can no longer set the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> by setting the <xref:System.Threading.ApartmentState?displayProperty=nameWithType> property on the first line of code.</span></span> <span data-ttu-id="546fd-404">Вместо этого используйте <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="546fd-404">Use the <xref:System.STAThreadAttribute> instead.</span></span>  
  
 <span data-ttu-id="546fd-405">В .NET Framework версии 2,0 можно указать COM-потоковую модель для C++ приложения с помощью параметра компоновщика [/CLRTHREADATTRIBUTE (Установка атрибута потока CLR)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) .</span><span class="sxs-lookup"><span data-stu-id="546fd-405">In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) linker option.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-406">В следующем примере кода показано, как задать состояние подразделения потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-406">The following code example demonstrates how to set the apartment state of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="546fd-407">Предпринята попытка задать в этом свойстве состояние, которое не является допустимым состоянием подразделения (состояние, отличное от однопотокового подразделения (<see langword="STA" />) или многопотокового подразделения (<see langword="MTA" />)).</span><span class="sxs-lookup"><span data-stu-id="546fd-407">An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<see langword="STA" />) or multithreaded apartment (<see langword="MTA" />)).</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-408">Уведомляет узел, что выполнение близится ко входу в область кода, в которой эффекты прерывания выполнения или неуправляемого выполнения могут повлиять на другие задачи в домене приложения.</span><span class="sxs-lookup"><span data-stu-id="546fd-408">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-409">Узлы среды CLR, например Microsoft SQL Server 2005, могут устанавливать различные политики для сбоев в критических и некритических областях кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-409">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="546fd-410">Критическая область — это одна из тех, в которых влияние прерывания потока или необработанного исключения может не ограничиваться текущей задачей.</span><span class="sxs-lookup"><span data-stu-id="546fd-410">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="546fd-411">В отличие от этого, прерывание или сбой в некритической области кода влияет только на задачу, в которой возникла ошибка.</span><span class="sxs-lookup"><span data-stu-id="546fd-411">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="546fd-412">Например, рассмотрим задачу, которая пытается выделить память при удержании блокировки.</span><span class="sxs-lookup"><span data-stu-id="546fd-412">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="546fd-413">В случае сбоя выделения памяти прерывание текущей задачи недостаточно для обеспечения стабильности <xref:System.AppDomain>, так как в домене могут находиться другие задачи, ожидающие той же блокировки.</span><span class="sxs-lookup"><span data-stu-id="546fd-413">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="546fd-414">Если текущая задача прервана, другие задачи могут быть взаимоблокированы.</span><span class="sxs-lookup"><span data-stu-id="546fd-414">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="546fd-415">При возникновении сбоя в критической области узел может решить выгрузку всего <xref:System.AppDomain>, а не риск продолжения выполнения в потенциально нестабильном состоянии.</span><span class="sxs-lookup"><span data-stu-id="546fd-415">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="546fd-416">Чтобы сообщить узлу о входе кода в критическую область, вызовите <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-416">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="546fd-417">Вызовите <xref:System.Threading.Thread.EndCriticalRegion%2A>, когда выполнение возвращается в некритическую область кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-417">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="546fd-418">При использовании этого метода в коде, который выполняется в SQL Server 2005, требуется, чтобы код выполнялся на самом верхнем уровне защиты узла.</span><span class="sxs-lookup"><span data-stu-id="546fd-418">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-419">В следующем примере демонстрируется использование методов <xref:System.Threading.Thread.BeginCriticalRegion%2A> и <xref:System.Threading.Thread.EndCriticalRegion%2A> для разделения блока кода на критические и некритические регионы.</span><span class="sxs-lookup"><span data-stu-id="546fd-419">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-420">Уведомляет узел, что управляемый код близок к выполнению инструкций, зависящих от идентификации текущего потока операционной системы.</span><span class="sxs-lookup"><span data-stu-id="546fd-420">Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-421">Некоторые узлы среды CLR, например Microsoft SQL Server 2005, предоставляют собственное управление потоками.</span><span class="sxs-lookup"><span data-stu-id="546fd-421">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="546fd-422">Узел, предоставляющий собственное управление потоками, может перемещать исполняемую задачу из одного физического потока операционной системы в другой в любое время.</span><span class="sxs-lookup"><span data-stu-id="546fd-422">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="546fd-423">Это переключение не затрагивает большинство задач.</span><span class="sxs-lookup"><span data-stu-id="546fd-423">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="546fd-424">Однако некоторые задачи имеют сходство потоков, то есть они зависят от удостоверения физического потока операционной системы.</span><span class="sxs-lookup"><span data-stu-id="546fd-424">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="546fd-425">Эти задачи должны информировать узел при выполнении кода, который не должен переключаться.</span><span class="sxs-lookup"><span data-stu-id="546fd-425">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="546fd-426">Например, если приложение вызывает системный API для получения блокировки операционной системы, имеющей сходство потоков, например Win32 CRITICAL_SECTION, необходимо вызвать <xref:System.Threading.Thread.BeginThreadAffinity%2A> перед получением блокировки и <xref:System.Threading.Thread.EndThreadAffinity%2A> после снятия блокировки.</span><span class="sxs-lookup"><span data-stu-id="546fd-426">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="546fd-427">При использовании этого метода в коде, который выполняется в SQL Server 2005, требуется, чтобы код выполнялся на самом верхнем уровне защиты узла.</span><span class="sxs-lookup"><span data-stu-id="546fd-427">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-428">В следующем примере показано использование методов <xref:System.Threading.Thread.BeginThreadAffinity%2A> и <xref:System.Threading.Thread.EndThreadAffinity%2A> для уведомления узла о том, что блок кода зависит от удостоверения физического потока операционной системы.</span><span class="sxs-lookup"><span data-stu-id="546fd-428">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="546fd-429">У вызывающего объекта отсутствует необходимое разрешение.</span><span class="sxs-lookup"><span data-stu-id="546fd-429">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="546fd-430">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="546fd-430">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="546fd-431">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="546fd-431">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-432">Возвращает текущий контекст, в котором выполняется поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-432">Gets the current context in which the thread is executing.</span></span></summary>
        <value><span data-ttu-id="546fd-433">Класс <see cref="T:System.Runtime.Remoting.Contexts.Context" />, представляющий текущий контекст потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-433">A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> representing the current thread context.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="546fd-434">У вызывающего объекта отсутствует необходимое разрешение.</span><span class="sxs-lookup"><span data-stu-id="546fd-434">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="546fd-435">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="546fd-435">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="546fd-436">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="546fd-436">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-437">Получает или задает язык и региональные параметры для текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-437">Gets or sets the culture for the current thread.</span></span></summary>
        <value><span data-ttu-id="546fd-438">Объект, представляющий язык и региональные параметры, используемые текущим потоком.</span><span class="sxs-lookup"><span data-stu-id="546fd-438">An object that represents the culture for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-439">Объект <xref:System.Globalization.CultureInfo>, возвращаемый этим свойством вместе со связанными с ним объектами, определяет формат по умолчанию для дат, времени, чисел, значений валют, порядок сортировки текста, соглашения о регистре и сравнения строк.</span><span class="sxs-lookup"><span data-stu-id="546fd-439">The <xref:System.Globalization.CultureInfo> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</span></span> <span data-ttu-id="546fd-440">Ознакомьтесь с классом <xref:System.Globalization.CultureInfo>, чтобы узнать об именах и идентификаторах языков и региональных параметров, различиях между инвариантными, нейтральными и конкретными культурами, а также о том, как язык и региональные параметры влияют на потоки и домены приложений.</span><span class="sxs-lookup"><span data-stu-id="546fd-440">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="546fd-441">Сведения о том, как определяется язык и региональные параметры по умолчанию для этого потока, см. в описании свойства <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-441">See the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="546fd-442">Свойство <xref:System.Threading.Thread.CurrentCulture> не работает надежно при использовании в любом потоке, отличном от текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-442">The <xref:System.Threading.Thread.CurrentCulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="546fd-443">В .NET Framework чтение свойства является надежным, хотя его задание для потока, отличного от текущего потока, — нет.</span><span class="sxs-lookup"><span data-stu-id="546fd-443">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="546fd-444">В .NET Core создается <xref:System.InvalidOperationException>, если поток пытается прочитать или записать свойство <xref:System.Threading.Thread.CurrentCulture> в другом потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-444">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentCulture> property on a different thread.</span></span>
> <span data-ttu-id="546fd-445">Для получения и задания текущего языка и региональных параметров рекомендуется использовать свойство <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-445">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="546fd-446">Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], можно задать свойство <xref:System.Threading.Thread.CurrentCulture%2A> для нейтрального языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="546fd-446">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], you can set the <xref:System.Threading.Thread.CurrentCulture%2A> property to a neutral culture.</span></span> <span data-ttu-id="546fd-447">Это обусловлено тем, что поведение класса <xref:System.Globalization.CultureInfo> изменилось: Если он представляет нейтральную культуру, значения свойств (в частности, свойства <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A> и <xref:System.Globalization.CultureInfo.TextInfo%2A>) теперь отражать конкретную культуру, связанную с нейтральным языком и региональными параметрами.</span><span class="sxs-lookup"><span data-stu-id="546fd-447">This is because the behavior of the <xref:System.Globalization.CultureInfo> class has changed: When it represents a neutral culture, its property values (in particular, the <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, and <xref:System.Globalization.CultureInfo.TextInfo%2A> properties) now reflect the specific culture that is associated with the neutral culture.</span></span> <span data-ttu-id="546fd-448">В более ранних версиях .NET Framework свойство <xref:System.Threading.Thread.CurrentCulture%2A> породило исключение <xref:System.NotSupportedException>, когда была назначена нейтральная культура.</span><span class="sxs-lookup"><span data-stu-id="546fd-448">In earlier versions of the .NET Framework, the <xref:System.Threading.Thread.CurrentCulture%2A> property threw a <xref:System.NotSupportedException> exception when a neutral culture was assigned.</span></span>  
  
## Examples  
 <span data-ttu-id="546fd-449">В следующем примере показана потоковая инструкция, которая позволяет пользовательскому интерфейсу приложения Windows Forms отображаться в культуре, заданной в панели управления.</span><span class="sxs-lookup"><span data-stu-id="546fd-449">The following example shows the threading statement that allows the user interface of a Windows Forms application to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="546fd-450">Требуется дополнительный код.</span><span class="sxs-lookup"><span data-stu-id="546fd-450">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="546fd-451">Для свойства задано значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-451">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="546fd-452">Только в .NET Core: чтение или запись данных о языке и региональных параметрах потока из другого потока не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="546fd-452">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="546fd-453">для задания свойства.</span><span class="sxs-lookup"><span data-stu-id="546fd-453">for setting the property.</span></span> <span data-ttu-id="546fd-454">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="546fd-454">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-455">Возвращает или задает текущего участника потока (для безопасности на основе ролей).</span><span class="sxs-lookup"><span data-stu-id="546fd-455">Gets or sets the thread's current principal (for role-based security).</span></span></summary>
        <value><span data-ttu-id="546fd-456">Значение <see cref="T:System.Security.Principal.IPrincipal" />, представляющее контекст безопасности.</span><span class="sxs-lookup"><span data-stu-id="546fd-456">An <see cref="T:System.Security.Principal.IPrincipal" /> value representing the security context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="546fd-457">В следующем примере кода показано, как задать и получить участника потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-457">The following code example shows how to set and retrieve the principal of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="546fd-458">Вызывающий объект не имеет разрешений, необходимых для задания участника.</span><span class="sxs-lookup"><span data-stu-id="546fd-458">The caller does not have the permission required to set the principal.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="546fd-459">для управления объектом Principal.</span><span class="sxs-lookup"><span data-stu-id="546fd-459">to manipulate the principal object.</span></span> <span data-ttu-id="546fd-460">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-460">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-461">Возвращает выполняющийся в данный момент поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-461">Gets the currently running thread.</span></span></summary>
        <value><span data-ttu-id="546fd-462">Объект <see cref="T:System.Threading.Thread" />, представляющий собой выполняющийся в данный момент поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-462">A <see cref="T:System.Threading.Thread" /> that is the representation of the currently running thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="546fd-463">В следующем примере создается задача, которая, в свою очередь, создает 20 дочерних задач.</span><span class="sxs-lookup"><span data-stu-id="546fd-463">The following example creates a task that in turn creates 20 child tasks.</span></span> <span data-ttu-id="546fd-464">Само приложение, а также каждая задача вызывает метод `ShowThreadInformation`, который использует свойство <xref:System.Threading.Thread.CurrentThread%2A> для вывода сведений о потоке, в котором он выполняется.</span><span class="sxs-lookup"><span data-stu-id="546fd-464">The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the <xref:System.Threading.Thread.CurrentThread%2A> property  to display information about the thread on which it is running.</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 <span data-ttu-id="546fd-465">Каждая дочерняя задача создает 1 000 000 случайных чисел от 1 до 1 000 000 и возвращает их среднее значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-465">Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</span></span> <span data-ttu-id="546fd-466">Родительская задача вызывает метод <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>, чтобы убедиться, что дочерние задачи завершены до отображения среднего значения, возвращаемого каждой задачей, и вычисления средних значений.</span><span class="sxs-lookup"><span data-stu-id="546fd-466">The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</span></span>  
  
 <span data-ttu-id="546fd-467">Обратите внимание, что хотя приложение выполняется в потоке переднего плана, каждая задача выполняется в потоке пула потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-467">Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-468">Получает или задает текущие язык и региональные параметры, используемые диспетчером ресурсов для поиска ресурсов, связанных с языком и региональными параметрами, во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="546fd-468">Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</span></span></summary>
        <value><span data-ttu-id="546fd-469">Объект, представляющий текущие языковые стандарты.</span><span class="sxs-lookup"><span data-stu-id="546fd-469">An object that represents the current culture.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-470">Язык и региональные параметры пользовательского интерфейса указывают ресурсы, необходимые приложению для поддержки ввода и вывода данных пользователем, и по умолчанию совпадает с культурой операционной системы.</span><span class="sxs-lookup"><span data-stu-id="546fd-470">The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</span></span> <span data-ttu-id="546fd-471">Ознакомьтесь с классом <xref:System.Globalization.CultureInfo>, чтобы узнать об именах и идентификаторах языков и региональных параметров, различиях между инвариантными, нейтральными и конкретными культурами, а также о том, как язык и региональные параметры влияют на потоки и домены приложений.</span><span class="sxs-lookup"><span data-stu-id="546fd-471">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="546fd-472">Сведения о том, как определяется язык и региональные параметры пользовательского интерфейса по умолчанию для потока, см. в описании свойства <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-472">See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property to learn how a thread's default UI culture is determined.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="546fd-473">Свойство <xref:System.Threading.Thread.CurrentUICulture> не работает надежно при использовании в любом потоке, отличном от текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-473">The <xref:System.Threading.Thread.CurrentUICulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="546fd-474">В .NET Framework чтение свойства является надежным, хотя его задание для потока, отличного от текущего потока, — нет.</span><span class="sxs-lookup"><span data-stu-id="546fd-474">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="546fd-475">В .NET Core создается <xref:System.InvalidOperationException>, если поток пытается прочитать или записать свойство <xref:System.Threading.Thread.CurrentUICulture> в другом потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-475">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentUICulture> property on a different thread.</span></span>
> <span data-ttu-id="546fd-476">Для получения и задания текущего языка и региональных параметров рекомендуется использовать свойство <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-476">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="546fd-477"><xref:System.Globalization.CultureInfo>, возвращаемое этим свойством, может быть нейтральным языком и региональными параметрами.</span><span class="sxs-lookup"><span data-stu-id="546fd-477">The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture.</span></span> <span data-ttu-id="546fd-478">Нейтральные языки и региональные параметры не следует использовать с такими методами форматирования, как <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> и <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-478">Neutral cultures should not be used with formatting methods such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="546fd-479">Используйте метод <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> для получения определенного языка и региональных параметров или используйте свойство <xref:System.Threading.Thread.CurrentCulture%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-479">Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-480">Метод <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> вызывает <xref:System.ArgumentException> для нейтральных культур "zh-Hant" ("zh-CHT") и "zh-Ханс" ("zh-CHS").</span><span class="sxs-lookup"><span data-stu-id="546fd-480">The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method throws <xref:System.ArgumentException> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-481">В следующем примере определяется, является ли язык языка и региональных параметров пользовательского интерфейса для текущего потока французским.</span><span class="sxs-lookup"><span data-stu-id="546fd-481">The following example determines whether the language of the current thread's UI culture is French.</span></span> <span data-ttu-id="546fd-482">В противном случае он устанавливает язык и региональные параметры пользовательского интерфейса для текущего потока на английский (США).</span><span class="sxs-lookup"><span data-stu-id="546fd-482">If it is not, it sets the UI culture of the current thread to English (United States).</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 <span data-ttu-id="546fd-483">В следующем примере кода показана инструкция для работы с потоками, которая позволяет пользовательскому интерфейсу Windows Forms отображаться в культуре, заданной в панели управления.</span><span class="sxs-lookup"><span data-stu-id="546fd-483">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="546fd-484">Требуется дополнительный код.</span><span class="sxs-lookup"><span data-stu-id="546fd-484">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="546fd-485">Для свойства задано значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-485">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="546fd-486">Свойству присвоено имя языка и региональных параметров, которое не может использоваться для нахождения файла ресурсов.</span><span class="sxs-lookup"><span data-stu-id="546fd-486">The property is set to a culture name that cannot be used to locate a resource file.</span></span> <span data-ttu-id="546fd-487">Имена файлов ресурсов могут содержать только буквы, цифры, дефисы или символы подчеркивания.</span><span class="sxs-lookup"><span data-stu-id="546fd-487">Resource filenames must include only letters, numbers, hyphens or underscores.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="546fd-488">Только в .NET Core: чтение или запись данных о языке и региональных параметрах потока из другого потока не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="546fd-488">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-489">Отключает автоматическую очистку вызываемых оболочек времени выполнения (RCW) для текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-489">Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-490">По умолчанию среда CLR автоматически очищает вызываемые оболочки времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="546fd-490">By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</span></span> <span data-ttu-id="546fd-491">Среда CLR переносит сообщения во время очистки, что может вызвать проблемы повторного входа для нескольких приложений, отвечающих следующим необычным критериям:</span><span class="sxs-lookup"><span data-stu-id="546fd-491">The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</span></span>  
  
-   <span data-ttu-id="546fd-492">Приложение выполняет собственную загрузку сообщений.</span><span class="sxs-lookup"><span data-stu-id="546fd-492">The application does its own message pumping.</span></span>  
  
-   <span data-ttu-id="546fd-493">Приложение должно точно управлять, когда происходит Выкачка сообщений.</span><span class="sxs-lookup"><span data-stu-id="546fd-493">The application needs to control precisely when message pumping occurs.</span></span>  
  
 <span data-ttu-id="546fd-494">Такие приложения могут использовать метод <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> для предотвращения автоматического восстановления вызываемых оболочек времени выполнения средой CLR.</span><span class="sxs-lookup"><span data-stu-id="546fd-494">Such applications can use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</span></span>  
  
 <span data-ttu-id="546fd-495">При вызове этого метода в потоке для этого потока нельзя повторно включить автоматическую очистку.</span><span class="sxs-lookup"><span data-stu-id="546fd-495">When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</span></span> <span data-ttu-id="546fd-496">Когда приложение будет готово к очистке вызываемых оболочек времени выполнения, используйте метод <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType>, чтобы указать среде выполнения очистить все вызываемые оболочки среды выполнения в текущем контексте.</span><span class="sxs-lookup"><span data-stu-id="546fd-496">When your application is ready to clean up runtime callable wrappers, use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</span></span> <span data-ttu-id="546fd-497">При выполнении метода происходит Выкачка сообщений.</span><span class="sxs-lookup"><span data-stu-id="546fd-497">Message pumping occurs while the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="546fd-498">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="546fd-498">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="546fd-499">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="546fd-499">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-500">Уведомляет узел, что выполнение близится ко входу в область кода, в которой эффекты прерывания выполнения или неуправляемой ошибки ограничены текущей задачей.</span><span class="sxs-lookup"><span data-stu-id="546fd-500">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-501">Узлы среды CLR, например Microsoft SQL Server 2005, могут устанавливать различные политики для сбоев в критических и некритических областях кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-501">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="546fd-502">Критическая область — это одна из тех, в которых влияние прерывания потока или необработанного исключения может не ограничиваться текущей задачей.</span><span class="sxs-lookup"><span data-stu-id="546fd-502">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="546fd-503">В отличие от этого, прерывание или сбой в некритической области кода влияет только на задачу, в которой возникла ошибка.</span><span class="sxs-lookup"><span data-stu-id="546fd-503">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="546fd-504">Например, рассмотрим задачу, которая пытается выделить память при удержании блокировки.</span><span class="sxs-lookup"><span data-stu-id="546fd-504">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="546fd-505">В случае сбоя выделения памяти прерывание текущей задачи недостаточно для обеспечения стабильности <xref:System.AppDomain>, так как в домене могут находиться другие задачи, ожидающие той же блокировки.</span><span class="sxs-lookup"><span data-stu-id="546fd-505">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="546fd-506">Если текущая задача прервана, другие задачи могут быть взаимоблокированы.</span><span class="sxs-lookup"><span data-stu-id="546fd-506">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="546fd-507">При возникновении сбоя в критической области узел может решить выгрузку всего <xref:System.AppDomain>, а не риск продолжения выполнения в потенциально нестабильном состоянии.</span><span class="sxs-lookup"><span data-stu-id="546fd-507">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="546fd-508">Чтобы сообщить узлу о входе кода в критическую область, вызовите <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-508">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="546fd-509">Вызовите <xref:System.Threading.Thread.EndCriticalRegion%2A>, когда выполнение возвращается в некритическую область кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-509">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="546fd-510">При использовании этого метода в коде, который выполняется в SQL Server 2005, требуется, чтобы код выполнялся на самом верхнем уровне защиты узла.</span><span class="sxs-lookup"><span data-stu-id="546fd-510">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-511">В следующем примере демонстрируется использование методов <xref:System.Threading.Thread.BeginCriticalRegion%2A> и <xref:System.Threading.Thread.EndCriticalRegion%2A> для разделения блока кода на критические и некритические регионы.</span><span class="sxs-lookup"><span data-stu-id="546fd-511">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-512">Уведомляет хост об окончании выполнения кодом инструкций, которые зависят от идентификатора текущего потока в операционной системе.</span><span class="sxs-lookup"><span data-stu-id="546fd-512">Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-513">Некоторые узлы среды CLR, например Microsoft SQL Server 2005, предоставляют собственное управление потоками.</span><span class="sxs-lookup"><span data-stu-id="546fd-513">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="546fd-514">Узел, предоставляющий собственное управление потоками, может перемещать исполняемую задачу из одного физического потока операционной системы в другой в любое время.</span><span class="sxs-lookup"><span data-stu-id="546fd-514">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="546fd-515">Это переключение не затрагивает большинство задач.</span><span class="sxs-lookup"><span data-stu-id="546fd-515">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="546fd-516">Однако некоторые задачи имеют сходство потоков, то есть они зависят от удостоверения физического потока операционной системы.</span><span class="sxs-lookup"><span data-stu-id="546fd-516">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="546fd-517">Эти задачи должны информировать узел при выполнении кода, который не должен переключаться.</span><span class="sxs-lookup"><span data-stu-id="546fd-517">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="546fd-518">Например, если приложение вызывает системный API для получения блокировки операционной системы, имеющей сходство потоков, например Win32 CRITICAL_SECTION, необходимо вызвать <xref:System.Threading.Thread.BeginThreadAffinity%2A> перед получением блокировки и <xref:System.Threading.Thread.EndThreadAffinity%2A> после снятия блокировки.</span><span class="sxs-lookup"><span data-stu-id="546fd-518">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="546fd-519">При использовании этого метода в коде, который выполняется в SQL Server 2005, требуется, чтобы код выполнялся на самом верхнем уровне защиты узла.</span><span class="sxs-lookup"><span data-stu-id="546fd-519">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-520">В следующем примере показано использование методов <xref:System.Threading.Thread.BeginThreadAffinity%2A> и <xref:System.Threading.Thread.EndThreadAffinity%2A> для уведомления узла о том, что блок кода зависит от удостоверения физического потока операционной системы.</span><span class="sxs-lookup"><span data-stu-id="546fd-520">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="546fd-521">У вызывающего объекта отсутствует необходимое разрешение.</span><span class="sxs-lookup"><span data-stu-id="546fd-521">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="546fd-522">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="546fd-522">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="546fd-523">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="546fd-523">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-524">Возвращает объект <see cref="T:System.Threading.ExecutionContext" />, содержащий сведения о различных контекстах текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-524">Gets an <see cref="T:System.Threading.ExecutionContext" /> object that contains information about the various contexts of the current thread.</span></span></summary>
        <value><span data-ttu-id="546fd-525">Объект <see cref="T:System.Threading.ExecutionContext" />, содержащий консолидированную информацию о контекстах текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-525">An <see cref="T:System.Threading.ExecutionContext" /> object that consolidates context information for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-526">Класс <xref:System.Threading.ExecutionContext> предоставляет один контейнер для всех сведений, относящихся к логическому потоку выполнения.</span><span class="sxs-lookup"><span data-stu-id="546fd-526">The <xref:System.Threading.ExecutionContext> class provides a single container for all information relevant to a logical thread of execution.</span></span> <span data-ttu-id="546fd-527">К ним относятся контекст безопасности, контекст вызова, контекст синхронизации, контекст локализации и контекст транзакции.</span><span class="sxs-lookup"><span data-stu-id="546fd-527">This includes security context, call context, synchronization context, localization context, and transaction context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-528">Обеспечивает освобождение ресурсов и выполнение других завершающих операций, когда сборщик мусора восстанавливает объект <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-528">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.Thread" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-529">Сборщик мусора вызывает <xref:System.Threading.Thread.Finalize%2A>, когда текущий объект готов к завершению.</span><span class="sxs-lookup"><span data-stu-id="546fd-529">The garbage collector calls <xref:System.Threading.Thread.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="546fd-530">Имя освобождаемой области данных.</span><span class="sxs-lookup"><span data-stu-id="546fd-530">The name of the data slot to be freed.</span></span></param>
        <summary><span data-ttu-id="546fd-531">Удаляет связь между названием и областью для всех потоков в процессе.</span><span class="sxs-lookup"><span data-stu-id="546fd-531">Eliminates the association between a name and a slot, for all threads in the process.</span></span> <span data-ttu-id="546fd-532">Для улучшения производительности используйте поля, отмеченные атрибутом <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-532">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="546fd-533">.NET Framework предоставляет два механизма использования локального хранилища потока (TLS): поля, относительные для потоков (то есть поля, помеченные атрибутом <xref:System.ThreadStaticAttribute>) и области данных.</span><span class="sxs-lookup"><span data-stu-id="546fd-533">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="546fd-534">Статические поля потоков обеспечивают гораздо лучшую производительность, чем области данных, и обеспечивают проверку типов во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="546fd-534">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="546fd-535">Дополнительные сведения об использовании протокола TLS см. в разделе [Thread локальное хранилище: Статические поля и области данных, относительные для потоков,](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="546fd-535">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="546fd-536">Когда любой поток вызывает `FreeNamedDataSlot`, любой другой поток, вызывающий <xref:System.Threading.Thread.GetNamedDataSlot%2A> с тем же именем, будет выделять новый слот, связанный с именем.</span><span class="sxs-lookup"><span data-stu-id="546fd-536">After any thread calls `FreeNamedDataSlot`, any other thread that calls <xref:System.Threading.Thread.GetNamedDataSlot%2A> with the same name will allocate a new slot associated with the name.</span></span> <span data-ttu-id="546fd-537">Последующие вызовы `GetNamedDataSlot` любым потоком будут возвращать новый слот.</span><span class="sxs-lookup"><span data-stu-id="546fd-537">Subsequent calls to `GetNamedDataSlot` by any thread will return the new slot.</span></span> <span data-ttu-id="546fd-538">Однако любой поток, который по-прежнему имеет <xref:System.LocalDataStoreSlot?displayProperty=nameWithType>, возвращенный предыдущим вызовом `GetNamedDataSlot`, может продолжать использовать старый слот.</span><span class="sxs-lookup"><span data-stu-id="546fd-538">However, any thread that still has a <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> returned by an earlier call to `GetNamedDataSlot` can continue to use the old slot.</span></span>  
  
 <span data-ttu-id="546fd-539">Слот, связанный с именем, освобождается, только если все `LocalDataStoreSlot`, полученные до вызова `FreeNamedDataSlot`, освобождены и собраны сборщиком мусора.</span><span class="sxs-lookup"><span data-stu-id="546fd-539">A slot that has been associated with a name is released only when every `LocalDataStoreSlot` that was obtained prior to the call to `FreeNamedDataSlot` has been released and garbage-collected.</span></span>  
  
 <span data-ttu-id="546fd-540">Потоки используют механизм локальной памяти хранилища для хранения данных конкретного потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-540">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="546fd-541">Среда CLR выделяет массив хранилища данных с несколькими слотами каждому процессу при его создании.</span><span class="sxs-lookup"><span data-stu-id="546fd-541">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="546fd-542">Поток может выделить область данных в хранилище данных, сохранить и извлечь значение данных в слоте и освободить слот для повторного использования после истечения срока действия потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-542">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="546fd-543">Области данных являются уникальными для каждого потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-543">Data slots are unique per thread.</span></span> <span data-ttu-id="546fd-544">Ни один другой поток (даже не дочерний поток) не может получить эти данные.</span><span class="sxs-lookup"><span data-stu-id="546fd-544">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-545">Этот раздел содержит два примера кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-545">This section contains two code examples.</span></span> <span data-ttu-id="546fd-546">В первом примере показано, как использовать поле, помеченное атрибутом <xref:System.ThreadStaticAttribute>, чтобы вместить сведения о конкретном потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-546">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="546fd-547">Во втором примере показано, как использовать область данных для того, чтобы сделать то же самое.</span><span class="sxs-lookup"><span data-stu-id="546fd-547">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="546fd-548">**Первый пример**</span><span class="sxs-lookup"><span data-stu-id="546fd-548">**First Example**</span></span>  
  
 <span data-ttu-id="546fd-549">В следующем примере показано, как использовать поле, помеченное <xref:System.ThreadStaticAttribute>, для хранения информации, относящейся к конкретному потоку.</span><span class="sxs-lookup"><span data-stu-id="546fd-549">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="546fd-550">Этот метод обеспечивает лучшую производительность, чем метод, показанный во втором примере.</span><span class="sxs-lookup"><span data-stu-id="546fd-550">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="546fd-551">**Второй пример**</span><span class="sxs-lookup"><span data-stu-id="546fd-551">**Second Example**</span></span>  
  
 <span data-ttu-id="546fd-552">В следующем примере показано, как использовать именованную область данных для хранения сведений о конкретном потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-552">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="546fd-553">Потоки и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="546fd-553">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="546fd-554">Локальное хранилище потока: статические поля потока и области данных</span><span class="sxs-lookup"><span data-stu-id="546fd-554">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-555">Возвращает значение типа <see cref="T:System.Threading.ApartmentState" />, показывающее состояние апартамента.</span><span class="sxs-lookup"><span data-stu-id="546fd-555">Returns an <see cref="T:System.Threading.ApartmentState" /> value indicating the apartment state.</span></span></summary>
        <returns><span data-ttu-id="546fd-556">Одно из значений <see cref="T:System.Threading.ApartmentState" />, показывающее состояние подразделения управляемого потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-556">One of the <see cref="T:System.Threading.ApartmentState" /> values indicating the apartment state of the managed thread.</span></span> <span data-ttu-id="546fd-557">Значение по умолчанию — <see cref="F:System.Threading.ApartmentState.Unknown" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-557">The default is <see cref="F:System.Threading.ApartmentState.Unknown" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-558">Этот метод вместе с методом <xref:System.Threading.Thread.SetApartmentState%2A> и методом <xref:System.Threading.Thread.TrySetApartmentState%2A> заменяет свойство <xref:System.Threading.Thread.ApartmentState%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-558">This method, along with the <xref:System.Threading.Thread.SetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-559">В следующем примере кода демонстрируются методы <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> и <xref:System.Threading.Thread.TrySetApartmentState%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-559">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="546fd-560">В примере кода создается поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-560">The code example creates a thread.</span></span> <span data-ttu-id="546fd-561">Перед началом потока <xref:System.Threading.Thread.GetApartmentState%2A> отображает начальное состояние <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>, а <xref:System.Threading.Thread.SetApartmentState%2A> меняет состояние на <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-561">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="546fd-562">Затем метод <xref:System.Threading.Thread.TrySetApartmentState%2A> возвращает `false` при попытке изменить состояние на <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>, так как состояние апартамента уже задано.</span><span class="sxs-lookup"><span data-stu-id="546fd-562">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="546fd-563">Если была предпринята попытка выполнения одной операции с <xref:System.Threading.Thread.SetApartmentState%2A>, будет выдано исключение <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="546fd-563">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="546fd-564">После запуска потока снова используется метод <xref:System.Threading.Thread.TrySetApartmentState%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-564">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="546fd-565">В этот раз возникает исключение <xref:System.Threading.ThreadStateException>, так как поток уже запущен.</span><span class="sxs-lookup"><span data-stu-id="546fd-565">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-566">Возвращает объект <see cref="T:System.Threading.CompressedStack" />, который может быть использован для записи стека текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-566">Returns a <see cref="T:System.Threading.CompressedStack" /> object that can be used to capture the stack for the current thread.</span></span></summary>
        <returns><span data-ttu-id="546fd-567">Отсутствует.</span><span class="sxs-lookup"><span data-stu-id="546fd-567">None.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-568">Этот метод больше не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="546fd-568">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="546fd-569">Во всех случаях.</span><span class="sxs-lookup"><span data-stu-id="546fd-569">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="546fd-570">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="546fd-570">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="546fd-571">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="546fd-571">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-572">Возвращает идентификатор, используемый для указания того, какой процессор исполняет текущий поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-572">Gets an ID used to indicate on which processor the current thread is executing.</span></span></summary>
        <returns><span data-ttu-id="546fd-573">Целое число, представляющее кэшированный идентификатор процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-573">An integer representing the cached processor ID.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="546fd-574">Это значение кэшируется и периодически обновляется.</span><span class="sxs-lookup"><span data-stu-id="546fd-574">This value is cached and periodically refreshed.</span></span> <span data-ttu-id="546fd-575">Время его использования может быть устаревшим: использование кода не должно полагаться на его точность для корректности.</span><span class="sxs-lookup"><span data-stu-id="546fd-575">It may be stale by the time it's used: consuming code must not rely on its accuracy for correctness.</span></span>

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="546fd-576">Объект <see cref="T:System.LocalDataStoreSlot" />, из которого возвращается значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-576">The <see cref="T:System.LocalDataStoreSlot" /> from which to get the value.</span></span></param>
        <summary><span data-ttu-id="546fd-577">Извлекает значение из заданной области текущего потока, внутри текущей области текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-577">Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</span></span> <span data-ttu-id="546fd-578">Для улучшения производительности используйте поля, отмеченные атрибутом <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-578">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="546fd-579">Извлекаемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-579">The retrieved value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="546fd-580">.NET Framework предоставляет два механизма использования локального хранилища потока (TLS): поля, относительные для потоков (то есть поля, помеченные атрибутом <xref:System.ThreadStaticAttribute>) и области данных.</span><span class="sxs-lookup"><span data-stu-id="546fd-580">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="546fd-581">Статические поля потоков обеспечивают гораздо лучшую производительность, чем области данных, и обеспечивают проверку типов во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="546fd-581">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="546fd-582">Дополнительные сведения об использовании протокола TLS см. в разделе [Thread локальное хранилище: Статические поля и области данных, относительные для потоков,](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="546fd-582">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="546fd-583">Потоки используют механизм локальной памяти хранилища для хранения данных конкретного потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-583">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="546fd-584">Среда CLR выделяет массив хранилища данных с несколькими слотами каждому процессу при его создании.</span><span class="sxs-lookup"><span data-stu-id="546fd-584">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="546fd-585">Поток может выделить область данных в хранилище данных, сохранить и извлечь значение данных в слоте и освободить слот для повторного использования после истечения срока действия потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-585">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="546fd-586">Области данных являются уникальными для каждого потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-586">Data slots are unique per thread.</span></span> <span data-ttu-id="546fd-587">Ни один другой поток (даже не дочерний поток) не может получить эти данные.</span><span class="sxs-lookup"><span data-stu-id="546fd-587">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-588"><xref:System.Threading.Thread.GetData%2A> — это метод `Shared`, который всегда применяется к выполняющимся в данный момент потокам, даже если он вызывается с помощью переменной, которая ссылается на другой поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-588"><xref:System.Threading.Thread.GetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="546fd-589">Чтобы избежать путаницы, используйте имя класса при вызове методов `Shared`: `Dim test As Object = Thread.GetData(testSlot)`.</span><span class="sxs-lookup"><span data-stu-id="546fd-589">To avoid confusion, use the class name when calling `Shared` methods: `Dim test As Object = Thread.GetData(testSlot)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-590">Этот раздел содержит два примера кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-590">This section contains two code examples.</span></span> <span data-ttu-id="546fd-591">В первом примере показано, как использовать поле, помеченное атрибутом <xref:System.ThreadStaticAttribute>, чтобы вместить сведения о конкретном потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-591">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="546fd-592">Во втором примере показано, как использовать область данных для того, чтобы сделать то же самое.</span><span class="sxs-lookup"><span data-stu-id="546fd-592">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="546fd-593">**Первый пример**</span><span class="sxs-lookup"><span data-stu-id="546fd-593">**First Example**</span></span>  
  
 <span data-ttu-id="546fd-594">В следующем примере показано, как использовать поле, помеченное <xref:System.ThreadStaticAttribute>, для хранения информации, относящейся к конкретному потоку.</span><span class="sxs-lookup"><span data-stu-id="546fd-594">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="546fd-595">Этот метод обеспечивает лучшую производительность, чем метод, показанный во втором примере.</span><span class="sxs-lookup"><span data-stu-id="546fd-595">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="546fd-596">**Второй пример**</span><span class="sxs-lookup"><span data-stu-id="546fd-596">**Second Example**</span></span>  
  
 <span data-ttu-id="546fd-597">В следующем примере показано, как использовать область данных для хранения сведений о конкретном потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-597">The following example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="546fd-598">Потоки и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="546fd-598">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="546fd-599">Локальное хранилище потока: статические поля потока и области данных</span><span class="sxs-lookup"><span data-stu-id="546fd-599">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-600">Возвращает текущую область, в которой выполняется текущий поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-600">Returns the current domain in which the current thread is running.</span></span></summary>
        <returns><span data-ttu-id="546fd-601">Объект <see cref="T:System.AppDomain" />, представляющий собой текущий домен приложения выполняющегося потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-601">An <see cref="T:System.AppDomain" /> representing the current application domain of the running thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="546fd-602">В следующем примере кода показано, как получить имя и идентификатор объекта `AppDomain`, в котором выполняется поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-602">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-603">Возвращает уникальный идентификатор домена приложения.</span><span class="sxs-lookup"><span data-stu-id="546fd-603">Returns a unique application domain identifier.</span></span></summary>
        <returns><span data-ttu-id="546fd-604">32-разрядное знаковое целое число, однозначно определяющее домен приложения.</span><span class="sxs-lookup"><span data-stu-id="546fd-604">A 32-bit signed integer uniquely identifying the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="546fd-605">В следующем примере кода показано, как получить имя и идентификатор объекта `AppDomain`, в котором выполняется поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-605">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-606">Возвращает хэш-код текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-606">Returns a hash code for the current thread.</span></span></summary>
        <returns><span data-ttu-id="546fd-607">Целочисленное значение хэш-кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-607">An integer hash code value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-608">Хэш-код не обязательно должен быть уникальным.</span><span class="sxs-lookup"><span data-stu-id="546fd-608">The hash code is not guaranteed to be unique.</span></span> <span data-ttu-id="546fd-609">Если для управляемого потока требуется уникальный идентификатор, используйте свойство <xref:System.Threading.Thread.ManagedThreadId%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-609">Use the <xref:System.Threading.Thread.ManagedThreadId%2A> property if you need a unique identifier for a managed thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="546fd-610">Имя локальной области данных.</span><span class="sxs-lookup"><span data-stu-id="546fd-610">The name of the local data slot.</span></span></param>
        <summary><span data-ttu-id="546fd-611">Ищет именованную область данных.</span><span class="sxs-lookup"><span data-stu-id="546fd-611">Looks up a named data slot.</span></span> <span data-ttu-id="546fd-612">Для улучшения производительности используйте поля, отмеченные атрибутом <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-612">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="546fd-613">Объект <see cref="T:System.LocalDataStoreSlot" />, выделенный для данного потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-613">A <see cref="T:System.LocalDataStoreSlot" /> allocated for this thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="546fd-614">.NET Framework предоставляет два механизма использования локального хранилища потока (TLS): поля, относительные для потоков (то есть поля, помеченные атрибутом <xref:System.ThreadStaticAttribute>) и области данных.</span><span class="sxs-lookup"><span data-stu-id="546fd-614">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="546fd-615">Статические поля потоков обеспечивают гораздо лучшую производительность, чем области данных, и обеспечивают проверку типов во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="546fd-615">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="546fd-616">Дополнительные сведения об использовании протокола TLS см. в разделе [Thread локальное хранилище: Статические поля и области данных, относительные для потоков,](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="546fd-616">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="546fd-617">Потоки используют механизм локальной памяти хранилища для хранения данных конкретного потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-617">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="546fd-618">Среда CLR выделяет массив хранилища данных с несколькими слотами каждому процессу при его создании.</span><span class="sxs-lookup"><span data-stu-id="546fd-618">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="546fd-619">Поток может выделить область данных в хранилище данных, сохранить и извлечь значение данных в слоте и освободить слот для повторного использования после истечения срока действия потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-619">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="546fd-620">Области данных являются уникальными для каждого потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-620">Data slots are unique per thread.</span></span> <span data-ttu-id="546fd-621">Ни один другой поток (даже не дочерний поток) не может получить эти данные.</span><span class="sxs-lookup"><span data-stu-id="546fd-621">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="546fd-622">Если именованный слот не существует, выделяется новый слот.</span><span class="sxs-lookup"><span data-stu-id="546fd-622">If the named slot does not exist, a new slot is allocated.</span></span> <span data-ttu-id="546fd-623">Именованные слоты данных являются общедоступными и могут управляться любым пользователем.</span><span class="sxs-lookup"><span data-stu-id="546fd-623">Named data slots are public and can be manipulated by anyone.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-624">Этот раздел содержит два примера кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-624">This section contains two code examples.</span></span> <span data-ttu-id="546fd-625">В первом примере показано, как использовать поле, помеченное атрибутом <xref:System.ThreadStaticAttribute>, чтобы вместить сведения о конкретном потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-625">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="546fd-626">Во втором примере показано, как использовать область данных для того, чтобы сделать то же самое.</span><span class="sxs-lookup"><span data-stu-id="546fd-626">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="546fd-627">**Первый пример**</span><span class="sxs-lookup"><span data-stu-id="546fd-627">**First Example**</span></span>  
  
 <span data-ttu-id="546fd-628">В следующем примере показано, как использовать поле, помеченное <xref:System.ThreadStaticAttribute>, для хранения информации, относящейся к конкретному потоку.</span><span class="sxs-lookup"><span data-stu-id="546fd-628">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="546fd-629">Этот метод обеспечивает лучшую производительность, чем метод, показанный во втором примере.</span><span class="sxs-lookup"><span data-stu-id="546fd-629">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="546fd-630">**Второй пример**</span><span class="sxs-lookup"><span data-stu-id="546fd-630">**Second Example**</span></span>  
  
 <span data-ttu-id="546fd-631">В следующем примере показано, как использовать именованную область данных для хранения сведений о конкретном потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-631">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="546fd-632">Потоки и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="546fd-632">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="546fd-633">Локальное хранилище потока: статические поля потока и области данных</span><span class="sxs-lookup"><span data-stu-id="546fd-633">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-634">Прерывает работу потока, находящегося в состоянии <see cref="F:System.Threading.ThreadState.WaitSleepJoin" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-634">Interrupts a thread that is in the <see cref="F:System.Threading.ThreadState.WaitSleepJoin" /> thread state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-635">Если этот поток в настоящее время не заблокирован в состоянии ожидания, спящего режима или приостановки, он будет прерван после того, как он начнет блокироваться.</span><span class="sxs-lookup"><span data-stu-id="546fd-635">If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</span></span>  
  
 <span data-ttu-id="546fd-636"><xref:System.Threading.ThreadInterruptedException> возникает в прерванном потоке, но не до блокировки потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-636"><xref:System.Threading.ThreadInterruptedException> is thrown in the interrupted thread, but not until the thread blocks.</span></span> <span data-ttu-id="546fd-637">Если поток никогда не блокируется, исключение никогда не создается, поэтому поток может завершиться без прерывания работы.</span><span class="sxs-lookup"><span data-stu-id="546fd-637">If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-638">В следующем примере кода показано поведение выполняющегося потока при его прерывании и последующем блокировании.</span><span class="sxs-lookup"><span data-stu-id="546fd-638">The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="546fd-639">У вызывающей стороны отсутствует надлежащий <see cref="T:System.Security.Permissions.SecurityPermission" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-639">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="546fd-640">для расширенных операций с потоками.</span><span class="sxs-lookup"><span data-stu-id="546fd-640">for advanced operations on threads.</span></span> <span data-ttu-id="546fd-641">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-641">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="546fd-642">Приостановка и прерывание потоков</span><span class="sxs-lookup"><span data-stu-id="546fd-642">Pausing and interrupting threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-643">Возвращает значение, показывающее статус выполнения текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-643">Gets a value indicating the execution status of the current thread.</span></span></summary>
        <value><span data-ttu-id="546fd-644">Значение <see langword="true" />, если этот поток был запущен и не был завершен нормально, либо был прерван; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-644"><see langword="true" /> if this thread has been started and has not terminated normally or aborted; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-645">Возвращает или задает значение, показывающее, является ли поток фоновым.</span><span class="sxs-lookup"><span data-stu-id="546fd-645">Gets or sets a value indicating whether or not a thread is a background thread.</span></span></summary>
        <value><span data-ttu-id="546fd-646">Значение <see langword="true" />, если этот поток является или станет фоновым потоком; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-646"><see langword="true" /> if this thread is or is to become a background thread; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-647">Поток — это либо фоновый поток, либо поток переднего плана.</span><span class="sxs-lookup"><span data-stu-id="546fd-647">A thread is either a background thread or a foreground thread.</span></span> <span data-ttu-id="546fd-648">Фоновые потоки идентичны основным потокам, за исключением того, что фоновые потоки не предотвращают завершение процесса.</span><span class="sxs-lookup"><span data-stu-id="546fd-648">Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</span></span> <span data-ttu-id="546fd-649">После завершения всех передних потоков, принадлежащих процессу, среда CLR завершает процесс.</span><span class="sxs-lookup"><span data-stu-id="546fd-649">Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</span></span> <span data-ttu-id="546fd-650">Все оставшиеся фоновые потоки останавливаются и не завершаются.</span><span class="sxs-lookup"><span data-stu-id="546fd-650">Any remaining background threads are stopped and do not complete.</span></span>  
  
 <span data-ttu-id="546fd-651">По умолчанию следующие потоки выполняются на переднем плане (то есть их свойство <xref:System.Threading.Thread.IsBackground%2A> возвращает `false`):</span><span class="sxs-lookup"><span data-stu-id="546fd-651">By default, the following threads execute in the foreground (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `false`):</span></span>  
  
-   <span data-ttu-id="546fd-652">Основной поток (или основной поток приложения).</span><span class="sxs-lookup"><span data-stu-id="546fd-652">The primary thread (or main application thread).</span></span>  
  
-   <span data-ttu-id="546fd-653">Все потоки, созданные путем вызова конструктора класса <xref:System.Threading.Thread>.</span><span class="sxs-lookup"><span data-stu-id="546fd-653">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="546fd-654">По умолчанию следующие потоки выполняются в фоновом режиме (то есть их свойство <xref:System.Threading.Thread.IsBackground%2A> возвращает `true`):</span><span class="sxs-lookup"><span data-stu-id="546fd-654">By default, the following threads execute in the background  (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `true`):</span></span>  
  
-   <span data-ttu-id="546fd-655">Потоки пула потоков, которые являются пулом рабочих потоков, обслуживаемых средой выполнения.</span><span class="sxs-lookup"><span data-stu-id="546fd-655">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span> <span data-ttu-id="546fd-656">Пул потоков и расписание работы можно настроить в потоках пула потоков с помощью класса <xref:System.Threading.ThreadPool>.</span><span class="sxs-lookup"><span data-stu-id="546fd-656">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="546fd-657">Асинхронные операции на основе задач автоматически выполняются в потоках пула потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-657">Task-based asynchronous operations automatically execute on thread pool threads.</span></span>  
  
-   <span data-ttu-id="546fd-658">Все потоки, которые вводят управляемую среду выполнения из неуправляемого кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-658">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-659">В следующем примере демонстрируется поведение переднего плана и фоновых потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-659">The following example contrasts the behavior of foreground and background threads.</span></span> <span data-ttu-id="546fd-660">Он создает поток переднего плана и фоновый поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-660">It creates a foreground thread and a background thread.</span></span> <span data-ttu-id="546fd-661">Основной поток продолжает выполнение процесса до завершения цикла `for` и завершается.</span><span class="sxs-lookup"><span data-stu-id="546fd-661">The foreground thread keeps the process running until completes its `for` loop and terminates.</span></span> <span data-ttu-id="546fd-662">Однако, как показано в выходных данных примера, поскольку поток переднего плана завершил выполнение, процесс завершается до завершения выполнения фонового потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-662">However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-663">Поток не работает.</span><span class="sxs-lookup"><span data-stu-id="546fd-663">The thread is dead.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md"><span data-ttu-id="546fd-664">Основные и фоновые потоки</span><span class="sxs-lookup"><span data-stu-id="546fd-664">Foreground and Background Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-665">Возвращает значение, показывающее, принадлежит ли поток к группе управляемых потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-665">Gets a value indicating whether or not a thread belongs to the managed thread pool.</span></span></summary>
        <value><span data-ttu-id="546fd-666">Значение <see langword="true" />, если этот поток принадлежит группе управляемых потоков; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-666"><see langword="true" /> if this thread belongs to the managed thread pool; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-667">Дополнительные сведения см. [в разделе Пул управляемых потоков](~/docs/standard/threading/the-managed-thread-pool.md).</span><span class="sxs-lookup"><span data-stu-id="546fd-667">For more information see [The managed thread pool](~/docs/standard/threading/the-managed-thread-pool.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-668">В следующем примере кода показано, как определить, находится ли поток из пула потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-668">The following code example shows how to determine whether a thread is from the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="546fd-669">Пул управляемых потоков</span><span class="sxs-lookup"><span data-stu-id="546fd-669">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="546fd-670">Блокирует вызывающий поток до завершения потока, представленного этим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="546fd-670">Blocks the calling thread until the thread represented by this instance terminates.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-671">Блокирует вызывающий поток до завершения потока, представленного экземпляром, продолжая отправлять стандартные сообщения COM и <see langword="SendMessage" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-671">Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <see langword="SendMessage" /> pumping.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-672"><xref:System.Threading.Thread.Join%2A> является методом синхронизации, который блокирует вызывающий поток (то есть поток, который вызывает метод) до тех пор, пока не завершится поток, чей метод <xref:System.Threading.Thread.Join%2A> не завершен.</span><span class="sxs-lookup"><span data-stu-id="546fd-672"><xref:System.Threading.Thread.Join%2A> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed.</span></span> <span data-ttu-id="546fd-673">Используйте этот метод, чтобы убедиться, что поток был завершен.</span><span class="sxs-lookup"><span data-stu-id="546fd-673">Use this method to ensure that a thread has been terminated.</span></span> <span data-ttu-id="546fd-674">Вызывающий объект будет блокироваться в течение неограниченного времени, если поток не завершается.</span><span class="sxs-lookup"><span data-stu-id="546fd-674">The caller will block indefinitely if the thread does not terminate.</span></span> <span data-ttu-id="546fd-675">В следующем примере поток `Thread1` вызывает метод <xref:System.Threading.Thread.Join> класса `Thread2`, что приводит к блокировке `Thread1` до тех пор, пока не завершится `Thread2`.</span><span class="sxs-lookup"><span data-stu-id="546fd-675">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block until `Thread2` has completed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 <span data-ttu-id="546fd-676">Если поток уже был завершен при вызове <xref:System.Threading.Thread.Join%2A>, метод немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-676">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="546fd-677">Никогда не следует вызывать метод <xref:System.Threading.Thread.Join%2A> объекта <xref:System.Threading.Thread>, который представляет текущий поток из текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-677">You should never call the <xref:System.Threading.Thread.Join%2A> method of the <xref:System.Threading.Thread> object that represents the current thread from the current thread.</span></span> <span data-ttu-id="546fd-678">Это приведет к тому, что ваше приложение перестанет отвечать, поскольку текущий поток ждет, пока не исключается.</span><span class="sxs-lookup"><span data-stu-id="546fd-678">This causes your app to become unresponsive because the current thread waits upon itself indefinitely,</span></span>  
  
 <span data-ttu-id="546fd-679">Этот метод изменяет состояние вызывающего потока, чтобы оно включало <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-679">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="546fd-680">Нельзя вызвать `Join` в потоке, который находится в состоянии <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-680">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-681">Вызывающая сторона пыталась присоединиться к потоку, который находится в состоянии <see cref="F:System.Threading.ThreadState.Unstarted" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-681">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="546fd-682">Выполнение потока прервано во время ожидания.</span><span class="sxs-lookup"><span data-stu-id="546fd-682">The thread is interrupted while waiting.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="546fd-683">Количество миллисекунд ожидания завершения потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-683">The number of milliseconds to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="546fd-684">Блокирует вызывающий поток до завершения потока, представленного экземпляром, или истечения указанного времени, продолжая отправлять стандартные сообщения COM и SendMessage.</span><span class="sxs-lookup"><span data-stu-id="546fd-684">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="546fd-685">Значение <see langword="true" />, если поток завершился; значение <see langword="false" />, если поток не завершился по истечении количества времени, заданного параметром <paramref name="millisecondsTimeout" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-685"><see langword="true" /> if the thread has terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="millisecondsTimeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-686"><xref:System.Threading.Thread.Join%28System.Int32%29> — это метод синхронизации, который блокирует вызывающий поток (то есть поток, который вызывает метод) до тех пор, пока не завершится поток, чей метод <xref:System.Threading.Thread.Join%2A> не завершен, или не истечет интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="546fd-686"><xref:System.Threading.Thread.Join%28System.Int32%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="546fd-687">В следующем примере поток `Thread1` вызывает метод <xref:System.Threading.Thread.Join> для `Thread2`, что приводит к блокировке `Thread1` до завершения `Thread2` или до истечения 2 секунд.</span><span class="sxs-lookup"><span data-stu-id="546fd-687">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 <span data-ttu-id="546fd-688">Если для параметра `millisecondsTimeout` указан <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, этот метод ведет себя идентично перегрузке метода <xref:System.Threading.Thread.Join>, за исключением возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="546fd-688">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for the `millisecondsTimeout` parameter, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="546fd-689">Если поток уже был завершен при вызове <xref:System.Threading.Thread.Join%2A>, метод немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-689">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="546fd-690">Этот метод изменяет состояние вызывающего потока, чтобы оно включало <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-690">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="546fd-691">Нельзя вызвать `Join` в потоке, который находится в состоянии <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-691">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="546fd-692">Значение <paramref name="millisecondsTimeout" /> является отрицательным и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (в миллисекундах).</span><span class="sxs-lookup"><span data-stu-id="546fd-692">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-693">Поток не запущен.</span><span class="sxs-lookup"><span data-stu-id="546fd-693">The thread has not been started.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <exception cref="T:System.ArgumentException"><span data-ttu-id="546fd-694">Значение <paramref name="millisecondsTimeout" /> меньше –1 (Timeout.Infinite).</span><span class="sxs-lookup"><span data-stu-id="546fd-694"><paramref name="millisecondsTimeout" /> is less than -1 (Timeout.Infinite).</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="546fd-695">Выполнение потока было прервано во время ожидания.</span><span class="sxs-lookup"><span data-stu-id="546fd-695">The thread was interrupted while waiting.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="546fd-696">Объект <see cref="T:System.TimeSpan" />, в качестве значения которого задано время ожидания завершения процесса.</span><span class="sxs-lookup"><span data-stu-id="546fd-696">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="546fd-697">Блокирует вызывающий поток до завершения потока, представленного экземпляром, или истечения указанного времени, продолжая отправлять стандартные сообщения COM и SendMessage.</span><span class="sxs-lookup"><span data-stu-id="546fd-697">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="546fd-698">Значение <see langword="true" />, если поток завершился; <see langword="false" />, если поток не завершился по истечении количества времени, заданного параметром <paramref name="timeout" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-698"><see langword="true" /> if the thread terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="timeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-699"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> — это метод синхронизации, который блокирует вызывающий поток (то есть поток, который вызывает метод) до тех пор, пока не завершится поток, чей метод <xref:System.Threading.Thread.Join%2A> не завершен, или не истечет интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="546fd-699"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="546fd-700">В следующем примере поток `Thread1` вызывает метод <xref:System.Threading.Thread.Join> для `Thread2`, что приводит к блокировке `Thread1` до завершения `Thread2` или до истечения 2 секунд.</span><span class="sxs-lookup"><span data-stu-id="546fd-700">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 <span data-ttu-id="546fd-701">Если для `timeout` указан <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, этот метод ведет себя идентично перегрузке метода <xref:System.Threading.Thread.Join>, за исключением возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="546fd-701">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for `timeout`, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="546fd-702">Если поток уже был завершен при вызове <xref:System.Threading.Thread.Join%2A>, метод немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-702">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="546fd-703">Этот метод изменяет состояние текущего потока, чтобы оно включало <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="546fd-703">This method changes the state of the current thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span> <span data-ttu-id="546fd-704">Нельзя вызвать `Join` в потоке, который находится в состоянии <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-704">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-705">В следующем примере кода показано, как использовать значение `TimeSpan` с методом `Join`.</span><span class="sxs-lookup"><span data-stu-id="546fd-705">The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="546fd-706">Значение <paramref name="timeout" /> является отрицательным и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (в миллисекундах) или больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="546fd-706">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-707">Вызывающая сторона пыталась присоединиться к потоку, который находится в состоянии <see cref="F:System.Threading.ThreadState.Unstarted" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-707">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-708">Возвращает уникальный идентификатор текущего управляемого потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-708">Gets a unique identifier for the current managed thread.</span></span></summary>
        <value><span data-ttu-id="546fd-709">Целочисленное значение, представляющее уникальный идентификатор для этого управляемого потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-709">An integer that represents a unique identifier for this managed thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-710">Значение свойства потока <xref:System.Threading.Thread.ManagedThreadId%2A> служит для уникальной идентификации этого потока в процессе.</span><span class="sxs-lookup"><span data-stu-id="546fd-710">A thread's <xref:System.Threading.Thread.ManagedThreadId%2A> property value serves to uniquely identify that thread within its process.</span></span>  
  
 <span data-ttu-id="546fd-711">Значение свойства <xref:System.Threading.Thread.ManagedThreadId%2A> не изменяется со временем, даже если неуправляемый код, в котором размещается среда CLR, реализует поток как волокно.</span><span class="sxs-lookup"><span data-stu-id="546fd-711">The value of the <xref:System.Threading.Thread.ManagedThreadId%2A> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-712">Выполняет синхронизацию доступа к памяти следующим образом: процессор, выполняющий текущий поток, не способен упорядочить инструкции так, чтобы обращения к памяти до вызова метода <see cref="M:System.Threading.Thread.MemoryBarrier" /> выполнялись после обращений к памяти, следующих за вызовом метода <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-712">Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <see cref="M:System.Threading.Thread.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-713"><xref:System.Threading.Thread.MemoryBarrier%2A> требуется только в многопроцессорных системах с слабым порядком памяти (например, система использует несколько процессоров Intel Itanium).</span><span class="sxs-lookup"><span data-stu-id="546fd-713"><xref:System.Threading.Thread.MemoryBarrier%2A> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="546fd-714">В большинстве случаев оператор C# `lock`, Visual Basic инструкция `SyncLock` или класс <xref:System.Threading.Monitor> предоставляют более простые способы синхронизации данных.</span><span class="sxs-lookup"><span data-stu-id="546fd-714">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-715">Получает или задает имя потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-715">Gets or sets the name of the thread.</span></span></summary>
        <value><span data-ttu-id="546fd-716">Строка, содержащая имя потока или <see langword="null" />, если имя не задано.</span><span class="sxs-lookup"><span data-stu-id="546fd-716">A string containing the name of the thread, or <see langword="null" /> if no name was set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-717">Это свойство доступно только для записи.</span><span class="sxs-lookup"><span data-stu-id="546fd-717">This property is write-once.</span></span> <span data-ttu-id="546fd-718">Поскольку значение по умолчанию для свойства потока <xref:System.Threading.Thread.Name%2A> равно `null`, можно определить, было ли явно назначено имя потоку путем его сравнения с `null`.</span><span class="sxs-lookup"><span data-stu-id="546fd-718">Because the default value of a thread's <xref:System.Threading.Thread.Name%2A> property is `null`, you can determine whether a name has already been explicitly assigned to the thread by comparing it with `null`.</span></span>  
  
 <span data-ttu-id="546fd-719">Строка, назначенная свойству <xref:System.Threading.Thread.Name%2A>, может включать любой символ Юникода.</span><span class="sxs-lookup"><span data-stu-id="546fd-719">The string assigned to the <xref:System.Threading.Thread.Name%2A> property can include any Unicode character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-720">В следующем примере показано, как присвоить имя потоку.</span><span class="sxs-lookup"><span data-stu-id="546fd-720">The following example shows how to name a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="546fd-721">Запрошена операция задания, но свойство <see langword="Name" /> уже задано.</span><span class="sxs-lookup"><span data-stu-id="546fd-721">A set operation was requested, but the <see langword="Name" /> property has already been set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-722">Возвращает или задает значение, указывающее на планируемый приоритет потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-722">Gets or sets a value indicating the scheduling priority of a thread.</span></span></summary>
        <value><span data-ttu-id="546fd-723">Одно из значений <see cref="T:System.Threading.ThreadPriority" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-723">One of the <see cref="T:System.Threading.ThreadPriority" /> values.</span></span> <span data-ttu-id="546fd-724">Значение по умолчанию — <see cref="F:System.Threading.ThreadPriority.Normal" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-724">The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-725">Потоку может быть назначен любой из следующих приоритетных значений <xref:System.Threading.ThreadPriority>:</span><span class="sxs-lookup"><span data-stu-id="546fd-725">A thread can be assigned any one of the following priority <xref:System.Threading.ThreadPriority> values:</span></span>  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 <span data-ttu-id="546fd-726">Операционная система не обязана учитывать приоритет потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-726">Operating systems are not required to honor the priority of a thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-727">В следующем примере показан результат изменения приоритета потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-727">The following example shows the result of changing the priority of a thread.</span></span> <span data-ttu-id="546fd-728">Создаются три потока, приоритет одного потока устанавливается равным <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, а приоритет секунды устанавливается равным <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-728">Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, and the priority of a second is set to <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span></span> <span data-ttu-id="546fd-729">Каждый поток увеличивает переменную в цикле `while` и выполняется в течение заданного времени.</span><span class="sxs-lookup"><span data-stu-id="546fd-729">Each thread increments a variable in a `while` loop and runs for a set time.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-730">Поток достиг конечного состояния, например <see cref="F:System.Threading.ThreadState.Aborted" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-730">The thread has reached a final state, such as <see cref="F:System.Threading.ThreadState.Aborted" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="546fd-731">Значение, указанное для операции задания, не является допустимым значением <see cref="T:System.Threading.ThreadPriority" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-731">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md"><span data-ttu-id="546fd-732">Планирование потоков</span><span class="sxs-lookup"><span data-stu-id="546fd-732">Scheduling threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-733">Отменяет метод <see cref="M:System.Threading.Thread.Abort(System.Object)" />, запрошенный для текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-733">Cancels an <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-734">Этот метод может быть вызван только кодом с соответствующими разрешениями.</span><span class="sxs-lookup"><span data-stu-id="546fd-734">This method can only be called by code with the proper permissions.</span></span>  
  
 <span data-ttu-id="546fd-735">Когда выполняется вызов `Abort` для завершения потока, система создает исключение <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="546fd-735">When a call is made to `Abort` to terminate a thread, the system throws a <xref:System.Threading.ThreadAbortException>.</span></span> <span data-ttu-id="546fd-736">`ThreadAbortException` — это специальное исключение, которое может быть перехвачено кодом приложения, но повторно создается в конце блока catch, если не вызывается `ResetAbort`.</span><span class="sxs-lookup"><span data-stu-id="546fd-736">`ThreadAbortException` is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless `ResetAbort` is called.</span></span> <span data-ttu-id="546fd-737">`ResetAbort` отменяет запрос на прерывание и предотвращает остановку потока `ThreadAbortException`.</span><span class="sxs-lookup"><span data-stu-id="546fd-737">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span>  
  
 <span data-ttu-id="546fd-738">Пример, демонстрирующий вызов метода `ResetAbort`, см. в <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="546fd-738">See <xref:System.Threading.ThreadAbortException> for an example that demonstrates calling the `ResetAbort` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="546fd-739">Только в .NET Core: этот элемент не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="546fd-739">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-740">Метод <see langword="Abort" /> не был вызван в текущем потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-740"><see langword="Abort" /> was not invoked on the current thread.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="546fd-741">Вызывающая сторона не имеет требуемого разрешения безопасности для текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-741">The caller does not have the required security permission for the current thread.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="546fd-742">для расширенных операций с потоками.</span><span class="sxs-lookup"><span data-stu-id="546fd-742">for advanced operations on threads.</span></span> <span data-ttu-id="546fd-743">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-743">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="546fd-744">Удаление потоков</span><span class="sxs-lookup"><span data-stu-id="546fd-744">Destroying threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-745">Возобновляет приостановленную работу потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-745">Resumes a thread that has been suspended.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="546fd-746">Не используйте методы <xref:System.Threading.Thread.Suspend%2A> и <xref:System.Threading.Thread.Resume%2A> для синхронизации действий потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-746">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="546fd-747">У вас нет способа узнать, какой код выполняется потоком при его приостановке.</span><span class="sxs-lookup"><span data-stu-id="546fd-747">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="546fd-748">Если приостановить поток, который удерживает блокировки во время оценки разрешений безопасности, другие потоки в <xref:System.AppDomain> могут быть заблокированы.</span><span class="sxs-lookup"><span data-stu-id="546fd-748">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="546fd-749">Если приостановить поток во время выполнения конструктора класса, то другие потоки в <xref:System.AppDomain>, которые пытаются использовать этот класс, блокируются.</span><span class="sxs-lookup"><span data-stu-id="546fd-749">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="546fd-750">Взаимоблокировки могут происходить очень легко.</span><span class="sxs-lookup"><span data-stu-id="546fd-750">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="546fd-751">Только в .NET Core: этот элемент не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="546fd-751">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-752">Поток не был запущен, бездействует или не находится в приостановленном состоянии.</span><span class="sxs-lookup"><span data-stu-id="546fd-752">The thread has not been started, is dead, or is not in the suspended state.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="546fd-753">У вызывающей стороны отсутствует надлежащий <see cref="T:System.Security.Permissions.SecurityPermission" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-753">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="546fd-754">для расширенных операций с потоками.</span><span class="sxs-lookup"><span data-stu-id="546fd-754">for advanced operations on threads.</span></span> <span data-ttu-id="546fd-755">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="546fd-755">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="546fd-756">Приостановка и прерывание потоков</span><span class="sxs-lookup"><span data-stu-id="546fd-756">Pausing and interrupting threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="546fd-757">Новая модель "apartment".</span><span class="sxs-lookup"><span data-stu-id="546fd-757">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="546fd-758">Задает модель "apartment" для потока до его запуска.</span><span class="sxs-lookup"><span data-stu-id="546fd-758">Sets the apartment state of a thread before it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-759">Новые потоки инициализируются как <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>, если их состояние апартамента не было задано до запуска.</span><span class="sxs-lookup"><span data-stu-id="546fd-759">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="546fd-760">Перед запуском потока необходимо задать состояние апартамента.</span><span class="sxs-lookup"><span data-stu-id="546fd-760">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-761">Основной поток приложения инициализируется значением по умолчанию <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-761">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="546fd-762">Единственный способ задать для состояния подразделения основного потока приложения значение <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> — применить атрибут <xref:System.STAThreadAttribute> к методу точки входа.</span><span class="sxs-lookup"><span data-stu-id="546fd-762">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="546fd-763">Метод <xref:System.Threading.Thread.SetApartmentState%2A> вместе с методом <xref:System.Threading.Thread.GetApartmentState%2A> и методом <xref:System.Threading.Thread.TrySetApartmentState%2A> заменяет свойство <xref:System.Threading.Thread.ApartmentState%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-763">The <xref:System.Threading.Thread.SetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-764">В следующем примере кода демонстрируются методы <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> и <xref:System.Threading.Thread.TrySetApartmentState%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-764">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="546fd-765">В примере кода создается поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-765">The code example creates a thread.</span></span> <span data-ttu-id="546fd-766">Перед началом потока <xref:System.Threading.Thread.GetApartmentState%2A> отображает начальное состояние <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>, а <xref:System.Threading.Thread.SetApartmentState%2A> меняет состояние на <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-766">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="546fd-767">Затем метод <xref:System.Threading.Thread.TrySetApartmentState%2A> возвращает `false` при попытке изменить состояние на <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>, так как состояние апартамента уже задано.</span><span class="sxs-lookup"><span data-stu-id="546fd-767">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="546fd-768">Если была предпринята попытка выполнения одной операции с <xref:System.Threading.Thread.SetApartmentState%2A>, будет выдано исключение <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="546fd-768">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="546fd-769">После запуска потока снова используется метод <xref:System.Threading.Thread.TrySetApartmentState%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-769">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="546fd-770">В этот раз возникает исключение <xref:System.Threading.ThreadStateException>, так как поток уже запущен.</span><span class="sxs-lookup"><span data-stu-id="546fd-770">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="546fd-771">Только в .NET Core: этот элемент не поддерживается на платформах Linux и macOS.</span><span class="sxs-lookup"><span data-stu-id="546fd-771">.NET Core only: This member is not supported on the macOS and Linux platforms.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="546fd-772"><paramref name="state" /> не является допустимым состоянием подразделения.</span><span class="sxs-lookup"><span data-stu-id="546fd-772"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-773">Поток уже запущен.</span><span class="sxs-lookup"><span data-stu-id="546fd-773">The thread has already been started.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="546fd-774">Состояние подразделения уже инициализировано.</span><span class="sxs-lookup"><span data-stu-id="546fd-774">The apartment state has already been initialized.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="stack"><span data-ttu-id="546fd-775">Объект <see cref="T:System.Threading.CompressedStack" />, который будет применен к текущему потоку.</span><span class="sxs-lookup"><span data-stu-id="546fd-775">The <see cref="T:System.Threading.CompressedStack" /> object to be applied to the current thread.</span></span></param>
        <summary><span data-ttu-id="546fd-776">Применяет записанное значение <see cref="T:System.Threading.CompressedStack" /> к текущему потоку.</span><span class="sxs-lookup"><span data-stu-id="546fd-776">Applies a captured <see cref="T:System.Threading.CompressedStack" /> to the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-777">Этот метод больше не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="546fd-777">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="546fd-778">Во всех случаях.</span><span class="sxs-lookup"><span data-stu-id="546fd-778">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="546fd-779">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="546fd-779">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="546fd-780">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="546fd-780">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="546fd-781">Объект <see cref="T:System.LocalDataStoreSlot" />, для которого задается значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-781">The <see cref="T:System.LocalDataStoreSlot" /> in which to set the value.</span></span></param>
        <param name="data"><span data-ttu-id="546fd-782">Задаваемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-782">The value to be set.</span></span></param>
        <summary><span data-ttu-id="546fd-783">Задает данные в указанной области для текущей области потока, выполняющегося в данный момент.</span><span class="sxs-lookup"><span data-stu-id="546fd-783">Sets the data in the specified slot on the currently running thread, for that thread's current domain.</span></span> <span data-ttu-id="546fd-784">Для улучшения производительности используйте поля, отмеченные атрибутом <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-784">For better performance, use fields marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="546fd-785">.NET Framework предоставляет два механизма использования локального хранилища потока (TLS): поля, относительные для потоков (то есть поля, помеченные атрибутом <xref:System.ThreadStaticAttribute>) и области данных.</span><span class="sxs-lookup"><span data-stu-id="546fd-785">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="546fd-786">Статические поля потоков обеспечивают гораздо лучшую производительность, чем области данных, и обеспечивают проверку типов во время компиляции.</span><span class="sxs-lookup"><span data-stu-id="546fd-786">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="546fd-787">Дополнительные сведения об использовании протокола TLS см. в разделе [Thread локальное хранилище: Статические поля и области данных, относительные для потоков,](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="546fd-787">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="546fd-788">Потоки используют механизм локальной памяти хранилища для хранения данных конкретного потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-788">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="546fd-789">Среда CLR выделяет массив хранилища данных с несколькими слотами каждому процессу при его создании.</span><span class="sxs-lookup"><span data-stu-id="546fd-789">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="546fd-790">Поток может выделить область данных в хранилище данных, сохранить и извлечь значение данных в слоте, а также освободить слот для повторного использования после завершения процедуры потока, а объект <xref:System.Threading.Thread> был освобожден сборкой мусора.</span><span class="sxs-lookup"><span data-stu-id="546fd-790">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <xref:System.Threading.Thread> object has been reclaimed by garbage collection.</span></span> <span data-ttu-id="546fd-791">Области данных являются уникальными для каждого потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-791">Data slots are unique per thread.</span></span> <span data-ttu-id="546fd-792">Ни один другой поток (даже не дочерний поток) не может получить эти данные.</span><span class="sxs-lookup"><span data-stu-id="546fd-792">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-793"><xref:System.Threading.Thread.SetData%2A> — это метод `Shared`, который всегда применяется к выполняющимся в данный момент потокам, даже если он вызывается с помощью переменной, которая ссылается на другой поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-793"><xref:System.Threading.Thread.SetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="546fd-794">Чтобы избежать путаницы, используйте имя класса при вызове методов `Shared`: `Thread.SetData(testSlot, "test data")`.</span><span class="sxs-lookup"><span data-stu-id="546fd-794">To avoid confusion, use the class name when calling `Shared` methods: `Thread.SetData(testSlot, "test data")`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-795">Этот раздел содержит два примера кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-795">This section contains two code examples.</span></span> <span data-ttu-id="546fd-796">В первом примере показано, как использовать поле, помеченное атрибутом <xref:System.ThreadStaticAttribute>, чтобы вместить сведения о конкретном потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-796">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="546fd-797">Во втором примере показано, как использовать область данных для того, чтобы сделать то же самое.</span><span class="sxs-lookup"><span data-stu-id="546fd-797">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="546fd-798">**Первый пример**</span><span class="sxs-lookup"><span data-stu-id="546fd-798">**First Example**</span></span>  
  
 <span data-ttu-id="546fd-799">В следующем примере показано, как использовать поле, помеченное <xref:System.ThreadStaticAttribute>, для хранения информации, относящейся к конкретному потоку.</span><span class="sxs-lookup"><span data-stu-id="546fd-799">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="546fd-800">Этот метод обеспечивает лучшую производительность, чем метод, показанный во втором примере.</span><span class="sxs-lookup"><span data-stu-id="546fd-800">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="546fd-801">**Второй пример**</span><span class="sxs-lookup"><span data-stu-id="546fd-801">**Second Example**</span></span>  
  
 <span data-ttu-id="546fd-802">В следующем примере показано, как использовать именованную область данных для хранения сведений о конкретном потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-802">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="546fd-803">Потоки и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="546fd-803">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="546fd-804">Локальное хранилище потока: статические поля потока и области данных</span><span class="sxs-lookup"><span data-stu-id="546fd-804">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="546fd-805">Приостанавливает текущий поток на заданное время.</span><span class="sxs-lookup"><span data-stu-id="546fd-805">Suspends the current thread for the specified amount of time.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="546fd-806">Количество миллисекунд, на которое приостанавливается поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-806">The number of milliseconds for which the thread is suspended.</span></span> <span data-ttu-id="546fd-807">Если значение аргумента <paramref name="millisecondsTimeout" /> равно нулю, поток освобождает оставшуюся часть своего интервала времени для любого потока с таким же приоритетом, готовым к выполнению.</span><span class="sxs-lookup"><span data-stu-id="546fd-807">If the value of the <paramref name="millisecondsTimeout" /> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="546fd-808">Если других готовых к выполнению потоков с таким же приоритетом нет, выполнение текущего потока не приостанавливается.</span><span class="sxs-lookup"><span data-stu-id="546fd-808">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="546fd-809">Приостанавливает текущий поток на заданное количество миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="546fd-809">Suspends the current thread for the specified number of milliseconds.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-810">Выполнение потока не будет запланировано операционной системой на указанный период времени.</span><span class="sxs-lookup"><span data-stu-id="546fd-810">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="546fd-811">Этот метод изменяет состояние потока, чтобы оно включало <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="546fd-811">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="546fd-812">Можно указать <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> для параметра `millisecondsTimeout`, чтобы приостановить поток бесконечно.</span><span class="sxs-lookup"><span data-stu-id="546fd-812">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the `millisecondsTimeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="546fd-813">Однако рекомендуется использовать другие классы <xref:System.Threading?displayProperty=nameWithType>, такие как <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle> или <xref:System.Threading.Semaphore>, а также синхронизировать потоки или управлять ресурсами.</span><span class="sxs-lookup"><span data-stu-id="546fd-813">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to synchronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="546fd-814">Системные тактовые импульсы с заданной скоростью, называемой разрешением часов.</span><span class="sxs-lookup"><span data-stu-id="546fd-814">The system clock ticks at a specific rate called the clock resolution.</span></span> <span data-ttu-id="546fd-815">Фактическое время ожидания может быть не равно указанному времени ожидания, так как указанное время ожидания будет изменено в соответствии с тактами времени.</span><span class="sxs-lookup"><span data-stu-id="546fd-815">The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</span></span> <span data-ttu-id="546fd-816">Дополнительные сведения о разрешении часов и времени ожидания см. в разделе [функция спящего режима](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) .</span><span class="sxs-lookup"><span data-stu-id="546fd-816">For more information on clock resolution and the waiting time, see the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) topic.</span></span> <span data-ttu-id="546fd-817">Этот метод вызывает [функцию Sleep](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) из системных API Windows.</span><span class="sxs-lookup"><span data-stu-id="546fd-817">This method calls the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) from the Windows system APIs.</span></span>  
  
 <span data-ttu-id="546fd-818">Этот метод не выполняет стандартные конвейеры COM и SendMessage.</span><span class="sxs-lookup"><span data-stu-id="546fd-818">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-819">Если необходимо включить спящий режим в потоке, который имеет <xref:System.STAThreadAttribute>, но вы хотите выполнить стандартные выгрузки COM и SendMessage, рассмотрите возможность использования одной из перегруженных версий метода <xref:System.Threading.Thread.Join%2A>, указывающего интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="546fd-819">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-820">В следующем примере используется метод <xref:System.Threading.Thread.Sleep%2A> для блокировки основного потока приложения.</span><span class="sxs-lookup"><span data-stu-id="546fd-820">The following example uses the <xref:System.Threading.Thread.Sleep%2A> method to block the application's main thread.</span></span>  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="546fd-821">Значение времени ожидания является отрицательной величиной и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-821">The time-out value is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="546fd-822">Время, на которое приостанавливается поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-822">The amount of time for which the thread is suspended.</span></span> <span data-ttu-id="546fd-823">Если значение аргумента <paramref name="millisecondsTimeout" /> равно <see cref="F:System.TimeSpan.Zero" />, поток освобождает оставшуюся часть своего интервала времени для любого потока с таким же приоритетом, готовым к выполнению.</span><span class="sxs-lookup"><span data-stu-id="546fd-823">If the value of the <paramref name="millisecondsTimeout" /> argument is <see cref="F:System.TimeSpan.Zero" />, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="546fd-824">Если других готовых к выполнению потоков с таким же приоритетом нет, выполнение текущего потока не приостанавливается.</span><span class="sxs-lookup"><span data-stu-id="546fd-824">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="546fd-825">Приостанавливает текущий поток на заданное время.</span><span class="sxs-lookup"><span data-stu-id="546fd-825">Suspends the current thread for the specified amount of time.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-826">Выполнение потока не будет запланировано операционной системой на указанный период времени.</span><span class="sxs-lookup"><span data-stu-id="546fd-826">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="546fd-827">Этот метод изменяет состояние потока, чтобы оно включало <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="546fd-827">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="546fd-828">Можно указать <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> для параметра `timeout`, чтобы приостановить поток бесконечно.</span><span class="sxs-lookup"><span data-stu-id="546fd-828">You can specify <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> for the `timeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="546fd-829">Однако рекомендуется использовать другие классы <xref:System.Threading?displayProperty=nameWithType>, такие как <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle> или <xref:System.Threading.Semaphore>, а также синхронизировать потоки или управлять ресурсами.</span><span class="sxs-lookup"><span data-stu-id="546fd-829">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to synchronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="546fd-830">Эта перегрузка <xref:System.Threading.Thread.Sleep%2A> используется для общего числа целых миллисекунд в `timeout`.</span><span class="sxs-lookup"><span data-stu-id="546fd-830">This overload of <xref:System.Threading.Thread.Sleep%2A> uses the total number of whole milliseconds in `timeout`.</span></span> <span data-ttu-id="546fd-831">Доли миллисекунд отбрасываются.</span><span class="sxs-lookup"><span data-stu-id="546fd-831">Fractional milliseconds are discarded.</span></span>  
  
 <span data-ttu-id="546fd-832">Этот метод не выполняет стандартные конвейеры COM и SendMessage.</span><span class="sxs-lookup"><span data-stu-id="546fd-832">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-833">Если необходимо включить спящий режим в потоке, который имеет <xref:System.STAThreadAttribute>, но вы хотите выполнить стандартные выгрузки COM и SendMessage, рассмотрите возможность использования одной из перегруженных версий метода <xref:System.Threading.Thread.Join%2A>, указывающего интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="546fd-833">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-834">В следующем примере используется перегрузка метода <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> для блокирования основного потока приложения пять раз, в течение двух секунд каждый раз.</span><span class="sxs-lookup"><span data-stu-id="546fd-834">The following example uses the <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> method overload to block the application's main thread five times, for two seconds each time.</span></span>  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="546fd-835">Значение <paramref name="timeout" /> является отрицательным и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (в миллисекундах) или больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="546fd-835">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="iterations"><span data-ttu-id="546fd-836">32-разрядное знаковое целое число, определяющее, как долго потоку ожидать.</span><span class="sxs-lookup"><span data-stu-id="546fd-836">A 32-bit signed integer that defines how long a thread is to wait.</span></span></param>
        <summary><span data-ttu-id="546fd-837">Вынуждает поток выполнять ожидание столько раз, сколько определено параметром <paramref name="iterations" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-837">Causes a thread to wait the number of times defined by the <paramref name="iterations" /> parameter.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-838">Метод <xref:System.Threading.Thread.SpinWait%2A> полезен для реализации блокировок.</span><span class="sxs-lookup"><span data-stu-id="546fd-838">The <xref:System.Threading.Thread.SpinWait%2A> method is useful for implementing locks.</span></span> <span data-ttu-id="546fd-839">Классы в .NET Framework, такие как <xref:System.Threading.Monitor> и <xref:System.Threading.ReaderWriterLock>, используют этот метод для внутренних целей.</span><span class="sxs-lookup"><span data-stu-id="546fd-839">Classes in the .NET Framework, such as <xref:System.Threading.Monitor> and <xref:System.Threading.ReaderWriterLock>, use this method internally.</span></span> <span data-ttu-id="546fd-840"><xref:System.Threading.Thread.SpinWait%2A> фактически помещает процессор в очень тесной цикл с числом циклов, заданным параметром `iterations`.</span><span class="sxs-lookup"><span data-stu-id="546fd-840"><xref:System.Threading.Thread.SpinWait%2A> essentially puts the processor into a very tight loop, with the loop count specified by the `iterations` parameter.</span></span> <span data-ttu-id="546fd-841">Таким образом, время ожидания зависит от скорости процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-841">The duration of the wait therefore depends on the speed of the processor.</span></span>  
  
 <span data-ttu-id="546fd-842">Сравните это с методом <xref:System.Threading.Thread.Sleep%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-842">Contrast this with the <xref:System.Threading.Thread.Sleep%2A> method.</span></span> <span data-ttu-id="546fd-843">Поток, вызывающий <xref:System.Threading.Thread.Sleep%2A>, возвращает оставшуюся часть его текущего среза, даже если указанный интервал равен нулю.</span><span class="sxs-lookup"><span data-stu-id="546fd-843">A thread that calls <xref:System.Threading.Thread.Sleep%2A> yields the rest of its current slice of processor time, even if the specified interval is zero.</span></span> <span data-ttu-id="546fd-844">Задание ненулевого интервала для <xref:System.Threading.Thread.Sleep%2A> удаляет поток из рассмотрения планировщиком потоков до истечения интервала времени.</span><span class="sxs-lookup"><span data-stu-id="546fd-844">Specifying a non-zero interval for <xref:System.Threading.Thread.Sleep%2A> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</span></span>  
  
 <span data-ttu-id="546fd-845"><xref:System.Threading.Thread.SpinWait%2A> обычно не используется для обычных приложений.</span><span class="sxs-lookup"><span data-stu-id="546fd-845"><xref:System.Threading.Thread.SpinWait%2A> is not generally useful for ordinary applications.</span></span> <span data-ttu-id="546fd-846">В большинстве случаев следует использовать классы синхронизации, предоставляемые .NET Framework; Например, вызовите <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> или инструкцию, которая заключает в оболочку <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> C# (`lock` в или `SyncLock` в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="546fd-846">In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> or a statement that wraps <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in C# or `SyncLock` in Visual Basic).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="546fd-847">В редких случаях, когда полезно избегать переключения контекста, например, если известно, что изменение состояния приближается, выполните вызов метода <xref:System.Threading.Thread.SpinWait%2A> в цикле.</span><span class="sxs-lookup"><span data-stu-id="546fd-847">In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <xref:System.Threading.Thread.SpinWait%2A> method in your loop.</span></span> <span data-ttu-id="546fd-848">Код, <xref:System.Threading.Thread.SpinWait%2A>, предназначен для предотвращения проблем, которые могут возникнуть на компьютерах с несколькими процессорами.</span><span class="sxs-lookup"><span data-stu-id="546fd-848">The code <xref:System.Threading.Thread.SpinWait%2A> executes is designed to prevent problems that can occur on computers with multiple processors.</span></span> <span data-ttu-id="546fd-849">Например, на компьютерах с несколькими процессорами Intel, использующими технологию Hyper-Threading, <xref:System.Threading.Thread.SpinWait%2A> предотвращает загрузку процессора в определенных ситуациях.</span><span class="sxs-lookup"><span data-stu-id="546fd-849">For example, on computers with multiple Intel processors employing Hyper-Threading technology, <xref:System.Threading.Thread.SpinWait%2A> prevents processor starvation in certain situations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="546fd-850">Позволяет планировать выполнение потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-850">Causes a thread to be scheduled for execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-851">Вынуждает операционную систему изменить состояние текущего экземпляра на <see cref="F:System.Threading.ThreadState.Running" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-851">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-852">Когда поток находится в состоянии <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType>, операционная система может запланировать его выполнение.</span><span class="sxs-lookup"><span data-stu-id="546fd-852">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="546fd-853">Поток начинает выполняться в первой строке метода, представленного делегатом <xref:System.Threading.ThreadStart> или <xref:System.Threading.ParameterizedThreadStart>, предоставленным конструктору потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-853">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="546fd-854">Обратите внимание, что вызов <xref:System.Threading.Thread.Start%2A> не блокирует вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-854">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-855">Если эта перегрузка используется с потоком, созданным с помощью делегата <xref:System.Threading.ParameterizedThreadStart>, `null` передается в метод, выполняемый потоком.</span><span class="sxs-lookup"><span data-stu-id="546fd-855">If this overload is used with a thread created using a <xref:System.Threading.ParameterizedThreadStart> delegate, `null` is passed to the method executed by the thread.</span></span>  
  
 <span data-ttu-id="546fd-856">После завершения потока он не может быть перезапущен с другим вызовом `Start`.</span><span class="sxs-lookup"><span data-stu-id="546fd-856">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-857">В следующем примере создается и запускается поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-857">The following example creates and starts a thread.</span></span>  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-858">Поток уже запущен.</span><span class="sxs-lookup"><span data-stu-id="546fd-858">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="546fd-859">Недостаточно памяти для запуска этого потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-859">There is not enough memory available to start this thread.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="546fd-860">Потоки и работа с потоками</span><span class="sxs-lookup"><span data-stu-id="546fd-860">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="546fd-861">Создание потоков и передача данных во время запуска</span><span class="sxs-lookup"><span data-stu-id="546fd-861">Creating Threads and Passing Data at Start Time</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="parameter"><span data-ttu-id="546fd-862">Объект, содержащий данные, используемые методом, который выполняется потоком.</span><span class="sxs-lookup"><span data-stu-id="546fd-862">An object that contains data to be used by the method the thread executes.</span></span></param>
        <summary><span data-ttu-id="546fd-863">Заставляет операционную систему изменить состояние текущего экземпляра на <see cref="F:System.Threading.ThreadState.Running" />, а также (необязательно) передает объект с данными, используемыми методом в потоке.</span><span class="sxs-lookup"><span data-stu-id="546fd-863">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />, and optionally supplies an object containing data to be used by the method the thread executes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-864">Когда поток находится в состоянии <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType>, операционная система может запланировать его выполнение.</span><span class="sxs-lookup"><span data-stu-id="546fd-864">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="546fd-865">Поток начинает выполняться в первой строке метода, представленного делегатом <xref:System.Threading.ThreadStart> или <xref:System.Threading.ParameterizedThreadStart>, предоставленным конструктору потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-865">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="546fd-866">Обратите внимание, что вызов <xref:System.Threading.Thread.Start%2A> не блокирует вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-866">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
 <span data-ttu-id="546fd-867">После завершения потока он не может быть перезапущен с другим вызовом `Start`.</span><span class="sxs-lookup"><span data-stu-id="546fd-867">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
 <span data-ttu-id="546fd-868">Эта перегрузка и делегат <xref:System.Threading.ParameterizedThreadStart> позволяют легко передавать данные в потоковую процедуру, но этот метод не является типобезопасным, так как любой объект может быть передан в эту перегрузку.</span><span class="sxs-lookup"><span data-stu-id="546fd-868">This overload and the <xref:System.Threading.ParameterizedThreadStart> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</span></span> <span data-ttu-id="546fd-869">Более надежный способ передачи данных в потоковую процедуру заключается в помещении как процедуры потока, так и полей данных в рабочий объект.</span><span class="sxs-lookup"><span data-stu-id="546fd-869">A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</span></span> <span data-ttu-id="546fd-870">Дополнительные сведения см. [в разделе Создание потоков и передача данных во время начала](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span><span class="sxs-lookup"><span data-stu-id="546fd-870">For more information, see [Creating Threads and Passing Data at Start Time](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-871">В следующем примере создается делегат <xref:System.Threading.ParameterizedThreadStart> с статическим методом и методом экземпляра.</span><span class="sxs-lookup"><span data-stu-id="546fd-871">The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-872">Поток уже запущен.</span><span class="sxs-lookup"><span data-stu-id="546fd-872">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="546fd-873">Недостаточно памяти для запуска этого потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-873">There is not enough memory available to start this thread.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="546fd-874">Этот поток был создан с помощью делегата <see cref="T:System.Threading.ThreadStart" />, а не делегата <see cref="T:System.Threading.ParameterizedThreadStart" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-874">This thread was created using a <see cref="T:System.Threading.ThreadStart" /> delegate instead of a <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="546fd-875">Создание потоков</span><span class="sxs-lookup"><span data-stu-id="546fd-875">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-876">Приостанавливает работу потока; если работа потока уже приостановлена, не оказывает влияния.</span><span class="sxs-lookup"><span data-stu-id="546fd-876">Either suspends the thread, or if the thread is already suspended, has no effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-877">Если поток уже приостановлен, этот метод не действует.</span><span class="sxs-lookup"><span data-stu-id="546fd-877">If the thread is already suspended, this method has no effect.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="546fd-878">Не используйте методы <xref:System.Threading.Thread.Suspend%2A> и <xref:System.Threading.Thread.Resume%2A> для синхронизации действий потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-878">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="546fd-879">У вас нет способа узнать, какой код выполняется потоком при его приостановке.</span><span class="sxs-lookup"><span data-stu-id="546fd-879">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="546fd-880">Если приостановить поток, который удерживает блокировки во время оценки разрешений безопасности, другие потоки в <xref:System.AppDomain> могут быть заблокированы.</span><span class="sxs-lookup"><span data-stu-id="546fd-880">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="546fd-881">Если приостановить поток во время выполнения конструктора класса, то другие потоки в <xref:System.AppDomain>, которые пытаются использовать этот класс, блокируются.</span><span class="sxs-lookup"><span data-stu-id="546fd-881">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="546fd-882">Взаимоблокировки могут происходить очень легко.</span><span class="sxs-lookup"><span data-stu-id="546fd-882">Deadlocks can occur very easily.</span></span>

<span data-ttu-id="546fd-883">При вызове в потоке метода `Suspend` система закладывает запрос на приостановку потока и позволяет выполнить поток до того, как он достигнет точки безопасности, прежде чем фактически приостановить поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-883">When you call the `Suspend` method on a thread, the system notes that a thread suspension has been requested and allows the thread to execute until it reaches a safe point before actually suspending the thread.</span></span> <span data-ttu-id="546fd-884">Безопасной точкой для потока считается такой этап выполнения, в котором можно безопасно выполнять сборку мусора.</span><span class="sxs-lookup"><span data-stu-id="546fd-884">A safe point for a thread is a point in its execution at which garbage collection can be performed.</span></span> <span data-ttu-id="546fd-885">После достижения безопасной точки среда выполнения гарантирует, что поток не выполняет никаких действий в управляемом коде.</span><span class="sxs-lookup"><span data-stu-id="546fd-885">Once a safe point is reached, the runtime guarantees that the suspended thread will not make any further progress in managed code.</span></span> <span data-ttu-id="546fd-886">В потоке, выполняемом вне управляемого кода, всегда можно безопасно выполнить сборку мусора, поэтому его выполнение продолжается, пока он попытается возобновить выполнение управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-886">A thread executing outside managed code is always safe for garbage collection, and its execution continues until it attempts to resume execution of managed code.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="546fd-887">Только в .NET Core: этот элемент не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="546fd-887">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-888">Поток не запущен или удален.</span><span class="sxs-lookup"><span data-stu-id="546fd-888">The thread has not been started or is dead.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="546fd-889">У вызывающей стороны отсутствует надлежащий <see cref="T:System.Security.Permissions.SecurityPermission" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-889">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="546fd-890">для расширенных операций с потоками.</span><span class="sxs-lookup"><span data-stu-id="546fd-890">for advanced operations on threads.</span></span> <span data-ttu-id="546fd-891">Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-891">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="546fd-892">Приостановка и прерывание потоков</span><span class="sxs-lookup"><span data-stu-id="546fd-892">Pausing and interrupting threads</span></span></related>
        <altmember cref="T:System.Threading.ThreadState" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="546fd-893">Зарезервировано для будущего использования.</span><span class="sxs-lookup"><span data-stu-id="546fd-893">Reserved for future use.</span></span> <span data-ttu-id="546fd-894">Должно быть равным IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="546fd-894">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="546fd-895">Переданный массив имен, которые необходимо сопоставить.</span><span class="sxs-lookup"><span data-stu-id="546fd-895">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="546fd-896">Количество сопоставляемых имен.</span><span class="sxs-lookup"><span data-stu-id="546fd-896">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="546fd-897">Контекст языкового стандарта для интерпретации имен.</span><span class="sxs-lookup"><span data-stu-id="546fd-897">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="546fd-898">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</span><span class="sxs-lookup"><span data-stu-id="546fd-898">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="546fd-899">Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</span><span class="sxs-lookup"><span data-stu-id="546fd-899">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-900">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-900">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="546fd-901">Дополнительные сведения о `IDispatch::GetIDsOfNames` см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="546fd-901">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="546fd-902">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="546fd-902">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="546fd-903">Возвращаемые сведения о типе.</span><span class="sxs-lookup"><span data-stu-id="546fd-903">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="546fd-904">Идентификатор языкового стандарта для сведений о типе.</span><span class="sxs-lookup"><span data-stu-id="546fd-904">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="546fd-905">Получает указатель на объект с запрошенными сведениями о типе.</span><span class="sxs-lookup"><span data-stu-id="546fd-905">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="546fd-906">Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</span><span class="sxs-lookup"><span data-stu-id="546fd-906">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-907">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-907">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="546fd-908">Дополнительные сведения о `IDispatch::GetTypeInfo` см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="546fd-908">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="546fd-909">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="546fd-909">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="546fd-910">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</span><span class="sxs-lookup"><span data-stu-id="546fd-910">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="546fd-911">Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</span><span class="sxs-lookup"><span data-stu-id="546fd-911">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-912">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-912">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="546fd-913">Дополнительные сведения о `IDispatch::GetTypeInfoCount` см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="546fd-913">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="546fd-914">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="546fd-914">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="546fd-915">Идентифицирует член.</span><span class="sxs-lookup"><span data-stu-id="546fd-915">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="546fd-916">Зарезервировано для будущего использования.</span><span class="sxs-lookup"><span data-stu-id="546fd-916">Reserved for future use.</span></span> <span data-ttu-id="546fd-917">Должно быть равным IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="546fd-917">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="546fd-918">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</span><span class="sxs-lookup"><span data-stu-id="546fd-918">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="546fd-919">Флаги, описывающие контекст вызова.</span><span class="sxs-lookup"><span data-stu-id="546fd-919">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="546fd-920">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</span><span class="sxs-lookup"><span data-stu-id="546fd-920">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="546fd-921">Указатель, по которому будет сохранен результат.</span><span class="sxs-lookup"><span data-stu-id="546fd-921">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="546fd-922">Указатель на структуру, содержащую сведения об исключении.</span><span class="sxs-lookup"><span data-stu-id="546fd-922">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="546fd-923">Индекс первого аргумента, вызвавшего ошибку.</span><span class="sxs-lookup"><span data-stu-id="546fd-923">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="546fd-924">Предоставляет доступ к открытым свойствам и методам объекта.</span><span class="sxs-lookup"><span data-stu-id="546fd-924">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-925">Этот метод предназначен для доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</span><span class="sxs-lookup"><span data-stu-id="546fd-925">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="546fd-926">Дополнительные сведения о `IDispatch::Invoke` см. в библиотеке MSDN.</span><span class="sxs-lookup"><span data-stu-id="546fd-926">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="546fd-927">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="546fd-927">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="546fd-928">Возвращает значение, содержащее состояния текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-928">Gets a value containing the states of the current thread.</span></span></summary>
        <value><span data-ttu-id="546fd-929">Одно из значений <see cref="T:System.Threading.ThreadState" />, показывающее состояние текущего потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-929">One of the <see cref="T:System.Threading.ThreadState" /> values indicating the state of the current thread.</span></span> <span data-ttu-id="546fd-930">Начальное значение — <see cref="F:System.Threading.ThreadState.Unstarted" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-930">The initial value is <see cref="F:System.Threading.ThreadState.Unstarted" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-931">Свойство <xref:System.Threading.Thread.ThreadState%2A> предоставляет более конкретные сведения, чем свойство <xref:System.Threading.Thread.IsAlive%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-931">The <xref:System.Threading.Thread.ThreadState%2A> property provides more specific information than the <xref:System.Threading.Thread.IsAlive%2A> property.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="546fd-932">Состояние потока представляет интерес только в сценариях отладки.</span><span class="sxs-lookup"><span data-stu-id="546fd-932">Thread state is only of interest in debugging scenarios.</span></span> <span data-ttu-id="546fd-933">Не используйте в коде состояния потоков для синхронизации действий потоков.</span><span class="sxs-lookup"><span data-stu-id="546fd-933">Your code should never use thread state to synchronize the activities of threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-934">В следующем примере кода демонстрируется доступ к `ThreadState` потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-934">The following code example demonstrates accessing the `ThreadState` of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="546fd-935">Новая модель "apartment".</span><span class="sxs-lookup"><span data-stu-id="546fd-935">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="546fd-936">Задает модель "apartment" для потока до его запуска.</span><span class="sxs-lookup"><span data-stu-id="546fd-936">Sets the apartment state of a thread before it is started.</span></span></summary>
        <returns><span data-ttu-id="546fd-937">Значение <see langword="true" />, если задана модель "apartment"; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-937"><see langword="true" /> if the apartment state is set; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-938">Новые потоки инициализируются как <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>, если их состояние апартамента не было задано до запуска.</span><span class="sxs-lookup"><span data-stu-id="546fd-938">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="546fd-939">Перед запуском потока необходимо задать состояние апартамента.</span><span class="sxs-lookup"><span data-stu-id="546fd-939">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-940">Основной поток приложения инициализируется значением по умолчанию <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-940">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="546fd-941">Единственный способ задать для состояния подразделения основного потока приложения значение <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> — применить атрибут <xref:System.STAThreadAttribute> к методу точки входа.</span><span class="sxs-lookup"><span data-stu-id="546fd-941">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="546fd-942">Метод <xref:System.Threading.Thread.TrySetApartmentState%2A> вместе с методом <xref:System.Threading.Thread.GetApartmentState%2A> и методом <xref:System.Threading.Thread.SetApartmentState%2A> заменяет свойство <xref:System.Threading.Thread.ApartmentState%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-942">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.SetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="546fd-943">В следующем примере кода демонстрируются методы <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A> и <xref:System.Threading.Thread.TrySetApartmentState%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-943">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="546fd-944">В примере кода создается поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-944">The code example creates a thread.</span></span> <span data-ttu-id="546fd-945">Перед началом потока <xref:System.Threading.Thread.GetApartmentState%2A> отображает начальное состояние <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>, а <xref:System.Threading.Thread.SetApartmentState%2A> меняет состояние на <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="546fd-945">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="546fd-946">Затем метод <xref:System.Threading.Thread.TrySetApartmentState%2A> возвращает `false` при попытке изменить состояние на <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>, так как состояние апартамента уже задано.</span><span class="sxs-lookup"><span data-stu-id="546fd-946">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="546fd-947">Если была предпринята попытка выполнения одной операции с <xref:System.Threading.Thread.SetApartmentState%2A>, будет выдано исключение <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="546fd-947">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="546fd-948">После запуска потока снова используется метод <xref:System.Threading.Thread.TrySetApartmentState%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-948">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="546fd-949">В этот раз возникает исключение <xref:System.Threading.ThreadStateException>, так как поток уже запущен.</span><span class="sxs-lookup"><span data-stu-id="546fd-949">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="546fd-950">Только в .NET Core: этот элемент не поддерживается на платформах Linux и macOS.</span><span class="sxs-lookup"><span data-stu-id="546fd-950">.NET Core only: This member is not supported on the macOS and Linux platforms.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="546fd-951"><paramref name="state" /> не является допустимым состоянием подразделения.</span><span class="sxs-lookup"><span data-stu-id="546fd-951"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="546fd-952">Поток был запущен, а затем завершен, либо вызов выполняется не из контекста потока во время выполнения потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-952">The thread was started and has terminated, or the call is not being made from the thread's context while the thread is running.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="546fd-953">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-953">Reads the value of a field.</span></span> <span data-ttu-id="546fd-954">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-954">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : byte -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-955">Поле для чтения.</span><span class="sxs-lookup"><span data-stu-id="546fd-955">The field to be read.</span></span></param>
        <summary><span data-ttu-id="546fd-956">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-956">Reads the value of a field.</span></span> <span data-ttu-id="546fd-957">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-957">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="546fd-958">Последнее значение, записанное в поле любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-958">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-959"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-959"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-960">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-960">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-961">В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> получает самое последнее значение, записанное в область памяти любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-961">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="546fd-962">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-962">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-963">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-963">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-964">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-964">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-965">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-965">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-966">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-966">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-967">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-967">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : double -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-968">Поле для чтения.</span><span class="sxs-lookup"><span data-stu-id="546fd-968">The field to be read.</span></span></param>
        <summary><span data-ttu-id="546fd-969">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-969">Reads the value of a field.</span></span> <span data-ttu-id="546fd-970">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-970">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="546fd-971">Последнее значение, записанное в поле любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-971">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-972"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-972"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-973">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-973">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-974">В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> получает самое последнее значение, записанное в область памяти любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-974">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="546fd-975">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-975">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-976">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-976">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-977">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-977">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-978">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-978">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-979">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-979">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-980">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-980">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int16 -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-981">Поле для чтения.</span><span class="sxs-lookup"><span data-stu-id="546fd-981">The field to be read.</span></span></param>
        <summary><span data-ttu-id="546fd-982">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-982">Reads the value of a field.</span></span> <span data-ttu-id="546fd-983">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-983">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="546fd-984">Последнее значение, записанное в поле любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-984">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-985"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-985"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-986">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-986">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-987">В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> получает самое последнее значение, записанное в область памяти любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-987">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="546fd-988">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-988">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-989">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-989">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-990">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-990">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-991">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-991">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-992">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-992">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-993">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-993">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-994">Поле для чтения.</span><span class="sxs-lookup"><span data-stu-id="546fd-994">The field to be read.</span></span></param>
        <summary><span data-ttu-id="546fd-995">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-995">Reads the value of a field.</span></span> <span data-ttu-id="546fd-996">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-996">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="546fd-997">Последнее значение, записанное в поле любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-997">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-998"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-998"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-999">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-999">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1000">В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> получает самое последнее значение, записанное в область памяти любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1000">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="546fd-1001">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1001">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1002">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1002">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1003">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1003">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1004">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1004">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1005">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1005">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1006">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1006">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : int64 -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1007">Поле для чтения.</span><span class="sxs-lookup"><span data-stu-id="546fd-1007">The field to be read.</span></span></param>
        <summary><span data-ttu-id="546fd-1008">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-1008">Reads the value of a field.</span></span> <span data-ttu-id="546fd-1009">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1009">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="546fd-1010">Последнее значение, записанное в поле любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1010">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1011"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1011"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1012">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1012">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1013">В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> получает самое последнее значение, записанное в область памяти любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1013">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="546fd-1014">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1014">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1015">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1015">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1016">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1016">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1017">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1017">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1018">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1018">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1019">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1019">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : nativeint -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1020">Поле для чтения.</span><span class="sxs-lookup"><span data-stu-id="546fd-1020">The field to be read.</span></span></param>
        <summary><span data-ttu-id="546fd-1021">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-1021">Reads the value of a field.</span></span> <span data-ttu-id="546fd-1022">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1022">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="546fd-1023">Последнее значение, записанное в поле любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1023">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1024"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1024"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1025">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1025">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1026">В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> получает самое последнее значение, записанное в область памяти любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1026">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="546fd-1027">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1027">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1028">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1028">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1029">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1029">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1030">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1030">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1031">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1031">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1032">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1032">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : obj -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1033">Поле для чтения.</span><span class="sxs-lookup"><span data-stu-id="546fd-1033">The field to be read.</span></span></param>
        <summary><span data-ttu-id="546fd-1034">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-1034">Reads the value of a field.</span></span> <span data-ttu-id="546fd-1035">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1035">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="546fd-1036">Последнее значение, записанное в поле любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1036">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1037"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1037"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1038">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1038">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1039">В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> получает самое последнее значение, записанное в область памяти любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1039">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="546fd-1040">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1040">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1041">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1041">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1042">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1042">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1043">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1043">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1044">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1044">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1045">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1045">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : sbyte -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1046">Поле для чтения.</span><span class="sxs-lookup"><span data-stu-id="546fd-1046">The field to be read.</span></span></param>
        <summary><span data-ttu-id="546fd-1047">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-1047">Reads the value of a field.</span></span> <span data-ttu-id="546fd-1048">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1048">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="546fd-1049">Последнее значение, записанное в поле любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1049">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1050"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1050"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1051">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1051">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1052">В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> получает самое последнее значение, записанное в область памяти любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1052">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="546fd-1053">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1053">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1054">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1054">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1055">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1055">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1056">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1056">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1057">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1057">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1058">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1058">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : single -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1059">Поле для чтения.</span><span class="sxs-lookup"><span data-stu-id="546fd-1059">The field to be read.</span></span></param>
        <summary><span data-ttu-id="546fd-1060">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-1060">Reads the value of a field.</span></span> <span data-ttu-id="546fd-1061">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1061">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="546fd-1062">Последнее значение, записанное в поле любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1062">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1063"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1063"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1064">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1064">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1065">В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> получает самое последнее значение, записанное в область памяти любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1065">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="546fd-1066">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1066">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1067">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1067">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1068">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1068">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1069">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1069">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1070">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1070">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1071">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1071">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint16 -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1072">Поле для чтения.</span><span class="sxs-lookup"><span data-stu-id="546fd-1072">The field to be read.</span></span></param>
        <summary><span data-ttu-id="546fd-1073">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-1073">Reads the value of a field.</span></span> <span data-ttu-id="546fd-1074">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1074">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="546fd-1075">Последнее значение, записанное в поле любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1075">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1076"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1076"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1077">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1077">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1078">В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> получает самое последнее значение, записанное в область памяти любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1078">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="546fd-1079">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1079">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1080">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1080">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1081">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1081">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1082">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1082">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1083">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1083">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1084">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1084">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint32 -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1085">Поле для чтения.</span><span class="sxs-lookup"><span data-stu-id="546fd-1085">The field to be read.</span></span></param>
        <summary><span data-ttu-id="546fd-1086">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-1086">Reads the value of a field.</span></span> <span data-ttu-id="546fd-1087">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1087">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="546fd-1088">Последнее значение, записанное в поле любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1088">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1089"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1089"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1090">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1090">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1091">В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> получает самое последнее значение, записанное в область памяти любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1091">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="546fd-1092">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1092">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1093">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1093">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1094">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1094">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1095">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1095">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1096">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1096">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1097">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1097">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : uint64 -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1098">Поле для чтения.</span><span class="sxs-lookup"><span data-stu-id="546fd-1098">The field to be read.</span></span></param>
        <summary><span data-ttu-id="546fd-1099">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-1099">Reads the value of a field.</span></span> <span data-ttu-id="546fd-1100">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1100">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="546fd-1101">Последнее значение, записанное в поле любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1101">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1102"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1102"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1103">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1103">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1104">В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> получает самое последнее значение, записанное в область памяти любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1104">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="546fd-1105">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1105">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1106">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1106">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1107">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1107">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1108">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1108">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1109">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1109">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1110">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1110">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead : unativeint -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1111">Поле для чтения.</span><span class="sxs-lookup"><span data-stu-id="546fd-1111">The field to be read.</span></span></param>
        <summary><span data-ttu-id="546fd-1112">Считывает значение поля.</span><span class="sxs-lookup"><span data-stu-id="546fd-1112">Reads the value of a field.</span></span> <span data-ttu-id="546fd-1113">Это значение является последним записанным каким-либо из процессоров компьютера, независимо от количества процессоров и от состояния кэш-буфера процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1113">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="546fd-1114">Последнее значение, записанное в поле любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1114">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1115"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1115"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1116">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1116">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1117">В многопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> получает самое последнее значение, записанное в область памяти любым процессором.</span><span class="sxs-lookup"><span data-stu-id="546fd-1117">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="546fd-1118">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1118">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1119">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1119">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1120">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1120">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1121">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1121">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1122">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1122">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1123">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1123">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="546fd-1124">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1124">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : byte * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Byte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1125">Поле, в которое требуется записать значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1125">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="546fd-1126">Записываемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1126">The value to be written.</span></span></param>
        <summary><span data-ttu-id="546fd-1127">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1127">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1128"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1128"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1129">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1129">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1130">В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение, записанное в место в памяти, сразу становится видимым для всех процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1130">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="546fd-1131">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1131">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1132">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1132">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1133">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1133">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1134">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1134">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1135">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1135">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1136">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1136">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : double * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1137">Поле, в которое требуется записать значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1137">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="546fd-1138">Записываемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1138">The value to be written.</span></span></param>
        <summary><span data-ttu-id="546fd-1139">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1139">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1140"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1140"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1141">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1141">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1142">В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение, записанное в место в памяти, сразу становится видимым для всех процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1142">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="546fd-1143">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1143">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1144">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1144">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1145">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1145">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1146">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1146">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1147">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1147">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1148">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1148">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int16 * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Int16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1149">Поле, в которое требуется записать значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1149">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="546fd-1150">Записываемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1150">The value to be written.</span></span></param>
        <summary><span data-ttu-id="546fd-1151">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1151">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1152"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1152"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1153">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1153">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1154">В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение, записанное в место в памяти, сразу становится видимым для всех процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1154">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="546fd-1155">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1155">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1156">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1156">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1157">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1157">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1158">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1158">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1159">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1159">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1160">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1160">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1161">Поле, в которое требуется записать значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1161">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="546fd-1162">Записываемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1162">The value to be written.</span></span></param>
        <summary><span data-ttu-id="546fd-1163">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1163">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1164"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1164"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1165">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1165">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1166">В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение, записанное в место в памяти, сразу становится видимым для всех процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1166">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="546fd-1167">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1167">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1168">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1168">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1169">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1169">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1170">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1170">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1171">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1171">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1172">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1172">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : int64 * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1173">Поле, в которое требуется записать значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1173">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="546fd-1174">Записываемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1174">The value to be written.</span></span></param>
        <summary><span data-ttu-id="546fd-1175">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1175">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1176"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1176"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1177">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1177">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1178">В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение, записанное в место в памяти, сразу становится видимым для всех процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1178">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="546fd-1179">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1179">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1180">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1180">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1181">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1181">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1182">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1182">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1183">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1183">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1184">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1184">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : nativeint * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.IntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1185">Поле, в которое требуется записать значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1185">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="546fd-1186">Записываемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1186">The value to be written.</span></span></param>
        <summary><span data-ttu-id="546fd-1187">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1187">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1188"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1188"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1189">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1189">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1190">В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение, записанное в место в памяти, сразу становится видимым для всех процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1190">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="546fd-1191">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1191">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1192">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1192">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1193">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1193">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1194">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1194">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1195">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1195">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1196">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1196">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : obj * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1197">Поле, в которое требуется записать значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1197">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="546fd-1198">Записываемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1198">The value to be written.</span></span></param>
        <summary><span data-ttu-id="546fd-1199">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1199">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1200"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1200"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1201">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1201">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1202">В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение, записанное в место в памяти, сразу становится видимым для всех процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1202">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="546fd-1203">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1203">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1204">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1204">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1205">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1205">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1206">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1206">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1207">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1207">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1208">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1208">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : sbyte * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.SByte" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1209">Поле, в которое требуется записать значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1209">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="546fd-1210">Записываемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1210">The value to be written.</span></span></param>
        <summary><span data-ttu-id="546fd-1211">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1211">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1212"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1212"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1213">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1213">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1214">В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение, записанное в место в памяти, сразу становится видимым для всех процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1214">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="546fd-1215">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1215">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1216">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1216">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1217">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1217">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1218">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1218">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1219">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1219">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1220">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1220">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : single * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1221">Поле, в которое требуется записать значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1221">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="546fd-1222">Записываемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1222">The value to be written.</span></span></param>
        <summary><span data-ttu-id="546fd-1223">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1223">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1224"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1224"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1225">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1225">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1226">В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение, записанное в место в памяти, сразу становится видимым для всех процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1226">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="546fd-1227">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1227">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1228">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1228">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1229">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1229">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1230">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1230">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1231">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1231">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1232">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1232">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint16 * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UInt16" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1233">Поле, в которое требуется записать значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1233">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="546fd-1234">Записываемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1234">The value to be written.</span></span></param>
        <summary><span data-ttu-id="546fd-1235">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1235">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1236"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1236"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1237">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1237">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1238">В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение, записанное в место в памяти, сразу становится видимым для всех процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1238">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="546fd-1239">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1239">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1240">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1240">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1241">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1241">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1242">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1242">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1243">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1243">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1244">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1244">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint32 * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UInt32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1245">Поле, в которое требуется записать значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1245">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="546fd-1246">Записываемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1246">The value to be written.</span></span></param>
        <summary><span data-ttu-id="546fd-1247">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1247">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1248"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1248"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1249">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1249">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1250">В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение, записанное в место в памяти, сразу становится видимым для всех процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1250">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="546fd-1251">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1251">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1252">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1252">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1253">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1253">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1254">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1254">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1255">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1255">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1256">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1256">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : uint64 * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UInt64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1257">Поле, в которое требуется записать значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1257">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="546fd-1258">Записываемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1258">The value to be written.</span></span></param>
        <summary><span data-ttu-id="546fd-1259">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1259">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1260"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1260"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1261">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1261">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1262">В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение, записанное в место в памяти, сразу становится видимым для всех процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1262">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="546fd-1263">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1263">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1264">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1264">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1265">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1265">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1266">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1266">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1267">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1267">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1268">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1268">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite : unativeint * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.UIntPtr" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="546fd-1269">Поле, в которое требуется записать значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1269">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="546fd-1270">Записываемое значение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1270">The value to be written.</span></span></param>
        <summary><span data-ttu-id="546fd-1271">Записывает значение непосредственно в поле, так что оно становится видимым для всех процессоров компьютера.</span><span class="sxs-lookup"><span data-stu-id="546fd-1271">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1272"><xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> предназначены для особых случаев синхронизации.</span><span class="sxs-lookup"><span data-stu-id="546fd-1272"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="546fd-1273">В нормальных обстоятельствах оператор C# `lock`, Visual Basic `SyncLock` и класс <xref:System.Threading.Monitor> предоставляют более простые альтернативы.</span><span class="sxs-lookup"><span data-stu-id="546fd-1273">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="546fd-1274">В многопроцессорной системе <xref:System.Threading.Thread.VolatileWrite%2A> гарантирует, что значение, записанное в место в памяти, сразу становится видимым для всех процессоров.</span><span class="sxs-lookup"><span data-stu-id="546fd-1274">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="546fd-1275">Для этого может потребоваться очистка кэша процессора.</span><span class="sxs-lookup"><span data-stu-id="546fd-1275">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="546fd-1276">Даже в однопроцессорной системе <xref:System.Threading.Thread.VolatileRead%2A> и <xref:System.Threading.Thread.VolatileWrite%2A> гарантируют, что значение считывается или записывается в память, а не кэшируется (например, в реестре процессора).</span><span class="sxs-lookup"><span data-stu-id="546fd-1276">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="546fd-1277">Поэтому их можно использовать для синхронизации доступа к полю, которое может быть обновлено другим потоком или оборудованием.</span><span class="sxs-lookup"><span data-stu-id="546fd-1277">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="546fd-1278">Вызов этого метода влияет только на доступ к одной памяти.</span><span class="sxs-lookup"><span data-stu-id="546fd-1278">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="546fd-1279">Чтобы обеспечить эффективную синхронизацию для поля, любой доступ к полю должен использовать <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1279">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="546fd-1280">В C#использование модификатора `volatile` для поля гарантирует, что все доступ к этому полю использует <xref:System.Threading.Thread.VolatileRead%2A> или <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="546fd-1280">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="546fd-1281">Позволяет вызвавшему потоку передать выполнение другому потоку, готовому к использованию на текущем процессоре.</span><span class="sxs-lookup"><span data-stu-id="546fd-1281">Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</span></span> <span data-ttu-id="546fd-1282">Операционная система выбирает, какому потоку передается выполнение.</span><span class="sxs-lookup"><span data-stu-id="546fd-1282">The operating system selects the thread to yield to.</span></span></summary>
        <returns><span data-ttu-id="546fd-1283">Значение <see langword="true" />, если операционная система переключила выполнение на другой поток, в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="546fd-1283"><see langword="true" /> if the operating system switched execution to another thread; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="546fd-1284">Если этот метод завершился с ошибкой, выдается оставшаяся часть текущего временного среза потока.</span><span class="sxs-lookup"><span data-stu-id="546fd-1284">If this method succeeds, the rest of the thread's current time slice is yielded.</span></span> <span data-ttu-id="546fd-1285">Операционная система планирует вызывающий поток для другого временного среза в соответствии с его приоритетом и состоянием других потоков, доступных для выполнения.</span><span class="sxs-lookup"><span data-stu-id="546fd-1285">The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</span></span>  
  
 <span data-ttu-id="546fd-1286">Оператор yield ограничивается процессором, выполняющим вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="546fd-1286">Yielding is limited to the processor that is executing the calling thread.</span></span> <span data-ttu-id="546fd-1287">Операционная система не будет переключать выполнение на другой процессор, даже если этот процессор бездействует или выполняет поток с более низким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="546fd-1287">The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</span></span> <span data-ttu-id="546fd-1288">Если нет других потоков, готовых к выполнению на текущем процессоре, операционная система не дает выполнения и этот метод возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="546fd-1288">If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns `false`.</span></span>  
  
 <span data-ttu-id="546fd-1289">Этот метод эквивалентен использованию вызова неуправляемого кода для вызова собственной функции Win32 `SwitchToThread`.</span><span class="sxs-lookup"><span data-stu-id="546fd-1289">This method is equivalent to using platform invoke to call the native Win32 `SwitchToThread` function.</span></span> <span data-ttu-id="546fd-1290">Следует вызвать метод <xref:System.Threading.Thread.Yield%2A> вместо использования вызова неуправляемого кода, так как вызов неуправляемого кода обходит любое пользовательское поведение потоков, запрошенное узлом.</span><span class="sxs-lookup"><span data-stu-id="546fd-1290">You should call the <xref:System.Threading.Thread.Yield%2A> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
