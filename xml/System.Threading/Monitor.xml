<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="43eb33d069ff4708c6978251697a86abcffa143c" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75116232" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет механизм для синхронизации доступа к объектам.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Класс <xref:System.Threading.Monitor> позволяет синхронизировать доступ к области кода, вызывая и освобождая блокировку конкретного объекта путем вызова методов <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>и <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>. Блокировки объектов предоставляют возможность ограничить доступ к блоку кода, обычно называемому критическим разделом. Пока поток владеет блокировкой объекта, другой поток не может получить эту блокировку. Можно также использовать класс <xref:System.Threading.Monitor>, чтобы запретить другим потокам доступ к разделу кода приложения, выполняемому владельцем блокировки, если только другой поток не выполняет код, используя другой заблокированный объект.  
  
 Содержание этой статьи  
  
 [Класс Monitor: Общие сведения](#Overview)   
 [Объект блокировки](#Lock)   
 [Критическая секция](#CriticalSection)   
 [Pulse, PulseAll и Wait](#Pulse)   
 [Мониторы и дескрипторы ожидания](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>Обзор класса Monitor.  
 <xref:System.Threading.Monitor> имеет следующие возможности.  
  
-   Он связан с объектом по требованию.  
  
-   Он не связан. Это означает, что его можно вызывать непосредственно из любого контекста.  
  
-   Не удается создать экземпляр класса <xref:System.Threading.Monitor>; методы класса <xref:System.Threading.Monitor> являются статическими. Каждому методу передается синхронизированный объект, который управляет доступом к критической секции.  
  
> [!NOTE]
>  Используйте класс <xref:System.Threading.Monitor> для блокировки объектов, отличных от строк (то есть ссылочных типов, отличных от <xref:System.String>), а не типов значений. Дополнительные сведения см. в разделе перегрузки метода <xref:System.Threading.Monitor.Enter%2A> и [объекта Lock](#Lock) далее в этой статье.  
  
 В следующей таблице описаны действия, которые могут выполняться потоками, обращающимися к синхронизированным объектам.  
  
|Действие|Описание|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|Получает блокировку для объекта. Это действие также помечает начало критического раздела. Ни один другой поток не может войти в критическую секцию, если он не будет выполнять инструкции в критическом разделе, используя другой заблокированный объект.|  
|<xref:System.Threading.Monitor.Wait%2A>|Освобождает блокировку объекта, чтобы позволить другим потокам блокировать и получать доступ к объекту. Вызывающий поток ожидает, пока другой поток пообращается к объекту. Импульсные сигналы используются для уведомления ожидающих потоков об изменениях в состоянии объекта.|  
|<xref:System.Threading.Monitor.Pulse%2A> (сигнал), <xref:System.Threading.Monitor.PulseAll%2A>|Отправляет сигнал одному или нескольким ожидающим потокам. Сигнал уведомляет ожидающий поток о том, что состояние заблокированного объекта изменилось, а владелец блокировки готов освободить блокировку. Ожидающий поток помещается в очередь готовности объекта, чтобы она могла в конечном итоге получить блокировку для объекта. После блокировки потока он может проверить новое состояние объекта, чтобы узнать, было ли достигнуто требуемое состояние.|  
|<xref:System.Threading.Monitor.Exit%2A>|Освобождает блокировку объекта. Это действие также помечает конец критической секции, защищенной заблокированным объектом.|  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]существует два набора перегрузок для методов <xref:System.Threading.Monitor.Enter%2A> и <xref:System.Threading.Monitor.TryEnter%2A>. Один набор перегрузок имеет `ref` (в C#) или `ByRef` (в Visual Basic) <xref:System.Boolean> параметр, который атомарно устанавливается в `true`, если блокировка получена, даже если при получении блокировки возникает исключение. Используйте эти перегрузки, если важно снять блокировку во всех случаях, даже если ресурсы, защищающие блокировку, могут находиться в нестабильном состоянии.  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>Объект Lock  
 Класс Monitor состоит из методов `static` (in C#) или `Shared` (в Visual Basic), которые работают с объектом, который управляет доступом к критическому разделу.  Для каждого синхронизированного объекта сохраняются следующие сведения.  
  
-   Ссылка на поток, который в настоящий момент удерживает блокировку.  
  
-   Ссылка на очередь готовности, которая содержит потоки, готовые к получению блокировки.  
  
-   Ссылка на очередь ожидания, которая содержит потоки, ожидающие уведомления об изменении состояния заблокированного объекта.  
  
 <xref:System.Threading.Monitor> блокирует объекты (то есть ссылочные типы), а не типы значений. Хотя можно передать тип значения в <xref:System.Threading.Monitor.Enter%2A> и <xref:System.Threading.Monitor.Exit%2A>, он упаковывается отдельно для каждого вызова. Поскольку при каждом вызове создается отдельный объект, <xref:System.Threading.Monitor.Enter%2A> никогда не выполняет блокировку, а код, который он предположительно защищает, на самом деле не синхронизируется. Кроме того, объект, переданный в <xref:System.Threading.Monitor.Exit%2A>, отличается от объекта, переданного в <xref:System.Threading.Monitor.Enter%2A>, поэтому <xref:System.Threading.Monitor> вызывает исключение <xref:System.Threading.SynchronizationLockException> с сообщением «Для не синхронизированного блока кода вызван метод синхронизации объектов».  
  
 Приведенный ниже пример иллюстрирует данную проблему. Он запускает десять задач, каждая из которых просто бездействует в течение 250 миллисекунд. Затем каждая задача обновляет переменную счетчика `nTasks`, который предназначен для подсчета количества фактически запущенных и выполненных задач. Поскольку `nTasks` является глобальной переменной, которая может обновляться несколькими задачами одновременно, используется монитор, защищающий ее от одновременного изменения несколькими задачами. Тем не менее, как показывают выходные данные в примере, каждая из задач вызывает исключение <xref:System.Threading.SynchronizationLockException>.  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 Каждая задача вызывает исключение <xref:System.Threading.SynchronizationLockException> из-за того, что переменная `nTasks` упаковывается перед вызовом метода <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> в каждой задаче. Другими словами, в каждый вызов метода передается отдельная переменная, которая независима от остальных. `nTasks` снова упаковывается в вызове метода <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>. И снова при этом создается десять новых упакованных переменных, которые не зависят друг от друга, `nTasks`, и десять упакованных переменных, созданных при вызове метода <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>. Затем вызывается исключение, поскольку наш код пытается снять блокировку для вновь созданной переменной, которая ранее не была заблокирована.  
  
 Хотя можно упаковать переменную типа значения перед вызовом <xref:System.Threading.Monitor.Enter%2A> и <xref:System.Threading.Monitor.Exit%2A>, как показано в следующем примере, и передать тот же упакованный объект в оба метода, такой подход не дает никаких преимуществ. Изменения неупакованной переменной не отражаются в упакованной копии, и возможность изменения значения упакованной копии отсутствует.  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 При выборе объекта для синхронизации следует блокировать только закрытые или внутренние объекты. Блокировка внешних объектов может привести к взаимоблокировкам, так как несвязанный код может выбирать те же объекты для блокировки в различных целях.  
  
 Обратите внимание, что можно выполнить синхронизацию для объекта в нескольких доменах приложений, если объект, используемый для блокировки, является производным от <xref:System.MarshalByRefObject>.  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>Критическая секция  
 Используйте методы <xref:System.Threading.Monitor.Enter%2A> и <xref:System.Threading.Monitor.Exit%2A>, чтобы пометить начало и конец критического раздела.  
  
> [!NOTE]
>  Функциональные возможности, предоставляемые методами <xref:System.Threading.Monitor.Enter%2A> и <xref:System.Threading.Monitor.Exit%2A>, идентичны инструкциям, предоставляемым [](~/docs/csharp/language-reference/keywords/lock-statement.md) оператором lock C# в, и оператором [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) в Visual Basic, за исключением того, что языковые конструкции заключают перегрузку метода <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> и метод <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> в `try`...`finally` , чтобы убедиться, что монитор освобожден.  
  
 Если критическая секция является набором смежных инструкций, то блокировка, полученная методом <xref:System.Threading.Monitor.Enter%2A>, гарантирует, что только один поток сможет выполнить вложенный код с заблокированным объектом. В этом случае рекомендуется поместить этот код в блок `try` и поместить вызов метода <xref:System.Threading.Monitor.Exit%2A> в блоке `finally`. Это гарантирует снятие блокировки даже при возникновении исключения. Этот шаблон показан в следующем фрагменте кода.  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 Это средство обычно используется для синхронизации доступа к статическому методу или экземпляру класса.  
  
 Если критическая секция охватывает весь метод, механизм блокировки можно достичь, поместив <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> в метод и указав значение <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> в конструкторе <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>. При использовании этого атрибута вызовы методов <xref:System.Threading.Monitor.Enter%2A> и <xref:System.Threading.Monitor.Exit%2A> не требуются. Этот шаблон показан в следующем фрагменте кода:  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 Обратите внимание, что атрибут заставляет текущий поток удерживать блокировку до тех пор, пока метод не вернет значение. Если блокировку можно снять раньше, используйте класс <xref:System.Threading.Monitor>, C# оператор [Lock](~/docs/csharp/language-reference/keywords/lock-statement.md) или оператор Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) внутри метода, а не атрибута.  
  
 Хотя можно использовать операторы <xref:System.Threading.Monitor.Enter%2A> и <xref:System.Threading.Monitor.Exit%2A>, которые блокируют и выпускают заданный объект для перекрестных элементов или границ класса или и того, и другого, такой подход не рекомендуется.  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Pulse, PulseAll и Wait  
 После того как поток владеет блокировкой и вошел в критический раздел, который защищается блокировкой, он может вызывать методы <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>и <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>.  
  
 Когда поток, содержащий вызовы блокировки, <xref:System.Threading.Monitor.Wait%2A>, блокировка снимается и поток добавляется в очередь ожидания синхронизированного объекта. Первый поток в очереди готовности, если таковой имеется, получает блокировку и вводит критическую секцию. Поток, который вызывал <xref:System.Threading.Monitor.Wait%2A>, перемещается из очереди ожидания в очередь готовности, <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> когда поток, в котором находится блокировка (для перемещения), вызывается потоком, содержащим блокировку (которую нужно переместить, поток должен находиться в заголовке очереди ожидания). Метод <xref:System.Threading.Monitor.Wait%2A> возвращает, когда вызывающий поток снова получает блокировку.  
  
 Когда поток, содержащий вызовы блокировки, <xref:System.Threading.Monitor.Pulse%2A>, поток в заголовке очереди ожидания перемещается в очередь готовности. Вызов метода <xref:System.Threading.Monitor.PulseAll%2A> перемещает все потоки из очереди ожидания в очередь готовности.  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>Мониторы и дескрипторы ожидания  
 Важно отметить различие между использованием класса <xref:System.Threading.Monitor> и <xref:System.Threading.WaitHandle> объектов.  
  
-   Класс <xref:System.Threading.Monitor> полностью управляемым, полным переносимым и может быть более эффективным с точки зрения требований к ресурсам операционной системы.  
  
-   Объекты <xref:System.Threading.WaitHandle> представляют объекты ожидания операционной системы, удобны для синхронизации между управляемым и неуправляемым кодом и предоставляют некоторые расширенные функции операционной системы, например возможность ожидания сразу нескольких объектов.  
  
   
  
## Examples  
 В следующем примере класс <xref:System.Threading.Monitor> используется для синхронизации доступа к одному экземпляру генератора случайных чисел, представленного классом <xref:System.Random>. В примере создается десять задач, каждый из которых асинхронно выполняется в потоке пула потоков. Каждая задача создает 10 000 случайных чисел, вычисляет их среднее значение и обновляет две переменные уровня процедуры, которые сохраняют общую сумму количества созданных случайных чисел и их сумму. После выполнения всех задач эти два значения затем используются для вычисления общего значения.  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 Так как к ним можно получить доступ из любой задачи, выполняющейся в потоке пула потоков, доступ к переменным `total` и `n` также должен быть синхронизирован. Для этой цели используется метод <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType>.  
  
 В следующем примере демонстрируется комбинированное использование класса <xref:System.Threading.Monitor> (реализованного с помощью `lock` или конструкции языка `SyncLock`), класса <xref:System.Threading.Interlocked> и класса <xref:System.Threading.AutoResetEvent>. Он определяет два класса `internal` (в C#) или `Friend` (в Visual Basic), `SyncResource` и `UnSyncResource`, которые соответственно предоставляют синхронизированный и несинхронизированный доступ к ресурсу. Чтобы обеспечить демонстрацию в примере различия между синхронизированным и несинхронизированным доступом (что может случиться, если каждый вызов метода завершается быстро), метод включает случайную задержку: для потоков, свойство <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> которых имеет четное значение, метод вызывает <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> для введения задержки в 2 000 миллисекунд. Обратите внимание, что поскольку класс `SyncResource` не является общим, ни один клиентский код не выполняет блокировку в синхронизированном ресурсе; внутренний класс сам выполняет блокировку. Это предотвращает блокировка общедоступного объекта вредоносным кодом.  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 В примере определяется переменная `numOps`, задающая число потоков, которые будут пытаться получить доступ к ресурсу. Поток приложения вызывает метод <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> для синхронизированного и несинхронизированного доступа по пять раз. Метод <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> имеет единственный параметр, делегат, который не принимает никаких параметров и не возвращает значений. Для синхронизированного доступа он вызывает метод `SyncUpdateResource`; для несинхронизированного доступа он вызывает метод `UnSyncUpdateResource`. После каждого набора вызовов метода поток приложения вызывает метод [AutoResetEvent. WaitOne](xref:System.Threading.WaitHandle.WaitOne*) , чтобы он блокировался до получения сигнала от экземпляра <xref:System.Threading.AutoResetEvent>.  
  
 Каждый вызов метода `SyncUpdateResource` вызывает внутренний метод `SyncResource.Access`, а затем вызывает метод <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> для уменьшения счетчика `numOps`. Метод <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> используется для уменьшения счетчика, так как в противном случае не может быть уверенности, что второй поток будет обращаться к значению до того, как в переменной было сохранено значение первого потока. Когда последний синхронизированный рабочий поток уменьшает счетчик до нуля, указывая на то, что все синхронизированные потоки завершили доступ к ресурсу, метод `SyncUpdateResource` вызывает метод <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>, который сигнализирует основному потоку продолжить выполнение.  
  
 Каждый вызов метода `UnSyncUpdateResource` вызывает внутренний метод `UnSyncResource.Access`, а затем вызывает метод <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> для уменьшения счетчика `numOps`. Опять же, метод <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> используется для уменьшения счетчика, чтобы второй поток не получил доступа к значению до того, как переменной будет присвоено уменьшенное значение первого потока. Когда последний несинхронизированный рабочий поток уменьшает значение счетчика до нуля, указывая на то, что больше несинхронизированных потоков не требуется доступ к ресурсу, метод `UnSyncUpdateResource` вызывает метод <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>, который сигнализирует основному потоку продолжить выполнение.  
  
 Как показывает результат этого примера, синхронизированный доступ обеспечивает, что вызывающий поток выходит из защищенного ресурса до того, как другой поток получит доступ к этому ресурсу; каждый поток ожидает своего предшественника. С другой стороны, без блокировки метод `UnSyncResource.Access` вызывается в том порядке, в котором потоки получают к нему доступ.  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">Объекты и функциональные возможности работы с потоками</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает монопольную блокировку указанного объекта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, для которого получается блокировка монитора.</param>
        <summary>Получает эксклюзивную блокировку указанного объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `Enter`, чтобы получить <xref:System.Threading.Monitor> объекта, переданного в качестве параметра. Если другой поток выполнил `Enter` для объекта, но еще не выполнил соответствующий <xref:System.Threading.Monitor.Exit%2A>, текущий поток будет заблокирован до тех пор, пока другой поток не освободит объект. Допустимо, чтобы один и тот же поток вызывал `Enter` несколько раз без блокировки. Тем не менее, необходимо вызвать равное количество вызовов `Exit`, прежде чем другие потоки, ожидающие объекта, будут разблокированы.  
  
 Используйте <xref:System.Threading.Monitor> для блокировки объектов (то есть ссылочных типов), а не типов значений. При передаче переменной типа значения в `Enter`она упаковывается как объект. Если вы передаете ту же переменную в `Enter` снова, она упаковывается как отдельный объект, а поток не блокируется. В этом случае код, который `Monitor` предполагается защищать, не защищен. Более того, при передаче переменной в `Exit`создается еще один отдельный объект. Так как объект, переданный в `Exit`, отличается от объекта, переданного в `Enter`, `Monitor` вызывает <xref:System.Threading.SynchronizationLockException>. Дополнительные сведения см. в разделе « [мониторы](xref:System.Threading.Monitor)».  
  
 <xref:System.Threading.Thread.Interrupt%2A> может прерывать потоки, ожидающие ввода `Monitor` для объекта. Будет выдано исключение <xref:System.Threading.ThreadInterruptedException>.  
  
 Использовать C# `try`...`finally` блок (`Try`...`Finally` в Visual Basic) убедитесь, что вы выпустите монитор, или используйте инструкцию C# `lock` (`SyncLock` в Visual Basic), которая упаковывает методы <xref:System.Threading.Monitor.Enter%2A> и <xref:System.Threading.Monitor.Exit%2A> в `try`...`finally` блок.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Enter`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj * bool -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, в котором следует ожидать.</param>
        <param name="lockTaken">Результат попытки получить блокировку, переданную по ссылке. Входное значение должно равняться <see langword="false" />. Выходное значение <see langword="true" />, если блокировка получена; в противном случае — выходное значение <see langword="false" />. Выходное значение задается, даже если при попытке получить блокировку возникает исключение.  
  
Примечание. Если исключение не возникает, выходное значение этого метода всегда равно <see langword="true" />.</param>
        <summary>Получает монопольную блокировку указанного объекта и единым блоком задает значение, указывающее, была ли выполнена блокировка.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `Enter`, чтобы получить <xref:System.Threading.Monitor> объекта, переданного в качестве параметра `obj`. Если другой поток выполнил `Enter` для объекта, но еще не выполнил соответствующий <xref:System.Threading.Monitor.Exit%2A>, текущий поток будет заблокирован до тех пор, пока другой поток не освободит объект. Допустимо, чтобы один и тот же поток вызывал `Enter` несколько раз без блокировки. Тем не менее, необходимо вызвать равное количество вызовов `Exit`, прежде чем другие потоки, ожидающие объекта, будут разблокированы.  
  
 Если блокировка не была выполнена из-за возникновения исключения, переменная, указанная для параметра `lockTaken`, будет `false` после завершения этого метода. Это позволяет программе определить во всех случаях, требуется ли снять блокировку. Если этот метод возвращает исключение без создания исключения, то переменная, указанная для параметра `lockTaken`, всегда `true`, и нет необходимости тестировать ее.  
  
 Используйте <xref:System.Threading.Monitor> для блокировки объектов (то есть ссылочных типов), а не типов значений. При передаче переменной типа значения в `Enter`она упаковывается как объект. Если вы передаете ту же переменную в `Enter` снова, она упаковывается как отдельный объект, а поток не блокируется. В этом случае код, который `Monitor` предполагается защищать, не защищен. Кроме того, при передаче переменной в `Exit`создается другой отдельный объект. Так как объект, переданный в `Exit`, отличается от объекта, переданного в `Enter`, `Monitor` вызывает <xref:System.Threading.SynchronizationLockException>. Дополнительные сведения см. в разделе « [мониторы](xref:System.Threading.Monitor)».  
  
 <xref:System.Threading.Thread.Interrupt%2A> может прерывать потоки, ожидающие ввода `Monitor` для объекта. Будет выдано исключение <xref:System.Threading.ThreadInterruptedException>.  
  
   
  
## Examples  
 В следующем коде показан базовый шаблон для использования перегрузки метода <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>. Эта перегрузка всегда задает значение переменной, которая передается в параметр `ref` (`ByRef` в Visual Basic) `lockTaken`, даже если метод создает исключение, поэтому значение переменной является надежным способом проверить, следует ли освободить блокировку.  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Входные данные для <paramref name="lockTaken" /> — <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, блокировка которого освобождается.</param>
        <summary>Освобождает эксклюзивную блокировку указанного объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызывающий поток должен владеть блокировкой параметра `obj`. Если вызывающий поток владеет блокировкой указанного объекта и произошел равное количество `Exit` и <xref:System.Threading.Monitor.Enter%2A> вызовы для объекта, блокировка снимается. Если вызывающий поток не вызывал `Exit` столько раз, сколько `Enter`, блокировка не снимается.  
  
 Если блокировка освобождается и другие потоки находятся в очереди готовности для объекта, один из потоков получает блокировку. Если другие потоки находятся в очереди ожидания, ожидающей получения блокировки, они не перемещаются автоматически в очередь готовности, когда владелец блокировки вызывает `Exit`. Чтобы переместить один или несколько ожидающих потоков в очередь готовности, вызовите <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A> перед вызовом `Exit`.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Exit`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Данный поток не владеет блокировкой для указанного объекта.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для тестирования.</param>
        <summary>Определяет, содержит ли текущий поток блокировку указанного объекта.</summary>
        <returns>Значение <see langword="true" />, если текущий поток владеет блокировкой в <paramref name="obj" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод работает только для блокировок, полученных с помощью методов класса <xref:System.Threading.Monitor> или с помощью инструкции C# `lock` или инструкции Visual Basic `SyncLock`, которые реализуются с помощью <xref:System.Threading.Monitor>.  
  
 Используйте этот метод со средствами диагностики, такими как метод <xref:System.Diagnostics.Debug.Assert%2A> и класс <xref:System.Diagnostics.Contracts.Contract>, для отладки проблем блокировки, в которых участвует класс <xref:System.Threading.Monitor>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LockContentionCount">
      <MemberSignature Language="C#" Value="public static long LockContentionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 LockContentionCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Monitor.LockContentionCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LockContentionCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long LockContentionCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LockContentionCount : int64" Usage="System.Threading.Monitor.LockContentionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, сколько раз возникало состязание при попытке установить блокировку монитора.</summary>
        <value>Количество конфликтов при попытке снятия блокировки монитора.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, ожидаемый потоком.</param>
        <summary>Уведомляет поток в очереди готовности об изменении состояния объекта с блокировкой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Только текущий владелец блокировки может передать сигнал ожидающему объекту с помощью `Pulse`.  
  
 Поток, который в настоящее время владеет блокировкой указанного объекта, вызывает этот метод, чтобы передать следующий поток в строке для блокировки. При получении пульса ожидающий поток перемещается в очередь готовности. Когда поток, вызвавший `Pulse`, освобождает блокировку, следующий поток в очереди готовности (который не обязательно является потоком, который был импульсным) получает блокировку.  
  
> [!IMPORTANT]
>  Класс <xref:System.Threading.Monitor> не сохраняет состояние, указывающее, что был вызван метод <xref:System.Threading.Monitor.Pulse%2A>. Таким образом, при вызове <xref:System.Threading.Monitor.Pulse%2A>, когда потоки не ожидают ожидания, следующий поток, вызывающий <xref:System.Threading.Monitor.Wait%2A> блоки, как если бы <xref:System.Threading.Monitor.Pulse%2A> никогда не вызывался. Если два потока используют <xref:System.Threading.Monitor.Pulse%2A> и <xref:System.Threading.Monitor.Wait%2A> для взаимодействия, это может привести к взаимоблокировке. Сравните это с поведением класса <xref:System.Threading.AutoResetEvent>: Если вы сообщаете <xref:System.Threading.AutoResetEvent>, вызвав его метод <xref:System.Threading.EventWaitHandle.Set%2A> и не ожидаете потоков, <xref:System.Threading.AutoResetEvent> остается в сигнальном состоянии до тех пор, пока поток не вызовет <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>или <xref:System.Threading.WaitHandle.WaitAll%2A>. <xref:System.Threading.AutoResetEvent> освобождает этот поток и возвращается в несигнальное состояние.  
  
 Обратите внимание, что синхронизированный объект содержит несколько ссылок, включая ссылку на поток, который в настоящее время владеет блокировкой, ссылку на очередь готовности, которая содержит потоки, готовые к получению блокировки, и ссылку на очередь ожидания, которая содержит потоки, ожидающие уведомления об изменении состояния объекта.  
  
 Методы `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>и <xref:System.Threading.Monitor.Wait%2A> должны вызываться из синхронизированного блока кода.  
  
 Чтобы сообщить о нескольких потоках, используйте метод <xref:System.Threading.Monitor.PulseAll%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, посылающий импульс.</param>
        <summary>Уведомляет все ожидающие потоки об изменении состояния объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток, которому в настоящее время принадлежит блокировка указанного объекта, вызывает этот метод, чтобы сообщить всем потокам, ожидающим получения блокировки объекта. После отправки сигнала ожидающие потоки перемещаются в очередь готовности. Когда поток, вызвавший `PulseAll`, освобождает блокировку, следующий поток в очереди готовности получает блокировку.  
  
 Обратите внимание, что синхронизированный объект содержит несколько ссылок, включая ссылку на поток, который в настоящее время владеет блокировкой, ссылку на очередь готовности, которая содержит потоки, готовые к получению блокировки, и ссылку на очередь ожидания, которая содержит потоки, ожидающие уведомления об изменении состояния объекта.  
  
 Методы <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`и <xref:System.Threading.Monitor.Wait%2A> должны вызываться из синхронизированного блока кода.  
  
 Примечания для метода <xref:System.Threading.Monitor.Pulse%2A> объяснит, что происходит, если <xref:System.Threading.Monitor.Pulse%2A> вызывается, когда потоки не ожидают ожидания.  
  
 Чтобы передать сигнал одному потоку, используйте метод `Pulse`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Пытается получить эксклюзивную блокировку указанного объекта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, блокировка которого получается.</param>
        <summary>Пытается получить эксклюзивную блокировку указанного объекта.</summary>
        <returns>Значение <see langword="true" />, если текущий поток получает блокировку; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В случае успешного выполнения этот метод получает монопольную блокировку на параметр `obj`. Этот метод немедленно возвращает значение, независимо от того, доступна ли блокировка.  
  
 Этот метод аналогичен <xref:System.Threading.Monitor.Enter%2A>, но он никогда не блокирует текущий поток. Если поток не может выполнить вход без блокировки, метод возвращает `false,`.  
  
> [!NOTE]
>  Используйте <xref:System.Threading.Monitor> для блокировки объектов (то есть ссылочных типов), а не типов значений. Дополнительные сведения см. в <xref:System.Threading.Monitor> статье.  
  
 Чтобы убедиться, что поток не входит в критическую секцию, следует изучить возвращаемое значение метода и выполнить код в критическом разделе, только если его возвращаемое значение равно `true`. В следующем фрагменте кода показан шаблон, используемый для вызова этого метода. Обратите внимание, что следует вызвать <xref:System.Threading.Monitor.Exit%2A> в блоке `finally`, чтобы вызывающий поток выпустил свою блокировку в критическом разделе, если возникает исключение.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 В следующем примере кода показано, как использовать метод `TryEnter`.  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, блокировка которого получается.</param>
        <param name="lockTaken">Результат попытки получить блокировку, переданную по ссылке. Входное значение должно равняться <see langword="false" />. Выходное значение <see langword="true" />, если блокировка получена; в противном случае — выходное значение <see langword="false" />. Выходное значение задается, даже если при попытке получить блокировку возникает исключение.</param>
        <summary>Пытается получить монопольную блокировку указанного объекта и единым блоком задает значение, указывающее, была ли выполнена блокировка.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В случае успешного выполнения этот метод получает монопольную блокировку на параметр `obj`. Этот метод немедленно возвращает значение, независимо от того, доступна ли блокировка.  
  
 Если блокировка не была выполнена из-за возникновения исключения, переменная, указанная для параметра `lockTaken`, будет `false` после завершения этого метода. Это позволяет программе определить во всех случаях, требуется ли снять блокировку.  
  
 Этот метод аналогичен <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, но он никогда не блокирует текущий поток. Если поток не может выполнить вход без блокировки, для аргумента `lockTaken` задается значение `false`, когда метод возвращает значение.  
  
> [!NOTE]
>  Используйте <xref:System.Threading.Monitor> для блокировки объектов (то есть ссылочных типов), а не типов значений. Дополнительные сведения см. в <xref:System.Threading.Monitor> статье.  
  
 Чтобы убедиться, что поток не входит в критическую секцию, следует проверить значение `lockTaken` и выполнить код в критическом разделе, только если его значение равно `true`. В следующем фрагменте кода показан шаблон, используемый для вызова этого метода. Обратите внимание, что следует вызвать <xref:System.Threading.Monitor.Exit%2A> в блоке `finally`, чтобы вызывающий поток выпустил свою блокировку в критическом разделе, если возникает исключение.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 В следующем коде показан базовый шаблон для использования перегрузки метода <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>. Эта перегрузка всегда задает значение переменной, которая передается в параметр `ref` (`ByRef` в Visual Basic) `lockTaken`, даже если метод создает исключение, поэтому значение переменной является надежным способом проверить, следует ли освободить блокировку.  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Входные данные для <paramref name="lockTaken" /> — <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, блокировка которого получается.</param>
        <param name="millisecondsTimeout">Количество миллисекунд, в течение которых ожидать блокировку.</param>
        <summary>Пытается получить эксклюзивную блокировку указанного объекта на заданное количество миллисекунд.</summary>
        <returns>Значение <see langword="true" />, если текущий поток получает блокировку; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если параметр `millisecondsTimeout` равен <xref:System.Threading.Timeout.Infinite>, этот метод эквивалентен <xref:System.Threading.Monitor.Enter%2A>. Если `millisecondsTimeout` равно 0, этот метод эквивалентен <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Используйте <xref:System.Threading.Monitor> для блокировки объектов (то есть ссылочных типов), а не типов значений. Дополнительные сведения см. в <xref:System.Threading.Monitor> статье.  
  
 Чтобы убедиться, что поток не входит в критическую секцию, следует изучить возвращаемое значение метода и выполнить код в критическом разделе, только если его возвращаемое значение равно `true`. В следующем фрагменте кода показан шаблон, используемый для вызова этого метода. Обратите внимание, что следует вызвать <xref:System.Threading.Monitor.Exit%2A> в блоке `finally`, чтобы вызывающий поток выпустил свою блокировку в критическом разделе, если возникает исключение.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> является отрицательным числом и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, блокировка которого получается.</param>
        <param name="timeout">Класс <see cref="T:System.TimeSpan" />, представляющий количество времени, в течение которого ожидается блокировка. Значение –1 миллисекунды обозначает бесконечное ожидание.</param>
        <summary>Пытается получить эксклюзивную блокировку указанного объекта в течение заданного количества времени.</summary>
        <returns>Значение <see langword="true" />, если текущий поток получает блокировку; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение параметра `timeout`, преобразованное в миллисекунды, равно-1, этот метод эквивалентен <xref:System.Threading.Monitor.Enter%2A>. Если значение `timeout` равно 0, этот метод эквивалентен <xref:System.Threading.Monitor.TryEnter%2A>.  
  
> [!NOTE]
>  Используйте <xref:System.Threading.Monitor> для блокировки объектов (то есть ссылочных типов), а не типов значений. Дополнительные сведения см. в разделе <xref:System.Threading.Monitor> Class.  
  
 Чтобы убедиться, что поток не входит в критическую секцию, следует изучить возвращаемое значение метода и выполнить код в критическом разделе, только если его возвращаемое значение равно `true`. В следующем фрагменте кода показан шаблон, используемый для вызова этого метода. Обратите внимание, что следует вызвать <xref:System.Threading.Monitor.Exit%2A> в блоке `finally`, чтобы вызывающий поток выпустил свою блокировку в критическом разделе, если возникает исключение.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="timeout" /> в миллисекундах отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (–1 миллисекунда) или больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, блокировка которого получается.</param>
        <param name="millisecondsTimeout">Количество миллисекунд, в течение которых ожидать блокировку.</param>
        <param name="lockTaken">Результат попытки получить блокировку, переданную по ссылке. Входное значение должно равняться <see langword="false" />. Выходное значение <see langword="true" />, если блокировка получена; в противном случае — выходное значение <see langword="false" />. Выходное значение задается, даже если при попытке получить блокировку возникает исключение.</param>
        <summary>В течение заданного количества миллисекунд пытается получить монопольную блокировку указанного объекта и единым блоком задает значение, указывающее, была ли выполнена блокировка.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если параметр `millisecondsTimeout` равен <xref:System.Threading.Timeout.Infinite>, этот метод эквивалентен <xref:System.Threading.Monitor.Enter%28System.Object%29>. Если `millisecondsTimeout` равно 0, этот метод эквивалентен <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Если блокировка не была выполнена из-за возникновения исключения, переменная, указанная для параметра `lockTaken`, будет `false` после завершения этого метода. Это позволяет программе определить во всех случаях, требуется ли снять блокировку.  
  
> [!NOTE]
>  Используйте <xref:System.Threading.Monitor> для блокировки объектов (то есть ссылочных типов), а не типов значений. Дополнительные сведения см. в разделе <xref:System.Threading.Monitor> Class.  
  
 Чтобы убедиться, что поток не входит в критическую секцию, следует проверить значение `lockTaken` и выполнить код в критическом разделе, только если его значение равно `true`. В следующем фрагменте кода показан шаблон, используемый для вызова этого метода. Обратите внимание, что следует вызвать <xref:System.Threading.Monitor.Exit%2A> в блоке `finally`, чтобы вызывающий поток выпустил свою блокировку в критическом разделе, если возникает исключение.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 В следующем коде показан базовый шаблон для использования перегрузки метода <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>. Эта перегрузка всегда задает значение переменной, которая передается в параметр `ref` (`ByRef` в Visual Basic) `lockTaken`, даже если метод создает исключение, поэтому значение переменной является надежным способом проверить, следует ли освободить блокировку.  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Входные данные для <paramref name="lockTaken" /> — <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> является отрицательным числом и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan * bool -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, блокировка которого получается.</param>
        <param name="timeout">Период времени, в течение которого ожидается блокировка. Значение –1 миллисекунды обозначает бесконечное ожидание.</param>
        <param name="lockTaken">Результат попытки получить блокировку, переданную по ссылке. Входное значение должно равняться <see langword="false" />. Выходное значение <see langword="true" />, если блокировка получена; в противном случае — выходное значение <see langword="false" />. Выходное значение задается, даже если при попытке получить блокировку возникает исключение.</param>
        <summary>В течение заданного периода времени пытается получить монопольную блокировку указанного объекта и единым блоком задает значение, указывающее, была ли выполнена блокировка.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение параметра `timeout`, преобразованное в миллисекунды, равно-1, этот метод эквивалентен <xref:System.Threading.Monitor.Enter%28System.Object%29>. Если значение `timeout` равно 0, этот метод эквивалентен <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  
  
 Если блокировка не была выполнена из-за возникновения исключения, переменная, указанная для параметра `lockTaken`, будет `false` после завершения этого метода. Это позволяет программе определить во всех случаях, требуется ли снять блокировку.  
  
> [!NOTE]
>  Используйте <xref:System.Threading.Monitor> для блокировки объектов (то есть ссылочных типов), а не типов значений. Дополнительные сведения см. в разделе <xref:System.Threading.Monitor> Class.  
  
 Чтобы убедиться, что поток не входит в критическую секцию, следует проверить значение `lockTaken` и выполнить код в критическом разделе, только если его значение равно `true`. В следующем фрагменте кода показан шаблон, используемый для вызова этого метода. Обратите внимание, что следует вызвать <xref:System.Threading.Monitor.Exit%2A> в блоке `finally`, чтобы вызывающий поток выпустил свою блокировку в критическом разделе, если возникает исключение.  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Входные данные для <paramref name="lockTaken" /> — <see langword="true" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="timeout" /> в миллисекундах отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (–1 миллисекунда) или больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, в котором следует ожидать.</param>
        <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова.</summary>
        <returns>Значение <see langword="true" />, если вызов осуществил возврат из-за того, что вызывающий поток заново получил блокировку заданного объекта. Этот метод не осуществляет возврат, если блокировка вновь не получена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток, который в настоящее время владеет блокировкой указанного объекта, вызывает этот метод, чтобы освободить объект, чтобы другой поток мог получить к нему доступ. Вызывающий объект блокируется при ожидании повторного получения блокировки. Этот метод вызывается, когда вызывающему объекту требуется подождать изменения состояния, которое будет происходить в результате операций другого потока.  
  
 Когда поток вызывает `Wait`, он освобождает блокировку объекта и переходит в очередь ожидания объекта. Следующий поток в очереди готовности объекта (если таковой имеется) получает блокировку и эксклюзивное использование объекта. Все потоки, вызывающие `Wait`, остаются в очереди ожидания до получения сигнала от <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A>, отправленного владельцем блокировки. При отправке `Pulse` затрагивается только поток в заголовке очереди ожидания. При отправке `PulseAll` затрагиваются все потоки, ожидающие объекта. При получении сигнала один или несколько потоков покидают очередь ожидания и наведите очередь готовности. Потоку в очереди готовности разрешено повторное получение блокировки.  
  
 Этот метод возвращает значение, если вызывающий поток повторно запрашивает блокировку объекта. Обратите внимание, что этот метод блокируется на неопределенное время, если владелец блокировки не вызывает `Pulse` или `PulseAll`.  
  
 Вызывающий объект выполняется `Wait` один раз, независимо от того, сколько раз было вызвано <xref:System.Threading.Monitor.Enter%2A> для указанного объекта. По сути, метод `Wait` сохраняет количество вызовов `Enter`, вызванных вызывающим объектом, и вызывает `Exit` столько раз, сколько необходимо для полного освобождения заблокированного объекта. Затем вызывающий объект блокируется при ожидании повторного получения объекта. Когда вызывающий объект повторно получает блокировку, система вызывает `Enter` столько раз, сколько необходимо для восстановления сохраненного количества `Enter` для вызывающего. Вызов `Wait` освобождает блокировку только для указанного объекта; Если вызывающий объект является владельцем блокировок на других объектах, эти блокировки не освобождаются.  
  
 Обратите внимание, что синхронизированный объект содержит несколько ссылок, включая ссылку на поток, который в настоящее время владеет блокировкой, ссылку на очередь готовности, которая содержит потоки, готовые к получению блокировки, и ссылку на очередь ожидания, которая содержит потоки, ожидающие уведомления об изменении состояния объекта.  
  
 Методы <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>и `Wait` должны вызываться из синхронизированного блока кода.  
  
 Примечания для метода <xref:System.Threading.Monitor.Pulse%2A> объяснит, что происходит, если <xref:System.Threading.Monitor.Pulse%2A> вызывается, когда потоки не ожидают ожидания.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Поток, который вызывает <see langword="Wait" />, позже прерывается из состояния ожидания. Это происходит, когда другой поток вызывает метод <see cref="M:System.Threading.Thread.Interrupt" /> этого потока.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, в котором следует ожидать.</param>
        <param name="millisecondsTimeout">Количество миллисекунд для ожидания постановки в очередь готовности.</param>
        <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова. Если указанные временные интервалы истекают, поток встает в очередь готовности.</summary>
        <returns>Значение <see langword="true" />, если блокировка была получена заново до истечения заданного времени; значение <see langword="false" />, если блокировка была получена заново по истечении заданного времени. Этот метод не осуществляет возврат, если блокировка не была получена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не возвращает значение до тех пор, пока не будет получен монопольный замок на параметр `obj`.  
  
 Поток, который в настоящее время владеет блокировкой указанного объекта, вызывает этот метод, чтобы освободить объект, чтобы другой поток мог получить к нему доступ. Вызывающий объект блокируется при ожидании повторного получения блокировки. Этот метод вызывается, когда вызывающему объекту требуется подождать изменения состояния, которое будет происходить в результате операций другого потока.  
  
 Время ожидания гарантирует, что текущий поток не блокируется в течение неограниченного времени, если другой поток освобождает блокировку без предварительного вызова метода <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A>. Он также перемещает поток в очередь готовности, обходя другие потоки перед ним в очереди ожидания, чтобы он мог повторно получить блокировку. Поток может проверить возвращаемое значение метода <xref:System.Threading.Monitor.Wait%2A>, чтобы определить, был ли он получен повторно до истечения времени ожидания. Поток может оценить условия, вызвавшие его, чтобы войти в ожидание, и при необходимости снова вызвать метод <xref:System.Threading.Monitor.Wait%2A>.  
  
 Когда поток вызывает `Wait`, он освобождает блокировку объекта и переходит в очередь ожидания объекта. Следующий поток в очереди готовности объекта (если таковой имеется) получает блокировку и эксклюзивное использование объекта. Поток, вызвавший `Wait`, остается в очереди ожидания до тех пор, пока поток, владеющий блокировкой, не <xref:System.Threading.Monitor.PulseAll%2A>или не является следующим в очереди и потоком, который удерживает блокировку, <xref:System.Threading.Monitor.Pulse%2A>. Однако если `millisecondsTimeout` истекает до того, как другой поток вызовет метод <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A> этого объекта, исходный поток перемещается в очередь готовности для восстановления блокировки.  
  
> [!NOTE]
>  Если для параметра `millisecondsTimeout` задано <xref:System.Threading.Timeout.Infinite>, этот метод блокируется неопределенно долго, только если владелец блокировки не вызывает <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A>. Если `millisecondsTimeout` равно 0, то поток, который вызывает `Wait`, освобождает блокировку, а затем сразу же входит в очередь готовности, чтобы восстановить блокировку.  
  
 Вызывающий объект выполняется `Wait` один раз, независимо от того, сколько раз было вызвано <xref:System.Threading.Monitor.Enter%2A> для указанного объекта. По сути, метод `Wait` сохраняет количество вызовов <xref:System.Threading.Monitor.Enter%2A>, вызванных вызывающим объектом, и вызывает <xref:System.Threading.Monitor.Exit%2A> столько раз, сколько необходимо для полного освобождения заблокированного объекта. Затем вызывающий объект блокируется при ожидании повторного получения объекта. Когда вызывающий объект повторно получает блокировку, система вызывает <xref:System.Threading.Monitor.Enter%2A> столько раз, сколько необходимо для восстановления сохраненного количества <xref:System.Threading.Monitor.Enter%2A> для вызывающего. Вызов `Wait` освобождает блокировку только для указанного объекта; Если вызывающий объект является владельцем блокировок на других объектах, эти блокировки не освобождаются.  
  
> [!NOTE]
>  Синхронизированный объект содержит несколько ссылок, включая ссылку на поток, который в настоящее время владеет блокировкой, ссылку на очередь готовности, которая содержит потоки, готовые к получению блокировки, и ссылку на очередь ожидания, которая содержит потоки, ожидающие уведомления об изменении состояния объекта.  
  
 Методы <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>и `Wait` должны вызываться из синхронизированного блока кода.  
  
 Примечания для метода <xref:System.Threading.Monitor.Pulse%2A> объяснит, что происходит, если <xref:System.Threading.Monitor.Pulse%2A> вызывается, когда потоки не ожидают ожидания.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Поток, который вызывает <see langword="Wait" />, позже прерывается из состояния ожидания. Это происходит, когда другой поток вызывает метод <see cref="M:System.Threading.Thread.Interrupt" /> этого потока.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, в котором следует ожидать.</param>
        <param name="timeout">Класс <see cref="T:System.TimeSpan" />, представляющий количество времени, до истечения которого поток поступает в очередь ожидания.</param>
        <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова. Если указанные временные интервалы истекают, поток встает в очередь готовности.</summary>
        <returns>Значение <see langword="true" />, если блокировка была получена заново до истечения заданного времени; значение <see langword="false" />, если блокировка была получена заново по истечении заданного времени. Этот метод не осуществляет возврат, если блокировка не была получена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не возвращает значение до тех пор, пока не будет получен монопольный замок на параметр `obj`.  
  
 Поток, который в настоящее время владеет блокировкой указанного объекта, вызывает этот метод, чтобы освободить объект, чтобы другой поток мог получить к нему доступ. Вызывающий объект блокируется при ожидании повторного получения блокировки. Этот метод вызывается, когда вызывающему объекту требуется подождать изменения состояния, которое будет происходить в результате операций другого потока.  
  
 Время ожидания гарантирует, что текущий поток не блокируется в течение неограниченного времени, если другой поток освобождает блокировку без предварительного вызова метода <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A>. Он также перемещает поток в очередь готовности, обходя другие потоки перед ним в очереди ожидания, чтобы он мог повторно получить блокировку. Поток может проверить возвращаемое значение метода <xref:System.Threading.Monitor.Wait%2A>, чтобы определить, был ли он получен повторно до истечения времени ожидания. Поток может оценить условия, вызвавшие его, чтобы войти в ожидание, и при необходимости снова вызвать метод <xref:System.Threading.Monitor.Wait%2A>.  
  
 Когда поток вызывает `Wait`, он освобождает блокировку объекта и переходит в очередь ожидания объекта. Следующий поток в очереди готовности объекта (если таковой имеется) получает блокировку и эксклюзивное использование объекта. Поток, вызвавший `Wait`, остается в очереди ожидания до тех пор, пока поток, владеющий блокировкой, не <xref:System.Threading.Monitor.PulseAll%2A>или не является следующим в очереди и потоком, который удерживает блокировку, <xref:System.Threading.Monitor.Pulse%2A>. Однако если `timeout` истекает до того, как другой поток вызовет метод <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A> этого объекта, исходный поток перемещается в очередь готовности для восстановления блокировки.  
  
> [!NOTE]
>  Если для параметра `timeout` указан <xref:System.TimeSpan>, представляющий-1 миллисекунда, этот метод блокируется неопределенно долго, только если владелец блокировки не вызывает <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A>. Если `timeout` равен 0 миллисекундам, поток, который вызывает `Wait`, освобождает блокировку, а затем сразу же входит в очередь готовности, чтобы восстановить блокировку.  
  
 Вызывающий объект выполняется `Wait` один раз, независимо от того, сколько раз было вызвано <xref:System.Threading.Monitor.Enter%2A> для указанного объекта. По сути, метод `Wait` сохраняет количество вызовов <xref:System.Threading.Monitor.Enter%2A>, вызванных вызывающим объектом, и вызывает <xref:System.Threading.Monitor.Exit%2A> столько раз, сколько необходимо для полного освобождения заблокированного объекта. Затем вызывающий объект блокируется при ожидании повторного получения объекта. Когда вызывающий объект повторно получает блокировку, система вызывает <xref:System.Threading.Monitor.Enter%2A> столько раз, сколько необходимо для восстановления сохраненного количества <xref:System.Threading.Monitor.Enter%2A> для вызывающего. Вызов `Wait` освобождает блокировку только для указанного объекта; Если вызывающий объект является владельцем блокировок на других объектах, эти блокировки не освобождаются.  
  
> [!NOTE]
>  Синхронизированный объект содержит несколько ссылок, включая ссылку на поток, который в настоящее время владеет блокировкой, ссылку на очередь готовности, которая содержит потоки, готовые к получению блокировки, и ссылку на очередь ожидания, которая содержит потоки, ожидающие уведомления об изменении состояния объекта.  
  
 Методы <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>и `Wait` должны вызываться из синхронизированного блока кода.  
  
 Примечания для метода <xref:System.Threading.Monitor.Pulse%2A> объяснит, что происходит, если <xref:System.Threading.Monitor.Pulse%2A> вызывается, когда потоки не ожидают ожидания.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">Вызывающий поток не владеет блокировкой для указанного объекта.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Поток, который вызывает <see langword="Wait" />, позже прерывается из состояния ожидания. Это происходит, когда другой поток вызывает метод <see cref="M:System.Threading.Thread.Interrupt" /> этого потока.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> в миллисекундах отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (–1 миллисекунда) или больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, в котором следует ожидать.</param>
        <param name="millisecondsTimeout">Количество миллисекунд для ожидания постановки в очередь готовности.</param>
        <param name="exitContext">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — значение <see langword="false" />.</param>
        <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова. Если указанные временные интервалы истекают, поток встает в очередь готовности. Этот метод также указывает на выход из области синхронизации для контекста (если она находится в синхронизированном контексте) до ожидания и ее повторное получение впоследствии.</summary>
        <returns>Значение <see langword="true" />, если блокировка была получена заново до истечения заданного времени; значение <see langword="false" />, если блокировка была получена заново по истечении заданного времени. Этот метод не осуществляет возврат, если блокировка не была получена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не возвращает значение до тех пор, пока не будет получен монопольный замок на параметр `obj`.  
  
 Поток, который в настоящее время владеет блокировкой указанного объекта, вызывает этот метод, чтобы освободить объект, чтобы другой поток мог получить к нему доступ. Вызывающий объект блокируется при ожидании повторного получения блокировки. Этот метод вызывается, когда вызывающему объекту требуется подождать изменения состояния, которое будет происходить в результате операций другого потока.  
  
 Время ожидания гарантирует, что текущий поток не блокируется в течение неограниченного времени, если другой поток освобождает блокировку без предварительного вызова метода <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A>. Он также перемещает поток в очередь готовности, обходя другие потоки перед ним в очереди ожидания, чтобы он мог повторно получить блокировку. Поток может проверить возвращаемое значение метода <xref:System.Threading.Monitor.Wait%2A>, чтобы определить, был ли он получен повторно до истечения времени ожидания. Поток может оценить условия, вызвавшие его, чтобы войти в ожидание, и при необходимости снова вызвать метод <xref:System.Threading.Monitor.Wait%2A>.  
  
 Когда поток вызывает `Wait`, он освобождает блокировку и переходит в очередь ожидания. На этом этапе следующий поток в очереди готовности (если таковой имеется) может контролировать блокировку. Поток, вызвавший `Wait`, остается в очереди ожидания до тех пор, пока поток, владеющий блокировкой, не <xref:System.Threading.Monitor.PulseAll%2A>или не является следующим в очереди и потоком, который удерживает блокировку, <xref:System.Threading.Monitor.Pulse%2A>. Однако если `millisecondsTimeout` истекает до того, как другой поток вызовет метод <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A> этого объекта, исходный поток перемещается в очередь готовности для восстановления блокировки.  
  
> [!NOTE]
>  Если для параметра `millisecondsTimeout` задано <xref:System.Threading.Timeout.Infinite>, этот метод блокируется неопределенно долго, только если владелец блокировки не вызывает <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A>. Если `millisecondsTimeout` равно 0, то поток, который вызывает `Wait`, освобождает блокировку, а затем сразу же входит в очередь готовности, чтобы восстановить блокировку.  
  
 Вызывающий объект выполняется `Wait` один раз, независимо от того, сколько раз было вызвано <xref:System.Threading.Monitor.Enter%2A> для указанного объекта. По сути, метод `Wait` сохраняет количество вызовов <xref:System.Threading.Monitor.Enter%2A>, вызванных вызывающим объектом, и вызывает <xref:System.Threading.Monitor.Exit%2A> столько раз, сколько необходимо для полного освобождения заблокированного объекта. Затем вызывающий объект блокируется при ожидании повторного получения объекта. Когда вызывающий объект повторно получает блокировку, система вызывает <xref:System.Threading.Monitor.Enter%2A> столько раз, сколько необходимо для восстановления сохраненного количества <xref:System.Threading.Monitor.Enter%2A> для вызывающего. Вызов `Wait` освобождает блокировку только для указанного объекта; Если вызывающий объект является владельцем блокировок на других объектах, эти блокировки не освобождаются.  
  
> [!NOTE]
>  Синхронизированный объект содержит несколько ссылок, включая ссылку на поток, который в настоящее время владеет блокировкой, ссылку на очередь готовности, которая содержит потоки, готовые к получению блокировки, и ссылку на очередь ожидания, которая содержит потоки, ожидающие уведомления об изменении состояния объекта.  
  
 Методы <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>и `Wait` должны вызываться из синхронизированного блока кода.  
  
 Примечания для метода <xref:System.Threading.Monitor.Pulse%2A> объяснит, что происходит, если <xref:System.Threading.Monitor.Pulse%2A> вызывается, когда потоки не ожидают ожидания.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 Параметр`exitContext` не действует, если метод <xref:System.Threading.Monitor.Wait%2A> не вызывается из управляемого контекста, не используемого по умолчанию. Это может произойти, если поток находится внутри вызова экземпляра класса, производного от <xref:System.ContextBoundObject>. Даже если в данный момент выполняется метод для класса, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, вы можете находиться в нестандартном контексте, если <xref:System.ContextBoundObject> находится в стеке в текущем домене приложения.  
  
 Если код выполняется в контексте, не заданном по умолчанию, то при указании `true` для `exitContext` в потоке происходит выход из управляемого контекста, не используемого по умолчанию (то есть до перехода в контекст по умолчанию) перед выполнением метода <xref:System.Threading.Monitor.Wait%2A>. После вызова метода <xref:System.Threading.Monitor.Wait%2A> он возвращается к исходному контексту, не заданному по умолчанию.  
  
 Это может быть полезно, если к контекстно-привязанному классу применен атрибут <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы членов класса автоматически синхронизируются, а домен синхронизации — весь текст кода для класса. Если код в стеке вызовов члена вызывает метод <xref:System.Threading.Monitor.Wait%2A> и указывает `true` для `exitContext`, поток завершает работу домена синхронизации, позволяя потоку, который заблокирован при вызове любого члена объекта, продолжать работу. Когда метод <xref:System.Threading.Monitor.Wait%2A> возвращает, поток, который выполнил вызов, должен дождаться повторного входа в домен синхронизации.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> — не вызывается из синхронизированного блока кода.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Поток, который вызывает <see langword="Wait" />, позже прерывается из состояния ожидания. Это происходит, когда другой поток вызывает метод <see cref="M:System.Threading.Thread.Interrupt" /> этого потока.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeout" /> отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, в котором следует ожидать.</param>
        <param name="timeout">Класс <see cref="T:System.TimeSpan" />, представляющий количество времени, до истечения которого поток поступает в очередь ожидания.</param>
        <param name="exitContext">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — значение <see langword="false" />.</param>
        <summary>Освобождает блокировку объекта и блокирует текущий поток до тех пор, пока тот не получит блокировку снова. Если указанные временные интервалы истекают, поток встает в очередь готовности. Дополнительно выходит из синхронизированного домена для синхронизации контекста до ожидания и получает домен впоследствии.</summary>
        <returns>Значение <see langword="true" />, если блокировка была получена заново до истечения заданного времени; значение <see langword="false" />, если блокировка была получена заново по истечении заданного времени. Этот метод не осуществляет возврат, если блокировка не была получена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не возвращает значение до тех пор, пока не будет получен монопольный замок на параметр `obj`.  
  
 Поток, который в настоящее время владеет блокировкой указанного объекта, вызывает этот метод, чтобы освободить объект, чтобы другой поток мог получить к нему доступ. Вызывающий объект блокируется при ожидании повторного получения блокировки. Этот метод вызывается, когда вызывающему объекту требуется подождать изменения состояния, которое будет происходить в результате операций другого потока.  
  
 Время ожидания гарантирует, что текущий поток не блокируется в течение неограниченного времени, если другой поток освобождает блокировку без предварительного вызова метода <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A>. Он также перемещает поток в очередь готовности, обходя другие потоки перед ним в очереди ожидания, чтобы он мог повторно получить блокировку. Поток может проверить возвращаемое значение метода <xref:System.Threading.Monitor.Wait%2A>, чтобы определить, был ли он получен повторно до истечения времени ожидания. Поток может оценить условия, вызвавшие его, чтобы войти в ожидание, и при необходимости снова вызвать метод <xref:System.Threading.Monitor.Wait%2A>.  
  
 Когда поток вызывает `Wait`, он освобождает блокировку и переходит в очередь ожидания. На этом этапе следующий поток в очереди готовности (если таковой имеется) может контролировать блокировку. Поток, вызвавший `Wait`, остается в очереди ожидания до тех пор, пока поток, владеющий блокировкой, не <xref:System.Threading.Monitor.PulseAll%2A>или не является следующим в очереди и потоком, который удерживает блокировку, <xref:System.Threading.Monitor.Pulse%2A>. Однако если `timeout` миллисекунды пройдут до того, как другой поток вызовет метод <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A> этого объекта, исходный поток перемещается в очередь готовности для восстановления блокировки.  
  
> [!NOTE]
>  Если для параметра `timeout` указан <xref:System.TimeSpan>, представляющий-1 миллисекунда, этот метод блокируется неопределенно долго, только если владелец блокировки не вызывает <xref:System.Threading.Monitor.Pulse%2A> или <xref:System.Threading.Monitor.PulseAll%2A>. Если `timeout` равен 0 миллисекундам, поток, который вызывает `Wait`, освобождает блокировку, а затем сразу же входит в очередь готовности, чтобы восстановить блокировку.  
  
 Вызывающий объект выполняется `Wait` один раз, независимо от того, сколько раз было вызвано <xref:System.Threading.Monitor.Enter%2A> для указанного объекта. По сути, метод `Wait` сохраняет количество вызовов <xref:System.Threading.Monitor.Enter%2A>, вызванных вызывающим объектом, и вызывает <xref:System.Threading.Monitor.Exit%2A> столько раз, сколько необходимо для полного освобождения заблокированного объекта. Затем вызывающий объект блокируется при ожидании повторного получения объекта. Когда вызывающий объект повторно получает блокировку, система вызывает <xref:System.Threading.Monitor.Enter%2A> столько раз, сколько необходимо для восстановления сохраненного количества <xref:System.Threading.Monitor.Enter%2A> для вызывающего. Вызов `Wait` освобождает блокировку только для указанного объекта; Если вызывающий объект является владельцем блокировок на других объектах, эти блокировки не освобождаются.  
  
> [!NOTE]
>  Синхронизированный объект содержит несколько ссылок, включая ссылку на поток, который в настоящее время владеет блокировкой, ссылку на очередь готовности, которая содержит потоки, готовые к получению блокировки, и ссылку на очередь ожидания, которая содержит потоки, ожидающие уведомления об изменении состояния объекта.  
  
 Методы <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>и `Wait` должны вызываться из синхронизированного блока кода.  
  
 Примечания для метода <xref:System.Threading.Monitor.Pulse%2A> объяснит, что происходит, если <xref:System.Threading.Monitor.Pulse%2A> вызывается, когда потоки не ожидают ожидания.  
  
## <a name="notes-on-exiting-the-context"></a>Примечания о выходе из контекста  
 Параметр`exitContext` не действует, если метод <xref:System.Threading.Monitor.Wait%2A> не вызывается из управляемого контекста, не используемого по умолчанию. Это может произойти, если поток находится внутри вызова экземпляра класса, производного от <xref:System.ContextBoundObject>. Даже если в данный момент выполняется метод для класса, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, вы можете находиться в нестандартном контексте, если <xref:System.ContextBoundObject> находится в стеке в текущем домене приложения.  
  
 Если код выполняется в контексте, не заданном по умолчанию, то при указании `true` для `exitContext` в потоке происходит выход из управляемого контекста, не используемого по умолчанию (то есть до перехода в контекст по умолчанию) перед выполнением метода <xref:System.Threading.Monitor.Wait%2A>. После вызова метода <xref:System.Threading.Monitor.Wait%2A> он возвращается к исходному контексту, не заданному по умолчанию.  
  
 Это может быть полезно, если к контекстно-привязанному классу применен атрибут <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. В этом случае все вызовы членов класса автоматически синхронизируются, а домен синхронизации — весь текст кода для класса. Если код в стеке вызовов члена вызывает метод <xref:System.Threading.Monitor.Wait%2A> и указывает `true` для `exitContext`, поток завершает работу домена синхронизации, позволяя потоку, который заблокирован при вызове любого члена объекта, продолжать работу. Когда метод <xref:System.Threading.Monitor.Wait%2A> возвращает, поток, который выполнил вызов, должен дождаться повторного входа в домен синхронизации.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> — не вызывается из синхронизированного блока кода.</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Для потока, который вызывает Wait, состояние ожидания позже прерывается. Это происходит, когда другой поток вызывает метод <see cref="M:System.Threading.Thread.Interrupt" /> этого потока.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> в миллисекундах отрицательно и не равно <see cref="F:System.Threading.Timeout.Infinite" /> (–1 миллисекунда) или больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
      </Docs>
    </Member>
  </Members>
</Type>
