<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ba249b86c9e38696438690262b884a5bac97ef6b" /><Meta Name="ms.sourcegitcommit" Value="95e24aee1283af2f120fc5da4b0bdc0712ab698f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="05/06/2019" /><Meta Name="ms.locfileid" Value="65155816" /></Metadata><TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет блокировку, используемую для управления доступом к ресурсу, которая позволяет нескольким потокам производить считывание или получать монопольный доступ на запись.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Threading.ReaderWriterLockSlim> для защиты ресурсов, который считывается с помощью нескольких потоков и запись в один поток за раз. <xref:System.Threading.ReaderWriterLockSlim> позволяет нескольким потокам в режиме чтения, одному потоку в режиме записи с монопольного доступа блокировки и позволяет одному потоку, который имеет доступ на чтение в обновляемом режиме чтения, из которого поток может перейти в режим записи без необходимости отказываться от его s чтения доступ к ресурсу.  
  
> [!NOTE]
>  <xref:System.Threading.ReaderWriterLockSlim> действует так же, как и <xref:System.Threading.ReaderWriterLock>, но с более простыми правилами рекурсии и изменения состояния блокировки. <xref:System.Threading.ReaderWriterLockSlim> позволяет избежать многих ситуаций взаимоблокировки. Кроме того, производительность <xref:System.Threading.ReaderWriterLockSlim> значительно выше, чем у <xref:System.Threading.ReaderWriterLock>. Мы рекомендуем применять <xref:System.Threading.ReaderWriterLockSlim> при любых новых разработках.  
  
 По умолчанию новые экземпляры <xref:System.Threading.ReaderWriterLockSlim> создаются с помощью <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> флаг и не допускает рекурсии. Эта политика по умолчанию рекомендуется для всех новых проектов, поскольку рекурсии приводит ненужные сложности и делает код вероятность возникновения взаимоблокировок. Чтобы упростить миграцию из существующего проекты, использующие <xref:System.Threading.Monitor> или <xref:System.Threading.ReaderWriterLock>, можно использовать <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> флаг для создания экземпляров <xref:System.Threading.ReaderWriterLockSlim> , позволяющие рекурсии.  
  
 Поток может войти в блокировку в трех режимах: режим, режим записи и обновляемый режим чтения. (В остальной части этого раздела, «обновляемый режим чтения» называется «обновляемый режим» и фразу «введите `x` режим» используется вместо более длинной фразы «войти в блокировку в `x` режим».)  
  
 Независимо от политики рекурсии только один поток может находиться в режиме записи в любое время. Когда поток находится в режиме записи, ни один поток может войти в блокировку в любом режиме. Только один поток может находиться в обновляемом режиме в любое время. Может быть любым количеством потоков в режиме чтения, и может существовать один поток в обновляемом режиме во время другие потоки находятся в режиме чтения.  
  
> [!IMPORTANT]
>  Этот тип реализует <xref:System.IDisposable> интерфейс. Когда вы закончите, используя тип, следует освободить его прямо или косвенно. Чтобы удалить тип напрямую, вызовите его <xref:System.IDisposable.Dispose%2A> метод в `try` / `catch` блока. Чтобы избавиться от его косвенно, используйте языковой конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе «С помощью объекта, реализует IDisposable» <xref:System.IDisposable> разделу интерфейса.  
  
 <xref:System.Threading.ReaderWriterLockSlim> управляемые сходство потоков; то есть каждый <xref:System.Threading.Thread> объекта необходимо вызвать функцию свой собственный метод войти и выйти из режимов блокировки. Ни один поток может изменить режим другого потока.  
  
 Если <xref:System.Threading.ReaderWriterLockSlim> не поддерживает рекурсии, поток можно заблокировать, пытается войти в блокировку по следующим причинам:  
  
-   Поток, который пытается войти в режим чтения, блокируется при наличии потоков, ожидающих входа в режим записи или, если один поток в режиме записи в.  
  
    > [!NOTE]
    >  Блокировка новых модулей чтения при записи помещаются в очередь — политика распределение ресурсов блокировок, дает преимущества потокам записи. Текущая политика распределение ресурсов балансирует распределение ресурсов для чтения и записи, для обеспечения оптимальной производительности в наиболее распространенных сценариев. Будущие версии [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] может введены новые политики равноправия.  
  
-   Поток, который пытается войти в обновляемый режим блокируется, если уже существует поток в обновляемом режиме, при наличии потоков, ожидающих входа в режим записи, или если имеется один поток в режиме записи.  
  
-   Поток, который пытается войти в режим записи блокируется, имеется ли поток в любом из трех режимов.  
  
## <a name="upgrading-and-downgrading-locks"></a>Повышение и понижение уровня блокировки  
 Обновляемый режим предназначен для ситуаций, где обычно считывает поток из защищенного ресурса, но может потребоваться запись в него, если выполнено определенное условие. Поток, который <xref:System.Threading.ReaderWriterLockSlim> в обновляемом режиме имеет доступ на чтение к защищенному ресурсу и можно перейти в режим записи путем вызова <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> или <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> методы. Так как может существовать только один поток в обновляемом режиме одновременно, обновление до режима записи нельзя взаимоблокировки, при рекурсии не допускается, это политика по умолчанию.  
  
> [!IMPORTANT]
>  Независимо от политики рекурсии поток, который изначально вошел чтения режим не разрешен для обновления до обновляемый режим или режим записи, так как этот шаблон создает большую вероятность возникновения взаимоблокировок. Например если два потока в режиме чтения, которые попытаются войти в режим записи, они будут принимать участие во взаимоблокировке. Обновляемый режим позволяет избежать такой взаимоблокировки.  
  
 При наличии других потоков в режиме чтения, поток, который обновляется блоков. Хотя поток блокируется, другие потоки, которые пытаются войти в режим чтения блокируются. Когда все потоки вышли из режима чтения, заблокированный обновляемый поток входит в режим записи. При наличии других потоков, ожидающих входа в режим записи, они остаются заблокированными, так как один поток, который находится в обновляемом режиме не дает им получить монопольный доступ к ресурсу.  
  
 Когда поток в обновляемом режиме выходит из режима записи, другие потоки, ожидающие в режим чтения можно сделать это, только при наличии потоков, ожидающих входа в режим записи. Поток в обновляемом режиме можно обновить и понизить неопределенно долгое время, поскольку он является единственным потоком, который записывает к защищенному ресурсу.  
  
> [!IMPORTANT]
>  Если разрешить нескольким потокам введите режим записи или обновляемый режим, вы не должны допускать один поток монополизировать обновляемый режим. В противном случае потоки, попробуйте ввести записи режиме непосредственно будет блокироваться бесконечно, и хотя они заблокированы, другие потоки не сможет войти в режим чтения.  
  
 Поток в обновляемом режиме можно понизить до режима чтения путем вызова метода <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> метод и последующего вызова <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> метод. Этот шаблон понижения допускается для всех политик рекурсии блокировки, даже <xref:System.Threading.LockRecursionPolicy.NoRecursion>.  
  
 После понижения до режима чтения, поток повторного обновляемый режим, пока он выйдет из режима чтения.  
  
## <a name="entering-the-lock-recursively"></a>Ввод в блокировку рекурсивно  
 Можно создать <xref:System.Threading.ReaderWriterLockSlim> , поддерживающий рекурсивная запись блокировки с помощью <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> конструктор, который определяет политику блокировки и указав <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Использование рекурсии не рекомендуется для разработки новых приложений, так как он вводит ненужные сложности и делает код вероятность возникновения взаимоблокировок.  
  
 Для <xref:System.Threading.ReaderWriterLockSlim> , позволяющий рекурсии, следующие можно сказать, что о режимах, поток может войти в:  
  
-   Поток в режиме чтения можно войти в режим чтения рекурсивно, но не может войти в режим записи или обновляемый режим. При попытке сделать это, <xref:System.Threading.LockRecursionException> возникает исключение. Введя считывать режим и введя в режим записи или обновляемый режим — это шаблон, с большой вероятностью взаимоблокировок, поэтому оно не допускается. Как обсуждалось ранее, обновляемый режим предназначен для случаев, где это необходимо, обновить блокировку.  
  
-   Поток в обновляемом режиме можно ввести в режим записи и/или в режиме чтения и можно ввести любой из трех режимов рекурсивно. Тем не менее при попытке ввести режим записи блокируется, если существуют другие потоки в режиме чтения.  
  
-   Поток в режим записи можно ввести в режиме чтения и/или обновляемый режим и можно ввести любой из трех режимов рекурсивно.  
  
-   Поток, который не входил в блокировку можно ввести любой режим. Эта попытка может заблокировать по тем же причинам, при попытке войти в блокировку нерекурсивный.  
  
 Поток можно выйти из режимов, которые он вошел в любом порядке, до тех пор, пока он выходит из каждого режима ровно столько раз, сколько он вошел в этот режим. Если поток пытается выйти из режима слишком много раз или выйти из режима, не вошел, <xref:System.Threading.SynchronizationLockException> возникает исключение.  
  
## <a name="lock-states"></a>Состояния блокировки  
 Может показаться можно представить в блокировку в терминах его состояний. Объект <xref:System.Threading.ReaderWriterLockSlim> может находиться в одном из четырех состояний: не указан, чтение, обновление и записи.  
  
-   Не введен: В этом состоянии нет потоков, вошедших в блокировку (или все потоки освободят блокировку).  
  
-   Для чтения: В этом состоянии один или несколько потоков вошедших в блокировку для доступа на чтение к защищенному ресурсу.  
  
    > [!NOTE]
    >  Поток может войти в блокировку в режиме чтения с помощью <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> или <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> методов, или путем изменения уровня обслуживания обновляемый режим.  
  
-   Обновление: В этом состоянии один поток вошел в блокировку для доступа на чтение с возможностью обновления до доступ на запись (то есть в обновляемом режиме), и нуль или более потоков, вошедших в блокировку для доступа на чтение. Не более чем один поток за раз можно войти в блокировку с возможностью обновления; Дополнительные потоки, которые пытаются войти в обновляемый режим, блокируются.  
  
-   Запись: В этом состоянии один поток вошел в блокировку для доступа на запись к защищенному ресурсу. Эксклюзивные владеет блокировкой у этого потока. Любой другой поток, который пытается войти в блокировку по любой причине блокируется.  
  
 В следующей таблице описаны переходы между состояниями для блокировок, которые не допускают рекурсии, когда поток `t` действия, описанные в крайнем левом столбце. Во время, необходимое действие, `t` имеет режим без. (Особого случая где `t` в обновляемый режим описан в сносках таблицы.) В верхней строке указано начальное состояние блокировки. Ячейки, выполняются в поток и отображать изменения в состоянии блокировки в круглых скобках.  
  
||Нет входов (N)|Read (R)|Обновления (U)|Запись (W)|  
|-|-----------------------|----------------|-------------------|-----------------|  
|`t` входит в режим чтения|`t` вводит (R).|`t` блокируется, если потоки ожидают режим записи; в противном случае `t` вводит.|`t` блокируется, если потоки ожидают режим записи; в противном случае `t` вводит.<sup> 1</sup>|`t` блоки.|  
|`t` входит в обновляемый режим|`t` вводит (U).|`t` блокируется, если потоки ожидают режим записи или обновляемый режим; в противном случае `t` вводит (U).|`t` блоки.|`t` блоки.|  
|`t` переходит в режим записи|`t` вводит (W).|`t` блоки.|`t` блоки. <sup>2</sup>|`t` блоки.|  
  
 <sup>1</sup> Если `t` запускает out в обновляемом режиме, он входит в режим чтения. Это действие никогда не блокируется. Состояние блокировки не изменяется. (Поток можно затем завершить режим чтения, выход из обновляемого режима на более раннюю версию).  
  
 <sup>2</sup> Если `t` запускается в обновляемый режим, он блокируется, если существуют потоки в режиме чтения. В противном случае он обновляет режим записи. Изменения состояния блокировки записи (W). Если `t` блокирует, поскольку отсутствуют потоки в режиме чтения, он переходит в режим записи как последний поток выходит из режима чтения, даже при наличии потоков, ожидающих входа в режим записи.  
  
 Когда происходит изменение состояния, так как поток завершает работу блокировку, следующий поток активируемый выбирается следующим образом:  
  
-   Во-первых поток, ожидающий режим записи и уже находится в обновляемом режиме (может существовать не более одного такого потока).  
  
-   Произошла ошибка, поток, который ожидает в режиме записи.  
  
-   Произошла ошибка, поток, ожидающий обновляемый режим.  
  
-   Произошла ошибка, все потоки, ожидающие в режиме чтения.  
  
 Состояние блокировки всегда находится запись (W) в первых двух случаях и обновления (U) в третьем случае, независимо от состояния блокировки, при выходе из нее потока, вызвавшего изменение состояния. В последнем случае состояние блокировки — обновления (U), если поток в обновляемом режиме после изменения состояния и Read (R) в противном случае, независимо от предыдущего состояния.  
  
   
  
## Examples  
 В следующем примере показано простого синхронизированного кэша, содержащего строки с целочисленных ключей. Экземпляр <xref:System.Threading.ReaderWriterLockSlim> используется для синхронизации доступа к <xref:System.Collections.Generic.Dictionary%602> который выступает в качестве внутреннего кэша.  
  
 Пример содержит простые методы для добавления в кэш, удалить из кэша и чтения из кэша. Чтобы продемонстрировать значения времени ожидания, в примере содержится метод, который добавляет в кэш только в том случае, если это можно сделать в заданный тайм-аут.  
  
 Чтобы продемонстрировать обновляемый режим, в примере включает метод, который получает значение, связанное с ключом и сравнивает его с новым значением. Если значение остается неизменным, метод возвращает состояние, указывающее без изменений. Если для ключа не найдено значение, будет вставлена данную пару ключ значение. Если значение изменилось, то он обновляется. Обновляемый режим позволяет потоку из доступ на чтение к доступ на запись по мере необходимости без риска возникновения взаимоблокировок.  
  
 Пример включает вложенные перечисления, которое указывает возвращаемые значения для метода, который демонстрирует обновляемый режим.  
  
 В примере используется конструктор по умолчанию для создания блокировки, поэтому рекурсия не допускается. Программирование <xref:System.Threading.ReaderWriterLockSlim> является простым и менее подверженной ошибкам, если блокировка не допускает рекурсии.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 В следующем коде используется затем `SynchronizedCache` объект для сохранения словаря имен овощной. Он создает три задачи. Первый записывает имена овощей, хранящихся в массиве для `SynchronizedCache` экземпляра. Второй и третий задачи с именами овощей, первым в порядке возрастания (от низкий индекс высокого уровня), второй в порядке убывания. Последняя задача осуществляет поиск строки «cucumber» и, при обнаружении ее, вызывает <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> способ подставить строку «зеленый bean».  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLockSlim" /> значениями свойств по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Threading.ReaderWriterLockSlim> , инициализированный с этим конструктор не допускает рекурсии. То есть свойство <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> возвращает значение <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.  
  
 Дополнительные сведения о политику рекурсии и его влияние, см. в разделе <xref:System.Threading.LockRecursionPolicy> перечисления и <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
   
  
## Examples  
 В следующем примере показано простого синхронизированного кэша, содержащего строки с целочисленных ключей. Экземпляр <xref:System.Threading.ReaderWriterLockSlim> используется для синхронизации доступа к <xref:System.Collections.Generic.Dictionary%602> который выступает в качестве внутреннего кэша. Этот конструктор используется для создания блокировки.  
  
 Пример содержит простые методы для добавления в кэш, удалить из кэша и чтения из кэша. Чтобы продемонстрировать значения времени ожидания, в примере содержится метод, который добавляет в кэш только в том случае, если это можно сделать в заданный тайм-аут.  
  
 Чтобы продемонстрировать обновляемый режим, в примере включает метод, который получает значение, связанное с ключом и сравнивает его с новым значением. Если значение остается неизменным, метод возвращает состояние, указывающее без изменений. Если для ключа не найдено значение, будет вставлена данную пару ключ значение. Если значение изменилось, то он обновляется. Обновляемый режим позволяет потоку из доступ на чтение к доступ на запись по мере необходимости без риска возникновения взаимоблокировок.  
  
 Пример включает вложенные перечисления, которое указывает возвращаемые значения для метода, который демонстрирует обновляемый режим.  
  
 В примере используется конструктор по умолчанию для создания блокировки, поэтому рекурсия не допускается. Программирование <xref:System.Threading.ReaderWriterLockSlim> является простым и менее подверженной ошибкам, если блокировка не допускает рекурсии.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 В следующем коде используется затем `SynchronizedCache` объект для сохранения словаря имен овощной. Он создает три задачи. Первый записывает имена овощей, хранящихся в массиве для `SynchronizedCache` экземпляра. Второй и третий задачи с именами овощей, первым в порядке возрастания (от низкий индекс высокого уровня), второй в порядке убывания. Последняя задача осуществляет поиск строки «cucumber» и, при обнаружении ее, вызывает <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> способ подставить строку «зеленый bean».  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">Одно из значений перечисления, определяющее политику рекурсии блокировки.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLockSlim" /> с указанием политики рекурсии блокировок.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Политику рекурсии определяет ограничения для потоков, войти в блокировку более одного раза. Например, если блокировка была создана с помощью <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> и поток вошел в блокировку в режиме чтения, <xref:System.Threading.LockRecursionException> возникает исключение, если поток пытается повторно ввести блокировку в режиме чтения. Аналогичным образом, если поток вошел в блокировку в режиме записи <xref:System.Threading.LockRecursionException> возникает, если поток пытается получить повторный ввод блокировки в любом режиме.  
  
> [!NOTE]
>  Поток в обновляемом режиме можно перейти в режим записи или перейти на режим независимо от настроек политики рекурсии блокировки чтения.  
  
 Независимо от политики рекурсии поток, который изначально вошел чтения режим не разрешен для обновления до обновляемый режим или режим записи, так как этот шаблон создает большую вероятность возникновения взаимоблокировок.  
  
 Дополнительные сведения о политику рекурсии и его влияние, см. в разделе <xref:System.Threading.LockRecursionPolicy> перечисления и <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
   
  
## Examples  
 В следующем примере показано два сценария исключения, который зависит от <xref:System.Threading.LockRecursionPolicy> параметр, а другая — нет.  
  
 В первом сценарии поток входит в режим чтения, а затем пытается войти в режим чтения рекурсивно. Если <xref:System.Threading.ReaderWriterLockSlim> создается с помощью конструктора по умолчанию, который задает политику рекурсии для <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, создается исключение. Если <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> используется для создания <xref:System.Threading.ReaderWriterLockSlim>, исключение не создается.  
  
 Во втором сценарии поток входит в режим чтения, и затем режим записи попыток ввода. <xref:System.Threading.LockRecursionException> создается независимо от политику рекурсии блокировки.  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 В следующем коде используется затем `SynchronizedCache` объект для сохранения словаря имен овощной. Он создает три задачи. Первый записывает имена овощей, хранящихся в массиве для `SynchronizedCache` экземпляра. Второй и третий задачи с именами овощей, первым в порядке возрастания (от низкий индекс высокого уровня), второй в порядке убывания. Последняя задача осуществляет поиск строки «cucumber» и, при обнаружении ее, вызывает <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> способ подставить строку «зеленый bean».  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает общее количество уникальных потоков, вошедших в блокировку в режиме чтения.</summary>
        <value>Количество уникальных потоков, вошедших в блокировку в режиме чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поток учитывается только один раз, даже если блокировка допускает рекурсию и поток вошел в режим чтения несколько раз.  
  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как только они были рассчитаны. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> свойства для создания записи журнала событий, если число потоков в режиме чтения превышает пороговое значение.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> по окончании использования класса <xref:System.Threading.ReaderWriterLockSlim>. Метод <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> оставляет класс <xref:System.Threading.ReaderWriterLockSlim> в непригодном для использования состоянии. После вызова метода <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, необходимо освободить все ссылки на <xref:System.Threading.ReaderWriterLockSlim> , сборщик мусора мог освободить память, <xref:System.Threading.ReaderWriterLockSlim> занимаемую. Дополнительные сведения см. в разделе [очистки неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> перед освобождением последней ссылки на <xref:System.Threading.ReaderWriterLockSlim> объекта.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> не равно нулю.  
  
-или- 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> не равно нулю.  
  
-или- 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> не равно нулю.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается выполнить вход в блокировку в режиме чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до вызывающий поток вошел в блокировку, а следовательно, может никогда не возвращают. Использование <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> метода на указанный промежуток времени, и возвращается, если вызывающий поток не вошел в режим чтения во время этого интервала.  
  
 Несколько потоков могут войти в режим чтения в то же время.  
  
 Если один или несколько потоков, ожидающих входа в режим записи, на поток, который вызывает <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> метод блокируется до этих потоков истекло время ожидания или вошел в режим записи и выйдут из него.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме чтения можно ввести рекурсивно в режиме чтения, даже если другие потоки ожидают в режим записи.  
  
 В обновляемом режиме может быть максимум один поток, когда другие потоки находятся в режиме чтения. Если нет потоков, ожидающих входа в режим записи дополнительных потоков, ожидающих входа в обновляемый режим, потоки этого вызова <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> метод немедленно войти в режим чтения и не блокируются.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> метод, чтобы войти в блокировку в режиме чтения. Метод, приведенный в примере извлекает значение, связанное с ключом. Если ключ не найден, исключение, вызванное внутреннего <xref:System.Collections.Generic.Dictionary%602> разрешено метод terminate. Объект `finally` блок используется для выполнения <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> метод, гарантируя, что вызывающий объект выходит из режима чтения.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, и текущий поток попытался получить блокировку чтения, когда уже удерживает эту блокировку чтения.  
  
-или- 
Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, и текущий поток попытался получить блокировку записи, когда уже удерживает эту блокировку записи.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Данное ограничение настолько велико, что приложения никогда не должны столкнуться с этим исключением.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается выполнить вход в блокировку в обновляемом режиме.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до вызывающий поток вошел в блокировку, а следовательно, может никогда не возвращают. Использование <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> метода на указанный промежуток времени, и возвращается, если вызывающий поток не вошел в обновляемый режим во время этого интервала.  
  
 Используйте обновляемый режим, когда поток обычно обращается к ресурсу, защищенному <xref:System.Threading.ReaderWriterLockSlim> в режиме чтения, но может потребоваться войти в режим записи при соблюдении определенных условий. Поток в обновляемом режиме можно понизить до режима чтения, или перейти в режим записи.  
  
 В любой момент времени только один поток может войти в обновляемый режим. Если поток находится в обновляемый режим и нет потоков, ожидающих входа в режим записи, любое количество других потоков может войти в режим чтения, даже при наличии потоков, ожидающих в обновляемый режим.  
  
 Если один или несколько потоков, ожидающих входа в режим записи, на поток, который вызывает <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> метод блокируется до этих потоков истекло время ожидания или вошел в режим записи и выйдут из него.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в обновляемом режиме можно ввести обновляемый режим рекурсивно, даже если другие потоки ожидают в режим записи.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> метод, чтобы войти в блокировку в обновляемом режиме. Объект `finally` блок используется для выполнения <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> метод, гарантируя, что вызывающий объект выходит из обновляемого режима.  
  
 Метод, приведенный в примере возвращает значение, связанное с ключом и сравнивает его с новым значением. Если значение остается неизменным, метод возвращает состояние, указывающее без изменений. Оно не найдено значение для ключа, вставляется данную пару ключ значение. Если значение изменилось, то он обновляется. Обновляемый режим позволяет потоку блокировку чтения без риска возникновения взаимоблокировок.  
  
 В примере используется конструктор по умолчанию для создания блокировки, поэтому рекурсия не допускается. Программирование <xref:System.Threading.ReaderWriterLockSlim> является простым и менее подверженной ошибкам, если блокировка не допускает рекурсии.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Свойство <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> и текущий поток уже вошел в блокировку в любом режиме.  
  
-или- 
Текущий поток вошел в режим чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение настолько велико, что он не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается выполнить вход в блокировку в режиме записи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод блокируется до вызывающий поток вошел в блокировку, а следовательно, может никогда не возвращают. Использование <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> метода на указанный промежуток времени, и возвращается, если вызывающий поток не вошел в режим записи во время этого интервала.  
  
 Если других потоков, вошедших в блокировку в режиме чтения, на поток, который вызывает <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> метод блокируется до эти потоки вышли из режима чтения. При наличии потоков, ожидающих входа в режим записи, дополнительные потоки, которые пытаются войти режим чтения или обновляемый режим, блокируются, пока не у всех потоков, ожидающих входа в режим записи, либо истекло время ожидания или вошел в режим записи и выйдут из него.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме записи можно ввести режим записи рекурсивно, даже если другие потоки ожидают в режим записи.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> метод, чтобы войти в блокировку в режиме записи. Метод, приведенный в примере добавляет новую пару ключ значение в синхронизированный кэш. Если ключ уже имеется в кэше, исключения, созданного внутреннего <xref:System.Collections.Generic.Dictionary%602> разрешено метод terminate. Объект `finally` блок используется для выполнения <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> метод, гарантируя, что вызывающий объект выходит из режима записи.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Свойство <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> и текущий поток уже вошел в блокировку в любом режиме.  
  
-или- 
Текущий поток вступил в режим чтения и еще не имеет блокировки записи, поэтому попытка войти в режим блокировки в режиме записи создаст возможность взаимоблокировки.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение настолько велико, что он не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уменьшает счетчик глубины рекурсии для режима чтения и выходит из режима чтения, если счетчик принял значение 0 (нуль).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не чувствителен к порядку рекурсии. Например если поток вошел в блокировку в обновляемом режиме, а затем вошел в блокировку в режиме чтения, порядок, в котором поток выходит из двух режимов не имеет значения. Если блокировка допускает рекурсию, поток может войти в блокировку в режиме записи, а затем введите в его рекурсивно в режиме чтения. порядок, в котором поток выходит из режима чтения и записи режим не имеет значения.  
  
 Выход из блокировки может сигнализировать другим ожидающим потокам.  
  
   
  
## Examples  
 В следующем примере показано, как использовать `finally` к выполнению блока <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> метод, гарантируя, что вызывающий объект выходит из режима чтения. Метод, приведенный в примере извлекает значение, связанное с ключом. Если ключ не найден, исключение, вызванное внутреннего <xref:System.Collections.Generic.Dictionary%602> разрешено метод terminate. <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> Метод используется в режим чтения.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Текущий поток не вошел в блокировку в режиме чтения.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уменьшает счетчик глубины рекурсии для обновляемого режима и выходит из обновляемого режима, если счетчик принял значение 0 (нуль).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не чувствителен к порядку рекурсии. Например если поток вошел в блокировку в обновляемом режиме, а затем вошел в блокировку в режиме записи, порядок, в котором поток выходит из двух режимов не имеет значения. Если блокировка допускает рекурсию, поток может войти в блокировку в режиме записи, а затем введите в его рекурсивно в обновляемом режиме. порядок, в котором поток выходит из обновляемого режима и режима записи не имеет значения.  
  
 Выход из блокировки может сигнализировать другим ожидающим потокам.  
  
   
  
## Examples  
 В следующем примере показано, как использовать `finally` к выполнению блока <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> метод, гарантируя, что вызывающий объект выходит из обновляемого режима.  
  
 Метод, приведенный в примере возвращает значение, связанное с ключом и сравнивает его с новым значением. Если значение остается неизменным, метод возвращает состояние, указывающее без изменений. Оно не найдено значение для ключа, вставляется данную пару ключ значение. Если значение изменилось, то он обновляется. Обновляемый режим позволяет потоку блокировку чтения без риска возникновения взаимоблокировок.  
  
 В примере используется конструктор по умолчанию для создания блокировки, поэтому рекурсия не допускается. Программирование <xref:System.Threading.ReaderWriterLockSlim> является простым и менее подверженной ошибкам, если блокировка не допускает рекурсии.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Текущий поток не вошел в блокировку в обновляемом режиме.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Уменьшает счетчик глубины рекурсии для режима записи и выходит из режима записи, если счетчик принял значение 0 (нуль).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не чувствителен к порядку рекурсии. Например если поток вошел в блокировку в обновляемом режиме, а затем вошел в блокировку в режиме записи, порядок, в котором поток выходит из двух режимов не имеет значения. Если блокировка допускает рекурсию, поток может войти в блокировку в режиме записи, а затем введите в его рекурсивно в режиме чтения. порядок, в котором поток выходит из режима чтения и записи режим не имеет значения.  
  
 Выход из блокировки может сигнализировать другим ожидающим потокам.  
  
   
  
## Examples  
 В следующем примере показано, как использовать `finally` к выполнению блока <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> метод, гарантируя, что вызывающий объект выходит из режима записи. Метод, приведенный в примере добавляет новую пару ключ значение в синхронизированный кэш. Если ключ уже имеется в кэше, исключения, созданного внутреннего <xref:System.Collections.Generic.Dictionary%602> разрешено метод terminate. <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> Метод позволяет войти в блокировку в режиме записи.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">Текущий поток не вошел в блокировку в режиме записи.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, вошел ли текущий поток в блокировку в режиме чтения.</summary>
        <value>Значение <see langword="true" />, если текущий поток вошел в режим чтения; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предназначено для использования в подтверждениях или для других целей отладки. Не используйте его для управления потоком выполнения программы.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> свойства для создания утверждения, если текущий поток вошел в режим чтения неожиданно.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, вошел ли текущий поток в блокировку в обновляемом режиме.</summary>
        <value>Значение <see langword="true" />, если текущий поток вошел в обновляемый режим; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предназначено для использования в подтверждениях или для других целей отладки. Не используйте его для управления потоком выполнения программы.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> свойства для создания утверждения, если текущий поток вошел в обновляемый режим неожиданно.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, вошел ли текущий поток в блокировку в режиме записи.</summary>
        <value>Значение <see langword="true" />, если текущий поток вошел в режим записи; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предназначено для использования в подтверждениях или для других целей отладки. Не используйте его для управления потоком выполнения программы.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> свойства для создания утверждения, если текущий поток вошел в режим записи неожиданно.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее политику рекурсии для текущего объекта <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
        <value>Одно из значений перечисления, определяющее политику рекурсии блокировки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Политику рекурсии определяет ограничения для потоков, войти в блокировку более одного раза. Например, если блокировка была создана с помощью <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> и поток вошел в блокировку в режиме чтения, <xref:System.Threading.LockRecursionException> возникает исключение, если поток пытается повторно ввести блокировку в режиме чтения.  
  
> [!NOTE]
>  Поток в обновляемом режиме можно перейти в режим записи или перейти на режим независимо от настроек политики рекурсии блокировки чтения.  
  
 Независимо от политики рекурсии поток, который изначально вошел чтения режим не разрешен для обновления до обновляемый режим или режим записи, так как этот шаблон создает большую вероятность возникновения взаимоблокировок.  
  
 Дополнительные сведения о политику рекурсии и его влияние, см. в разделе <xref:System.Threading.LockRecursionPolicy> перечисления и <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает количество раз, которые текущий поток входил в блокировку в режиме чтения, как показатель рекурсии.</summary>
        <value>0 (нуль), если текущий поток не вошел в режим чтения, 1, если поток вошел в режим чтения, но не вошел в него рекурсивно, или *n* Если поток вошел в блокировку рекурсивно *n* - 1 раз.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как только они были рассчитаны. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает количество раз, которые текущий поток входил в блокировку в обновляемом режиме, как показатель рекурсии.</summary>
        <value>0, если текущий поток не вошел в обновляемый режим, 1, если поток вошел в обновляемый режим, но не вошел в него рекурсивно, или *n* Если поток вошел в обновляемый режим рекурсивно *n* - 1 время ожидания.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как только они были рассчитаны. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает количество раз, которые текущий поток входил в блокировку в режиме записи, как показатель рекурсии.</summary>
        <value>0, если текущий поток не вошел в режим записи, 1, если поток вошел в режим записи, но не вошел в него рекурсивно, или *n* Если поток вошел в режим записи рекурсивно *n* - 1 раз.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как только они были рассчитаны. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) в случае неограниченного времени ожидания.</param>
        <summary>Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания целым числом.</summary>
        <returns>Значение <see langword="true" />, если вызывающий поток вошел в режим чтения; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает `false` немедленно в том случае, если нужное состояние недоступно.  
  
 Несколько потоков могут войти в режим чтения в то же время.  
  
 Если один или несколько потоков, ожидающих входа в режим записи, на поток, который вызывает <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> метод блокируется, пока эти потоки либо истекло время ожидания или вошел в режим записи и не выйдут из него, или пока не истечет время ожидания вызывающего потока собственные.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме чтения можно ввести рекурсивно в режиме чтения, даже если другие потоки ожидают в режим записи.  
  
 Один поток может находиться в обновляемом режиме, когда другие потоки находятся в режиме чтения. Если нет потоков, ожидающих входа в режим записи дополнительных потоков, ожидающих входа в обновляемый режим, потоки этого вызова <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> метод немедленно войти в режим чтения и не блокируются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Свойство <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> и текущий поток уже вошел в блокировку.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение настолько велико, что он не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="millisecondsTimeout" /> является отрицательным, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</param>
        <summary>Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания.</summary>
        <returns>Значение <see langword="true" />, если вызывающий поток вошел в режим чтения; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает `false` немедленно в том случае, если нужное состояние недоступно.  
  
 Несколько потоков могут войти в блокировку в режиме чтения в то же время.  
  
 Если один или несколько потоков находятся в очереди в режим записи, на поток, который вызывает <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> метод блокируется, пока эти потоки либо истекло время ожидания или вошел в режим записи и не выйдут из него, или пока не истечет время ожидания вызывающего потока собственные.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме чтения можно ввести рекурсивно в режиме чтения, даже если другие потоки ожидают в режим записи.  
  
 Один поток может находиться в обновляемом режиме, когда другие потоки находятся в режиме чтения. Если нет потоков, ожидающих входа в режим записи дополнительных потоков, ожидающих входа в обновляемый режим, потоки этого вызова <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> метод немедленно войти в режим чтения и не блокируются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Свойство <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> и текущий поток уже вошел в блокировку.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение настолько велико, что он не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="timeout" /> отрицательное, но оно не равно-1 миллисекунды, которое является единственным допустимым отрицательным значением.  
  
-или- 
Значение <paramref name="timeout" /> больше, чем <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) в случае неограниченного времени ожидания.</param>
        <summary>Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</summary>
        <returns>Значение <see langword="true" />, если вызывающий поток вошел в обновляемый режим; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает `false` немедленно в том случае, если нужное состояние недоступно.  
  
 Используйте обновляемый режим, когда поток обычно обращается к ресурсу, защищенному <xref:System.Threading.ReaderWriterLockSlim> в режиме чтения, но может потребоваться войти в режим записи при соблюдении определенных условий. Поток в обновляемом режиме можно перейти в режим записи или перейти на режим чтения.  
  
 Только один поток может войти в блокировку в обновляемом режиме в любой момент времени. Если поток находится в обновляемый режим и нет потоков, ожидающих входа в режим записи, любое количество других потоков может войти в режим чтения, даже при наличии потоков, ожидающих в обновляемый режим.  
  
 Если один или несколько потоков, ожидающих входа в режим записи, на поток, который вызывает <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> метод блокируется, пока эти потоки либо истекло время ожидания или вошел в режим записи и не выйдут из него, или пока не истечет время ожидания вызывающего потока собственные.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в обновляемом режиме можно ввести обновляемый режим рекурсивно, даже если другие потоки ожидают в режим записи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Свойство <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> и текущий поток уже вошел в блокировку.  
  
-или- 
Текущий поток изначально вошел в блокировку в режиме чтения, и поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение настолько велико, что он не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="millisecondsTimeout" /> является отрицательным, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</param>
        <summary>Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</summary>
        <returns>Значение <see langword="true" />, если вызывающий поток вошел в обновляемый режим; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает `false` немедленно в том случае, если нужное состояние недоступно.  
  
 Используйте обновляемый режим, когда поток обычно обращается к ресурсу, защищенному <xref:System.Threading.ReaderWriterLockSlim> в режиме чтения, но может потребоваться войти в режим записи при соблюдении определенных условий. Поток в обновляемом режиме можно перейти в режим записи или перейти на режим чтения.  
  
 Только один поток может войти в блокировку в обновляемом режиме в любой момент времени. Если поток находится в обновляемый режим и нет потоков, ожидающих входа в режим записи, любое количество других потоков может войти в режим чтения, даже при наличии потоков, ожидающих в обновляемый режим.  
  
 Если один или несколько потоков, ожидающих входа в режим записи, на поток, который вызывает <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> метод блокируется, пока эти потоки либо истекло время ожидания или вошел в режим записи и не выйдут из него, или пока не истечет время ожидания вызывающего потока собственные.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в обновляемом режиме можно ввести обновляемый режим рекурсивно, даже если другие потоки ожидают в режим записи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Свойство <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> и текущий поток уже вошел в блокировку.  
  
-или- 
Текущий поток изначально вошел в блокировку в режиме чтения, и поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение настолько велико, что он не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="timeout" /> отрицательное, но оно не равно-1 миллисекунды, которое является единственным допустимым отрицательным значением.  
  
-или- 
Значение <paramref name="timeout" /> больше, чем <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) в случае неограниченного времени ожидания.</param>
        <summary>Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</summary>
        <returns>Значение <see langword="true" />, если вызывающий поток вошел в режим записи; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `millisecondsTimeout` равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает `false` немедленно в том случае, если нужное состояние недоступно.  
  
 Если других потоков, вошедших в блокировку в режиме чтения, на поток, который вызывает <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> метод блокируется, пока эти потоки вышли из режима чтения, или пока не истечет период таймаута. Хотя потоки блокируются, ожидающих входа в режим записи, дополнительные потоки, которые пытаются войти в режим чтения или обновляемый режим блокируются до всех потоков, ожидающих входа в режим записи, имеют либо истекло время ожидания или вошел в режим записи и выйдут из него.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме записи можно ввести режим записи рекурсивно, даже если другие потоки ожидают в режим записи.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> метод, чтобы войти в блокировку в режиме записи, с временем ожидания. Метод, приведенный в примере добавляет новую пару ключ значение в синхронизированный кэш. Если заданное время ожидания по истечении интервала перед поток вошел в блокировку, метод возвращает `false`. Этот метод возвращает `true` Если добавляется пара ключ/значение.  
  
 Если ключ уже имеется в кэше, исключения, созданного внутреннего <xref:System.Collections.Generic.Dictionary%602> разрешено метод terminate. Объект `finally` блок используется для выполнения <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> метод, гарантируя, что вызывающий объект выходит из блокировки.  
  
 Этот код является частью большего примера для <xref:System.Threading.ReaderWriterLockSlim> класса.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Свойство <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> и текущий поток уже вошел в блокировку.  
  
-или- 
Текущий поток изначально вошел в блокировку в режиме чтения, и поэтому попытка войти в режим записи создаст возможность взаимоблокировки.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение настолько велико, что он не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="millisecondsTimeout" /> является отрицательным, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</param>
        <summary>Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</summary>
        <returns>Значение <see langword="true" />, если вызывающий поток вошел в режим записи; в противном случае <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `timeout` равно 0 (ноль), этот метод проверяет состояние блокировки и возвращает `false` немедленно в том случае, если нужное состояние недоступно.  
  
 Если других потоков, вошедших в блокировку в режиме чтения, на поток, который вызывает <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> метод блокируется, пока эти потоки вышли из режима чтения, или пока не истечет период таймаута. Хотя потоки блокируются, ожидающих входа в режим записи, дополнительные потоки, которые пытаются войти в режим чтения или обновляемый режим блокируются до всех потоков, ожидающих входа в режим записи, имеют либо истекло время ожидания или вошел в режим записи и выйдут из него.  
  
> [!NOTE]
>  Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме записи можно ввести режим записи рекурсивно, даже если другие потоки ожидают в режим записи.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> Свойство <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> и текущий поток уже вошел в блокировку.  
  
-или- 
Текущий поток изначально вошел в блокировку в режиме чтения, и поэтому попытка войти в режим записи создаст возможность взаимоблокировки.  
  
-или- 
Глубина рекурсии превышает емкость счетчика. Ограничение настолько велико, что он не должно достигаться приложениями на практике.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="timeout" /> отрицательное, но оно не равно-1 миллисекунды, которое является единственным допустимым отрицательным значением.  
  
-или- 
Значение <paramref name="timeout" /> больше, чем <see cref="F:System.Int32.MaxValue" /> миллисекунд.</exception>
        <exception cref="T:System.ObjectDisposedException">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает общее количество потоков, ожидающих вхождения в блокировку в режиме чтения.</summary>
        <value>Общее количество потоков, ожидающих вхождения в режим чтения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как только они были рассчитаны. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> свойства для создания записи журнала событий, если число потоков, заблокированных, ожидающих в режим чтения, превышает пороговое значение.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает общее количество потоков, ожидающих входа в блокировку в обновляемом режиме.</summary>
        <value>Общее количество потоков, ожидающих входа в обновляемый режим.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как только они были рассчитаны. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> свойства для создания записи журнала событий, если число потоков, заблокированных, ожидающих входа в обновляемый режим, превышает пороговое значение.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает общее количество потоков, ожидающих входа в блокировку в режиме записи.</summary>
        <value>Общее количество потоков, ожидающих входа в режим записи.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма. Результаты можно изменить, как только они были рассчитаны. Таким образом не является безопасным для принятия решений на основе этого свойства.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> свойства для создания записи журнала событий, если число потоков, заблокированных, ожидающих входа в режим записи превышает пороговое значение.  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
