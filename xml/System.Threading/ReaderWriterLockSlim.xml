<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="52eecb3efba89c4c616bb2a219a05fa825de9bfb" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75158638" /></Metadata><TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="01c08-101">Представляет блокировку, используемую для управления доступом к ресурсу, которая позволяет нескольким потокам производить считывание или получать монопольный доступ на запись.</span><span class="sxs-lookup"><span data-stu-id="01c08-101">Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-102">Используйте <xref:System.Threading.ReaderWriterLockSlim> для защиты ресурса, который считывается несколькими потоками и записывается в один поток за раз.</span><span class="sxs-lookup"><span data-stu-id="01c08-102">Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time.</span></span> <span data-ttu-id="01c08-103"><xref:System.Threading.ReaderWriterLockSlim> позволяет использовать несколько потоков в режиме чтения, позволяет одному потоку находиться в режиме записи с монопольным владельцем блокировки и допускает, чтобы один поток, имеющий доступ на чтение, был в обновляемом режиме чтения, из которого поток может обновиться до режима записи, не требуя от него доступа для чтения к ресурсу.</span><span class="sxs-lookup"><span data-stu-id="01c08-103"><xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-104"><xref:System.Threading.ReaderWriterLockSlim> действует так же, как и <xref:System.Threading.ReaderWriterLock>, но с более простыми правилами рекурсии и изменения состояния блокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="01c08-105"><xref:System.Threading.ReaderWriterLockSlim> позволяет избежать многих ситуаций взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="01c08-106">Кроме того, производительность <xref:System.Threading.ReaderWriterLockSlim> значительно выше, чем у <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="01c08-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="01c08-107">Мы рекомендуем применять <xref:System.Threading.ReaderWriterLockSlim> при любых новых разработках.</span><span class="sxs-lookup"><span data-stu-id="01c08-107"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span>  
  
 <span data-ttu-id="01c08-108">По умолчанию новые экземпляры <xref:System.Threading.ReaderWriterLockSlim> создаются с флагом <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> и не допускают рекурсии.</span><span class="sxs-lookup"><span data-stu-id="01c08-108">By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag and do not allow recursion.</span></span> <span data-ttu-id="01c08-109">Эта политика по умолчанию рекомендуется для всех новых приложений, так как рекурсия вносит ненужные сложности и делает код более подверженным взаимоблокировкам.</span><span class="sxs-lookup"><span data-stu-id="01c08-109">This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</span></span> <span data-ttu-id="01c08-110">Чтобы упростить миграцию из существующих проектов, использующих <xref:System.Threading.Monitor> или <xref:System.Threading.ReaderWriterLock>, можно использовать флаг <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> для создания экземпляров <xref:System.Threading.ReaderWriterLockSlim>, которые допускают рекурсию.</span><span class="sxs-lookup"><span data-stu-id="01c08-110">To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.</span></span>  
  
 <span data-ttu-id="01c08-111">Поток может войти в блокировку в трех режимах: режим чтения, режим записи и обновляемый режим чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-111">A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</span></span> <span data-ttu-id="01c08-112">(В оставшейся части этого раздела «обновляемый режим чтения» называется "обновляемым режимом", а фраза "вход в режим `x`" используется в качестве параметра более длинной фразы "введите блокировку в режиме `x`".)</span><span class="sxs-lookup"><span data-stu-id="01c08-112">(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter `x` mode" is used in preference to the longer phrase "enter the lock in `x` mode".)</span></span>  
  
 <span data-ttu-id="01c08-113">Независимо от политики рекурсии в любое время может находиться только один поток в режиме записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-113">Regardless of recursion policy, only one thread can be in write mode at any time.</span></span> <span data-ttu-id="01c08-114">Если поток находится в режиме записи, никакой другой поток не может войти в блокировку в любом режиме.</span><span class="sxs-lookup"><span data-stu-id="01c08-114">When a thread is in write mode, no other thread can enter the lock in any mode.</span></span> <span data-ttu-id="01c08-115">В любой момент времени в обновляемом режиме может находиться только один поток.</span><span class="sxs-lookup"><span data-stu-id="01c08-115">Only one thread can be in upgradeable mode at any time.</span></span> <span data-ttu-id="01c08-116">Любое количество потоков может находиться в режиме чтения, и в обновляемом режиме может быть один поток, а другие потоки находятся в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-116">Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="01c08-117">Этот тип реализует интерфейс <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="01c08-117">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="01c08-118">По окончании использования выдаленную ему память следует прямо или косвенно освободить.</span><span class="sxs-lookup"><span data-stu-id="01c08-118">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="01c08-119">Чтобы сделать это прямо, вызовите его метод <xref:System.IDisposable.Dispose%2A> в блоке `try`/`catch`.</span><span class="sxs-lookup"><span data-stu-id="01c08-119">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="01c08-120">Чтобы сделать это косвенно, используйте языковые конструкции, такие как `using` (в C#) или `Using` (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="01c08-120">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="01c08-121">Дополнительные сведения см. в разделе "Использование объекта, реализующего IDisposable" в статье об интерфейсе <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="01c08-121">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="01c08-122"><xref:System.Threading.ReaderWriterLockSlim> имеет сходство управляемого потока; то есть каждый объект <xref:System.Threading.Thread> должен делать свои собственные вызовы методов для входа и выхода из режимов блокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-122"><xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes.</span></span> <span data-ttu-id="01c08-123">Ни один поток не может изменить режим другого потока.</span><span class="sxs-lookup"><span data-stu-id="01c08-123">No thread can change the mode of another thread.</span></span>  
  
 <span data-ttu-id="01c08-124">Если <xref:System.Threading.ReaderWriterLockSlim> не допускает рекурсии, поток, пытающийся войти в блокировку, может блокироваться по нескольким причинам:</span><span class="sxs-lookup"><span data-stu-id="01c08-124">If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</span></span>  
  
-   <span data-ttu-id="01c08-125">Поток, пытающийся войти в блоки режима чтения, если есть потоки, ожидающие входа в режим записи или выполняющие один поток в режиме записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-125">A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="01c08-126">Блокирование новых читателей, когда модули записи помещаются в очередь, — это политика равноправия блокировок, которая дает предпочтение модулям записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-126">Blocking new readers when writers are queued is a lock fairness policy that favors writers.</span></span> <span data-ttu-id="01c08-127">Текущая политика равноправия равномерно распределяется между модулями чтения и записи, чтобы повысить пропускную способность в самых распространенных сценариях.</span><span class="sxs-lookup"><span data-stu-id="01c08-127">The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</span></span> <span data-ttu-id="01c08-128">В будущих версиях [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] могут возникнуть новые политики равноправия.</span><span class="sxs-lookup"><span data-stu-id="01c08-128">Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.</span></span>  
  
-   <span data-ttu-id="01c08-129">Поток, пытающийся войти в блоки обновляемого режима, если в обновляемом режиме уже имеется поток, если имеются потоки, ожидающие входа в режим записи, или если в режиме записи имеется один поток.</span><span class="sxs-lookup"><span data-stu-id="01c08-129">A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</span></span>  
  
-   <span data-ttu-id="01c08-130">Поток, который пытается войти в режим записи, блокируется, если имеется поток в любом из трех режимов.</span><span class="sxs-lookup"><span data-stu-id="01c08-130">A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</span></span>  
  
## <a name="upgrading-and-downgrading-locks"></a><span data-ttu-id="01c08-131">Обновление и понижение уровня блокировки</span><span class="sxs-lookup"><span data-stu-id="01c08-131">Upgrading and Downgrading Locks</span></span>  
 <span data-ttu-id="01c08-132">Обновляемый режим предназначен для случаев, когда поток обычно считывает данные из защищенного ресурса, но при выполнении какого-либо условия может потребоваться запись в него.</span><span class="sxs-lookup"><span data-stu-id="01c08-132">Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</span></span> <span data-ttu-id="01c08-133">Поток, который вошел в <xref:System.Threading.ReaderWriterLockSlim> в обновляемом режиме, имеет доступ на чтение к защищенному ресурсу и может обновить его до режима записи, вызвав методы <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> или <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="01c08-133">A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods.</span></span> <span data-ttu-id="01c08-134">Так как в обновляемом режиме может быть только один поток, обновление до режима записи не может быть взаимоблокировками, если рекурсия не разрешена, что является политикой по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="01c08-134">Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="01c08-135">Независимо от политики рекурсии потоку, который изначально перешел в режим чтения, запрещено обновление до обновляемого режима или режима записи, поскольку этот шаблон создает строгую вероятность взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="01c08-135">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span> <span data-ttu-id="01c08-136">Например, если два потока в режиме чтения пытаются войти в режим записи, они будут взаимоблокировками.</span><span class="sxs-lookup"><span data-stu-id="01c08-136">For example, if two threads in read mode both try to enter write mode, they will deadlock.</span></span> <span data-ttu-id="01c08-137">Обновляемый режим предназначен для предотвращения подобных взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="01c08-137">Upgradeable mode is designed to avoid such deadlocks.</span></span>  
  
 <span data-ttu-id="01c08-138">Если в режиме чтения есть другие потоки, то поток, который выполняет обновление, блокируется.</span><span class="sxs-lookup"><span data-stu-id="01c08-138">If there are other threads in read mode, the thread that is upgrading blocks.</span></span> <span data-ttu-id="01c08-139">Пока поток заблокирован, другие потоки, пытающиеся войти в режим чтения, блокируются.</span><span class="sxs-lookup"><span data-stu-id="01c08-139">While the thread is blocked, other threads that try to enter read mode are blocked.</span></span> <span data-ttu-id="01c08-140">Когда все потоки вышли из режима чтения, заблокированный обновляемый поток переходит в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-140">When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</span></span> <span data-ttu-id="01c08-141">Если существуют другие потоки, ожидающие входа в режим записи, они остаются заблокированными, так как один поток, находящихся в обновляемом режиме, не позволяет им получить монопольный доступ к ресурсу.</span><span class="sxs-lookup"><span data-stu-id="01c08-141">If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</span></span>  
  
 <span data-ttu-id="01c08-142">Когда поток в обновляемом режиме выходит из режима записи, другие потоки, ожидающие входа в режим чтения, могут сделать это, если нет потоков, ожидающих входа в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-142">When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</span></span> <span data-ttu-id="01c08-143">Поток в обновляемом режиме может обновляться и переходить на более раннюю версию неограниченно, пока это единственный поток, записывающий данные в защищенный ресурс.</span><span class="sxs-lookup"><span data-stu-id="01c08-143">The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="01c08-144">Если разрешить нескольким потокам переход в режим записи или обновляемый режим, то не следует разрешать одному потоку монопольно использовать обновляемый режим.</span><span class="sxs-lookup"><span data-stu-id="01c08-144">If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</span></span> <span data-ttu-id="01c08-145">В противном случае потоки, которые пытаются войти в режим записи напрямую, будут заблокированы на неопределенное время, и пока они будут заблокированы, другие потоки не смогут войти в режим чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-145">Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</span></span>  
  
 <span data-ttu-id="01c08-146">Поток в обновляемом режиме можно понизить до режима чтения, сначала вызвав метод <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> и вызвав метод <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="01c08-146">A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method.</span></span> <span data-ttu-id="01c08-147">Этот шаблон перехода на более раннюю версию разрешен для всех политик рекурсии блокировки, даже <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span><span class="sxs-lookup"><span data-stu-id="01c08-147">This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span></span>  
  
 <span data-ttu-id="01c08-148">После перехода в режим чтения поток не может повторно войти в обновляемый режим, пока он не завершит работу из режима чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-148">After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</span></span>  
  
## <a name="entering-the-lock-recursively"></a><span data-ttu-id="01c08-149">Рекурсивный вход в блокировку</span><span class="sxs-lookup"><span data-stu-id="01c08-149">Entering the Lock Recursively</span></span>  
 <span data-ttu-id="01c08-150">Можно создать <xref:System.Threading.ReaderWriterLockSlim>, поддерживающую запись рекурсивной блокировки, с помощью конструктора <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29>, который определяет политику блокировки, и указания <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="01c08-150">You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-151">Использование рекурсии не рекомендуется для новых разработок, поскольку оно создает ненужные сложности и делает код более подверженным взаимоблокировкам.</span><span class="sxs-lookup"><span data-stu-id="01c08-151">The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</span></span>  
  
 <span data-ttu-id="01c08-152">Для <xref:System.Threading.ReaderWriterLockSlim>, допускающих рекурсию, можно сказать о режимах, которые поток может ввести:</span><span class="sxs-lookup"><span data-stu-id="01c08-152">For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:</span></span>  
  
-   <span data-ttu-id="01c08-153">Поток в режиме чтения может войти в режим чтения рекурсивно, но не может войти в режим записи или обновляемый режим.</span><span class="sxs-lookup"><span data-stu-id="01c08-153">A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</span></span> <span data-ttu-id="01c08-154">При попытке сделать это возникает исключение <xref:System.Threading.LockRecursionException>.</span><span class="sxs-lookup"><span data-stu-id="01c08-154">If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown.</span></span> <span data-ttu-id="01c08-155">Переход в режим чтения и переход в режим записи или обновляемый режим — это шаблон с высокой вероятностью взаимоблокировок, поэтому он не разрешен.</span><span class="sxs-lookup"><span data-stu-id="01c08-155">Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</span></span> <span data-ttu-id="01c08-156">Как обсуждалось ранее, обновляемый режим предоставляется для случаев, когда требуется обновить блокировку.</span><span class="sxs-lookup"><span data-stu-id="01c08-156">As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</span></span>  
  
-   <span data-ttu-id="01c08-157">Поток в обновляемом режиме может входить в режим записи или чтения, а также может вводить любой из трех режимов рекурсивно.</span><span class="sxs-lookup"><span data-stu-id="01c08-157">A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</span></span> <span data-ttu-id="01c08-158">Однако попытка входа в режим записи блокируется, если в режиме чтения есть другие потоки.</span><span class="sxs-lookup"><span data-stu-id="01c08-158">However, an attempt to enter write mode blocks if there are other threads in read mode.</span></span>  
  
-   <span data-ttu-id="01c08-159">Поток в режиме записи может входить в режим чтения и (или) обновляемый режим, а также может вводить любой из трех режимов рекурсивно.</span><span class="sxs-lookup"><span data-stu-id="01c08-159">A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</span></span>  
  
-   <span data-ttu-id="01c08-160">Поток, который не вошел в блокировку, может войти в любой режим.</span><span class="sxs-lookup"><span data-stu-id="01c08-160">A thread that has not entered the lock can enter any mode.</span></span> <span data-ttu-id="01c08-161">Эта попытка может блокироваться по тем же причинам, что и попытка входа в нерекурсивную блокировку.</span><span class="sxs-lookup"><span data-stu-id="01c08-161">This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</span></span>  
  
 <span data-ttu-id="01c08-162">Поток может выйти из режимов, которые он указал в любом порядке, при условии, что каждый режим завершается точно так же, как если бы он был указан в этом режиме.</span><span class="sxs-lookup"><span data-stu-id="01c08-162">A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</span></span> <span data-ttu-id="01c08-163">Если поток пытается выйти из режима слишком много раз или выйти из режима, который он не указал, создается <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="01c08-163">If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.</span></span>  
  
## <a name="lock-states"></a><span data-ttu-id="01c08-164">Состояния блокировки</span><span class="sxs-lookup"><span data-stu-id="01c08-164">Lock States</span></span>  
 <span data-ttu-id="01c08-165">Может оказаться полезным рассматривать блокировку с точки зрения ее состояний.</span><span class="sxs-lookup"><span data-stu-id="01c08-165">You may find it useful to think of the lock in terms of its states.</span></span> <span data-ttu-id="01c08-166"><xref:System.Threading.ReaderWriterLockSlim> может находиться в одном из четырех состояний: не указано, чтение, обновление и запись.</span><span class="sxs-lookup"><span data-stu-id="01c08-166">A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.</span></span>  
  
-   <span data-ttu-id="01c08-167">Не введено. в этом состоянии потоки не вошел в блокировку (или все потоки вышли из блокировки).</span><span class="sxs-lookup"><span data-stu-id="01c08-167">Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</span></span>  
  
-   <span data-ttu-id="01c08-168">Read: в этом состоянии один или несколько потоков перешли в блокировку на доступ для чтения к защищенному ресурсу.</span><span class="sxs-lookup"><span data-stu-id="01c08-168">Read: In this state, one or more threads have entered the lock for read access to the protected resource.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="01c08-169">Поток может войти в блокировку в режиме чтения с помощью методов <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> или <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> или путем перехода на более раннюю версию из обновляемого режима.</span><span class="sxs-lookup"><span data-stu-id="01c08-169">A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.</span></span>  
  
-   <span data-ttu-id="01c08-170">Обновление. в этом состоянии один поток вошел в блокировку для доступа на чтение с возможностью обновления до доступа на запись (то есть в обновляемом режиме), а ноль или более потоков вошел в блокировку для доступа на чтение.</span><span class="sxs-lookup"><span data-stu-id="01c08-170">Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</span></span> <span data-ttu-id="01c08-171">Ни один поток за раз может войти в блокировку с возможностью обновления. дополнительные потоки, пытающиеся войти в обновляемый режим, блокируются.</span><span class="sxs-lookup"><span data-stu-id="01c08-171">No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</span></span>  
  
-   <span data-ttu-id="01c08-172">Запись: в этом состоянии один поток вошел в блокировку для доступа на запись к защищенному ресурсу.</span><span class="sxs-lookup"><span data-stu-id="01c08-172">Write: In this state, one thread has entered the lock for write access to the protected resource.</span></span> <span data-ttu-id="01c08-173">Этот поток монопольно владеет блокировкой.</span><span class="sxs-lookup"><span data-stu-id="01c08-173">That thread has exclusive possession of the lock.</span></span> <span data-ttu-id="01c08-174">Любой другой поток, пытающийся войти в блокировку по любой причине, блокируется.</span><span class="sxs-lookup"><span data-stu-id="01c08-174">Any other thread that tries to enter the lock for any reason is blocked.</span></span>  
  
 <span data-ttu-id="01c08-175">В следующей таблице описаны переходы между состояниями блокировки для блокировок, которые не допускают рекурсии, когда поток `t` выполняет действие, описанное в крайнем левом столбце.</span><span class="sxs-lookup"><span data-stu-id="01c08-175">The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column.</span></span> <span data-ttu-id="01c08-176">В момент выполнения действия `t` не имеет режима.</span><span class="sxs-lookup"><span data-stu-id="01c08-176">At the time it takes the action, `t` has no mode.</span></span> <span data-ttu-id="01c08-177">(Особый случай, когда `t` находится в обновляемом режиме, описывается в сносках таблицы.) В верхней строке описывается начальное состояние блокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-177">(The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</span></span> <span data-ttu-id="01c08-178">Ячейки описывают, что происходит с потоком, и отображают изменения состояния блокировки в круглых скобках.</span><span class="sxs-lookup"><span data-stu-id="01c08-178">The cells describe what happens to the thread, and show changes to the lock state in parentheses.</span></span>  
  
||<span data-ttu-id="01c08-179">Не задано (N)</span><span class="sxs-lookup"><span data-stu-id="01c08-179">Not entered (N)</span></span>|<span data-ttu-id="01c08-180">Чтение (R)</span><span class="sxs-lookup"><span data-stu-id="01c08-180">Read (R)</span></span>|<span data-ttu-id="01c08-181">Обновление (U)</span><span class="sxs-lookup"><span data-stu-id="01c08-181">Upgrade (U)</span></span>|<span data-ttu-id="01c08-182">Запись (W)</span><span class="sxs-lookup"><span data-stu-id="01c08-182">Write (W)</span></span>|  
|-|-----------------------|----------------|-------------------|-----------------|  
|<span data-ttu-id="01c08-183">`t` переходит в режим чтения</span><span class="sxs-lookup"><span data-stu-id="01c08-183">`t` enters read mode</span></span>|<span data-ttu-id="01c08-184">`t` вводит (R).</span><span class="sxs-lookup"><span data-stu-id="01c08-184">`t` enters (R).</span></span>|<span data-ttu-id="01c08-185">`t` блокируется, если потоки ожидают режима записи; в противном случае `t` вводит.</span><span class="sxs-lookup"><span data-stu-id="01c08-185">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.</span></span>|<span data-ttu-id="01c08-186">`t` блокируется, если потоки ожидают режима записи; в противном случае `t` вводит. <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="01c08-186">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup></span></span>|<span data-ttu-id="01c08-187">блоки `t`.</span><span class="sxs-lookup"><span data-stu-id="01c08-187">`t` blocks.</span></span>|  
|<span data-ttu-id="01c08-188">`t` входит в обновляемый режим</span><span class="sxs-lookup"><span data-stu-id="01c08-188">`t` enters upgradeable mode</span></span>|<span data-ttu-id="01c08-189">`t` вводит (U).</span><span class="sxs-lookup"><span data-stu-id="01c08-189">`t` enters (U).</span></span>|<span data-ttu-id="01c08-190">`t` блокируется, если потоки ожидают режима записи или обновления. в противном случае `t` вводит (U).</span><span class="sxs-lookup"><span data-stu-id="01c08-190">`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).</span></span>|<span data-ttu-id="01c08-191">блоки `t`.</span><span class="sxs-lookup"><span data-stu-id="01c08-191">`t` blocks.</span></span>|<span data-ttu-id="01c08-192">блоки `t`.</span><span class="sxs-lookup"><span data-stu-id="01c08-192">`t` blocks.</span></span>|  
|<span data-ttu-id="01c08-193">`t` входит в режим записи</span><span class="sxs-lookup"><span data-stu-id="01c08-193">`t` enters write mode</span></span>|<span data-ttu-id="01c08-194">`t` вводит (W).</span><span class="sxs-lookup"><span data-stu-id="01c08-194">`t` enters (W).</span></span>|<span data-ttu-id="01c08-195">блоки `t`.</span><span class="sxs-lookup"><span data-stu-id="01c08-195">`t` blocks.</span></span>|<span data-ttu-id="01c08-196">блоки `t`. <sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="01c08-196">`t` blocks.<sup>2</sup></span></span>|<span data-ttu-id="01c08-197">блоки `t`.</span><span class="sxs-lookup"><span data-stu-id="01c08-197">`t` blocks.</span></span>|  
  
 <span data-ttu-id="01c08-198"><sup>1</sup> если `t` запускается в обновляемом режиме, он переходит в режим чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-198"><sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode.</span></span> <span data-ttu-id="01c08-199">Это действие никогда не блокируется.</span><span class="sxs-lookup"><span data-stu-id="01c08-199">This action never blocks.</span></span> <span data-ttu-id="01c08-200">Состояние блокировки не изменяется.</span><span class="sxs-lookup"><span data-stu-id="01c08-200">The lock state does not change.</span></span> <span data-ttu-id="01c08-201">(Поток может выполнить переход на более раннюю версию в режиме чтения путем выхода из обновляемого режима.)</span><span class="sxs-lookup"><span data-stu-id="01c08-201">(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</span></span>  
  
 <span data-ttu-id="01c08-202"><sup>2</sup> если `t` запускается в обновляемом режиме, он блокируется при наличии потоков в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-202"><sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode.</span></span> <span data-ttu-id="01c08-203">В противном случае он обновляется до режима записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-203">Otherwise it upgrades to write mode.</span></span> <span data-ttu-id="01c08-204">Изменение состояния блокировки на запись (W).</span><span class="sxs-lookup"><span data-stu-id="01c08-204">The lock state changes to Write (W).</span></span> <span data-ttu-id="01c08-205">Если `t` блоки из-за наличия потоков в режиме чтения, он переходит в режим записи сразу после того, как последний поток выходит из режима чтения, даже если имеются потоки, ожидающие входа в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-205">If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="01c08-206">Когда происходит изменение состояния, поскольку поток завершает блокировку, следующий поток для пробуждения выбирается следующим образом:</span><span class="sxs-lookup"><span data-stu-id="01c08-206">When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</span></span>  
  
-   <span data-ttu-id="01c08-207">Во-первых, поток, который ожидает режима записи и уже находится в обновляемом режиме (может существовать не более одного такого потока).</span><span class="sxs-lookup"><span data-stu-id="01c08-207">First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</span></span>  
  
-   <span data-ttu-id="01c08-208">Сбой этого потока, ожидающего режима записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-208">Failing that, a thread that is waiting for write mode.</span></span>  
  
-   <span data-ttu-id="01c08-209">Сбой этого потока, ожидающего обновляемого режима.</span><span class="sxs-lookup"><span data-stu-id="01c08-209">Failing that, a thread that is waiting for upgradeable mode.</span></span>  
  
-   <span data-ttu-id="01c08-210">В таком случае все потоки ожидают режима чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-210">Failing that, all threads that are waiting for read mode.</span></span>  
  
 <span data-ttu-id="01c08-211">Последующее состояние блокировки всегда пишется (W) в первых двух случаях и обновляется (U) в третьем случае, независимо от состояния блокировки, когда поток выхода инициировал изменение состояния.</span><span class="sxs-lookup"><span data-stu-id="01c08-211">The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</span></span> <span data-ttu-id="01c08-212">В последнем случае состояние блокировки — Upgrade (U), если после изменения состояния поток находится в обновляемом режиме, а в противном случае — Read (R), независимо от предыдущего состояния.</span><span class="sxs-lookup"><span data-stu-id="01c08-212">In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-213">В следующем примере показан простой синхронизированный кэш, содержащий строки с целочисленными ключами.</span><span class="sxs-lookup"><span data-stu-id="01c08-213">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="01c08-214">Экземпляр <xref:System.Threading.ReaderWriterLockSlim> используется для синхронизации доступа к <xref:System.Collections.Generic.Dictionary%602>, который выступает в качестве внутреннего кэша.</span><span class="sxs-lookup"><span data-stu-id="01c08-214">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span>  
  
 <span data-ttu-id="01c08-215">Пример включает простые методы для добавления в кэш, удаления из кэша и чтения из кэша.</span><span class="sxs-lookup"><span data-stu-id="01c08-215">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="01c08-216">Чтобы продемонстрировать время ожидания, пример включает метод, который добавляет в кэш только в том случае, если это возможно в течение заданного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-216">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="01c08-217">Чтобы продемонстрировать обновляемый режим, в примере используется метод, который получает значение, связанное с ключом, и сравнивает его с новым значением.</span><span class="sxs-lookup"><span data-stu-id="01c08-217">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="01c08-218">Если значение не изменилось, метод возвращает состояние, указывающее на отсутствие изменений.</span><span class="sxs-lookup"><span data-stu-id="01c08-218">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="01c08-219">Если для ключа не найдено значение, вставляется пара ключ/значение.</span><span class="sxs-lookup"><span data-stu-id="01c08-219">If no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="01c08-220">Если значение изменилось, оно обновляется.</span><span class="sxs-lookup"><span data-stu-id="01c08-220">If the value has changed, it is updated.</span></span> <span data-ttu-id="01c08-221">Обновляемый режим позволяет потоку обновить доступ на чтение для записи при необходимости без риска взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="01c08-221">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="01c08-222">Пример включает вложенное перечисление, которое указывает возвращаемые значения для метода, который демонстрирует обновляемый режим.</span><span class="sxs-lookup"><span data-stu-id="01c08-222">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="01c08-223">В примере используется конструктор без параметров для создания блокировки, поэтому рекурсия не разрешена.</span><span class="sxs-lookup"><span data-stu-id="01c08-223">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="01c08-224">Программирование <xref:System.Threading.ReaderWriterLockSlim> проще и менее подвержено ошибкам, если блокировка не допускает рекурсии.</span><span class="sxs-lookup"><span data-stu-id="01c08-224">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="01c08-225">В следующем примере кода используется объект `SynchronizedCache` для хранения словаря имен овощ.</span><span class="sxs-lookup"><span data-stu-id="01c08-225">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="01c08-226">Он создает три задачи.</span><span class="sxs-lookup"><span data-stu-id="01c08-226">It creates three tasks.</span></span> <span data-ttu-id="01c08-227">Сначала записывает имена овощей, хранящиеся в массиве, в экземпляр `SynchronizedCache`.</span><span class="sxs-lookup"><span data-stu-id="01c08-227">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="01c08-228">Вторая и третья задачи отображают имена овощей, первый в возрастающем порядке (от нижнего индекса до верхнего индекса), второй в убывающем порядке.</span><span class="sxs-lookup"><span data-stu-id="01c08-228">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="01c08-229">Последняя задача выполняет поиск строки "Cucumber" и при ее обнаружении вызывает метод <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> для замены строки "Green Bean".</span><span class="sxs-lookup"><span data-stu-id="01c08-229">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="01c08-230">Данный тип потокобезопасен.</span><span class="sxs-lookup"><span data-stu-id="01c08-230">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="01c08-231">Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span><span class="sxs-lookup"><span data-stu-id="01c08-231">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01c08-232">Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLockSlim" /> значениями свойств по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="01c08-232">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-233"><xref:System.Threading.ReaderWriterLockSlim>, инициализированный этим конструктором, не допускает рекурсии.</span><span class="sxs-lookup"><span data-stu-id="01c08-233">A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion.</span></span> <span data-ttu-id="01c08-234">То есть свойство <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> возвращает значение <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="01c08-234">That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="01c08-235">Дополнительные сведения о политике рекурсии и ее эффектах см. в разделе Перечисление <xref:System.Threading.LockRecursionPolicy> и класс <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="01c08-235">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-236">В следующем примере показан простой синхронизированный кэш, содержащий строки с целочисленными ключами.</span><span class="sxs-lookup"><span data-stu-id="01c08-236">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="01c08-237">Экземпляр <xref:System.Threading.ReaderWriterLockSlim> используется для синхронизации доступа к <xref:System.Collections.Generic.Dictionary%602>, который выступает в качестве внутреннего кэша.</span><span class="sxs-lookup"><span data-stu-id="01c08-237">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span> <span data-ttu-id="01c08-238">Конструктор без параметров используется для создания блокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-238">The parameterless constructor is used to create the lock.</span></span>  
  
 <span data-ttu-id="01c08-239">Пример включает простые методы для добавления в кэш, удаления из кэша и чтения из кэша.</span><span class="sxs-lookup"><span data-stu-id="01c08-239">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="01c08-240">Чтобы продемонстрировать время ожидания, пример включает метод, который добавляет в кэш только в том случае, если это возможно в течение заданного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-240">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="01c08-241">Чтобы продемонстрировать обновляемый режим, в примере используется метод, который получает значение, связанное с ключом, и сравнивает его с новым значением.</span><span class="sxs-lookup"><span data-stu-id="01c08-241">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="01c08-242">Если значение не изменилось, метод возвращает состояние, указывающее на отсутствие изменений.</span><span class="sxs-lookup"><span data-stu-id="01c08-242">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="01c08-243">Если для ключа не найдено значение, вставляется пара ключ/значение.</span><span class="sxs-lookup"><span data-stu-id="01c08-243">If no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="01c08-244">Если значение изменилось, оно обновляется.</span><span class="sxs-lookup"><span data-stu-id="01c08-244">If the value has changed, it is updated.</span></span> <span data-ttu-id="01c08-245">Обновляемый режим позволяет потоку обновить доступ на чтение для записи при необходимости без риска взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="01c08-245">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="01c08-246">Пример включает вложенное перечисление, которое указывает возвращаемые значения для метода, который демонстрирует обновляемый режим.</span><span class="sxs-lookup"><span data-stu-id="01c08-246">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="01c08-247">В примере используется конструктор без параметров для создания блокировки, поэтому рекурсия не разрешена.</span><span class="sxs-lookup"><span data-stu-id="01c08-247">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="01c08-248">Программирование <xref:System.Threading.ReaderWriterLockSlim> проще и менее подвержено ошибкам, если блокировка не допускает рекурсии.</span><span class="sxs-lookup"><span data-stu-id="01c08-248">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="01c08-249">В следующем примере кода используется объект `SynchronizedCache` для хранения словаря имен овощ.</span><span class="sxs-lookup"><span data-stu-id="01c08-249">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="01c08-250">Он создает три задачи.</span><span class="sxs-lookup"><span data-stu-id="01c08-250">It creates three tasks.</span></span> <span data-ttu-id="01c08-251">Сначала записывает имена овощей, хранящиеся в массиве, в экземпляр `SynchronizedCache`.</span><span class="sxs-lookup"><span data-stu-id="01c08-251">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="01c08-252">Вторая и третья задачи отображают имена овощей, первый в возрастающем порядке (от нижнего индекса до верхнего индекса), второй в убывающем порядке.</span><span class="sxs-lookup"><span data-stu-id="01c08-252">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="01c08-253">Последняя задача выполняет поиск строки "Cucumber" и при ее обнаружении вызывает метод <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> для замены строки "Green Bean".</span><span class="sxs-lookup"><span data-stu-id="01c08-253">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy"><span data-ttu-id="01c08-254">Одно из значений перечисления, определяющее политику рекурсии блокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-254">One of the enumeration values that specifies the lock recursion policy.</span></span></param>
        <summary><span data-ttu-id="01c08-255">Инициализирует новый экземпляр класса <see cref="T:System.Threading.ReaderWriterLockSlim" /> с указанием политики рекурсии блокировок.</span><span class="sxs-lookup"><span data-stu-id="01c08-255">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-256">Политика рекурсии определяет ограничения для потоков, которые вводят блокировку несколько раз.</span><span class="sxs-lookup"><span data-stu-id="01c08-256">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="01c08-257">Например, если блокировка была создана с <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> и поток вошел в блокировку в режиме чтения, <xref:System.Threading.LockRecursionException> создается, если поток пытается повторно войти в блокировку в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-257">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span> <span data-ttu-id="01c08-258">Аналогично, если поток вошел в блокировку в режиме записи, <xref:System.Threading.LockRecursionException> создается, если поток пытается повторно войти в блокировку в любом режиме.</span><span class="sxs-lookup"><span data-stu-id="01c08-258">Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-259">Поток в обновляемом режиме может обновиться до режима записи или перехода на более раннюю версию в режиме чтения независимо от параметра политики рекурсии блокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-259">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="01c08-260">Независимо от политики рекурсии потоку, который изначально перешел в режим чтения, запрещено обновление до обновляемого режима или режима записи, поскольку этот шаблон создает строгую вероятность взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="01c08-260">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="01c08-261">Дополнительные сведения о политике рекурсии и ее эффектах см. в разделе Перечисление <xref:System.Threading.LockRecursionPolicy> и класс <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="01c08-261">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-262">В следующем примере показаны два сценария исключений, один из которых зависит от параметра <xref:System.Threading.LockRecursionPolicy>, а другой — нет.</span><span class="sxs-lookup"><span data-stu-id="01c08-262">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="01c08-263">В первом сценарии поток переходит в режим чтения, а затем пытается войти в режим чтения рекурсивно.</span><span class="sxs-lookup"><span data-stu-id="01c08-263">In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="01c08-264">Если <xref:System.Threading.ReaderWriterLockSlim> создается с помощью конструктора без параметров, который задает для политики рекурсии значение <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, возникает исключение.</span><span class="sxs-lookup"><span data-stu-id="01c08-264">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the parameterless constructor, which sets recursion policy to <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="01c08-265">Если для создания <xref:System.Threading.ReaderWriterLockSlim>используется <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>, исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="01c08-265">If <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="01c08-266">Во втором сценарии поток переходит в режим чтения, а затем пытается войти в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-266">In the second scenario, the thread enters read mode and then tries to enter write mode.</span></span> <span data-ttu-id="01c08-267"><xref:System.Threading.LockRecursionException> создается независимо от политики рекурсии блокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-267"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 <span data-ttu-id="01c08-268">В следующем примере кода используется объект `SynchronizedCache` для хранения словаря имен овощ.</span><span class="sxs-lookup"><span data-stu-id="01c08-268">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="01c08-269">Он создает три задачи.</span><span class="sxs-lookup"><span data-stu-id="01c08-269">It creates three tasks.</span></span> <span data-ttu-id="01c08-270">Сначала записывает имена овощей, хранящиеся в массиве, в экземпляр `SynchronizedCache`.</span><span class="sxs-lookup"><span data-stu-id="01c08-270">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="01c08-271">Вторая и третья задачи отображают имена овощей, первый в возрастающем порядке (от нижнего индекса до верхнего индекса), второй в убывающем порядке.</span><span class="sxs-lookup"><span data-stu-id="01c08-271">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="01c08-272">Последняя задача выполняет поиск строки "Cucumber" и при ее обнаружении вызывает метод <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> для замены строки "Green Bean".</span><span class="sxs-lookup"><span data-stu-id="01c08-272">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01c08-273">Получает общее количество уникальных потоков, вошедших в блокировку в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-273">Gets the total number of unique threads that have entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="01c08-274">Количество уникальных потоков, вошедших в блокировку в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-274">The number of unique threads that have entered the lock in read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-275">Поток учитывается только один раз, даже если блокировка допускает рекурсию и поток перешел в режим чтения несколько раз.</span><span class="sxs-lookup"><span data-stu-id="01c08-275">A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</span></span>  
  
 <span data-ttu-id="01c08-276">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</span><span class="sxs-lookup"><span data-stu-id="01c08-276">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="01c08-277">Результаты могут измениться, как только они будут вычислены.</span><span class="sxs-lookup"><span data-stu-id="01c08-277">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="01c08-278">Поэтому не рекомендуется принимать решения на основе этого свойства.</span><span class="sxs-lookup"><span data-stu-id="01c08-278">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-279">В следующем примере показано, как использовать свойство <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> для создания записи в журнале событий, если число потоков в режиме чтения превышает пороговое значение.</span><span class="sxs-lookup"><span data-stu-id="01c08-279">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01c08-280">Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span><span class="sxs-lookup"><span data-stu-id="01c08-280">Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-281">Вызовите метод <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> по окончании использования класса <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="01c08-281">Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="01c08-282">Метод <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> оставляет класс <xref:System.Threading.ReaderWriterLockSlim> в непригодном для использования состоянии.</span><span class="sxs-lookup"><span data-stu-id="01c08-282">The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state.</span></span> <span data-ttu-id="01c08-283">После вызова метода <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> необходимо освободить все ссылки на объект <xref:System.Threading.ReaderWriterLockSlim>, чтобы сборщик мусора мог освободить память, занимаемую объектом <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="01c08-283">After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying.</span></span> <span data-ttu-id="01c08-284">Дополнительные сведения см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="01c08-284">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-285">Всегда вызывайте <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> перед тем, как освободить последнюю ссылку на объект <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="01c08-285">Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="01c08-286">Значение параметра <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> больше нуля.</span><span class="sxs-lookup"><span data-stu-id="01c08-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="01c08-287">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-287">-or-</span></span> 
 <span data-ttu-id="01c08-288">Значение параметра <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> больше нуля.</span><span class="sxs-lookup"><span data-stu-id="01c08-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="01c08-289">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-289">-or-</span></span> 
 <span data-ttu-id="01c08-290">Значение параметра <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> больше нуля.</span><span class="sxs-lookup"><span data-stu-id="01c08-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01c08-291">Пытается выполнить вход в блокировку в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-291">Tries to enter the lock in read mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-292">Этот метод блокируется до тех пор, пока вызывающий поток не введет блокировку и, следовательно, никогда не вернет.</span><span class="sxs-lookup"><span data-stu-id="01c08-292">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="01c08-293">Используйте метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> для блокировки в течение указанного интервала, а затем возвращает значение, если вызывающий поток не вошел в режим чтения в течение этого интервала.</span><span class="sxs-lookup"><span data-stu-id="01c08-293">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</span></span>  
  
 <span data-ttu-id="01c08-294">Несколько потоков могут одновременно войти в режим чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-294">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="01c08-295">Если один или несколько потоков ожидают входа в режим записи, поток, вызывающий метод <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>, блокируется до тех пор, пока эти потоки не истечет время ожидания или не перейдет в режим записи, а затем вышли из него.</span><span class="sxs-lookup"><span data-stu-id="01c08-295">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-296">Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме чтения, может войти в режим чтения рекурсивно, даже если другие потоки ожидают входа в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-296">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="01c08-297">Не более одного потока может находиться в обновляемом режиме, в то время как другие потоки находятся в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-297">At most one thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="01c08-298">Если дополнительные потоки ожидают входа в обновляемый режим и отсутствуют потоки, ожидающие входа в режим записи, потоки, вызывающие метод <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>, немедленно переводятся в режим чтения и не блокируют.</span><span class="sxs-lookup"><span data-stu-id="01c08-298">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-299">В следующем примере показано, как использовать метод <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> для входа в блокировку в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-299">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method to enter the lock in read mode.</span></span> <span data-ttu-id="01c08-300">Метод, показанный в примере, извлекает значение, связанное с ключом.</span><span class="sxs-lookup"><span data-stu-id="01c08-300">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="01c08-301">Если ключ не найден, то исключение, созданное внутренним <xref:System.Collections.Generic.Dictionary%602>, может завершить метод.</span><span class="sxs-lookup"><span data-stu-id="01c08-301">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="01c08-302">Блок `finally` используется для выполнения метода <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>, гарантируя, что вызывающий объект выходит из режима чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-302">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span>  
  
 <span data-ttu-id="01c08-303">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="01c08-303">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="01c08-304">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, и текущий поток попытался получить блокировку чтения, когда уже удерживает эту блокировку чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-304">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock.</span></span>  
  
<span data-ttu-id="01c08-305">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-305">-or-</span></span> 
<span data-ttu-id="01c08-306">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, и текущий поток попытался получить блокировку записи, когда уже удерживает эту блокировку записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-306">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock.</span></span>  
  
<span data-ttu-id="01c08-307">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-307">-or-</span></span> 
<span data-ttu-id="01c08-308">Глубина рекурсии превышает емкость счетчика.</span><span class="sxs-lookup"><span data-stu-id="01c08-308">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="01c08-309">Данное ограничение настолько велико, что приложения никогда не должны столкнуться с этим исключением.</span><span class="sxs-lookup"><span data-stu-id="01c08-309">This limit is so large that applications should never encounter this exception.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="01c08-310">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="01c08-310">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01c08-311">Пытается выполнить вход в блокировку в обновляемом режиме.</span><span class="sxs-lookup"><span data-stu-id="01c08-311">Tries to enter the lock in upgradeable mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-312">Этот метод блокируется до тех пор, пока вызывающий поток не введет блокировку и, следовательно, никогда не вернет.</span><span class="sxs-lookup"><span data-stu-id="01c08-312">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="01c08-313">Используйте метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> для блокировки в течение указанного интервала, а затем возвращает значение, если вызывающий поток не вошел в обновляемый режим в течение этого интервала.</span><span class="sxs-lookup"><span data-stu-id="01c08-313">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</span></span>  
  
 <span data-ttu-id="01c08-314">Используйте обновляемый режим, когда поток обычно обращается к ресурсу, защищенному <xref:System.Threading.ReaderWriterLockSlim>ом в режиме чтения, но при соблюдении определенных условий может потребоваться вход в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-314">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="01c08-315">Поток в обновляемом режиме можно понизить до режима чтения или обновить до режима записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-315">A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</span></span>  
  
 <span data-ttu-id="01c08-316">Только один поток может войти в обновляемый режим в любое заданное время.</span><span class="sxs-lookup"><span data-stu-id="01c08-316">Only one thread can enter upgradeable mode at any given time.</span></span> <span data-ttu-id="01c08-317">Если поток находится в обновляемом режиме и отсутствуют потоки, ожидающие входа в режим записи, любое число других потоков может войти в режим чтения, даже если есть потоки, ожидающие входа в обновляемый режим.</span><span class="sxs-lookup"><span data-stu-id="01c08-317">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="01c08-318">Если один или несколько потоков ожидают входа в режим записи, поток, вызывающий метод <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>, блокируется до тех пор, пока эти потоки не истечет время ожидания или не перейдет в режим записи, а затем вышли из него.</span><span class="sxs-lookup"><span data-stu-id="01c08-318">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-319">Если блокировка допускает рекурсию, поток, который вошел в блокировку в обновляемом режиме, может войти в обновляемый режим рекурсивно, даже если другие потоки ожидают входа в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-319">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-320">В следующем примере показано, как использовать метод <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> для входа в блокировку в обновляемом режиме.</span><span class="sxs-lookup"><span data-stu-id="01c08-320">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method to enter the lock in upgradeable mode.</span></span> <span data-ttu-id="01c08-321">Блок `finally` используется для выполнения метода <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>, гарантируя, что вызывающий объект завершает обновляемый режим.</span><span class="sxs-lookup"><span data-stu-id="01c08-321">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="01c08-322">Метод, показанный в примере, извлекает значение, связанное с ключом, и сравнивает его с новым значением.</span><span class="sxs-lookup"><span data-stu-id="01c08-322">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="01c08-323">Если значение не изменилось, метод возвращает состояние, указывающее на отсутствие изменений.</span><span class="sxs-lookup"><span data-stu-id="01c08-323">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="01c08-324">Для ключа не найдено значение, вставляется пара "ключ — значение".</span><span class="sxs-lookup"><span data-stu-id="01c08-324">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="01c08-325">Если значение изменилось, оно обновляется.</span><span class="sxs-lookup"><span data-stu-id="01c08-325">If the value has changed, it is updated.</span></span> <span data-ttu-id="01c08-326">Обновляемый режим позволяет потоку обновлять блокировку чтения по мере необходимости без риска взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="01c08-326">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="01c08-327">В примере используется конструктор без параметров для создания блокировки, поэтому рекурсия не разрешена.</span><span class="sxs-lookup"><span data-stu-id="01c08-327">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="01c08-328">Программирование <xref:System.Threading.ReaderWriterLockSlim> проще и менее подвержено ошибкам, если блокировка не допускает рекурсии.</span><span class="sxs-lookup"><span data-stu-id="01c08-328">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="01c08-329">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="01c08-329">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="01c08-330">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку в любом из режимов.</span><span class="sxs-lookup"><span data-stu-id="01c08-330">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="01c08-331">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-331">-or-</span></span> 
<span data-ttu-id="01c08-332">Текущий поток вошел в режим чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-332">The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="01c08-333">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-333">-or-</span></span> 
<span data-ttu-id="01c08-334">Глубина рекурсии превышает емкость счетчика.</span><span class="sxs-lookup"><span data-stu-id="01c08-334">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="01c08-335">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</span><span class="sxs-lookup"><span data-stu-id="01c08-335">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="01c08-336">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="01c08-336">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01c08-337">Пытается выполнить вход в блокировку в режиме записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-337">Tries to enter the lock in write mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-338">Этот метод блокируется до тех пор, пока вызывающий поток не введет блокировку и, следовательно, никогда не вернет.</span><span class="sxs-lookup"><span data-stu-id="01c08-338">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="01c08-339">Используйте метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> для блокировки в течение указанного интервала, а затем возвращает значение, если вызывающий поток не вошел в режим записи в течение этого интервала.</span><span class="sxs-lookup"><span data-stu-id="01c08-339">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</span></span>  
  
 <span data-ttu-id="01c08-340">Если другие потоки вошел в блокировку в режиме чтения, поток, вызывающий метод <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>, блокируется до тех пор, пока эти потоки не вышли из режима чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-340">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode.</span></span> <span data-ttu-id="01c08-341">При наличии потоков, ожидающих входа в режим записи, дополнительные потоки, пытающиеся войти в режим чтения или обновляемый блок режима, пока не истечет время ожидания всех потоков, ожидающих входа в режим записи, или не перейдет в режим записи, а затем завершили работу.</span><span class="sxs-lookup"><span data-stu-id="01c08-341">When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-342">Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме записи, может войти в режим записи рекурсивно, даже если другие потоки ожидают входа в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-342">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-343">В следующем примере показано, как использовать метод <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> для входа в блокировку в режиме записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-343">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method to enter the lock in write mode.</span></span> <span data-ttu-id="01c08-344">Метод, показанный в примере, добавляет новую пару «ключ-значение» в синхронизированный кэш.</span><span class="sxs-lookup"><span data-stu-id="01c08-344">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="01c08-345">Если ключ уже находится в кэше, исключение, выдаваемое внутренним <xref:System.Collections.Generic.Dictionary%602>, может завершить метод.</span><span class="sxs-lookup"><span data-stu-id="01c08-345">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="01c08-346">Блок `finally` используется для выполнения метода <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>, гарантируя, что вызывающий объект выходит из режима записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-346">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span>  
  
 <span data-ttu-id="01c08-347">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="01c08-347">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="01c08-348">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку в любом из режимов.</span><span class="sxs-lookup"><span data-stu-id="01c08-348">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="01c08-349">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-349">-or-</span></span> 
<span data-ttu-id="01c08-350">Текущий поток вступил в режим чтения и еще не имеет блокировки записи, поэтому попытка войти в режим блокировки в режиме записи создаст возможность взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-350">The current thread has entered read mode and doesn't already own a write lock, so trying to enter the lock in write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="01c08-351">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-351">-or-</span></span> 
<span data-ttu-id="01c08-352">Глубина рекурсии превышает емкость счетчика.</span><span class="sxs-lookup"><span data-stu-id="01c08-352">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="01c08-353">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</span><span class="sxs-lookup"><span data-stu-id="01c08-353">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="01c08-354">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="01c08-354">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01c08-355">Уменьшает счетчик глубины рекурсии для режима чтения и выходит из режима чтения, если счетчик принял значение 0 (нуль).</span><span class="sxs-lookup"><span data-stu-id="01c08-355">Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-356">Этот метод не зависит от порядка рекурсии.</span><span class="sxs-lookup"><span data-stu-id="01c08-356">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="01c08-357">Например, если поток входит в блокировку в обновляемом режиме, а затем входит в блокировку в режиме чтения, то порядок, в котором поток выходит из двух режимов, не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="01c08-357">For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="01c08-358">Если блокировка допускает рекурсию, поток может войти в блокировку в режиме записи, а затем ввести ее рекурсивно в режиме чтения. порядок, в котором поток выходит из режима чтения и записи, не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="01c08-358">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="01c08-359">Выход из блокировки может подать сигнал другим ожидающим потокам.</span><span class="sxs-lookup"><span data-stu-id="01c08-359">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-360">В следующем примере показано, как использовать блок `finally` для выполнения метода <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>, гарантируя, что вызывающий объект выходит из режима чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-360">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span> <span data-ttu-id="01c08-361">Метод, показанный в примере, извлекает значение, связанное с ключом.</span><span class="sxs-lookup"><span data-stu-id="01c08-361">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="01c08-362">Если ключ не найден, то исключение, созданное внутренним <xref:System.Collections.Generic.Dictionary%602>, может завершить метод.</span><span class="sxs-lookup"><span data-stu-id="01c08-362">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="01c08-363">Для входа в режим чтения используется метод <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="01c08-363">The <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method is used to enter read mode.</span></span>  
  
 <span data-ttu-id="01c08-364">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="01c08-364">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="01c08-365">Текущий поток не вошел в блокировку в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-365">The current thread has not entered the lock in read mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01c08-366">Уменьшает счетчик глубины рекурсии для обновляемого режима и выходит из обновляемого режима, если счетчик принял значение 0 (нуль).</span><span class="sxs-lookup"><span data-stu-id="01c08-366">Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-367">Этот метод не зависит от порядка рекурсии.</span><span class="sxs-lookup"><span data-stu-id="01c08-367">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="01c08-368">Например, если поток входит в блокировку в обновляемом режиме, а затем входит в блокировку в режиме записи, то порядок, в котором поток выходит из двух режимов, не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="01c08-368">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="01c08-369">Если блокировка допускает рекурсию, поток может войти в блокировку в режиме записи, а затем ввести ее рекурсивно в обновляемом режиме. порядок, в котором поток выходит из обновляемого режима и режима записи, не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="01c08-369">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="01c08-370">Выход из блокировки может подать сигнал другим ожидающим потокам.</span><span class="sxs-lookup"><span data-stu-id="01c08-370">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-371">В следующем примере показано, как использовать блок `finally` для выполнения метода <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>, гарантируя, что вызывающий объект завершает обновляемый режим.</span><span class="sxs-lookup"><span data-stu-id="01c08-371">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="01c08-372">Метод, показанный в примере, извлекает значение, связанное с ключом, и сравнивает его с новым значением.</span><span class="sxs-lookup"><span data-stu-id="01c08-372">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="01c08-373">Если значение не изменилось, метод возвращает состояние, указывающее на отсутствие изменений.</span><span class="sxs-lookup"><span data-stu-id="01c08-373">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="01c08-374">Для ключа не найдено значение, вставляется пара "ключ — значение".</span><span class="sxs-lookup"><span data-stu-id="01c08-374">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="01c08-375">Если значение изменилось, оно обновляется.</span><span class="sxs-lookup"><span data-stu-id="01c08-375">If the value has changed, it is updated.</span></span> <span data-ttu-id="01c08-376">Обновляемый режим позволяет потоку обновлять блокировку чтения по мере необходимости без риска взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="01c08-376">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="01c08-377">В примере используется конструктор без параметров для создания блокировки, поэтому рекурсия не разрешена.</span><span class="sxs-lookup"><span data-stu-id="01c08-377">The example uses the parameterless constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="01c08-378">Программирование <xref:System.Threading.ReaderWriterLockSlim> проще и менее подвержено ошибкам, если блокировка не допускает рекурсии.</span><span class="sxs-lookup"><span data-stu-id="01c08-378">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="01c08-379">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="01c08-379">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="01c08-380">Текущий поток не вошел в блокировку в обновляемом режиме.</span><span class="sxs-lookup"><span data-stu-id="01c08-380">The current thread has not entered the lock in upgradeable mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="01c08-381">Уменьшает счетчик глубины рекурсии для режима записи и выходит из режима записи, если счетчик принял значение 0 (нуль).</span><span class="sxs-lookup"><span data-stu-id="01c08-381">Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-382">Этот метод не зависит от порядка рекурсии.</span><span class="sxs-lookup"><span data-stu-id="01c08-382">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="01c08-383">Например, если поток входит в блокировку в обновляемом режиме, а затем входит в блокировку в режиме записи, то порядок, в котором поток выходит из двух режимов, не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="01c08-383">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="01c08-384">Если блокировка допускает рекурсию, поток может войти в блокировку в режиме записи, а затем ввести ее рекурсивно в режиме чтения. порядок, в котором поток выходит из режима чтения и записи, не имеет значения.</span><span class="sxs-lookup"><span data-stu-id="01c08-384">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="01c08-385">Выход из блокировки может подать сигнал другим ожидающим потокам.</span><span class="sxs-lookup"><span data-stu-id="01c08-385">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-386">В следующем примере показано, как использовать блок `finally` для выполнения метода <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>, гарантируя, что вызывающий объект выходит из режима записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-386">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span> <span data-ttu-id="01c08-387">Метод, показанный в примере, добавляет новую пару «ключ-значение» в синхронизированный кэш.</span><span class="sxs-lookup"><span data-stu-id="01c08-387">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="01c08-388">Если ключ уже находится в кэше, исключение, выдаваемое внутренним <xref:System.Collections.Generic.Dictionary%602>, может завершить метод.</span><span class="sxs-lookup"><span data-stu-id="01c08-388">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="01c08-389">Метод <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> используется для входа в блокировку в режиме записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-389">The <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method is used to enter the lock in write mode.</span></span>  
  
 <span data-ttu-id="01c08-390">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="01c08-390">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="01c08-391">Текущий поток не вошел в блокировку в режиме записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-391">The current thread has not entered the lock in write mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01c08-392">Получает значение, указывающее, вошел ли текущий поток в блокировку в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-392">Gets a value that indicates whether the current thread has entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="01c08-393">Значение <see langword="true" />, если текущий поток вошел в режим чтения; в противном случае <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="01c08-393"><see langword="true" /> if the current thread has entered read mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-394">Это свойство предназначено для использования в утверждениях или для других целей отладки.</span><span class="sxs-lookup"><span data-stu-id="01c08-394">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="01c08-395">Не используйте его для управления потоком выполнения программы.</span><span class="sxs-lookup"><span data-stu-id="01c08-395">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-396">В следующем примере показано, как использовать свойство <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> для создания Assert, если текущий поток неожиданно перешел в режим чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-396">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> property to generate an assert if the current thread has entered read mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01c08-397">Возвращает значение, указывающее, вошел ли текущий поток в блокировку в обновляемом режиме.</span><span class="sxs-lookup"><span data-stu-id="01c08-397">Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="01c08-398">Значение <see langword="true" />, если текущий поток вошел в обновляемый режим, противном случае – <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="01c08-398"><see langword="true" /> if the current thread has entered upgradeable mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-399">Это свойство предназначено для использования в утверждениях или для других целей отладки.</span><span class="sxs-lookup"><span data-stu-id="01c08-399">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="01c08-400">Не используйте его для управления потоком выполнения программы.</span><span class="sxs-lookup"><span data-stu-id="01c08-400">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-401">В следующем примере показано, как использовать свойство <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> для создания утверждения, если текущий поток неожиданно перешел в обновляемый режим.</span><span class="sxs-lookup"><span data-stu-id="01c08-401">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01c08-402">Получает значение, указывающее, вошел ли текущий поток в блокировку в режиме записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-402">Gets a value that indicates whether the current thread has entered the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="01c08-403">Значение <see langword="true" />, если текущий поток вошел в режим записи; в противном случае <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="01c08-403"><see langword="true" /> if the current thread has entered write mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-404">Это свойство предназначено для использования в утверждениях или для других целей отладки.</span><span class="sxs-lookup"><span data-stu-id="01c08-404">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="01c08-405">Не используйте его для управления потоком выполнения программы.</span><span class="sxs-lookup"><span data-stu-id="01c08-405">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-406">В следующем примере показано, как использовать свойство <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> для создания Assert, если текущий поток неожиданно перешел в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-406">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> property to generate an assert if the current thread has entered write mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01c08-407">Возвращает значение, указывающее политику рекурсии для текущего объекта <see cref="T:System.Threading.ReaderWriterLockSlim" />.</span><span class="sxs-lookup"><span data-stu-id="01c08-407">Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</span></span></summary>
        <value><span data-ttu-id="01c08-408">Одно из значений перечисления, определяющее политику рекурсии блокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-408">One of the enumeration values that specifies the lock recursion policy.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-409">Политика рекурсии определяет ограничения для потоков, которые вводят блокировку несколько раз.</span><span class="sxs-lookup"><span data-stu-id="01c08-409">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="01c08-410">Например, если блокировка была создана с <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> и поток вошел в блокировку в режиме чтения, <xref:System.Threading.LockRecursionException> создается, если поток пытается повторно войти в блокировку в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-410">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-411">Поток в обновляемом режиме может обновиться до режима записи или перехода на более раннюю версию в режиме чтения независимо от параметра политики рекурсии блокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-411">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="01c08-412">Независимо от политики рекурсии потоку, который изначально перешел в режим чтения, запрещено обновление до обновляемого режима или режима записи, поскольку этот шаблон создает строгую вероятность взаимоблокировок.</span><span class="sxs-lookup"><span data-stu-id="01c08-412">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="01c08-413">Дополнительные сведения о политике рекурсии и ее эффектах см. в разделе Перечисление <xref:System.Threading.LockRecursionPolicy> и класс <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="01c08-413">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01c08-414">Получает количество раз, которые текущий поток входил в блокировку в режиме чтения, как показатель рекурсии.</span><span class="sxs-lookup"><span data-stu-id="01c08-414">Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="01c08-415">0 (ноль), если текущий поток не вошел в режим чтения, 1, если поток вошел в режим чтения, но не вошел в него рекурсивно, или *n* , если поток вошел в блокировку рекурсивно *n* -1 раз.</span><span class="sxs-lookup"><span data-stu-id="01c08-415">0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-416">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</span><span class="sxs-lookup"><span data-stu-id="01c08-416">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="01c08-417">Результаты могут измениться, как только они будут вычислены.</span><span class="sxs-lookup"><span data-stu-id="01c08-417">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="01c08-418">Поэтому не рекомендуется принимать решения на основе этого свойства.</span><span class="sxs-lookup"><span data-stu-id="01c08-418">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01c08-419">Получает количество раз, которые текущий поток входил в блокировку в обновляемом режиме, как показатель рекурсии.</span><span class="sxs-lookup"><span data-stu-id="01c08-419">Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="01c08-420">0, если текущий поток не вошел в обновляемый режим, 1, если поток вошел в обновляемый режим, но не вошел в него рекурсивно, или *n* , если поток вошел в обновляемый режим рекурсивно *n* – 1 раз.</span><span class="sxs-lookup"><span data-stu-id="01c08-420">0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-421">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</span><span class="sxs-lookup"><span data-stu-id="01c08-421">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="01c08-422">Результаты могут измениться, как только они будут вычислены.</span><span class="sxs-lookup"><span data-stu-id="01c08-422">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="01c08-423">Поэтому не рекомендуется принимать решения на основе этого свойства.</span><span class="sxs-lookup"><span data-stu-id="01c08-423">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01c08-424">Получает количество раз, которые текущий поток входил в блокировку в режиме записи, как показатель рекурсии.</span><span class="sxs-lookup"><span data-stu-id="01c08-424">Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="01c08-425">0, если текущий поток не вошел в режим записи, 1, если поток вошел в режим записи, но не вошел в него рекурсивно, или *n* , если поток вошел в режим записи рекурсивно *n* -1 раз.</span><span class="sxs-lookup"><span data-stu-id="01c08-425">0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-426">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</span><span class="sxs-lookup"><span data-stu-id="01c08-426">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="01c08-427">Результаты могут измениться, как только они будут вычислены.</span><span class="sxs-lookup"><span data-stu-id="01c08-427">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="01c08-428">Поэтому не рекомендуется принимать решения на основе этого свойства.</span><span class="sxs-lookup"><span data-stu-id="01c08-428">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="01c08-429">Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-429">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="01c08-430">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-430">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="01c08-431">Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания целым числом.</span><span class="sxs-lookup"><span data-stu-id="01c08-431">Tries to enter the lock in read mode, with an optional integer time-out.</span></span></summary>
        <returns><span data-ttu-id="01c08-432">Значение <see langword="true" />, если вызывающий поток вошел в режим чтения; в противном случае <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="01c08-432"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-433">Если `millisecondsTimeout` равен 0 (нулю), этот метод проверяет состояние блокировки и возвращает `false` немедленно, если требуемое состояние недоступно.</span><span class="sxs-lookup"><span data-stu-id="01c08-433">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="01c08-434">Несколько потоков могут одновременно войти в режим чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-434">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="01c08-435">Если один или несколько потоков ожидают входа в режим записи, то поток, вызывающий метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>, блокируется до тех пор, пока эти потоки не истечет время ожидания или не перейдет в режим записи, а затем вышли из него или пока не истечет собственный интервал времени ожидания вызывающего потока.</span><span class="sxs-lookup"><span data-stu-id="01c08-435">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-436">Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме чтения, может войти в режим чтения рекурсивно, даже если другие потоки ожидают входа в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-436">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="01c08-437">Один поток может находиться в обновляемом режиме, в то время как другие потоки находятся в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-437">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="01c08-438">Если дополнительные потоки ожидают входа в обновляемый режим и отсутствуют потоки, ожидающие входа в режим записи, потоки, вызывающие метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>, немедленно переводятся в режим чтения и не блокируют.</span><span class="sxs-lookup"><span data-stu-id="01c08-438">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="01c08-439">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.</span><span class="sxs-lookup"><span data-stu-id="01c08-439">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="01c08-440">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-440">-or-</span></span> 
<span data-ttu-id="01c08-441">Глубина рекурсии превышает емкость счетчика.</span><span class="sxs-lookup"><span data-stu-id="01c08-441">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="01c08-442">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</span><span class="sxs-lookup"><span data-stu-id="01c08-442">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01c08-443">Значение параметра <paramref name="millisecondsTimeout" /> меньше нуля, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="01c08-443">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="01c08-444">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="01c08-444">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="01c08-445">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</span><span class="sxs-lookup"><span data-stu-id="01c08-445">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="01c08-446">Пытается войти в блокировку в режиме чтения с необязательным указанием времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-446">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="01c08-447">Значение <see langword="true" />, если вызывающий поток вошел в режим чтения; в противном случае <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="01c08-447"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-448">Если `timeout` равен 0 (нулю), этот метод проверяет состояние блокировки и возвращает `false` немедленно, если требуемое состояние недоступно.</span><span class="sxs-lookup"><span data-stu-id="01c08-448">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="01c08-449">Несколько потоков могут одновременно войти в блокировку в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-449">Multiple threads can enter the lock in read mode at the same time.</span></span>  
  
 <span data-ttu-id="01c08-450">Если один или несколько потоков помещаются в очередь для входа в режим записи, поток, вызывающий метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>, блокируется до тех пор, пока эти потоки не истечет время ожидания или не перейдет в режим записи, а затем не выйдет из него или не истечет собственный интервал времени ожидания вызывающего потока.</span><span class="sxs-lookup"><span data-stu-id="01c08-450">If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-451">Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме чтения, может войти в режим чтения рекурсивно, даже если другие потоки ожидают входа в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-451">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="01c08-452">Один поток может находиться в обновляемом режиме, в то время как другие потоки находятся в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-452">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="01c08-453">Если дополнительные потоки ожидают входа в обновляемый режим и отсутствуют потоки, ожидающие входа в режим записи, потоки, вызывающие метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>, немедленно переводятся в режим чтения и не блокируют.</span><span class="sxs-lookup"><span data-stu-id="01c08-453">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="01c08-454">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.</span><span class="sxs-lookup"><span data-stu-id="01c08-454">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="01c08-455">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-455">-or-</span></span> 
<span data-ttu-id="01c08-456">Глубина рекурсии превышает емкость счетчика.</span><span class="sxs-lookup"><span data-stu-id="01c08-456">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="01c08-457">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</span><span class="sxs-lookup"><span data-stu-id="01c08-457">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01c08-458">Значение параметра <paramref name="timeout" /> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="01c08-458">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="01c08-459">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-459">-or-</span></span> 
<span data-ttu-id="01c08-460">Значение <paramref name="timeout" /> больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="01c08-460">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="01c08-461">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="01c08-461">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="01c08-462">Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-462">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="01c08-463">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-463">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="01c08-464">Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-464">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="01c08-465">Значение <see langword="true" />, если вызывающий поток вошел в обновляемый режим; в противном случае <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="01c08-465"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-466">Если `millisecondsTimeout` равен 0 (нулю), этот метод проверяет состояние блокировки и возвращает `false` немедленно, если требуемое состояние недоступно.</span><span class="sxs-lookup"><span data-stu-id="01c08-466">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="01c08-467">Используйте обновляемый режим, когда поток обычно обращается к ресурсу, защищенному <xref:System.Threading.ReaderWriterLockSlim>ом в режиме чтения, но при соблюдении определенных условий может потребоваться вход в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-467">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="01c08-468">Поток в обновляемом режиме может обновиться до режима записи или перехода на более раннюю версию в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-468">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="01c08-469">Только один поток может войти в блокировку в обновляемом режиме в любое заданное время.</span><span class="sxs-lookup"><span data-stu-id="01c08-469">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="01c08-470">Если поток находится в обновляемом режиме и отсутствуют потоки, ожидающие входа в режим записи, любое число других потоков может войти в режим чтения, даже если есть потоки, ожидающие входа в обновляемый режим.</span><span class="sxs-lookup"><span data-stu-id="01c08-470">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="01c08-471">Если один или несколько потоков ожидают входа в режим записи, то поток, вызывающий метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>, блокируется до тех пор, пока эти потоки не истечет время ожидания или не перейдет в режим записи, а затем вышли из него или пока не истечет собственный интервал времени ожидания вызывающего потока.</span><span class="sxs-lookup"><span data-stu-id="01c08-471">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-472">Если блокировка допускает рекурсию, поток, который вошел в блокировку в обновляемом режиме, может войти в обновляемый режим рекурсивно, даже если другие потоки ожидают входа в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-472">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="01c08-473">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.</span><span class="sxs-lookup"><span data-stu-id="01c08-473">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="01c08-474">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-474">-or-</span></span> 
<span data-ttu-id="01c08-475">Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-475">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="01c08-476">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-476">-or-</span></span> 
<span data-ttu-id="01c08-477">Глубина рекурсии превышает емкость счетчика.</span><span class="sxs-lookup"><span data-stu-id="01c08-477">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="01c08-478">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</span><span class="sxs-lookup"><span data-stu-id="01c08-478">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01c08-479">Значение параметра <paramref name="millisecondsTimeout" /> меньше нуля, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="01c08-479">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="01c08-480">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="01c08-480">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="01c08-481">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</span><span class="sxs-lookup"><span data-stu-id="01c08-481">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="01c08-482">Пытается войти в блокировку в обновляемом режиме с необязательным указанием времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-482">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="01c08-483">Значение <see langword="true" />, если вызывающий поток вошел в обновляемый режим; в противном случае <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="01c08-483"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-484">Если `timeout` равен 0 (нулю), этот метод проверяет состояние блокировки и возвращает `false` немедленно, если требуемое состояние недоступно.</span><span class="sxs-lookup"><span data-stu-id="01c08-484">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="01c08-485">Используйте обновляемый режим, когда поток обычно обращается к ресурсу, защищенному <xref:System.Threading.ReaderWriterLockSlim>ом в режиме чтения, но при соблюдении определенных условий может потребоваться вход в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-485">Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="01c08-486">Поток в обновляемом режиме может обновиться до режима записи или перехода на более раннюю версию в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-486">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="01c08-487">Только один поток может войти в блокировку в обновляемом режиме в любое заданное время.</span><span class="sxs-lookup"><span data-stu-id="01c08-487">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="01c08-488">Если поток находится в обновляемом режиме и отсутствуют потоки, ожидающие входа в режим записи, любое число других потоков может войти в режим чтения, даже если есть потоки, ожидающие входа в обновляемый режим.</span><span class="sxs-lookup"><span data-stu-id="01c08-488">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="01c08-489">Если один или несколько потоков ожидают входа в режим записи, то поток, вызывающий метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>, блокируется до тех пор, пока эти потоки не истечет время ожидания или не перейдет в режим записи, а затем вышли из него или пока не истечет собственный интервал времени ожидания вызывающего потока.</span><span class="sxs-lookup"><span data-stu-id="01c08-489">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-490">Если блокировка допускает рекурсию, поток, который вошел в блокировку в обновляемом режиме, может войти в обновляемый режим рекурсивно, даже если другие потоки ожидают входа в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-490">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="01c08-491">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.</span><span class="sxs-lookup"><span data-stu-id="01c08-491">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="01c08-492">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-492">-or-</span></span> 
<span data-ttu-id="01c08-493">Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в обновляемый режим создаст возможность взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-493">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="01c08-494">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-494">-or-</span></span> 
<span data-ttu-id="01c08-495">Глубина рекурсии превышает емкость счетчика.</span><span class="sxs-lookup"><span data-stu-id="01c08-495">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="01c08-496">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</span><span class="sxs-lookup"><span data-stu-id="01c08-496">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01c08-497">Значение параметра <paramref name="timeout" /> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="01c08-497">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="01c08-498">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-498">-or-</span></span> 
<span data-ttu-id="01c08-499">Значение <paramref name="timeout" /> больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="01c08-499">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="01c08-500">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="01c08-500">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="01c08-501">Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-501">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="01c08-502">Время ожидания в миллисекундах или -1 (<see cref="F:System.Threading.Timeout.Infinite" />) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-502">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="01c08-503">Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-503">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="01c08-504">Значение <see langword="true" />, если вызывающий поток вошел в режим записи, иначе — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="01c08-504"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-505">Если `millisecondsTimeout` равен 0 (нулю), этот метод проверяет состояние блокировки и возвращает `false` немедленно, если требуемое состояние недоступно.</span><span class="sxs-lookup"><span data-stu-id="01c08-505">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="01c08-506">Если другие потоки вошел в блокировку в режиме чтения, поток, вызывающий метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>, блокируется до тех пор, пока эти потоки не вышли из режима чтения или пока не истечет интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-506">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="01c08-507">Пока потоки заблокированы в ожидании входа в режим записи, дополнительные потоки, пытающиеся войти в режим чтения или обновляемый блок режима, пока не истечет время ожидания всех потоков, ожидающих входа в режим записи, или не перейдет в режим записи, а затем вышли из нее.</span><span class="sxs-lookup"><span data-stu-id="01c08-507">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-508">Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме записи, может войти в режим записи рекурсивно, даже если другие потоки ожидают входа в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-508">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-509">В следующем примере показано, как использовать метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> для входа в блокировку в режиме записи с истечением времени ожидания. Метод, показанный в примере, добавляет новую пару «ключ-значение» в синхронизированный кэш.</span><span class="sxs-lookup"><span data-stu-id="01c08-509">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="01c08-510">Если указанный интервал времени ожидания истекает до того, как поток войдет в блокировку, метод возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="01c08-510">If the specified time-out interval elapses before the thread enters the lock, the method returns `false`.</span></span> <span data-ttu-id="01c08-511">Метод возвращает `true` при добавлении пары "ключ-значение".</span><span class="sxs-lookup"><span data-stu-id="01c08-511">The method returns `true` if the key/value pair is added.</span></span>  
  
 <span data-ttu-id="01c08-512">Если ключ уже находится в кэше, исключение, выдаваемое внутренним <xref:System.Collections.Generic.Dictionary%602>, может завершить метод.</span><span class="sxs-lookup"><span data-stu-id="01c08-512">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="01c08-513">Блок `finally` используется для выполнения метода <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>, гарантируя, что вызывающий объект завершает блокировку.</span><span class="sxs-lookup"><span data-stu-id="01c08-513">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits the lock.</span></span>  
  
 <span data-ttu-id="01c08-514">Этот код является частью большого примера, приведенного для класса <xref:System.Threading.ReaderWriterLockSlim>.</span><span class="sxs-lookup"><span data-stu-id="01c08-514">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="01c08-515">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.</span><span class="sxs-lookup"><span data-stu-id="01c08-515">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="01c08-516">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-516">-or-</span></span> 
<span data-ttu-id="01c08-517">Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в режим записи создаст возможность взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-517">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="01c08-518">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-518">-or-</span></span> 
<span data-ttu-id="01c08-519">Глубина рекурсии превышает емкость счетчика.</span><span class="sxs-lookup"><span data-stu-id="01c08-519">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="01c08-520">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</span><span class="sxs-lookup"><span data-stu-id="01c08-520">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01c08-521">Значение параметра <paramref name="millisecondsTimeout" /> меньше нуля, но не равно <see cref="F:System.Threading.Timeout.Infinite" /> (-1), которое является единственным допустимым отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="01c08-521">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="01c08-522">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="01c08-522">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="01c08-523">Период ожидания или значение -1 миллисекунда для ожидания в течение неограниченного времени.</span><span class="sxs-lookup"><span data-stu-id="01c08-523">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="01c08-524">Пытается войти в блокировку в режиме записи с необязательным указанием времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-524">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="01c08-525">Значение <see langword="true" />, если вызывающий поток вошел в режим записи, иначе — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="01c08-525"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-526">Если `timeout` равен 0 (нулю), этот метод проверяет состояние блокировки и возвращает `false` немедленно, если требуемое состояние недоступно.</span><span class="sxs-lookup"><span data-stu-id="01c08-526">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="01c08-527">Если другие потоки вошел в блокировку в режиме чтения, поток, вызывающий метод <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>, блокируется до тех пор, пока эти потоки не вышли из режима чтения или пока не истечет интервал времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="01c08-527">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="01c08-528">Пока потоки заблокированы в ожидании входа в режим записи, дополнительные потоки, пытающиеся войти в режим чтения или обновляемый блок режима, пока не истечет время ожидания всех потоков, ожидающих входа в режим записи, или не перейдет в режим записи, а затем вышли из нее.</span><span class="sxs-lookup"><span data-stu-id="01c08-528">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="01c08-529">Если блокировка допускает рекурсию, поток, который вошел в блокировку в режиме записи, может войти в режим записи рекурсивно, даже если другие потоки ожидают входа в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-529">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="01c08-530">Свойство <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> имеет значение <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, а текущий поток уже вошел в блокировку.</span><span class="sxs-lookup"><span data-stu-id="01c08-530">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="01c08-531">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-531">-or-</span></span> 
<span data-ttu-id="01c08-532">Текущий поток изначально вошел в блокировку в режиме чтения, поэтому попытка войти в режим записи создаст возможность взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="01c08-532">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="01c08-533">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-533">-or-</span></span> 
<span data-ttu-id="01c08-534">Глубина рекурсии превышает емкость счетчика.</span><span class="sxs-lookup"><span data-stu-id="01c08-534">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="01c08-535">Ограничение допускает настолько большое число рекурсивных вхождений, что оно не должно достигаться приложениями на практике.</span><span class="sxs-lookup"><span data-stu-id="01c08-535">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="01c08-536">Значение параметра <paramref name="timeout" /> отрицательное, но оно не равно -1 миллисекунде, которое является единственным допустимым отрицательным значением.</span><span class="sxs-lookup"><span data-stu-id="01c08-536">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="01c08-537">-или-</span><span class="sxs-lookup"><span data-stu-id="01c08-537">-or-</span></span> 
<span data-ttu-id="01c08-538">Значение <paramref name="timeout" /> больше <see cref="F:System.Int32.MaxValue" /> миллисекунд.</span><span class="sxs-lookup"><span data-stu-id="01c08-538">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="01c08-539">Объект <see cref="T:System.Threading.ReaderWriterLockSlim" /> был удален.</span><span class="sxs-lookup"><span data-stu-id="01c08-539">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01c08-540">Получает общее количество потоков, ожидающих вхождения в блокировку в режиме чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-540">Gets the total number of threads that are waiting to enter the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="01c08-541">Общее количество потоков, ожидающих вхождения в режим чтения.</span><span class="sxs-lookup"><span data-stu-id="01c08-541">The total number of threads that are waiting to enter read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-542">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</span><span class="sxs-lookup"><span data-stu-id="01c08-542">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="01c08-543">Результаты могут измениться, как только они будут вычислены.</span><span class="sxs-lookup"><span data-stu-id="01c08-543">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="01c08-544">Поэтому не рекомендуется принимать решения на основе этого свойства.</span><span class="sxs-lookup"><span data-stu-id="01c08-544">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-545">В следующем примере показано, как использовать свойство <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> для создания записи в журнале событий, если число заблокированных потоков, ожидающих входа в режим чтения, превышает пороговое значение.</span><span class="sxs-lookup"><span data-stu-id="01c08-545">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01c08-546">Получает общее количество потоков, ожидающих входа в блокировку в обновляемом режиме.</span><span class="sxs-lookup"><span data-stu-id="01c08-546">Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="01c08-547">Общее количество потоков, ожидающих входа в обновляемый режим.</span><span class="sxs-lookup"><span data-stu-id="01c08-547">The total number of threads that are waiting to enter upgradeable mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-548">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</span><span class="sxs-lookup"><span data-stu-id="01c08-548">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="01c08-549">Результаты могут измениться, как только они будут вычислены.</span><span class="sxs-lookup"><span data-stu-id="01c08-549">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="01c08-550">Поэтому не рекомендуется принимать решения на основе этого свойства.</span><span class="sxs-lookup"><span data-stu-id="01c08-550">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-551">В следующем примере показано, как использовать свойство <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> для создания записи в журнале событий, если число заблокированных потоков, ожидающих входа в обновляемый режим, превышает пороговое значение.</span><span class="sxs-lookup"><span data-stu-id="01c08-551">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="01c08-552">Получает общее количество потоков, ожидающих входа в блокировку в режиме записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-552">Gets the total number of threads that are waiting to enter the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="01c08-553">Общее количество потоков, ожидающих входа в режим записи.</span><span class="sxs-lookup"><span data-stu-id="01c08-553">The total number of threads that are waiting to enter write mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="01c08-554">Это свойство используется только для отладки, профилирования и ведения журнала, а не для управления поведением алгоритма.</span><span class="sxs-lookup"><span data-stu-id="01c08-554">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="01c08-555">Результаты могут измениться, как только они будут вычислены.</span><span class="sxs-lookup"><span data-stu-id="01c08-555">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="01c08-556">Поэтому не рекомендуется принимать решения на основе этого свойства.</span><span class="sxs-lookup"><span data-stu-id="01c08-556">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="01c08-557">В следующем примере показано, как использовать свойство <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> для создания записи в журнале событий, если число заблокированных потоков, ожидающих входа в режим записи, превышает пороговое значение.</span><span class="sxs-lookup"><span data-stu-id="01c08-557">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
