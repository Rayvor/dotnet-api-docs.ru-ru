<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d1155367ffed453c9616698e60c5a31d0ab90cef" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70610536" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Примитив синхронизации, который также может использоваться в межпроцессорной синхронизации.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда двум или более потокам требуется одновременный доступ к общему ресурсу, системе необходим механизм синхронизации, гарантирующий, что ресурс будет использоваться только одним потоком в каждый момент времени. <xref:System.Threading.Mutex>— это примитив синхронизации, предоставляющий эксклюзивный доступ к общему ресурсу только одному потоку. Если поток получает мьютекс, второй поток, желающий получить этот мьютекс, приостанавливается до тех пор, пока первый поток не освободит мьютекс.  
  
> [!IMPORTANT]
>  Этот тип реализует интерфейс <xref:System.IDisposable>. По окончании использования выдаленную ему память следует прямо или косвенно освободить. Чтобы сделать это прямо, вызовите его метод <xref:System.IDisposable.Dispose%2A> в блоке `try`/`catch`. Чтобы сделать это косвенно, используйте языковые конструкции, такие как `using` (в C#) или `Using` (в Visual Basic). Дополнительные сведения см. в разделе "Использование объекта, реализующего IDisposable" в статье об интерфейсе <xref:System.IDisposable>.  
  
 <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Метод можно использовать для запроса владения мьютексом. Вызывающий поток блокируется до тех пор, пока не произойдет одно из следующих событий:  
  
-   Мьютекс получает сигнал, указывающий, что он не принадлежит. В <xref:System.Threading.WaitHandle.WaitOne%2A> этом случае метод возвращает `true`значение, и вызывающий поток принимает владение мьютексом и обращается к ресурсу, защищенному мьютексом. После завершения доступа к ресурсу поток должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод, чтобы освободить владение мьютексом. В первом примере в разделе "примеры" показан этот шаблон.  
  
-   Истекает интервал времени ожидания, указанный в вызове <xref:System.Threading.WaitHandle.WaitOne%2A> метода с `millisecondsTimeout` параметром или `timeout` . В этом случае метод возвращает <xref:System.Threading.WaitHandle.WaitOne%2A> `false`значение, и вызывающий поток не предпринимает дальнейших попыток получить владение мьютексом. В этом случае необходимо структурировать код таким образом, чтобы доступ к ресурсу, защищенному мьютексом, был запрещен вызывающему потоку. Поскольку поток никогда не получил владение мьютексом, он не должен вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод. Второй пример в разделе "примеры" иллюстрирует этот шаблон.  
  
 <xref:System.Threading.Mutex> Класс применяет удостоверение потока, поэтому мьютекс может быть освобожден только потоком, который его получил. В <xref:System.Threading.Semaphore> отличие от этого, класс не применяет удостоверение потока. Мьютекс также может передаваться через границы домена приложения.  
  
 Поток, владеющий мьютексом, может запрашивать один и тот же мьютекс <xref:System.Threading.WaitHandle.WaitOne%2A> в повторяющихся вызовах без блокирования его выполнения. Однако поток должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод таким же количество раз, чтобы освободить владение мьютексом.  
  
 Поскольку класс наследуется от <xref:System.Threading.WaitHandle>, можно также вызвать статические <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> методы и <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> для синхронизации доступа к защищенному ресурсу. <xref:System.Threading.Mutex>  
  
 Если поток завершается во время владения мьютексом, мьютекс считается брошенным. Состояние мьютекса имеет значение "сигнальный", а следующий ожидающий поток получает владение. Начиная с версии 2,0 .NET Framework, <xref:System.Threading.AbandonedMutexException> в следующем потоке, который получает брошенный мьютекс, создается исключение. До версии 2,0 .NET Framework не было создано исключение.  
  
> [!CAUTION]
>  Брошенный мьютекс часто указывает на серьезную ошибку в коде. Когда поток завершает работу, не освобождая мьютекс, структуры данных, защищенные мьютексом, могут находиться в непротиворечивом состоянии. Следующий поток, запрашивающий владение мьютексом, может обрабатывать это исключение и продолжать, если целостность структур данных может быть проверена.  
  
 В случае системного мьютекса брошенный мьютекс может указывать на то, что работа приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).  
  
 Мьютексы бывают двух типов: локальные мьютексы, которые являются неименованными, и именованные системные мьютексы. Локальный мьютекс существует только в вашем процессе. Он может использоваться любым потоком в процессе, имеющим ссылку на <xref:System.Threading.Mutex> объект, представляющий мьютекс. Каждый неименованный <xref:System.Threading.Mutex> объект представляет отдельный локальный мьютекс.  
  
 Именованные системные мьютексы видимы во всей операционной системе и могут использоваться для синхронизации действий процессов. Можно создать <xref:System.Threading.Mutex> объект, представляющий именованный системный мьютекс, с помощью конструктора, принимающего имя. Объект операционной системы может быть создан одновременно, или же он может существовать до создания <xref:System.Threading.Mutex> объекта. Вы можете создать сразу несколько объектов <xref:System.Threading.Mutex>, представляющих один и тот именованный системный мьютекс, а также открывать именованный системный мьютекс с помощью метода <xref:System.Threading.Mutex.OpenExisting%2A>.  
  
> [!NOTE]
>  На сервере, на котором выполняются службы терминалов, именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса "Global\\", мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса Local\\, мьютекс является видимым только в сеансе сервера терминалов, где он был создан. В этом случае отдельный мьютекс с одним и тем же именем может существовать в каждом сеансе сервера терминалов на сервере. Если префикс не указан при создании именованного мьютекса, он принимает префикс Local\\. В сеансе сервера терминалов два мьютекса, имена которых отличаются только префиксами, являются отдельными мьютексами, и оба они видимы для всех процессов в сеансе сервера терминалов. То есть префикс именуется "Global\\" и "Local\\", описывающий область действия имени мьютекса относительно сеансов сервера терминалов, а не относительно процессов.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 В этом примере показано, как <xref:System.Threading.Mutex> локальный объект используется для синхронизации доступа к защищенному ресурсу. Поскольку каждый вызывающий поток блокируется до тех пор, пока не получит владение мьютексом, <xref:System.Threading.Mutex.ReleaseMutex%2A> он должен вызвать метод, чтобы освободить владение потоком.  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 В следующем примере каждый поток вызывает <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> метод для получения мьютекса. Если интервал времени ожидания истекает, метод возвращает `false`, а поток не получает мьютекс и не получает доступ к ресурсу, который защищает мьютекс. <xref:System.Threading.Mutex.ReleaseMutex%2A> Метод вызывается только потоком, который получает мьютекс.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> стандартными свойствами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этой перегрузки конструктора аналогичен вызову <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> перегрузки конструктора `false` и указанию для первоначального владения мьютексом. То есть вызывающий поток не владеет мьютексом.  
  
   
  
## Examples  
 В следующем примере кода показано, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поток, создающий мьютекс, не владеет его изначально.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения мьютексом; в противном случае — <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, является ли вызывающий поток изначальным владельцем мьютекса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Изначально поток, который создает <xref:System.Threading.Mutex> , владеет его владельцем.  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</param>
        <param name="name">Имя <see cref="T:System.Threading.Mutex" />. Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> с логическим значением, показывающим необходимость наличия начального владения семафором у вызывающего потока, и строкой, являющейся именем семафора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `name` `initiallyOwned` параметр не `true` имеет значение и является, вызывающий поток владеет мьютексом только в том случае, если именованный системный мьютекс был создан в результате этого вызова. `null` Поскольку не существует механизма для определения того, был ли создан именованный системный мьютекс, лучше указать `false` для `initiallyOwned` при вызове этой перегрузки конструктора. Конструктор можно использовать, <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> если необходимо определить первоначальный владелец.  
  
 Этот конструктор инициализирует <xref:System.Threading.Mutex> объект, представляющий именованный системный мьютекс. Можно создать несколько <xref:System.Threading.Mutex> объектов, представляющих один и тот же именованный системный мьютекс.  
  
 Если именованный мьютекс уже создан с защитой управления доступом и у вызывающего объекта нет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, возникает исключение. Чтобы открыть существующий именованный мьютекс с только теми разрешениями, которые необходимы для синхронизации действий потока <xref:System.Threading.Mutex.OpenExisting%2A> , см. метод.  
  
 Если указать `null` или пустую строку для `name`, создается локальный мьютекс, как <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> если бы вы вызывали конструктор. В этом случае `createdNew` всегда `true`является.  
  
 Так как они являются общесистемными, именованные мьютексы можно использовать для координации использования ресурсов в пределах границ процесса.  
  
> [!NOTE]
>  На сервере, на котором выполняются службы терминалов, именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса "Global\\", мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса Local\\, мьютекс является видимым только в сеансе сервера терминалов, где он был создан. В этом случае отдельный мьютекс с одним и тем же именем может существовать в каждом сеансе сервера терминалов на сервере. Если префикс не указан при создании именованного мьютекса, он принимает префикс Local\\. В сеансе сервера терминалов два мьютекса, имена которых отличаются только префиксами, являются отдельными мьютексами, и оба они видимы для всех процессов в сеансе сервера терминалов. То есть префикс именуется "Global\\" и "Local\\", описывающий область действия имени мьютекса относительно сеансов сервера терминалов, а не относительно процессов.  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 В следующем примере показано, как именованный мьютекс используется для передачи сигналов между потоками, запущенными в двух отдельных процессах.  
  
 Запустите эту программу из двух или более командных окон. Каждый процесс создает <xref:System.Threading.Mutex> объект, представляющий именованный мьютекс `MyMutex`. Именованный мьютекс — это системный объект, время существования которого ограничено временем существования <xref:System.Threading.Mutex> объектов, представляющих его. Именованный мьютекс создается, когда первый процесс создает <xref:System.Threading.Mutex> объект. в этом примере именованный мьютекс принадлежит первому процессу, запускающему программу. Именованный мьютекс уничтожается, когда освобождаются все <xref:System.Threading.Mutex> объекты, представляющие его.  
  
 Перегрузка конструктора, используемая в этом примере, не может сообщить вызывающему потоку, был ли предоставлен первоначальный владелец именованного мьютекса. Не следует использовать этот конструктор для запроса первоначального владения, если вы не уверены, что поток создаст именованный мьютекс.  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <exception cref="T:System.ArgumentException">Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</param>
        <param name="name">Имя <see cref="T:System.Threading.Mutex" />. Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</param>
        <param name="createdNew">При возврате из метода содержит логическое значение <see langword="true" />, если был создан локальный мьютекс (то есть, если параметр <paramref name="name" /> имеет значение <see langword="null" /> или содержит пустую строку) или был создан именованный системный мьютекс; значение <see langword="false" />, если указанный именованный системный мьютекс уже существует. Этот параметр передается неинициализированным.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса, иметь строку, являющуюся именем мьютекса, и логическое значение, которое при возврате метода показывает, предоставлено ли вызывающему потоку изначальное владение мьютексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `name` параметр имеет `null` значение `initiallyOwned` Not `true`и имеет значение, вызывающий поток владеет именованным `createdNew` мьютексом, только если параметр имеет значение `true` после вызова. В противном случае поток может запросить мьютекс, вызвав <xref:System.Threading.WaitHandle.WaitOne%2A> метод.  
  
 Этот конструктор инициализирует <xref:System.Threading.Mutex> объект, представляющий именованный системный мьютекс. Можно создать несколько <xref:System.Threading.Mutex> объектов, представляющих один и тот же именованный системный мьютекс.  
  
 Если именованный мьютекс уже создан с защитой управления доступом и вызывающий объект не имеет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> прав, возникает исключение. Чтобы открыть существующий именованный мьютекс с только теми разрешениями, которые необходимы для синхронизации действий потока <xref:System.Threading.Mutex.OpenExisting%2A> , см. метод.  
  
 Если указать `null` или пустую строку для `name`, создается локальный мьютекс, как <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> если бы вы вызывали конструктор. В этом случае `createdNew` всегда `true`является.  
  
 Так как они являются общесистемными, именованные мьютексы можно использовать для координации использования ресурсов в пределах границ процесса.  
  
> [!NOTE]
>  На сервере, на котором выполняются службы терминалов, именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса "Global\\", мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса Local\\, мьютекс является видимым только в сеансе сервера терминалов, где он был создан. В этом случае отдельный мьютекс с одним и тем же именем может существовать в каждом сеансе сервера терминалов на сервере. Если префикс не указан при создании именованного мьютекса, он принимает префикс Local\\. В сеансе сервера терминалов два мьютекса, имена которых отличаются только префиксами, являются отдельными мьютексами, и оба они видимы для всех процессов в сеансе сервера терминалов. То есть префикс именуется "Global\\" и "Local\\", описывающий область действия имени мьютекса относительно сеансов сервера терминалов, а не относительно процессов.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 В следующем примере кода показано, как именованный мьютекс используется для передачи сигналов между процессами или потоками. Запустите эту программу из двух или более командных окон. Каждый процесс создает <xref:System.Threading.Mutex> объект, представляющий именованный мьютекс "мимутекс". Именованный мьютекс является системным объектом. В этом примере время существования ограничено временем существования <xref:System.Threading.Mutex> объектов, представляющих его. Именованный мьютекс создается, когда первый процесс создает свой локальный <xref:System.Threading.Mutex> объект и уничтожается, когда освобождаются <xref:System.Threading.Mutex> все объекты, представляющие его. Именованный мьютекс изначально принадлежит первому процессу. Второй процесс и все последующие процессы ожидают, пока предыдущие процессы освобождают именованный мьютекс.  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <exception cref="T:System.ArgumentException">Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">Значение <see langword="true" /> для предоставления вызывающему потоку изначального владения именованным системным мьютексом, если этот мьютекс создан данным вызовом; в противном случае — значение <see langword="false" />.</param>
        <param name="name">Имя системного мьютекса. Если значение равно <see langword="null" />, у объекта <see cref="T:System.Threading.Mutex" /> нет имени.</param>
        <param name="createdNew">При возврате из метода содержит логическое значение <see langword="true" />, если был создан локальный мьютекс (то есть, если параметр <paramref name="name" /> имеет значение <see langword="null" /> или содержит пустую строку) или был создан именованный системный мьютекс; значение <see langword="false" />, если указанный именованный системный мьютекс уже существует. Этот параметр передается неинициализированным.</param>
        <param name="mutexSecurity">Объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для применения к именованному системному мьютексу.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Mutex" /> логическим значением, указывающим, должен ли вызывающий поток быть изначальным владельцем мьютекса, иметь строку, являющуюся именем мьютекса, и логическое значение, которое при возврате метода показывает, предоставлено ли вызывающему потоку изначальное владение мьютексом, а также безопасность управления доступом для применения к именованному мьютексу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `name` параметр имеет `null` значение `initiallyOwned` Not `true`и имеет значение, вызывающий поток владеет именованным `createdNew` мьютексом, только если параметр имеет значение `true` после вызова. В противном случае поток может запросить мьютекс, вызвав <xref:System.Threading.WaitHandle.WaitOne%2A> метод.  
  
 Используйте этот конструктор для применения безопасности управления доступом к именованному системному мьютексу при его создании, предотвращая управление мьютексом другим кодом.  
  
 Этот конструктор инициализирует <xref:System.Threading.Mutex> объект, представляющий именованный системный мьютекс. Можно создать несколько <xref:System.Threading.Mutex> объектов, представляющих один и тот же именованный системный мьютекс.  
  
 Если именованный системный мьютекс не существует, он создается с указанной защитой управления доступом. Если именованный мьютекс существует, заданная безопасность контроля доступа игнорируется.  
  
> [!NOTE]
>  Вызывающий объект имеет полный контроль над вновь созданным <xref:System.Threading.Mutex> объектом, даже если `mutexSecurity` он запрещает или не может предоставить некоторые права доступа для текущего пользователя. Однако если текущий пользователь пытается получить другой <xref:System.Threading.Mutex> объект для представления того же именованного мьютекса с помощью конструктора <xref:System.Threading.Mutex.OpenExisting%2A> или метода, применяется безопасность управления доступом Windows.  
  
 Если именованный мьютекс уже создан с защитой управления доступом и у вызывающего объекта нет <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, возникает исключение. Чтобы открыть существующий именованный мьютекс с только теми разрешениями, которые необходимы для синхронизации действий потока <xref:System.Threading.Mutex.OpenExisting%2A> , см. метод.  
  
 Если указать `null` или пустую строку для `name`, создается локальный мьютекс, как <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> если бы вы вызывали конструктор. В этом случае `createdNew` всегда `true`является.  
  
 Так как они являются общесистемными, именованные мьютексы можно использовать для координации использования ресурсов в пределах границ процесса.  
  
> [!NOTE]
>  На сервере, на котором выполняются службы терминалов, именованный системный мьютекс может иметь два уровня видимости. Если его имя начинается с префикса "Global\\", мьютекс является видимым во всех сеансах сервера терминалов. Если его имя начинается с префикса Local\\, мьютекс является видимым только в сеансе сервера терминалов, где он был создан. В этом случае отдельный мьютекс с одним и тем же именем может существовать в каждом сеансе сервера терминалов на сервере. Если префикс не указан при создании именованного мьютекса, он принимает префикс Local\\. В сеансе сервера терминалов два мьютекса, имена которых отличаются только префиксами, являются отдельными мьютексами, и оба они видимы для всех процессов в сеансе сервера терминалов. То есть префикс именуется "Global\\" и "Local\\", описывающий область действия имени мьютекса относительно сеансов сервера терминалов, а не относительно процессов.  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 В следующем примере кода показано поведение между процессами именованного мьютекса с защитой управления доступом. В примере перегрузка <xref:System.Threading.Mutex.OpenExisting%28System.String%29> метода используется для проверки существования именованного мьютекса.  
  
 Если мьютекс не существует, он создается с первоначальным владельцем и безопасностью контроля доступа, который запрещает текущему пользователю использовать мьютекс, но предоставляет право на чтение и изменение этого мьютекса.  
  
 Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Исключение перехвачено, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузка метода для открытия мьютекса с правами, необходимыми для чтения и изменения разрешений.  
  
 После изменения разрешений мьютекс открывается с правами, необходимыми для ввода и освобождения. Если запустить скомпилированный пример из третьего командного окна, он будет запущен с использованием новых разрешений.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, имеет безопасность управления доступом, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс нельзя создать; вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <exception cref="T:System.ArgumentException">Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для именованного мьютекса.</summary>
        <returns>Объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для именованного мьютекса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для поиска разрешений <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType> <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType> <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>метод использует следующее сочетание флагов (в сочетании с побитовой операцией OR):, и. <xref:System.Threading.Mutex.GetAccessControl%2A>  
  
 Пользователь должен <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> вызвать этот метод, и мьютекс должен быть открыт с помощью <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода показано поведение между процессами именованного мьютекса с защитой управления доступом. В примере перегрузка <xref:System.Threading.Mutex.OpenExisting%28System.String%29> метода используется для проверки существования именованного мьютекса.  
  
 Если мьютекс не существует, он создается с первоначальным владельцем и безопасностью контроля доступа, который запрещает текущему пользователю использовать мьютекс, но предоставляет право на чтение и изменение этого мьютекса.  
  
 Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Исключение перехвачено, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузка метода для открытия мьютекса с правами, необходимыми для чтения и изменения разрешений <xref:System.Threading.Mutex.GetAccessControl%2A> с помощью методов и <xref:System.Threading.Mutex.SetAccessControl%2A> .  
  
 После изменения разрешений мьютекс открывается с правами, необходимыми для ввода и освобождения. Если запустить скомпилированный пример из третьего командного окна, он будет запущен с использованием новых разрешений.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Текущий объект <see cref="T:System.Threading.Mutex" /> представляет именованный системный мьютекс, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.  
  
-или- 
Текущий объект <see cref="T:System.Threading.Mutex" /> представляет именованный системный мьютекс, но он не был открыт с правами <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Не поддерживается для Windows 98 или Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает указанный именованный мьютекс, если он уже существует.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного мьютекса для открытия.</param>
        <summary>Открывает указанный именованный мьютекс, если он уже существует.</summary>
        <returns>Объект, представляющий именованный системный мьютекс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A> Метод пытается открыть указанный именованный системный мьютекс. Если системный мьютекс не существует, этот метод создает исключение, а не создает системный объект. Чтобы создать системный мьютекс, если он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторов с `name` параметром.  
  
 Несколько вызовов этого метода, которые используют одно и то же `name` значение для, не обязательно возвращают один и тот же <xref:System.Threading.Mutex> объект, даже если возвращаемые объекты представляют один и тот же именованный системный мьютекс.  
  
 Перегрузка этого метода эквивалентна вызову <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузки метода и указания <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> и прав в сочетании с помощью побитовой операции или.  
  
 Указание флага позволяет потоку ожидать мьютекс, а <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> указание флага позволяет потоку вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод. <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>  
  
 Этот метод не запрашивает владение мьютексом.  
  
   
  
## Examples  
 В следующем примере кода показано поведение между процессами именованного мьютекса с защитой управления доступом. В примере перегрузка <xref:System.Threading.Mutex.OpenExisting%28System.String%29> метода используется для проверки существования именованного мьютекса.  
  
 Если мьютекс не существует, он создается с первоначальным владельцем и безопасностью контроля доступа, который запрещает текущему пользователю использовать мьютекс, но предоставляет право на чтение и изменение этого мьютекса.  
  
 Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Исключение перехвачено, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузка метода для открытия мьютекса с правами, необходимыми для чтения и изменения разрешений.  
  
 После изменения разрешений мьютекс открывается с правами, необходимыми для ввода и освобождения. Если запустить скомпилированный пример из третьего командного окна, он будет запущен с использованием новых разрешений.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
- или - 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс не существует.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного мьютекса для открытия.</param>
        <param name="rights">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</param>
        <summary>Открывает указанный именованный мьютекс, если он уже существует, с требуемыми правами доступа.</summary>
        <returns>Объект, представляющий именованный системный мьютекс.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр должен <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> включать флаг, позволяющий потокам ожидать мьютекс, и флаг, позволяющий потокам вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод. <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> `rights`  
  
 <xref:System.Threading.Mutex.OpenExisting%2A> Метод пытается открыть существующий именованный мьютекс. Если системный мьютекс не существует, этот метод создает исключение, а не создает системный объект. Чтобы создать системный мьютекс, если он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторов с `name` параметром.  
  
 Несколько вызовов этого метода, которые используют одно и то же `name` значение для, не обязательно возвращают один и тот же <xref:System.Threading.Mutex> объект, даже если возвращаемые объекты представляют один и тот же именованный системный мьютекс.  
  
 Этот метод не запрашивает владение мьютексом.  
  
   
  
## Examples  
 В следующем примере кода показано поведение между процессами именованного мьютекса с защитой управления доступом. В примере перегрузка <xref:System.Threading.Mutex.OpenExisting%28System.String%29> метода используется для проверки существования именованного мьютекса.  
  
 Если мьютекс не существует, он создается с первоначальным владельцем и безопасностью контроля доступа, который запрещает текущему пользователю использовать мьютекс, но предоставляет право на чтение и изменение этого мьютекса.  
  
 Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Исключение перехвачено, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузка метода для открытия мьютекса с правами, необходимыми для чтения и изменения разрешений.  
  
 После изменения разрешений мьютекс открывается с правами, необходимыми для ввода и освобождения. Если запустить скомпилированный пример из третьего командного окна, он будет запущен с использованием новых разрешений.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
- или - 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный мьютекс не существует.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет необходимой безопасности доступа.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Освобождает объект <see cref="T:System.Threading.Mutex" /> один раз.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Всякий раз, когда поток получает мьютекс (например, путем вызова его <xref:System.Threading.WaitHandle.WaitOne%2A> метода), он должен затем вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод для повторного владения мьютексом и разблокировать другие потоки, которые пытаются получить владение мьютексом. Если <xref:System.Threading.WaitHandle.WaitOne%2A> попытка получить владение мьютексом завершается сбоем (например, если вызов метода `millisecondsTimeout` с `timeout` параметром или возвращается `false` из-за истечения времени ожидания запроса), поток не должен вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A>в этом в этом случае потоку также не должен быть разрешен доступ к ресурсу, защищенному мьютексом, как показано в следующем примере.  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 Поток, владеющий мьютексом, может указывать один и тот же мьютекс в повторяющихся вызовах функции Wait без блокирования его выполнения. Количество вызовов хранится в среде CLR. Поток должен вызвать <xref:System.Threading.Mutex.ReleaseMutex%2A> то же количество раз, чтобы освободить владение мьютексом.  
  
 Если поток завершается во время владения мьютексом, мьютекс считается брошенным. Состояние мьютекса имеет значение "сигнальный", а следующий ожидающий поток получает владение. Если ни один из них не владеет мьютексом, то состояние мьютекса будет сигнальным. Начиная с версии 2,0 .NET Framework, <xref:System.Threading.AbandonedMutexException> в следующем потоке, который получает мьютекс, создается исключение. До версии 2,0 .NET Framework не было создано исключение.  
  
> [!CAUTION]
>  Брошенный мьютекс часто указывает на серьезную ошибку в коде. Когда поток завершает работу, не освобождая мьютекс, структуры данных, защищенные мьютексом, могут находиться в непротиворечивом состоянии. Следующий поток, запрашивающий владение мьютексом, может обрабатывать это исключение и продолжать, если целостность структур данных может быть проверена.  
  
 В случае системного мьютекса брошенный мьютекс может указывать на то, что работа приложения была внезапно прекращена (например, с помощью диспетчера задач Windows).  
  
   
  
## Examples  
 В следующем примере показано, как локальный <xref:System.Threading.Mutex> объект используется для синхронизации доступа к защищенному ресурсу. Поток, создающий мьютекс, не владеет его изначально. <xref:System.Threading.Mutex.ReleaseMutex%2A> Метод используется для освобождения мьютекса, когда он больше не нужен.  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">Вызывающий поток не является владельцем мьютекса.</exception>
        <exception cref="T:System.ObjectDisposedException">Текущий экземпляр уже удален.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">Mutexes</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">Объект <see cref="T:System.Security.AccessControl.MutexSecurity" />, представляющий безопасность управления доступом для применения к именованному системному мьютексу.</param>
        <summary>Задает безопасность управления доступом для именованного системного мьютекса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пользователь должен иметь <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> права на вызов этого метода, и мьютекс должен быть открыт с помощью <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода показано поведение между процессами именованного мьютекса с защитой управления доступом. В примере перегрузка <xref:System.Threading.Mutex.OpenExisting%28System.String%29> метода используется для проверки существования именованного мьютекса.  
  
 Если мьютекс не существует, он создается с первоначальным владельцем и безопасностью контроля доступа, который запрещает текущему пользователю использовать мьютекс, но предоставляет право на чтение и изменение этого мьютекса.  
  
 Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове <xref:System.Threading.Mutex.OpenExisting%28System.String%29>. Исключение перехвачено, и в примере используется <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузка метода для открытия мьютекса с правами, необходимыми для чтения и изменения разрешений <xref:System.Threading.Mutex.GetAccessControl%2A> с помощью методов и <xref:System.Threading.Mutex.SetAccessControl%2A> .  
  
 После изменения разрешений мьютекс открывается с правами, необходимыми для ввода и освобождения. Если запустить скомпилированный пример из третьего командного окна, он будет запущен с использованием новых разрешений.  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="mutexSecurity" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.  
  
- или - 
Мьютекс не был открыт с <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">Текущий объект <see cref="T:System.Threading.Mutex" /> не представляет именованный системный мьютекс.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает указанный именованный мьютекс, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного мьютекса для открытия.</param>
        <param name="result">Когда выполнение этого метода завершается, содержит объект <see cref="T:System.Threading.Mutex" />, представляющий именованный мьютекс, если вызов завершился успешно, или значение <see langword="null" />, если произошел сбой вызова. Этот параметр обрабатывается как неинициализированный.</param>
        <summary>Открывает указанный именованный мьютекс, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
        <returns>Значение <see langword="true" />, если именованный мьютекс был успешно открыт; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный мьютекс не существует, этот метод не создает его. Чтобы создать системный мьютекс, если он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторов с `name` параметром.  
  
 Если вы не уверены, существует ли именованный мьютекс, используйте эту перегрузку метода вместо <xref:System.Threading.Mutex.OpenExisting%28System.String%29> перегрузки метода, которая вызывает исключение, если мьютекс не существует.  
  
 Несколько вызовов этого метода, которые используют одно и то же `name` значение для, не обязательно возвращают один и тот же <xref:System.Threading.Mutex> объект, даже если возвращаемые объекты представляют один и тот же именованный системный мьютекс.  
  
 Перегрузка этого метода эквивалентна вызову <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> перегрузки метода и указания <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> и прав в сочетании с помощью побитовой операции или. Указание флага позволяет потоку ожидать мьютекс, а <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> указание флага позволяет потоку вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод. <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>  
  
 Этот метод не запрашивает владение мьютексом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
- или - 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного мьютекса для открытия.</param>
        <param name="rights">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</param>
        <param name="result">Когда выполнение этого метода завершается, содержит объект <see cref="T:System.Threading.Mutex" />, представляющий именованный мьютекс, если вызов завершился успешно, или значение <see langword="null" />, если произошел сбой вызова. Этот параметр обрабатывается как неинициализированный.</param>
        <summary>Открывает указанный именованный мьютекс, если он уже существует, с требуемыми правами доступа, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
        <returns>Значение <see langword="true" />, если именованный мьютекс был успешно открыт; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный мьютекс не существует, этот метод не создает его. Чтобы создать системный мьютекс, если он еще не существует, используйте один из <xref:System.Threading.Mutex.%23ctor%2A> конструкторов с `name` параметром.  
  
 Если вы не уверены, существует ли именованный мьютекс, используйте эту перегрузку метода вместо <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> перегрузки метода, которая вызывает исключение, если мьютекс не существует.  
  
 Параметр должен <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> включать флаг, позволяющий потокам ожидать мьютекс, и флаг, позволяющий потокам вызывать <xref:System.Threading.Mutex.ReleaseMutex%2A> метод. <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> `rights`  
  
 Несколько вызовов этого метода, которые используют одно и то же `name` значение для, не обязательно возвращают один и тот же <xref:System.Threading.Mutex> объект, даже если возвращаемые объекты представляют один и тот же именованный системный мьютекс.  
  
 Этот метод не запрашивает владение мьютексом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
- или - 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный мьютекс существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для немедленного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
