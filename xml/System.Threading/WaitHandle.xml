<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="504b6bc511637b840cc4d40d3a8e1af9f0204678" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73380681" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="d2f72-101">Инкапсулирует связанные с операционной системой объекты, ожидающие монопольного доступа к общим ресурсам.</span><span class="sxs-lookup"><span data-stu-id="d2f72-101">Encapsulates operating system-specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-102">Класс <xref:System.Threading.WaitHandle> инкапсулирует собственный обработчик синхронизации операционной системы и используется для представления всех объектов синхронизации в среде выполнения, которые допускают несколько операций ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="d2f72-103">Сравнение дескрипторов ожидания с другими объектами синхронизации см. в разделе [Обзор примитивов синхронизации](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span><span class="sxs-lookup"><span data-stu-id="d2f72-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="d2f72-104">Класс <xref:System.Threading.WaitHandle> является абстрактным.</span><span class="sxs-lookup"><span data-stu-id="d2f72-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="d2f72-105">Классы, производные от <xref:System.Threading.WaitHandle>, определяют механизм сигнализации, указывающий на получение или освобождение доступа к общему ресурсу, но они используют унаследованные методы <xref:System.Threading.WaitHandle> для блокировки при ожидании доступа к общим ресурсам.</span><span class="sxs-lookup"><span data-stu-id="d2f72-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="d2f72-106">Классы, производные от <xref:System.Threading.WaitHandle>, включают:</span><span class="sxs-lookup"><span data-stu-id="d2f72-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="d2f72-107">класс <xref:System.Threading.Mutex>;</span><span class="sxs-lookup"><span data-stu-id="d2f72-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="d2f72-108">См. раздел [мьютексы](~/docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="d2f72-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="d2f72-109">Класс <xref:System.Threading.EventWaitHandle> и его производные классы, <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span>  
  
-   <span data-ttu-id="d2f72-110">класс <xref:System.Threading.Semaphore>;</span><span class="sxs-lookup"><span data-stu-id="d2f72-110">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="d2f72-111">См. раздел [семафор и SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="d2f72-111">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="d2f72-112">Потоки могут блокироваться по отдельному обработчику ожидания путем вызова метода экземпляра <xref:System.Threading.WaitHandle.WaitOne%2A>, который наследуется классами, производными от <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-112">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="d2f72-113">Производные классы <xref:System.Threading.WaitHandle> отличаются в сходстве потоков.</span><span class="sxs-lookup"><span data-stu-id="d2f72-113">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="d2f72-114">Дескрипторы ожидания событий (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent> и <xref:System.Threading.ManualResetEvent>) и семафоры не имеют сходства потоков; любой поток может сообщить дескриптору ожидания события или семафору.</span><span class="sxs-lookup"><span data-stu-id="d2f72-114">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="d2f72-115">Мьютексы, с другой стороны, имеют сходство потоков; поток, владеющий мьютексом, должен освободить его, и исключение создается, если поток вызывает метод <xref:System.Threading.Mutex.ReleaseMutex%2A> для мьютекса, который ему не владеет.</span><span class="sxs-lookup"><span data-stu-id="d2f72-115">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="d2f72-116">Поскольку класс <xref:System.Threading.WaitHandle> является производным от <xref:System.MarshalByRefObject>, эти классы можно использовать для синхронизации действий потоков через границы домена приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-116">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="d2f72-117">В дополнение к производным классам класс <xref:System.Threading.WaitHandle> имеет ряд статических методов, которые блокируют поток, пока один или несколько объектов синхронизации не получат сигнал.</span><span class="sxs-lookup"><span data-stu-id="d2f72-117">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="d2f72-118">Сюда входит следующее.</span><span class="sxs-lookup"><span data-stu-id="d2f72-118">These include:</span></span>  
  
-   <span data-ttu-id="d2f72-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, что позволяет потоку сообщить об одном дескрипторе ожидания и сразу же ждать другого.</span><span class="sxs-lookup"><span data-stu-id="d2f72-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="d2f72-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, что позволяет потоку ожидать, пока все дескрипторы ожидания в массиве не получат сигнал.</span><span class="sxs-lookup"><span data-stu-id="d2f72-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="d2f72-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, что позволяет потоку ожидать, пока любой из указанных наборов дескрипторов ожидания не будет сигнальным.</span><span class="sxs-lookup"><span data-stu-id="d2f72-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled.</span></span>  
  
 <span data-ttu-id="d2f72-122">Перегрузки этих методов предоставляют интервалы времени ожидания для отмены ожидания и возможность выхода из контекста синхронизации до входа в ожидание, что позволяет другим потокам использовать контекст синхронизации.</span><span class="sxs-lookup"><span data-stu-id="d2f72-122">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d2f72-123">Этот тип реализует интерфейс <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-123">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="d2f72-124">После завершения использования типа или производного от него типа его следует удалить прямо или косвенно.</span><span class="sxs-lookup"><span data-stu-id="d2f72-124">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="d2f72-125">Чтобы сделать это прямо, вызовите его метод <xref:System.Threading.WaitHandle.Close%2A> в блоке `try`/`catch`.</span><span class="sxs-lookup"><span data-stu-id="d2f72-125">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="d2f72-126">Чтобы сделать это косвенно, используйте языковые конструкции, такие как `using` (в C#) или `Using` (в Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="d2f72-126">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="d2f72-127">Дополнительные сведения см. в разделе "Использование объекта, реализующего IDisposable" в статье об интерфейсе <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-127">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="d2f72-128"><xref:System.Threading.WaitHandle> реализует шаблон <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-128"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="d2f72-129">См. [реализация метода Dispose] (~/Докс/Стандард/гарбаже-коллектион/имплементинг-диспосе. md).</span><span class="sxs-lookup"><span data-stu-id="d2f72-129">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="d2f72-130">При наследовании от <xref:System.Threading.WaitHandle> используйте свойство <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> для хранения собственного обработчика операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-130">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="d2f72-131">Не нужно переопределять защищенный метод <xref:System.Threading.WaitHandle.Dispose%2A>, если не используются дополнительные неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-131">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d2f72-132">В следующем примере кода показано, как два потока могут выполнять фоновые задачи, в то время как главный поток ожидает завершения задач с помощью статических методов <xref:System.Threading.WaitHandle.WaitAny%2A> и <xref:System.Threading.WaitHandle.WaitAll%2A> класса <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-132">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="d2f72-133">Данный тип потокобезопасен.</span><span class="sxs-lookup"><span data-stu-id="d2f72-133">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="d2f72-134">Потоки</span><span class="sxs-lookup"><span data-stu-id="d2f72-134">Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md"><span data-ttu-id="d2f72-135">Объекты и функциональные возможности работы с потоками</span><span class="sxs-lookup"><span data-stu-id="d2f72-135">Threading Objects and Features</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="d2f72-136">Mutexes</span><span class="sxs-lookup"><span data-stu-id="d2f72-136">Mutexes</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d"><span data-ttu-id="d2f72-137">EventWaitHandle, AutoResetEvent и ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="d2f72-137">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span></span></related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="d2f72-138">Семафоры</span><span class="sxs-lookup"><span data-stu-id="d2f72-138">Semaphores</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public WaitHandle ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WaitHandle();" FrameworkAlternate="netframework-1.1" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d2f72-139">Инициализирует новый экземпляр класса <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-139">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d2f72-140">Освобождает все ресурсы, удерживаемые текущим объектом <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-140">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-141">Этот метод является открытой реализацией метода <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> для класса <xref:System.Threading.WaitHandle> и его производных классов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-141">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="d2f72-142">Он предоставляет стандартную реализацию, которая вызывает перегрузку `Dispose(Boolean)` с аргументом `true`, а затем вызывает метод <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-142">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d2f72-143">Вызовите этот метод, чтобы освободить все ресурсы, удерживаемые экземпляром `WaitHandle` или производным классом.</span><span class="sxs-lookup"><span data-stu-id="d2f72-143">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="d2f72-144">После вызова этого метода ссылки на текущий экземпляр приводят к неопределенному поведению.</span><span class="sxs-lookup"><span data-stu-id="d2f72-144">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d2f72-145">Перед освобождением последней ссылки на <xref:System.Threading.WaitHandle> всегда вызывайте <xref:System.Threading.WaitHandle.Close%2A> или <xref:System.Threading.WaitHandle.Dispose>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-145">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="d2f72-146">В противном случае ресурсы, которые он использует, не будут освобождены.</span><span class="sxs-lookup"><span data-stu-id="d2f72-146">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d2f72-147">Следует переопределить метод <see langword="Dispose(Boolean)" />, чтобы освободить ресурсы, выделенные в производных классах.</span><span class="sxs-lookup"><span data-stu-id="d2f72-147">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="d2f72-148">Реализация метода Dispose</span><span class="sxs-lookup"><span data-stu-id="d2f72-148">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d2f72-149">Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-149">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d2f72-150">Освобождает все ресурсы, используемые текущим экземпляром класса <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-151">Этот метод эквивалентен методу <xref:System.Threading.WaitHandle.Close%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-151">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d2f72-152">Перед освобождением последней ссылки на <xref:System.Threading.WaitHandle> всегда вызывайте <xref:System.Threading.WaitHandle.Close%2A> или <xref:System.Threading.WaitHandle.Dispose>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-152">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="d2f72-153">В противном случае ресурсы, которые он использует, не будут освобождены.</span><span class="sxs-lookup"><span data-stu-id="d2f72-153">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md"><span data-ttu-id="d2f72-154">Очистка неуправляемых ресурсов</span><span class="sxs-lookup"><span data-stu-id="d2f72-154">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing"><span data-ttu-id="d2f72-155">Значение <see langword="true" /> позволяет освободить управляемые и неуправляемые ресурсы; значение <see langword="false" /> позволяет освободить только неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-155"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="d2f72-156">При переопределении в производном классе освобождает неуправляемые ресурсы, используемые объектом <see cref="T:System.Threading.WaitHandle" />, и при необходимости освобождает управляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-156">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-157">Этот метод вызывается <xref:System.Threading.WaitHandle.Close%2A> и методами <xref:System.Threading.WaitHandle.Dispose> с параметром `explicitDisposing`, для которого задано значение `true`.</span><span class="sxs-lookup"><span data-stu-id="d2f72-157">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="d2f72-158">Если параметр `explicitDisposing` имеет значение `true`, этот метод освобождает все ресурсы, удерживаемые любыми управляемыми объектами, на которые ссылается объект <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-158">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d2f72-159">Следует переопределить метод <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />, чтобы освободить ресурсы, выделенные в производных классах.</span><span class="sxs-lookup"><span data-stu-id="d2f72-159">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
<span data-ttu-id="d2f72-160">Метод <see cref="M:System.Threading.WaitHandle.Close" /> или <see cref="M:System.Threading.WaitHandle.Dispose" /> можно вызывать несколько раз с помощью других объектов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-160">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="d2f72-161">При переопределении этого метода следует избегать ссылок на объекты, которые ранее были удалены в предыдущем вызове <see langword="Dispose" /> или <see langword="Close" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-161">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="d2f72-162">Реализация метода Dispose</span><span class="sxs-lookup"><span data-stu-id="d2f72-162">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d2f72-163">Освобождает ресурсы, удерживаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="d2f72-163">Releases the resources held by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> <span data-ttu-id="d2f72-164">Этот член был удален из .NET Framework версии 2,0 и последующих версий.</span><span class="sxs-lookup"><span data-stu-id="d2f72-164">This member has been removed from the .NET Framework version 2.0 and subsequent versions.</span></span> <span data-ttu-id="d2f72-165">Этот раздел относится только к версиям, перечисленным далее в разделе "сведения о версии".</span><span class="sxs-lookup"><span data-stu-id="d2f72-165">This topic applies only to the versions listed in "Version Information" later in this topic.</span></span>


<span data-ttu-id="d2f72-166">Код приложения не вызывает этот метод. он автоматически вызывается во время сборки мусора, если окончательное завершение сборщика мусора не отключено.</span><span class="sxs-lookup"><span data-stu-id="d2f72-166">Application code does not call this method; it is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled.</span></span> <span data-ttu-id="d2f72-167">Дополнительные сведения см. в разделах <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> и <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-167">For more information, see <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> and <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="d2f72-168">Этот метод переопределяет метод <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-168">This method overrides <xref:System.Object.Finalize>.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d2f72-169">Возвращает или задает собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-169">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="d2f72-170">Объект <see langword="IntPtr" />, представляющий собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-170">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="d2f72-171">Значением по умолчанию является значение поля <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-171">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-172">Присвоение нового значения свойству <xref:System.Threading.WaitHandle.Handle%2A> не приводит к закрытию предыдущего маркера.</span><span class="sxs-lookup"><span data-stu-id="d2f72-172">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="d2f72-173">Это может привести к утечке дескриптора.</span><span class="sxs-lookup"><span data-stu-id="d2f72-173">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="d2f72-174">Не используйте это свойство в .NET Framework версии 2,0 или более поздней; Вместо этого используйте свойство <xref:System.Threading.WaitHandle.SafeWaitHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-174">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="d2f72-175">Присвоение этому свойству допустимого дескриптора также задает свойство <xref:System.Threading.WaitHandle.SafeWaitHandle%2A>, но установка значения <xref:System.Threading.WaitHandle.InvalidHandle> может привести к утечке дескриптора.</span><span class="sxs-lookup"><span data-stu-id="d2f72-175">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="d2f72-176">Требуется полное доверие для немедленного вызывающего объекта, чтобы задать значение свойства.</span><span class="sxs-lookup"><span data-stu-id="d2f72-176">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="d2f72-177">Этот элемент не может быть задан частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="d2f72-177">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="d2f72-178">Производные типы должны иметь <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />, чтобы задать значение свойства.</span><span class="sxs-lookup"><span data-stu-id="d2f72-178">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d2f72-179">Представляет недопустимый собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-179">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="d2f72-180">Это поле доступно только для чтения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-180">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-181">Используется для внутренних целей для инициализации свойства <xref:System.Threading.WaitHandle.Handle%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-181">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d2f72-182">Это значение можно использовать, чтобы определить, содержит ли свойство <see cref="P:System.Threading.WaitHandle.Handle" /> допустимый собственный обработчик операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-182">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d2f72-183">Возвращает или задает собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-183">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="d2f72-184">Объект <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />, представляющий собственный дескриптор операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-184">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-185">При назначении нового значения свойству <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> предыдущий маркер будет закрыт при сборе предыдущего объекта <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-185">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="d2f72-186">Не закрывайте маркер вручную, так как это приводит к <xref:System.ObjectDisposedException>, когда <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> пытается закрыть этот обработчик.</span><span class="sxs-lookup"><span data-stu-id="d2f72-186">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="d2f72-187"><xref:System.Threading.WaitHandle> реализует шаблон <xref:System.IDisposable.Dispose%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-187"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="d2f72-188">См. раздел [Реализация метода Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="d2f72-188">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span> <span data-ttu-id="d2f72-189">При наследовании от <xref:System.Threading.WaitHandle> используйте свойство <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> для хранения собственного обработчика операционной системы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-189">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="d2f72-190">Не нужно переопределять защищенный метод <xref:System.Threading.WaitHandle.Dispose%2A>, если не используются дополнительные неуправляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-190">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="d2f72-191">Требуется полное доверие для немедленного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="d2f72-191">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="d2f72-192">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="d2f72-192">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="d2f72-193">Производные типы должны иметь <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> для вызова этого члена.</span><span class="sxs-lookup"><span data-stu-id="d2f72-193">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d2f72-194">Подает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает другого.</span><span class="sxs-lookup"><span data-stu-id="d2f72-194">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="d2f72-195">Объект <see cref="T:System.Threading.WaitHandle" />, который получает сигнал.</span><span class="sxs-lookup"><span data-stu-id="d2f72-195">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="d2f72-196">Объект <see cref="T:System.Threading.WaitHandle" />, сигнализация которого ожидается.</span><span class="sxs-lookup"><span data-stu-id="d2f72-196">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="d2f72-197">Подает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает другого.</span><span class="sxs-lookup"><span data-stu-id="d2f72-197">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns><span data-ttu-id="d2f72-198">Значение <see langword="true" />, если и сигнал, и ожидание завершаются удачно; если операция ожидания не завершается, то возврат из метода не происходит.</span><span class="sxs-lookup"><span data-stu-id="d2f72-198"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-199">Эта операция не обязательно должна быть атомарной.</span><span class="sxs-lookup"><span data-stu-id="d2f72-199">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="d2f72-200">После того как текущий поток сигнализирует `toSignal`, но перед ожиданием `toWaitOn`, поток, выполняющийся на другом процессоре, может передать сигнал `toWaitOn` или подождать его.</span><span class="sxs-lookup"><span data-stu-id="d2f72-200">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d2f72-201">В следующем примере кода используется перегрузка метода <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>, позволяющая основному потоку сообщить о заблокированном потоке, а затем подождать, пока поток не завершит задачу.</span><span class="sxs-lookup"><span data-stu-id="d2f72-201">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="d2f72-202">В примере запускается пять потоков, что позволяет блокироваться на <xref:System.Threading.EventWaitHandle>, созданном с флагом <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>, а затем освобождает один поток каждый раз, когда пользователь нажимает клавишу ВВОД.</span><span class="sxs-lookup"><span data-stu-id="d2f72-202">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="d2f72-203">Затем этот пример помещает в очередь еще пять потоков и освобождает их все с помощью <xref:System.Threading.EventWaitHandle>, созданного с флагом <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-203">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d2f72-204">Свойство <paramref name="toSignal" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-204"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-205">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-205">-or-</span></span> 
 <span data-ttu-id="d2f72-206">Свойство <paramref name="toWaitOn" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-206"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d2f72-207">Метод был вызван в потоке с атрибутом <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-207">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="d2f72-208">Этот метод не поддерживается в Windows 98 и Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-208">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-209">Параметр <paramref name="toSignal" /> является семафором и его счетчик уже достиг максимального значения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-209"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-210">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-210">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-211">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-211">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="d2f72-212">Объект <see cref="T:System.Threading.WaitHandle" />, который получает сигнал.</span><span class="sxs-lookup"><span data-stu-id="d2f72-212">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="d2f72-213">Объект <see cref="T:System.Threading.WaitHandle" />, сигнализация которого ожидается.</span><span class="sxs-lookup"><span data-stu-id="d2f72-213">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="d2f72-214">Целое число, представляющее интервал ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-214">An integer that represents the interval to wait.</span></span> <span data-ttu-id="d2f72-215">Если значение равно <see cref="F:System.Threading.Timeout.Infinite" />, то есть -1, то ожидание длится неограниченное время.</span><span class="sxs-lookup"><span data-stu-id="d2f72-215">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d2f72-216">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-216"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d2f72-217">Передает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает сигнализации другого, задавая время ожидания в виде 32-разрядного целого числа со знаком и указывая, следует ли выйти из домена синхронизации контекста до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-217">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="d2f72-218">Значение <see langword="true" />, если и передача сигнала, и ожидание завершились успешно; значение <see langword="false" />, если передача сигнала была выполнена, но время ожидания истекло.</span><span class="sxs-lookup"><span data-stu-id="d2f72-218"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-219">Эта операция не обязательно должна быть атомарной.</span><span class="sxs-lookup"><span data-stu-id="d2f72-219">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="d2f72-220">После того как текущий поток сигнализирует `toSignal`, но перед ожиданием `toWaitOn`, поток, выполняющийся на другом процессоре, может передать сигнал `toWaitOn` или подождать его.</span><span class="sxs-lookup"><span data-stu-id="d2f72-220">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="d2f72-221">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-221">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-222">Он проверяет состояние `toWaitOn` и немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="d2f72-222">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d2f72-223">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="d2f72-223">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d2f72-224">Параметр `exitContext` не действует, если только метод <xref:System.Threading.WaitHandle.SignalAndWait%2A> не вызывается из управляемого контекста, не используемого по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="d2f72-224">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d2f72-225">Это может произойти, если поток находится внутри вызова экземпляра класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-225">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d2f72-226">Даже если в данный момент выполняется метод для класса, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, можно использовать нестандартный контекст, если <xref:System.ContextBoundObject> находится в стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-226">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d2f72-227">Если код выполняется в контексте, не заданном по умолчанию, то при указании `true` для `exitContext` поток будет выходить из управляемого контекста, не используемого по умолчанию (то есть до перехода в контекст по умолчанию), перед выполнением метода <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-227">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="d2f72-228">Поток возвращается к исходному контексту, не заданному по умолчанию, после вызова метода <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-228">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="d2f72-229">Это может быть полезно, если класс, привязанный к контексту, имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-229">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d2f72-230">В этом случае все вызовы членов класса автоматически синхронизируются, а домен синхронизации — весь текст кода для класса.</span><span class="sxs-lookup"><span data-stu-id="d2f72-230">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d2f72-231">Если код в стеке вызовов члена вызывает метод <xref:System.Threading.WaitHandle.SignalAndWait%2A> и указывает `true` для `exitContext`, поток завершает работу домена синхронизации, позволяя потоку, который блокируется на вызов любого члена объекта, продолжать работу.</span><span class="sxs-lookup"><span data-stu-id="d2f72-231">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d2f72-232">Когда метод <xref:System.Threading.WaitHandle.SignalAndWait%2A> возвращает значение, поток, который выполнил вызов, должен дождаться повторного входа в домен синхронизации.</span><span class="sxs-lookup"><span data-stu-id="d2f72-232">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d2f72-233">Свойство <paramref name="toSignal" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-233"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-234">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-234">-or-</span></span> 
 <span data-ttu-id="d2f72-235"><paramref name="toWaitOn" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-235"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d2f72-236">Метод вызывается в потоке с атрибутом <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-236">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="d2f72-237">Этот метод не поддерживается в Windows 98 и Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-237">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-238">Невозможно передать сигнал объекту <see cref="T:System.Threading.WaitHandle" />, поскольку его счетчик превысит максимальное значение.</span><span class="sxs-lookup"><span data-stu-id="d2f72-238">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-239">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-239"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-240">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-240">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-241">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-241">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="d2f72-242">Объект <see cref="T:System.Threading.WaitHandle" />, который получает сигнал.</span><span class="sxs-lookup"><span data-stu-id="d2f72-242">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="d2f72-243">Объект <see cref="T:System.Threading.WaitHandle" />, сигнализация которого ожидается.</span><span class="sxs-lookup"><span data-stu-id="d2f72-243">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="d2f72-244">Объект <see cref="T:System.TimeSpan" />, представляющий период ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-244">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="d2f72-245">Если значение равно -1, то ожидание выполняется неограниченное время.</span><span class="sxs-lookup"><span data-stu-id="d2f72-245">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d2f72-246">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-246"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d2f72-247">Передает сигнал одному объекту <see cref="T:System.Threading.WaitHandle" /> и ожидает сигнализации другого, задавая время ожидания в виде <see cref="T:System.TimeSpan" /> и указывая, следует ли выйти из домена синхронизации контекста до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-247">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="d2f72-248">Значение <see langword="true" />, если и передача сигнала, и ожидание завершились успешно; значение <see langword="false" />, если передача сигнала была выполнена, но время ожидания истекло.</span><span class="sxs-lookup"><span data-stu-id="d2f72-248"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-249">Эта операция не обязательно должна быть атомарной.</span><span class="sxs-lookup"><span data-stu-id="d2f72-249">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="d2f72-250">После того как текущий поток сигнализирует `toSignal`, но перед ожиданием `toWaitOn`, поток, выполняющийся на другом процессоре, может передать сигнал `toWaitOn` или подождать его.</span><span class="sxs-lookup"><span data-stu-id="d2f72-250">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="d2f72-251">Максимальное значение для `timeout` равно <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-251">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d2f72-252">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-252">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-253">Он проверяет состояние `toWaitOn` и немедленно возвращает значение.</span><span class="sxs-lookup"><span data-stu-id="d2f72-253">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d2f72-254">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="d2f72-254">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d2f72-255">Параметр `exitContext` не действует, если только метод <xref:System.Threading.WaitHandle.SignalAndWait%2A> не вызывается из управляемого контекста, не используемого по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="d2f72-255">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d2f72-256">Это может произойти, если поток находится внутри вызова экземпляра класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-256">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d2f72-257">Даже если в данный момент выполняется метод для класса, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, можно использовать нестандартный контекст, если <xref:System.ContextBoundObject> находится в стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-257">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d2f72-258">Если код выполняется в контексте, не заданном по умолчанию, то при указании `true` для `exitContext` поток будет выходить из управляемого контекста, не используемого по умолчанию (то есть до перехода в контекст по умолчанию), перед выполнением метода <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-258">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="d2f72-259">Поток возвращается к исходному контексту, не заданному по умолчанию, после вызова метода <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-259">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="d2f72-260">Это может быть полезно, если класс, привязанный к контексту, имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-260">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d2f72-261">В этом случае все вызовы членов класса автоматически синхронизируются, а домен синхронизации — весь текст кода для класса.</span><span class="sxs-lookup"><span data-stu-id="d2f72-261">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d2f72-262">Если код в стеке вызовов члена вызывает метод <xref:System.Threading.WaitHandle.SignalAndWait%2A> и указывает `true` для `exitContext`, поток завершает работу домена синхронизации, позволяя потоку, который блокируется на вызов любого члена объекта, продолжать работу.</span><span class="sxs-lookup"><span data-stu-id="d2f72-262">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d2f72-263">Когда метод <xref:System.Threading.WaitHandle.SignalAndWait%2A> возвращает значение, поток, который выполнил вызов, должен дождаться повторного входа в домен синхронизации.</span><span class="sxs-lookup"><span data-stu-id="d2f72-263">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d2f72-264">Свойство <paramref name="toSignal" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-264"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-265">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-265">-or-</span></span> 
 <span data-ttu-id="d2f72-266">Свойство <paramref name="toWaitOn" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-266"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d2f72-267">Метод был вызван в потоке с атрибутом <see cref="T:System.STAThreadAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-267">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="d2f72-268">Этот метод не поддерживается в Windows 98 и Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-268">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-269">Параметр <paramref name="toSignal" /> является семафором и его счетчик уже достиг максимального значения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-269"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-270">Значение параметра <paramref name="timeout" /> соответствует отрицательному числу, отличному от -1 миллисекунды.</span><span class="sxs-lookup"><span data-stu-id="d2f72-270"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
<span data-ttu-id="d2f72-271">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-271">-or-</span></span> 
 <span data-ttu-id="d2f72-272">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-272"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-273">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-273">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-274">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-274">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d2f72-275">Освобождает все ресурсы, занятые модулем <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-275">Releases all resources used by the <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="d2f72-276">Вызов `Dispose` позволяет перераспределить ресурсы, используемые <xref:System.Threading.WaitHandle>, для других целей.</span><span class="sxs-lookup"><span data-stu-id="d2f72-276">Calling `Dispose` allows the resources used by the <xref:System.Threading.WaitHandle> to be reallocated for other purposes.</span></span> <span data-ttu-id="d2f72-277">Дополнительные сведения о `Dispose`см. в разделе [Очистка неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="d2f72-277">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d2f72-278">Ожидает получения сигнала всеми элементами заданного массива.</span><span class="sxs-lookup"><span data-stu-id="d2f72-278">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d2f72-279">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="d2f72-279">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="d2f72-280">Этот массив не может содержать несколько ссылок на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="d2f72-280">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="d2f72-281">Ожидает получения сигнала всеми элементами заданного массива.</span><span class="sxs-lookup"><span data-stu-id="d2f72-281">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="d2f72-282"><see langword="true" />, когда каждый элемент <paramref name="waitHandles" /> получил сигнал. В противном случае возврат из метода не происходит.</span><span class="sxs-lookup"><span data-stu-id="d2f72-282"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-283"><xref:System.Threading.AbandonedMutexException> впервые пойдет в .NET Framework версии 2,0.</span><span class="sxs-lookup"><span data-stu-id="d2f72-283"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d2f72-284">В предыдущих версиях метод <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает `true`, когда мьютекс отброшен.</span><span class="sxs-lookup"><span data-stu-id="d2f72-284">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="d2f72-285">Брошенный мьютекс часто указывает на серьезную ошибку кода.</span><span class="sxs-lookup"><span data-stu-id="d2f72-285">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d2f72-286">В случае с мьютексом на уровне системы это может означать, что приложение было внезапно завершено (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="d2f72-286">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d2f72-287">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="d2f72-287">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d2f72-288">Метод <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает значение, когда все дескрипторы получают сигнал.</span><span class="sxs-lookup"><span data-stu-id="d2f72-288">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="d2f72-289">В некоторых реализациях, если передано более 64 дескрипторов, выдается <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-289">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="d2f72-290">Если массив содержит дубликаты, вызов завершается с <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-290">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d2f72-291">Метод <xref:System.Threading.WaitHandle.WaitAll%2A> не поддерживается в потоках, имеющих <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-291">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="d2f72-292">Вызов этой перегрузки метода эквивалентен вызову перегрузки метода <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> и указанию-1 (или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) для `millisecondsTimeout` и `true` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d2f72-292">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d2f72-293">В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи в группу файлов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-293">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="d2f72-294">Каждая операция записи помещается в очередь как рабочий элемент и сигнализирует о ее завершении.</span><span class="sxs-lookup"><span data-stu-id="d2f72-294">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="d2f72-295">Основной поток ожидает сигнала всех элементов и завершает работу.</span><span class="sxs-lookup"><span data-stu-id="d2f72-295">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d2f72-296">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-296">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="d2f72-297">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-297">-or-</span></span> 
<span data-ttu-id="d2f72-298">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-298">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-299">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-299">-or-</span></span> 
 <span data-ttu-id="d2f72-300">Массив<paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 2.0 или более поздней.</span><span class="sxs-lookup"><span data-stu-id="d2f72-300"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="d2f72-301">Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.ArgumentException" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-301">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="d2f72-302">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-302">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d2f72-303">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="d2f72-303">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="d2f72-304">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-304">-or-</span></span> 
<span data-ttu-id="d2f72-305">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="d2f72-305">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="d2f72-306">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 1.0 или 1.1.</span><span class="sxs-lookup"><span data-stu-id="d2f72-306"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-307">Ожидание прервано, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-307">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-308">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-308">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-309">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-309">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d2f72-310">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="d2f72-310">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="d2f72-311">Данный массив не может содержать несколько ссылок на один и тот же объект (дубликатов).</span><span class="sxs-lookup"><span data-stu-id="d2f72-311">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="d2f72-312">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-312">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d2f72-313">Ожидает получения сигнала всеми элементами заданного массива, используя значение <see cref="T:System.Int32" /> для указания интервала времени.</span><span class="sxs-lookup"><span data-stu-id="d2f72-313">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="d2f72-314">Значение <see langword="true" />, если каждый элемент массива <paramref name="waitHandles" /> получил сигнал; в противном случае значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-314"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-315">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-315">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-316">Он проверяет состояние дескрипторов ожидания и немедленно возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="d2f72-316">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d2f72-317">Метод <xref:System.Threading.WaitHandle.WaitAll%2A> возвращается при завершении ожидания, что означает, когда все дескрипторы получают сигнал или когда происходит время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-317">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="d2f72-318">В некоторых реализациях, если передано более 64 дескрипторов, выдается <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-318">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="d2f72-319">Если в массиве есть дубликаты, вызов завершается с <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-319">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d2f72-320">Метод <xref:System.Threading.WaitHandle.WaitAll%2A> не поддерживается в потоках, имеющих <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-320">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="d2f72-321">Вызов этой перегрузки метода аналогичен вызову перегрузки <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> и указанию `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d2f72-321">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d2f72-322">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-322">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-323">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-323">-or-</span></span> 
<span data-ttu-id="d2f72-324">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-324">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-325">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-325">-or-</span></span> 
 <span data-ttu-id="d2f72-326">В массиве <paramref name="waitHandles" /> отсутствуют элементы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-326"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="d2f72-327">Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.ArgumentException" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-327">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="d2f72-328">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-328">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d2f72-329">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="d2f72-329">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="d2f72-330">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-330">-or-</span></span> 
<span data-ttu-id="d2f72-331">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="d2f72-331">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-332">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-332"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-333">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-333">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-334">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-334">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-335">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-335">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d2f72-336">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="d2f72-336">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="d2f72-337">Этот массив не может содержать несколько ссылок на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="d2f72-337">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="d2f72-338">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-338">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d2f72-339">Ожидает получения сигнала всеми элементами заданного массива, используя значение <see cref="T:System.TimeSpan" /> для указания интервала времени.</span><span class="sxs-lookup"><span data-stu-id="d2f72-339">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="d2f72-340">Значение <see langword="true" />, если каждый элемент массива <paramref name="waitHandles" /> получил сигнал; в противном случае значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-340"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-341">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-341">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-342">Он проверяет состояние дескрипторов ожидания и немедленно возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="d2f72-342">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d2f72-343">Метод <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает, когда ожидание завершается, а это означает, что либо все дескрипторы являются сигнальными, либо истекает время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-343">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="d2f72-344">В некоторых реализациях, если передано более 64 дескрипторов, выдается <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-344">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="d2f72-345">Если массив содержит дубликаты, вызов завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="d2f72-345">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d2f72-346">Метод <xref:System.Threading.WaitHandle.WaitAll%2A> не поддерживается в потоках, имеющих <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-346">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="d2f72-347">Максимальное значение для `timeout` равно <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-347">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d2f72-348">Вызов этой перегрузки метода аналогичен вызову перегрузки <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> и указанию `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d2f72-348">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d2f72-349">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-349">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-350">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-350">-or-</span></span> 
<span data-ttu-id="d2f72-351">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-351">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-352">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-352">-or-</span></span> 
 <span data-ttu-id="d2f72-353">В массиве <paramref name="waitHandles" /> отсутствуют элементы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-353"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="d2f72-354">Вместо этого в <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET для приложений Магазина Windows</see> или в <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">переносимой библиотеке классов</see> перехватите исключение базового класса <see cref="T:System.ArgumentException" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-354">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="d2f72-355">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-355">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d2f72-356">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="d2f72-356">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="d2f72-357">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-357">-or-</span></span> 
<span data-ttu-id="d2f72-358">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="d2f72-358">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-359"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-359"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="d2f72-360">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-360">-or-</span></span> 
 <span data-ttu-id="d2f72-361">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-361"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-362">Ожидание прервано, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-362">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-363">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-363">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-364">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-364">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d2f72-365">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="d2f72-365">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="d2f72-366">Данный массив не может содержать несколько ссылок на один и тот же объект (дубликатов).</span><span class="sxs-lookup"><span data-stu-id="d2f72-366">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="d2f72-367">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-367">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d2f72-368">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-368"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d2f72-369">Ожидает получения сигнала всеми элементами заданного массива, используя значение типа <see cref="T:System.Int32" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-369">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="d2f72-370">Значение <see langword="true" />, если каждый элемент массива <paramref name="waitHandles" /> получил сигнал; в противном случае значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-370"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-371">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-371">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-372">Он проверяет состояние дескрипторов ожидания и немедленно возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="d2f72-372">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d2f72-373"><xref:System.Threading.AbandonedMutexException> впервые пойдет в .NET Framework версии 2,0.</span><span class="sxs-lookup"><span data-stu-id="d2f72-373"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d2f72-374">В предыдущих версиях метод <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает `true`, когда мьютекс отброшен.</span><span class="sxs-lookup"><span data-stu-id="d2f72-374">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="d2f72-375">Брошенный мьютекс часто указывает на серьезную ошибку кода.</span><span class="sxs-lookup"><span data-stu-id="d2f72-375">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d2f72-376">В случае с мьютексом на уровне системы это может означать, что приложение было внезапно завершено (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="d2f72-376">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d2f72-377">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="d2f72-377">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d2f72-378">Метод <xref:System.Threading.WaitHandle.WaitAll%2A> возвращается при завершении ожидания, что означает, когда все дескрипторы получают сигнал или когда происходит время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-378">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="d2f72-379">В некоторых реализациях, если передано более 64 дескрипторов, выдается <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-379">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="d2f72-380">Если в массиве есть дубликаты, вызов завершается с <xref:System.DuplicateWaitObjectException>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-380">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d2f72-381">Метод <xref:System.Threading.WaitHandle.WaitAll%2A> не поддерживается в потоках, имеющих <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-381">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d2f72-382">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="d2f72-382">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d2f72-383">Параметр `exitContext` не действует, если только метод <xref:System.Threading.WaitHandle.WaitAll%2A> не вызывается из управляемого контекста, не используемого по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="d2f72-383">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d2f72-384">Это может произойти, если поток находится внутри вызова экземпляра класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-384">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d2f72-385">Даже если в данный момент выполняется метод для класса, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, можно использовать нестандартный контекст, если <xref:System.ContextBoundObject> находится в стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-385">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d2f72-386">Если код выполняется в контексте, не заданном по умолчанию, то при указании `true` для `exitContext` поток будет выходить из управляемого контекста, не используемого по умолчанию (то есть до перехода в контекст по умолчанию), перед выполнением метода <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-386">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="d2f72-387">Поток возвращается к исходному контексту, не заданному по умолчанию, после вызова метода <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-387">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="d2f72-388">Это может быть полезно, если у контекстно-привязанного класса имеется атрибут <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-388">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="d2f72-389">В этом случае все вызовы членов класса автоматически синхронизируются, а домен синхронизации — весь текст кода для класса.</span><span class="sxs-lookup"><span data-stu-id="d2f72-389">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d2f72-390">Если код в стеке вызовов члена вызывает метод <xref:System.Threading.WaitHandle.WaitAll%2A> и указывает `true` для `exitContext`, поток завершает работу домена синхронизации, позволяя потоку, который блокируется на вызов любого члена объекта, продолжать работу.</span><span class="sxs-lookup"><span data-stu-id="d2f72-390">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d2f72-391">Когда метод <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает значение, поток, который выполнил вызов, должен дождаться повторного входа в домен синхронизации.</span><span class="sxs-lookup"><span data-stu-id="d2f72-391">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d2f72-392">В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи в группу файлов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-392">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="d2f72-393">Каждая операция записи помещается в очередь как рабочий элемент и сигнализирует о ее завершении.</span><span class="sxs-lookup"><span data-stu-id="d2f72-393">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="d2f72-394">Основной поток ожидает сигнала всех элементов и завершает работу.</span><span class="sxs-lookup"><span data-stu-id="d2f72-394">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d2f72-395">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-395">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-396">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-396">-or-</span></span> 
<span data-ttu-id="d2f72-397">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-397">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-398">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-398">-or-</span></span> 
 <span data-ttu-id="d2f72-399">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 2.0 или более поздней.</span><span class="sxs-lookup"><span data-stu-id="d2f72-399"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="d2f72-400">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-400">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d2f72-401">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="d2f72-401">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="d2f72-402">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-402">-or-</span></span> 
<span data-ttu-id="d2f72-403">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="d2f72-403">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="d2f72-404">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 1.0 или 1.1.</span><span class="sxs-lookup"><span data-stu-id="d2f72-404"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-405">Параметр<paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-405"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-406">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-406">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-407">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-407">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-408">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-408">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d2f72-409">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="d2f72-409">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="d2f72-410">Этот массив не может содержать несколько ссылок на один и тот же объект.</span><span class="sxs-lookup"><span data-stu-id="d2f72-410">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="d2f72-411">Объект <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или объект <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-411">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d2f72-412">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-412"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d2f72-413">Ожидает получения сигнала всеми элементами заданного массива, используя значение типа <see cref="T:System.TimeSpan" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-413">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="d2f72-414">Значение <see langword="true" />, когда каждый элемент массива <paramref name="waitHandles" /> получил сигнал; иначе — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-414"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-415">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-415">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-416">Он проверяет состояние дескрипторов ожидания и немедленно возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="d2f72-416">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d2f72-417"><xref:System.Threading.AbandonedMutexException> впервые пойдет в .NET Framework версии 2,0.</span><span class="sxs-lookup"><span data-stu-id="d2f72-417"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d2f72-418">В предыдущих версиях метод <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает `true`, когда мьютекс отброшен.</span><span class="sxs-lookup"><span data-stu-id="d2f72-418">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="d2f72-419">Брошенный мьютекс часто указывает на серьезную ошибку кода.</span><span class="sxs-lookup"><span data-stu-id="d2f72-419">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d2f72-420">В случае с мьютексом на уровне системы это может означать, что приложение было внезапно завершено (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="d2f72-420">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d2f72-421">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="d2f72-421">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d2f72-422">Метод <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает, когда ожидание завершается, а это означает, что либо все дескрипторы являются сигнальными, либо истекает время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-422">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="d2f72-423">В некоторых реализациях, если передано более 64 дескрипторов, выдается <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-423">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="d2f72-424">Если массив содержит дубликаты, вызов завершится ошибкой.</span><span class="sxs-lookup"><span data-stu-id="d2f72-424">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d2f72-425">Метод <xref:System.Threading.WaitHandle.WaitAll%2A> не поддерживается в потоках, имеющих <xref:System.STAThreadAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-425">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="d2f72-426">Максимальное значение для `timeout` равно <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-426">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d2f72-427">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="d2f72-427">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d2f72-428">Параметр `exitContext` не действует, если только метод <xref:System.Threading.WaitHandle.WaitAll%2A> не вызывается из управляемого контекста, не используемого по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="d2f72-428">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d2f72-429">Это может произойти, если поток находится внутри вызова экземпляра класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-429">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d2f72-430">Даже если в данный момент выполняется метод для класса, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, можно использовать нестандартный контекст, если <xref:System.ContextBoundObject> находится в стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-430">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d2f72-431">Если код выполняется в контексте, не заданном по умолчанию, то при указании `true` для `exitContext` поток будет выходить из управляемого контекста, не используемого по умолчанию (то есть до перехода в контекст по умолчанию), перед выполнением метода <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-431">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="d2f72-432">Он возвращается к исходному контексту, не заданному по умолчанию, после вызова метода <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-432">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="d2f72-433">Это может быть полезно, если класс, привязанный к контексту, имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-433">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d2f72-434">В этом случае все вызовы членов класса автоматически синхронизируются, а домен синхронизации — весь текст кода для класса.</span><span class="sxs-lookup"><span data-stu-id="d2f72-434">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d2f72-435">Если код в стеке вызовов члена вызывает метод <xref:System.Threading.WaitHandle.WaitAll%2A> и указывает `true` для `exitContext`, поток завершает работу домена синхронизации, позволяя потоку, который блокируется на вызов любого члена объекта, продолжать работу.</span><span class="sxs-lookup"><span data-stu-id="d2f72-435">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d2f72-436">Когда метод <xref:System.Threading.WaitHandle.WaitAll%2A> возвращает значение, поток, который выполнил вызов, должен дождаться повторного входа в домен синхронизации.</span><span class="sxs-lookup"><span data-stu-id="d2f72-436">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d2f72-437">В следующем примере кода показано, как использовать пул потоков для асинхронного создания и записи в группу файлов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-437">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="d2f72-438">Каждая операция записи помещается в очередь как рабочий элемент и сигнализирует о ее завершении.</span><span class="sxs-lookup"><span data-stu-id="d2f72-438">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="d2f72-439">Основной поток ожидает сигнала всех элементов и завершает работу.</span><span class="sxs-lookup"><span data-stu-id="d2f72-439">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d2f72-440">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-440">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-441">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-441">-or-</span></span> 
<span data-ttu-id="d2f72-442">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-442">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-443">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-443">-or-</span></span> 
 <span data-ttu-id="d2f72-444">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 2.0 или более поздней.</span><span class="sxs-lookup"><span data-stu-id="d2f72-444"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="d2f72-445">Массив <paramref name="waitHandles" /> содержит повторяющиеся элементы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-445">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d2f72-446">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="d2f72-446">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="d2f72-447">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-447">-or-</span></span> 
<span data-ttu-id="d2f72-448">Атрибут <see cref="T:System.STAThreadAttribute" /> применяется к процедуре потока для текущего потока, а массив <paramref name="waitHandles" /> содержит более одного элемента.</span><span class="sxs-lookup"><span data-stu-id="d2f72-448">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="d2f72-449">Массив <paramref name="waitHandles" /> не содержит элементов, и используется платформа .NET Framework версии 1.0 или 1.1.</span><span class="sxs-lookup"><span data-stu-id="d2f72-449"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-450"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-450"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="d2f72-451">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-451">-or-</span></span> 
 <span data-ttu-id="d2f72-452">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-452"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-453">Ожидание прервано, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-453">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-454">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-454">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-455">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-455">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d2f72-456">Ожидает получения сигнала какими-либо элементами заданного массива.</span><span class="sxs-lookup"><span data-stu-id="d2f72-456">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d2f72-457">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="d2f72-457">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="d2f72-458">Ожидает получения сигнала какими-либо элементами заданного массива.</span><span class="sxs-lookup"><span data-stu-id="d2f72-458">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="d2f72-459">Индекс объекта, удовлетворившего операцию ожидания, в массиве.</span><span class="sxs-lookup"><span data-stu-id="d2f72-459">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-460"><xref:System.Threading.AbandonedMutexException> впервые пойдет в .NET Framework версии 2,0.</span><span class="sxs-lookup"><span data-stu-id="d2f72-460"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d2f72-461">В предыдущих версиях метод <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает `true`, если ожидание завершается, так как мьютекс отброшен.</span><span class="sxs-lookup"><span data-stu-id="d2f72-461">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="d2f72-462">Брошенный мьютекс часто указывает на серьезную ошибку кода.</span><span class="sxs-lookup"><span data-stu-id="d2f72-462">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d2f72-463">В случае с мьютексом на уровне системы это может означать, что приложение было внезапно завершено (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="d2f72-463">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d2f72-464">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="d2f72-464">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d2f72-465">Метод <xref:System.Threading.WaitHandle.WaitAny%2A> создает исключение <xref:System.Threading.AbandonedMutexException>, только если ожидание завершается из-за брошенного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="d2f72-465">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="d2f72-466">Если `waitHandles` содержит освобожденный мьютекс с меньшим номером индекса, чем брошенный мьютекс, метод <xref:System.Threading.WaitHandle.WaitAny%2A> завершается нормально, и исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="d2f72-466">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d2f72-467">В версиях .NET Framework более ранние, чем 2,0, если поток завершается или прерывается без явного освобождения <xref:System.Threading.Mutex>, а `Mutex` — с индексом 0 (нулем) в массиве `WaitAny` в другом потоке, индекс, возвращаемый `WaitAny`, равен 128, а не 0.</span><span class="sxs-lookup"><span data-stu-id="d2f72-467">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="d2f72-468">Этот метод возвращает значение, если какой-либо дескриптор имеет сигнал.</span><span class="sxs-lookup"><span data-stu-id="d2f72-468">This method returns when any handle is signaled.</span></span> <span data-ttu-id="d2f72-469">Если во время вызова передается более одного объекта, возвращаемое значение представляет собой индекс массива сигнального объекта с наименьшим значением индекса всех сигнальных объектов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-469">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="d2f72-470">В некоторых реализациях при передаче более 64 дескрипторов возникает исключение <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-470">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="d2f72-471">Вызов этой перегрузки метода эквивалентен вызову перегрузки метода <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> и указанию-1 (или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) для `millisecondsTimeout` и `true` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d2f72-471">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d2f72-472">В следующем примере кода демонстрируется вызов метода <xref:System.Threading.WaitHandle.WaitAny%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-472">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d2f72-473">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-473">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-474">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-474">-or-</span></span> 
<span data-ttu-id="d2f72-475">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-475">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d2f72-476">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="d2f72-476">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="d2f72-477"><paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 1.0 или 1.1.</span><span class="sxs-lookup"><span data-stu-id="d2f72-477"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-478">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-478">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-479">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-479">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d2f72-480"><paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 2.0 или выше.</span><span class="sxs-lookup"><span data-stu-id="d2f72-480"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-481">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-481">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d2f72-482">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="d2f72-482">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="d2f72-483">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-483">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d2f72-484">Ожидает получения сигнала любыми элементами указанного массива, используя 32-разрядное целое число со знаком для задания интервала времени.</span><span class="sxs-lookup"><span data-stu-id="d2f72-484">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="d2f72-485">Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="millisecondsTimeout" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-485">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-486">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-486">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-487">Он проверяет состояние дескрипторов ожидания и немедленно возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="d2f72-487">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d2f72-488">Метод <xref:System.Threading.WaitHandle.WaitAny%2A> создает исключение <xref:System.Threading.AbandonedMutexException>, только если ожидание завершается из-за брошенного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="d2f72-488">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="d2f72-489">Если `waitHandles` содержит освобожденный мьютекс с меньшим номером индекса, чем брошенный мьютекс, метод <xref:System.Threading.WaitHandle.WaitAny%2A> завершается нормально, и исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="d2f72-489">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="d2f72-490">Этот метод возвращает значение, когда ожидание завершается, когда любой из дескрипторов получает сигнал или когда происходит время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-490">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="d2f72-491">Если во время вызова передается более одного объекта, возвращаемое значение представляет собой индекс массива сигнального объекта с наименьшим значением индекса всех сигнальных объектов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-491">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="d2f72-492">В некоторых реализациях при передаче более 64 дескрипторов возникает исключение <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-492">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="d2f72-493">Вызов этой перегрузки метода аналогичен вызову перегрузки <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> и указанию `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d2f72-493">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d2f72-494">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-494">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-495">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-495">-or-</span></span> 
<span data-ttu-id="d2f72-496">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-496">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d2f72-497">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="d2f72-497">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-498">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-498"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-499">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-499">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-500">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-500">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d2f72-501">В массиве <paramref name="waitHandles" /> отсутствуют элементы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-501"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-502">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-502">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d2f72-503">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="d2f72-503">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="d2f72-504">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-504">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d2f72-505">Ожидает получения сигнала любыми элементами заданного массива, используя значение типа <see cref="T:System.TimeSpan" /> для указания интервала времени.</span><span class="sxs-lookup"><span data-stu-id="d2f72-505">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="d2f72-506">Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="timeout" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-506">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-507">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-507">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-508">Он проверяет состояние дескрипторов ожидания и немедленно возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="d2f72-508">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d2f72-509">Метод <xref:System.Threading.WaitHandle.WaitAny%2A> создает исключение <xref:System.Threading.AbandonedMutexException>, только если ожидание завершается из-за брошенного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="d2f72-509">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="d2f72-510">Если `waitHandles` содержит освобожденный мьютекс с меньшим номером индекса, чем брошенный мьютекс, метод <xref:System.Threading.WaitHandle.WaitAny%2A> завершается нормально, и исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="d2f72-510">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="d2f72-511">Этот метод возвращает значение, когда ожидание завершается, когда любой из дескрипторов получает сигнал или когда происходит тайм-аут.</span><span class="sxs-lookup"><span data-stu-id="d2f72-511">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="d2f72-512">Если во время вызова передается более одного объекта, возвращаемое значение представляет собой индекс массива сигнального объекта с наименьшим значением индекса всех сигнальных объектов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-512">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="d2f72-513">В некоторых реализациях при передаче более 64 дескрипторов возникает исключение <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-513">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="d2f72-514">Максимальное значение для `timeout` равно <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-514">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d2f72-515">Вызов этой перегрузки метода аналогичен вызову перегрузки <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> и указанию `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d2f72-515">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d2f72-516">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-516">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-517">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-517">-or-</span></span> 
<span data-ttu-id="d2f72-518">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-518">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d2f72-519">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="d2f72-519">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-520"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-520"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="d2f72-521">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-521">-or-</span></span> 
 <span data-ttu-id="d2f72-522">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-522"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-523">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-523">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-524">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-524">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d2f72-525">В массиве <paramref name="waitHandles" /> отсутствуют элементы.</span><span class="sxs-lookup"><span data-stu-id="d2f72-525"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-526">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-526">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d2f72-527">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="d2f72-527">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="d2f72-528">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-528">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d2f72-529">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-529"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d2f72-530">Ожидает, пока какой-либо из элементов заданного массива не получит сигнал, используя 32-разрядное целое число со знаком для задания интервала времени и определения, нужно ли осуществить выход из домена синхронизации до окончания ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-530">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="d2f72-531">Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="millisecondsTimeout" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-531">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-532">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-532">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-533">Он проверяет состояние дескрипторов ожидания и немедленно возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="d2f72-533">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d2f72-534"><xref:System.Threading.AbandonedMutexException> впервые пойдет в .NET Framework версии 2,0.</span><span class="sxs-lookup"><span data-stu-id="d2f72-534"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d2f72-535">В предыдущих версиях метод <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает `true`, если ожидание завершается, так как мьютекс отброшен.</span><span class="sxs-lookup"><span data-stu-id="d2f72-535">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="d2f72-536">Брошенный мьютекс часто указывает на серьезную ошибку кода.</span><span class="sxs-lookup"><span data-stu-id="d2f72-536">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d2f72-537">В случае с мьютексом на уровне системы это может означать, что приложение было внезапно завершено (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="d2f72-537">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d2f72-538">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="d2f72-538">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d2f72-539">Метод <xref:System.Threading.WaitHandle.WaitAny%2A> создает исключение <xref:System.Threading.AbandonedMutexException>, только если ожидание завершается из-за брошенного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="d2f72-539">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="d2f72-540">Если `waitHandles` содержит освобожденный мьютекс с меньшим номером индекса, чем брошенный мьютекс, метод <xref:System.Threading.WaitHandle.WaitAny%2A> завершается нормально, и исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="d2f72-540">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d2f72-541">В версиях .NET Framework более ранние, чем 2,0, если поток завершается или прерывается без явного освобождения <xref:System.Threading.Mutex>, а `Mutex` — с индексом 0 (нулем) в массиве `WaitAny` в другом потоке, индекс, возвращаемый `WaitAny`, равен 128, а не 0.</span><span class="sxs-lookup"><span data-stu-id="d2f72-541">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="d2f72-542">Этот метод возвращает значение, когда ожидание завершается, когда любой из дескрипторов получает сигнал или когда происходит время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-542">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="d2f72-543">Если во время вызова передается более одного объекта, возвращаемое значение представляет собой индекс массива сигнального объекта с наименьшим значением индекса всех сигнальных объектов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-543">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="d2f72-544">В некоторых реализациях при передаче более 64 дескрипторов возникает исключение <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-544">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d2f72-545">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="d2f72-545">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d2f72-546">Параметр `exitContext` не действует, если только метод <xref:System.Threading.WaitHandle.WaitAny%2A> не вызывается из управляемого контекста, не используемого по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="d2f72-546">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d2f72-547">Это может произойти, если поток находится внутри вызова экземпляра класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-547">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d2f72-548">Даже если в данный момент выполняется метод для класса, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, можно использовать нестандартный контекст, если <xref:System.ContextBoundObject> находится в стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-548">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d2f72-549">Если код выполняется в контексте, не заданном по умолчанию, то при указании `true` для `exitContext` поток будет выходить из управляемого контекста, не используемого по умолчанию (то есть до перехода в контекст по умолчанию), перед выполнением метода <xref:System.Threading.WaitHandle.WaitAny%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-549">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="d2f72-550">Поток возвращается к исходному контексту, не заданному по умолчанию, после вызова метода <xref:System.Threading.WaitHandle.WaitAny%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-550">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="d2f72-551">Это может быть полезно, если класс, привязанный к контексту, имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-551">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d2f72-552">В этом случае все вызовы членов класса автоматически синхронизируются, а домен синхронизации — весь текст кода для класса.</span><span class="sxs-lookup"><span data-stu-id="d2f72-552">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d2f72-553">Если код в стеке вызовов члена вызывает метод <xref:System.Threading.WaitHandle.WaitAny%2A> и указывает `true` для `exitContext`, поток завершает работу домена синхронизации, позволяя потоку, который блокируется на вызов любого члена объекта, продолжать работу.</span><span class="sxs-lookup"><span data-stu-id="d2f72-553">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d2f72-554">Когда метод <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает значение, поток, который выполнил вызов, должен дождаться повторного входа в домен синхронизации.</span><span class="sxs-lookup"><span data-stu-id="d2f72-554">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d2f72-555">В следующем примере кода показано, как использовать пул потоков для одновременного поиска файла на нескольких дисках.</span><span class="sxs-lookup"><span data-stu-id="d2f72-555">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="d2f72-556">Для соображений места на диске выполняется поиск только в корневом каталоге каждого диска.</span><span class="sxs-lookup"><span data-stu-id="d2f72-556">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d2f72-557">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-557">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-558">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-558">-or-</span></span> 
<span data-ttu-id="d2f72-559">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-559">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d2f72-560">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="d2f72-560">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="d2f72-561"><paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 1.0 или 1.1.</span><span class="sxs-lookup"><span data-stu-id="d2f72-561"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-562">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-562"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-563">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-563">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-564">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-564">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d2f72-565"><paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 2.0 или выше.</span><span class="sxs-lookup"><span data-stu-id="d2f72-565"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-566">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-566">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="d2f72-567">Массив <see langword="WaitHandle" />, содержащий объекты, ожидаемые текущим экземпляром.</span><span class="sxs-lookup"><span data-stu-id="d2f72-567">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="d2f72-568">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-568">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d2f72-569">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-569"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d2f72-570">Ожидает получения сигнала какими-либо элементами заданного массива, используя <see cref="T:System.TimeSpan" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-570">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="d2f72-571">Индекс объекта в массиве, удовлетворившего условиям ожидания, или значение <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, если ни один из объектов не удовлетворил условиям ожидания и истек интервал времени, равный <paramref name="timeout" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-571">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-572">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-572">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-573">Он проверяет состояние дескрипторов ожидания и немедленно возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="d2f72-573">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="d2f72-574"><xref:System.Threading.AbandonedMutexException> впервые пойдет в .NET Framework версии 2,0.</span><span class="sxs-lookup"><span data-stu-id="d2f72-574"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d2f72-575">В предыдущих версиях метод <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает `true`, если ожидание завершается, так как мьютекс отброшен.</span><span class="sxs-lookup"><span data-stu-id="d2f72-575">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="d2f72-576">Брошенный мьютекс часто указывает на серьезную ошибку кода.</span><span class="sxs-lookup"><span data-stu-id="d2f72-576">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d2f72-577">В случае с мьютексом на уровне системы это может означать, что приложение было внезапно завершено (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="d2f72-577">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d2f72-578">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="d2f72-578">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d2f72-579">Метод <xref:System.Threading.WaitHandle.WaitAny%2A> создает исключение <xref:System.Threading.AbandonedMutexException>, только если ожидание завершается из-за брошенного мьютекса.</span><span class="sxs-lookup"><span data-stu-id="d2f72-579">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="d2f72-580">Если `waitHandles` содержит освобожденный мьютекс с меньшим номером индекса, чем брошенный мьютекс, метод <xref:System.Threading.WaitHandle.WaitAny%2A> завершается нормально, и исключение не создается.</span><span class="sxs-lookup"><span data-stu-id="d2f72-580">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d2f72-581">В версиях .NET Framework более ранние, чем 2,0, если поток завершается или прерывается без явного освобождения <xref:System.Threading.Mutex>, а `Mutex` — с индексом 0 (нулем) в массиве `WaitAny` в другом потоке, индекс, возвращаемый `WaitAny`, равен 128, а не 0.</span><span class="sxs-lookup"><span data-stu-id="d2f72-581">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="d2f72-582">Этот метод возвращает значение, когда ожидание завершается, когда любой из дескрипторов получает сигнал или когда происходит тайм-аут.</span><span class="sxs-lookup"><span data-stu-id="d2f72-582">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="d2f72-583">Если во время вызова передается более одного объекта, возвращаемое значение представляет собой индекс массива сигнального объекта с наименьшим значением индекса всех сигнальных объектов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-583">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="d2f72-584">В некоторых реализациях при передаче более 64 дескрипторов возникает исключение <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-584">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="d2f72-585">Максимальное значение для `timeout` равно <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-585">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d2f72-586">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="d2f72-586">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d2f72-587">Параметр `exitContext` не действует, если только метод <xref:System.Threading.WaitHandle.WaitAny%2A> не вызывается из управляемого контекста, не используемого по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="d2f72-587">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d2f72-588">Это может произойти, если поток находится внутри вызова экземпляра класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-588">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d2f72-589">Даже если в данный момент выполняется метод для класса, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, можно использовать нестандартный контекст, если <xref:System.ContextBoundObject> находится в стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-589">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d2f72-590">Если код выполняется в контексте, не заданном по умолчанию, то при указании `true` для `exitContext` поток будет выходить из управляемого контекста, не используемого по умолчанию (то есть до перехода в контекст по умолчанию), перед выполнением метода <xref:System.Threading.WaitHandle.WaitAny%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-590">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="d2f72-591">Поток возвращается к исходному контексту, не заданному по умолчанию, после вызова метода <xref:System.Threading.WaitHandle.WaitAny%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-591">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="d2f72-592">Это может быть полезно, если класс, привязанный к контексту, имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-592">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d2f72-593">В этом случае все вызовы членов класса автоматически синхронизируются, а домен синхронизации — весь текст кода для класса.</span><span class="sxs-lookup"><span data-stu-id="d2f72-593">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d2f72-594">Если код в стеке вызовов члена вызывает метод <xref:System.Threading.WaitHandle.WaitAny%2A> и указывает `true` для `exitContext`, поток завершает работу домена синхронизации, позволяя потоку, который блокируется на вызов любого члена объекта, продолжать работу.</span><span class="sxs-lookup"><span data-stu-id="d2f72-594">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d2f72-595">Когда метод <xref:System.Threading.WaitHandle.WaitAny%2A> возвращает значение, поток, который выполнил вызов, должен дождаться повторного входа в домен синхронизации.</span><span class="sxs-lookup"><span data-stu-id="d2f72-595">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d2f72-596">В следующем примере кода показано, как использовать пул потоков для одновременного поиска файла на нескольких дисках.</span><span class="sxs-lookup"><span data-stu-id="d2f72-596">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="d2f72-597">Для соображений места на диске выполняется поиск только в корневом каталоге каждого диска.</span><span class="sxs-lookup"><span data-stu-id="d2f72-597">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d2f72-598">Параметр <paramref name="waitHandles" /> имеет значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-598">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d2f72-599">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-599">-or-</span></span> 
<span data-ttu-id="d2f72-600">Один или несколько объектов массива <paramref name="waitHandles" /> имеют значение <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-600">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d2f72-601">Массив <paramref name="waitHandles" /> содержит больше объектов, чем разрешено системой.</span><span class="sxs-lookup"><span data-stu-id="d2f72-601">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="d2f72-602"><paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 1.0 или 1.1.</span><span class="sxs-lookup"><span data-stu-id="d2f72-602"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-603"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-603"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="d2f72-604">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-604">-or-</span></span> 
 <span data-ttu-id="d2f72-605">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-605"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-606">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-606">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-607">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-607">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d2f72-608"><paramref name="waitHandles" /> является массивом без элементов, а платформа .NET Framework имеет версию 2.0 или выше.</span><span class="sxs-lookup"><span data-stu-id="d2f72-608"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-609">Массив <paramref name="waitHandles" /> содержит прозрачный прокси для элемента <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-609">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d2f72-610">Блокирует текущий поток до получения сигнала объектом <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-610">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d2f72-611">Блокирует текущий поток до получения сигнала объектом <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-611">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns><span data-ttu-id="d2f72-612">Значение <see langword="true" />, если текущий экземпляр получает сигнал.</span><span class="sxs-lookup"><span data-stu-id="d2f72-612"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="d2f72-613">Пока текущий экземпляр не сигнализирует, метод <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> не возвращает управление.</span><span class="sxs-lookup"><span data-stu-id="d2f72-613">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-614"><xref:System.Threading.AbandonedMutexException> впервые пойдет в .NET Framework версии 2,0.</span><span class="sxs-lookup"><span data-stu-id="d2f72-614"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d2f72-615">В предыдущих версиях метод <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает `true`, когда мьютекс отброшен.</span><span class="sxs-lookup"><span data-stu-id="d2f72-615">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="d2f72-616">Брошенный мьютекс часто указывает на серьезную ошибку кода.</span><span class="sxs-lookup"><span data-stu-id="d2f72-616">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d2f72-617">В случае с мьютексом на уровне системы это может означать, что приложение было внезапно завершено (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="d2f72-617">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d2f72-618">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="d2f72-618">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d2f72-619">Вызывающий объект этого метода блокируется на неограниченное время, пока текущий экземпляр не получит сигнал.</span><span class="sxs-lookup"><span data-stu-id="d2f72-619">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="d2f72-620">Используйте этот метод для блокировки до тех пор, пока <xref:System.Threading.WaitHandle> не получит сигнал от другого потока, например создается после завершения асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="d2f72-620">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="d2f72-621">Дополнительные сведения см. в описании интерфейса <xref:System.IAsyncResult>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-621">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="d2f72-622">Вызов этой перегрузки метода эквивалентен вызову перегрузки метода <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> и указанию-1 или <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> для первого параметра и `false` для второго параметра.</span><span class="sxs-lookup"><span data-stu-id="d2f72-622">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="d2f72-623">Переопределите этот метод, чтобы настроить поведение производных классов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-623">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d2f72-624">В следующем примере кода показано, как использовать обработчик ожидания для предотвращения завершения процесса, пока он ожидает завершения выполнения фонового потока.</span><span class="sxs-lookup"><span data-stu-id="d2f72-624">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d2f72-625">Текущий экземпляр уже удален.</span><span class="sxs-lookup"><span data-stu-id="d2f72-625">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-626">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-626">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-627">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-628">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="d2f72-629">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-629">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d2f72-630">Блокирует текущий поток до получения текущим дескриптором <see cref="T:System.Threading.WaitHandle" /> сигнала, используя 32-разрядное целое число со знаком для указания интервала времени в миллисекундах.</span><span class="sxs-lookup"><span data-stu-id="d2f72-630">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="d2f72-631">Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-631"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-632">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-632">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-633">Он проверяет состояние маркера ожидания и немедленно возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="d2f72-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="d2f72-634">Вызывающий объект этого метода блокируется до тех пор, пока текущий экземпляр не получит сигнал или не истечет время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="d2f72-635">Используйте этот метод для блокировки до тех пор, пока <xref:System.Threading.WaitHandle> не получит сигнал от другого потока, например создается после завершения асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="d2f72-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="d2f72-636">Дополнительные сведения см. в описании интерфейса <xref:System.IAsyncResult>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="d2f72-637">Переопределите этот метод, чтобы настроить поведение производных классов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="d2f72-638">Вызов этой перегрузки метода аналогичен вызову перегрузки <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> и указанию `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d2f72-638">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d2f72-639">В следующем примере кода показано, как использовать обработчик ожидания для предотвращения завершения процесса, пока он ожидает завершения выполнения фонового потока.</span><span class="sxs-lookup"><span data-stu-id="d2f72-639">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d2f72-640">Текущий экземпляр уже удален.</span><span class="sxs-lookup"><span data-stu-id="d2f72-640">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-641">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-641"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-642">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-642">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-643">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-643">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-644">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-644">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="d2f72-645">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-645">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d2f72-646">Блокирует текущий поток до получения сигнала текущим экземпляром, используя значение типа <see cref="T:System.TimeSpan" /> для указания интервала времени.</span><span class="sxs-lookup"><span data-stu-id="d2f72-646">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="d2f72-647">Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-647"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-648">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-648">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-649">Он проверяет состояние маркера ожидания и немедленно возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="d2f72-649">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="d2f72-650">Вызывающий объект этого метода блокируется до тех пор, пока текущий экземпляр не получит сигнал или не истечет время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-650">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="d2f72-651">Используйте этот метод для блокировки до тех пор, пока <xref:System.Threading.WaitHandle> не получит сигнал от другого потока, например создается после завершения асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="d2f72-651">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="d2f72-652">Дополнительные сведения см. в описании интерфейса <xref:System.IAsyncResult>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-652">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="d2f72-653">Переопределите этот метод, чтобы настроить поведение производных классов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-653">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="d2f72-654">Максимальное значение для `timeout` равно <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-654">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d2f72-655">Вызов этой перегрузки метода аналогичен вызову перегрузки <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> и указанию `false` для `exitContext`.</span><span class="sxs-lookup"><span data-stu-id="d2f72-655">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d2f72-656">Текущий экземпляр уже удален.</span><span class="sxs-lookup"><span data-stu-id="d2f72-656">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-657"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-657"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="d2f72-658">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-658">-or-</span></span> 
 <span data-ttu-id="d2f72-659">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-659"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-660">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-660">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-661">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-661">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-662">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-662">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="d2f72-663">Время ожидания в миллисекундах или функция <see cref="F:System.Threading.Timeout.Infinite" /> (-1) в случае неограниченного времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-663">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d2f72-664">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-664"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d2f72-665">Блокирует текущий поток до получения сигнала текущим объектом <see cref="T:System.Threading.WaitHandle" />, используя 32-разрядное целое число со знаком для задания периода времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-665">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="d2f72-666">Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-666"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-667">Если `millisecondsTimeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-667">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-668">Он проверяет состояние маркера ожидания и немедленно возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="d2f72-668">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="d2f72-669"><xref:System.Threading.AbandonedMutexException> впервые пойдет в .NET Framework версии 2,0.</span><span class="sxs-lookup"><span data-stu-id="d2f72-669"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d2f72-670">В предыдущих версиях метод <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает `true`, когда мьютекс отброшен.</span><span class="sxs-lookup"><span data-stu-id="d2f72-670">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="d2f72-671">Брошенный мьютекс часто указывает на серьезную ошибку кода.</span><span class="sxs-lookup"><span data-stu-id="d2f72-671">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d2f72-672">В случае с мьютексом на уровне системы это может означать, что приложение было внезапно завершено (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="d2f72-672">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d2f72-673">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="d2f72-673">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d2f72-674">Вызывающий объект этого метода блокируется до тех пор, пока текущий экземпляр не получит сигнал или не истечет время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-674">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="d2f72-675">Используйте этот метод для блокировки до тех пор, пока <xref:System.Threading.WaitHandle> не получит сигнал от другого потока, например создается после завершения асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="d2f72-675">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="d2f72-676">Дополнительные сведения см. в описании интерфейса <xref:System.IAsyncResult>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-676">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="d2f72-677">Переопределите этот метод, чтобы настроить поведение производных классов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-677">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d2f72-678">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="d2f72-678">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d2f72-679">Параметр `exitContext` не действует, если только метод <xref:System.Threading.WaitHandle.WaitOne%2A> не вызывается из управляемого контекста, не используемого по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="d2f72-679">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d2f72-680">Это может произойти, если поток находится внутри вызова экземпляра класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-680">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d2f72-681">Даже если в данный момент выполняется метод для класса, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, можно использовать нестандартный контекст, если <xref:System.ContextBoundObject> находится в стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-681">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d2f72-682">Если код выполняется в контексте, не заданном по умолчанию, то при указании `true` для `exitContext` поток будет выходить из управляемого контекста, не используемого по умолчанию (то есть до перехода в контекст по умолчанию), перед выполнением метода <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-682">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="d2f72-683">Поток возвращается к исходному контексту, не заданному по умолчанию, после вызова метода <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-683">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="d2f72-684">Это может быть полезно, если класс, привязанный к контексту, имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-684">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d2f72-685">В этом случае все вызовы членов класса автоматически синхронизируются, а домен синхронизации — весь текст кода для класса.</span><span class="sxs-lookup"><span data-stu-id="d2f72-685">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d2f72-686">Если код в стеке вызовов члена вызывает метод <xref:System.Threading.WaitHandle.WaitOne%2A> и указывает `true` для `exitContext`, поток завершает работу домена синхронизации, позволяя потоку, который блокируется на вызов любого члена объекта, продолжать работу.</span><span class="sxs-lookup"><span data-stu-id="d2f72-686">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d2f72-687">Когда метод <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает значение, поток, который выполнил вызов, должен дождаться повторного входа в домен синхронизации.</span><span class="sxs-lookup"><span data-stu-id="d2f72-687">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d2f72-688">В следующем примере показано, как перегрузка метода <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> ведет себя при вызове в домене синхронизации.</span><span class="sxs-lookup"><span data-stu-id="d2f72-688">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="d2f72-689">Во-первых, поток ожидает, `exitContext` имеет значение `false`, и блокируется до истечения времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-689">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="d2f72-690">Второй поток выполняется после завершения первого потока и ожидает от `exitContext`, установленного в `true`.</span><span class="sxs-lookup"><span data-stu-id="d2f72-690">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="d2f72-691">Вызов для сигнализации дескриптора ожидания для этого второго потока не блокируется, и поток завершается до истечения времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-691">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d2f72-692">Текущий экземпляр уже удален.</span><span class="sxs-lookup"><span data-stu-id="d2f72-692">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-693">Параметр <paramref name="millisecondsTimeout" /> является отрицательным числом, отличным от –1, что означает бесконечное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-693"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-694">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-694">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-695">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-695">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-696">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-696">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="d2f72-697">Период <see cref="T:System.TimeSpan" />, представляющий время ожидания в миллисекундах, или период <see cref="T:System.TimeSpan" />, представляющий -1 миллисекунду для неограниченного ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-697">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="d2f72-698">Значение <see langword="true" /> для выхода из домена синхронизации в текущем контексте перед ожиданием (в синхронизированном контексте) с его последующим повторным получением; в противном случае — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-698"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d2f72-699">Блокирует текущий поток до получения сигнала текущим экземпляром, используя значение типа <see cref="T:System.TimeSpan" /> для задания интервала времени и указывая, следует ли выйти из домена синхронизации до начала ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-699">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="d2f72-700">Значение <see langword="true" /> при получении сигнала текущим экземпляром; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-700"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-701">Если `timeout` равно нулю, метод не блокируется.</span><span class="sxs-lookup"><span data-stu-id="d2f72-701">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="d2f72-702">Он проверяет состояние маркера ожидания и немедленно возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="d2f72-702">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="d2f72-703"><xref:System.Threading.AbandonedMutexException> впервые пойдет в .NET Framework версии 2,0.</span><span class="sxs-lookup"><span data-stu-id="d2f72-703"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="d2f72-704">В предыдущих версиях метод <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает `true`, когда мьютекс отброшен.</span><span class="sxs-lookup"><span data-stu-id="d2f72-704">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="d2f72-705">Брошенный мьютекс часто указывает на серьезную ошибку кода.</span><span class="sxs-lookup"><span data-stu-id="d2f72-705">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="d2f72-706">В случае с мьютексом на уровне системы это может означать, что приложение было внезапно завершено (например, с помощью диспетчера задач Windows).</span><span class="sxs-lookup"><span data-stu-id="d2f72-706">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="d2f72-707">Исключение содержит сведения, полезные для отладки.</span><span class="sxs-lookup"><span data-stu-id="d2f72-707">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="d2f72-708">Вызывающий объект этого метода блокируется до тех пор, пока текущий экземпляр не получит сигнал или не истечет время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-708">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="d2f72-709">Используйте этот метод для блокировки до тех пор, пока <xref:System.Threading.WaitHandle> не получит сигнал от другого потока, например создается после завершения асинхронной операции.</span><span class="sxs-lookup"><span data-stu-id="d2f72-709">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="d2f72-710">Дополнительные сведения см. в описании интерфейса <xref:System.IAsyncResult>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-710">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="d2f72-711">Переопределите этот метод, чтобы настроить поведение производных классов.</span><span class="sxs-lookup"><span data-stu-id="d2f72-711">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="d2f72-712">Максимальное значение для `timeout` равно <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-712">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d2f72-713">Примечания о выходе из контекста</span><span class="sxs-lookup"><span data-stu-id="d2f72-713">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d2f72-714">Параметр `exitContext` не действует, если только метод <xref:System.Threading.WaitHandle.WaitOne%2A> не вызывается из управляемого контекста, не используемого по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="d2f72-714">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d2f72-715">Это может произойти, если поток находится внутри вызова экземпляра класса, производного от <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-715">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d2f72-716">Даже если в данный момент выполняется метод для класса, который не является производным от <xref:System.ContextBoundObject>, например <xref:System.String>, можно использовать нестандартный контекст, если <xref:System.ContextBoundObject> находится в стеке в текущем домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-716">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d2f72-717">Если код выполняется в контексте, не заданном по умолчанию, то при указании `true` для `exitContext` поток будет выходить из управляемого контекста, не используемого по умолчанию (то есть до перехода в контекст по умолчанию), перед выполнением метода <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-717">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="d2f72-718">Поток возвращается к исходному контексту, не заданному по умолчанию, после вызова метода <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-718">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="d2f72-719">Это может быть полезно, если класс, привязанный к контексту, имеет <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span><span class="sxs-lookup"><span data-stu-id="d2f72-719">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="d2f72-720">В этом случае все вызовы членов класса автоматически синхронизируются, а домен синхронизации — весь текст кода для класса.</span><span class="sxs-lookup"><span data-stu-id="d2f72-720">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d2f72-721">Если код в стеке вызовов члена вызывает метод <xref:System.Threading.WaitHandle.WaitOne%2A> и указывает `true` для `exitContext`, поток завершает работу домена синхронизации, позволяя потоку, который блокируется на вызов любого члена объекта, продолжать работу.</span><span class="sxs-lookup"><span data-stu-id="d2f72-721">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d2f72-722">Когда метод <xref:System.Threading.WaitHandle.WaitOne%2A> возвращает значение, поток, который выполнил вызов, должен дождаться повторного входа в домен синхронизации.</span><span class="sxs-lookup"><span data-stu-id="d2f72-722">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d2f72-723">В следующем примере кода показано, как использовать обработчик ожидания для предотвращения завершения процесса, пока он ожидает завершения выполнения фонового потока.</span><span class="sxs-lookup"><span data-stu-id="d2f72-723">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d2f72-724">Текущий экземпляр уже удален.</span><span class="sxs-lookup"><span data-stu-id="d2f72-724">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d2f72-725"><paramref name="timeout" /> является отрицательным числом, отличным от -1 миллисекунды, которое представляет неограниченное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-725"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="d2f72-726">- или -</span><span class="sxs-lookup"><span data-stu-id="d2f72-726">-or-</span></span> 
 <span data-ttu-id="d2f72-727">Значение <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="d2f72-727"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="d2f72-728">Ожидание закончилось, так как поток завершил работу, не освободив мьютекс.</span><span class="sxs-lookup"><span data-stu-id="d2f72-728">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="d2f72-729">Это исключение не вызывается в ОС Windows 98 или Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="d2f72-729">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d2f72-730">Текущий экземпляр является прозрачным прокси для объекта <see cref="T:System.Threading.WaitHandle" /> в другом домене приложения.</span><span class="sxs-lookup"><span data-stu-id="d2f72-730">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="d2f72-731">Указывает, что время ожидания операции <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> истекло до получения сигнала каким-либо из дескрипторов ожидания.</span><span class="sxs-lookup"><span data-stu-id="d2f72-731">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="d2f72-732">Это поле является константой.</span><span class="sxs-lookup"><span data-stu-id="d2f72-732">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d2f72-733">Это поле является одним из возможных возвращаемых значений `WaitAny`.</span><span class="sxs-lookup"><span data-stu-id="d2f72-733">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d2f72-734">В следующем примере кода показано, как использовать пул потоков для одновременного поиска файла на нескольких дисках.</span><span class="sxs-lookup"><span data-stu-id="d2f72-734">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="d2f72-735">Для соображений места на диске выполняется поиск только в корневом каталоге каждого диска.</span><span class="sxs-lookup"><span data-stu-id="d2f72-735">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
