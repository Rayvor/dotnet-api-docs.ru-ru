<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="41e264494954e65638de0bb2a5aa51afc107bba3" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73395625" /></Metadata><TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ограничивает число потоков, которые могут одновременно обращаться к ресурсу или пулу ресурсов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте класс <xref:System.Threading.Semaphore> для управления доступом к пулу ресурсов. Потоки вводят семафор, вызывая метод <xref:System.Threading.WaitHandle.WaitOne%2A>, который наследуется от класса <xref:System.Threading.WaitHandle>, и освобождает семафор, вызывая метод <xref:System.Threading.Semaphore.Release%2A>.  
  
 Счетчик для семафора уменьшается каждый раз, когда поток входит в семафор, и увеличивается, когда поток освобождает семафор. Если значение счетчика равно нулю, последующие запросы блокируются до освобождения семафора другими потоками. Когда семафор освобожден всеми потоками, счетчик будет иметь максимальное значение, указанное при создании семафора.  
  
 Нет гарантированного порядка, например FIFO или ЛИФО, в котором заблокированные потоки вводят семафор.  
  
 Поток может многократно вводить семафор, вызывая метод <xref:System.Threading.WaitHandle.WaitOne%2A> несколько раз. Чтобы освободить некоторые или все эти записи, поток может вызвать перегрузку метода без параметров <xref:System.Threading.Semaphore.Release> несколько раз, или же можно вызвать перегрузку метода <xref:System.Threading.Semaphore.Release%28System.Int32%29>, указывающую число освобожденных записей.  
  
 Класс <xref:System.Threading.Semaphore> не обеспечивает идентификацию потоков при вызовах <xref:System.Threading.WaitHandle.WaitOne%2A> или <xref:System.Threading.Semaphore.Release%2A>. Ответственность за то, чтобы потоки не освободили семафор слишком много раз, лежит на программисте. Например предположим, что семафор имеет максимальное значение счетчика равное двум, а два потока A и B входят в семафор. Если ошибка программирования в потоке B приводит к вызову метода <xref:System.Threading.Semaphore.Release%2A> дважды, оба вызова будут выполнены. Счетчик на семафоре переполнен, и если поток A вызывает <xref:System.Threading.Semaphore.Release%2A>, <xref:System.Threading.SemaphoreFullException> создается исключение.  
  
 Семафоры имеют два типа: локальные семафоры и именованные системные семафоры. При создании <xref:System.Threading.Semaphore> объекта с помощью конструктора, который принимает имя, он связывается с семафором операционной системы этого имени. Именованные системные семафоры видимы во всей операционной системе и могут использоваться для синхронизации действий процессов. Можно создать несколько <xref:System.Threading.Semaphore> объектов, представляющих один и тот же именованный системный семафор, а метод <xref:System.Threading.Semaphore.OpenExisting%2A> можно использовать для открытия существующего именованного системного семафора.  
  
 Локальный семафор существует только в пределах процесса. Его может использовать любой поток в вашем процессе, имеющий ссылку на локальный объект <xref:System.Threading.Semaphore>. Каждый объект <xref:System.Threading.Semaphore> является отдельным локальным семафором.  
  
   
  
## Examples  
 В следующем примере кода создается семафор с максимальным числом трех и начальным счетчиком, равным нулю. В примере запускается пять потоков, которые блокируют ожидание семафора. Основной поток использует перегрузку метода <xref:System.Threading.Semaphore.Release%28System.Int32%29> для увеличения числа семафоров до максимального значения, позволяя трем потокам входить в семафор. Каждый поток использует метод <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> для ожидания одной секунды, для имитации работы, а затем вызывает перегрузку метода <xref:System.Threading.Semaphore.Release> для освобождения семафора. При каждом освобождении семафора отображается предыдущее число семафоров. Сообщения консоли записывают использование семафора. Рабочий интервал смоделированной работы немного увеличивается для каждого потока, чтобы упростить чтение выходных данных.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Начальное количество запросов для семафора, которое может быть обеспечено одновременно.</param>
        <param name="maximumCount">Максимальное количество запросов семафора, которое может быть обеспеченно одновременно.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" />, задающий начальное количество входов и максимальное количество одновременных входов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует безымянный семафор. Все потоки, использующие экземпляр такого семафора, должны иметь ссылки на экземпляр.  
  
 Если `initialCount` меньше `maximumCount`, то результат будет таким же, как если бы текущий поток вызывал <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` минус `initialCount`) раз. Если вы не хотите зарезервировать какие бы то ни было записи для потока, создающего семафор, используйте то же значение для `maximumCount` и `initialCount`.  
  
   
  
## Examples  
 В следующем примере создается семафор с максимальным числом трех и начальным счетчиком, равным нулю. В примере запускается пять потоков, которые блокируют ожидание семафора. Основной поток использует перегрузку метода <xref:System.Threading.Semaphore.Release%28System.Int32%29> для увеличения числа семафоров до максимального значения, позволяя трем потокам входить в семафор. Каждый поток использует метод <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> для ожидания одной секунды, для имитации работы, а затем вызывает перегрузку метода <xref:System.Threading.Semaphore.Release> для освобождения семафора. При каждом освобождении семафора отображается предыдущее число семафоров. Сообщения консоли записывают использование семафора. Рабочий интервал смоделированной работы немного увеличивается для каждого потока, чтобы упростить чтение выходных данных.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maximumCount" /> меньше 1.  
  
- или - 
 Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">Начальное количество запросов для семафора, которое может быть обеспечено одновременно.</param>
        <param name="maximumCount">Максимальное количество запросов семафора, которое может быть обеспеченно одновременно.</param>
        <param name="name">Имя объекта именованного системного семафора.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" />, задающий начальное количество входов и максимальное количество одновременных входов, а также при необходимости имя объекта системного семафора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует объект <xref:System.Threading.Semaphore>, представляющий именованный системный семафор. Можно создать несколько <xref:System.Threading.Semaphore> объектов, представляющих один и тот же именованный системный семафор.  
  
 Если именованный системный семафор не существует, он создается с начальным числом и максимальным числом, заданным в `initialCount` и `maximumCount`. Если именованный системный семафор уже существует, `initialCount` и `maximumCount` не используются, хотя недопустимые значения по-прежнему вызывают исключения. Если необходимо определить, был ли именованный системный семафор создан, используйте вместо него перегрузку <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> конструктора.  
  
> [!IMPORTANT]
>  При использовании этой перегрузки конструктора рекомендуется указать тот же номер для `initialCount` и `maximumCount`. Если `initialCount` меньше `maximumCount`и создается именованный системный семафор, то результат будет таким же, как если бы текущий поток вызывал <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` минус `initialCount`) раз. Однако при использовании этой перегруженной версии конструктора невозможно определить, был ли создан именованный системный семафор.  
  
 Если для `name`указан `null` или пустая строка, создается локальный семафор, как если бы вы вызывали перегрузку конструктора <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>.  
  
 Так как именованные семафоры видимы во всей операционной системе, их можно использовать для координации использования ресурсов в пределах границ процесса.  
  
 Если вы хотите узнать, существует ли именованный системный семафор, используйте метод <xref:System.Threading.Semaphore.OpenExisting%2A>. Метод <xref:System.Threading.Semaphore.OpenExisting%2A> пытается открыть существующий именованный семафор и создает исключение, если системный семафор не существует.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение перекрестной обработки именованного семафора. В этом примере создается именованный семафор с максимальным числом, равным пяти, и начальным числом, равным пяти. Программа выполняет три вызова метода <xref:System.Threading.WaitHandle.WaitOne%2A>. Таким образом, если запустить скомпилированный пример из двух окон командной строки, вторая копия будет блокироваться по третьему вызову <xref:System.Threading.WaitHandle.WaitOne%2A>. Выпустите одну или несколько записей в первой копии программы, чтобы разблокировать вторую.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />.  
  
- или - 
 Длина значения параметра<paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maximumCount" /> меньше 1.  
  
- или - 
 Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, доступ к нему безопасно регулируется, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор нельзя создать. Вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для создания именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Действие безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string * bool -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">Начальное количество запросов семафора, которое может быть удовлетворено одновременно.</param>
        <param name="maximumCount">Максимальное количество запросов семафора, которое может быть удовлетворено одновременно.</param>
        <param name="name">Имя объекта именованного системного семафора.</param>
        <param name="createdNew">При возврате этот метод содержит значение <see langword="true" />, если был создан локальный семафор (то есть если параметр <paramref name="name" /> имеет значение <see langword="null" /> или содержит пустую строку) или был создан заданный именованный системный семафор; значение <see langword="false" />, если указанный именованный семафор уже существовал. Этот параметр передается неинициализированным.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" />, задающий начальное количество входов и максимальное количество одновременных входов, а также при необходимости задающий имя объекта системного семафора и переменную, получающую значение, которое указывает, был ли создан новый системный семафор.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор инициализирует объект <xref:System.Threading.Semaphore>, представляющий именованный системный семафор. Можно создать несколько <xref:System.Threading.Semaphore> объектов, представляющих один и тот же именованный системный семафор.  
  
 Если именованный системный семафор не существует, он создается с начальным числом и максимальным числом, заданным в `initialCount` и `maximumCount`. Если именованный системный семафор уже существует, `initialCount` и `maximumCount` не используются, хотя недопустимые значения по-прежнему вызывают исключения. Чтобы определить, был ли создан системный семафор, используйте `createdNew`.  
  
 Если `initialCount` меньше `maximumCount`, а `createdNew` `true`, то результат будет таким же, как если бы текущий поток вызывал <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` минус `initialCount`) раз.  
  
 Если для `name`указан `null` или пустая строка, создается локальный семафор, как если бы вы вызывали перегрузку конструктора <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>. В этом случае `createdNew` всегда `true`.  
  
 Так как именованные семафоры видимы во всей операционной системе, их можно использовать для координации использования ресурсов в пределах границ процесса.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется поведение перекрестной обработки именованного семафора. В этом примере создается именованный семафор с максимальным числом, равным пяти, и начальным счетчиком двух. То есть он резервирует три записи для потока, который вызывает конструктор. Если `createNew` `false`, программа выполняет три вызова метода <xref:System.Threading.WaitHandle.WaitOne%2A>. Таким образом, если запустить скомпилированный пример из двух окон командной строки, вторая копия будет блокироваться по третьему вызову <xref:System.Threading.WaitHandle.WaitOne%2A>. Выпустите одну или несколько записей в первой копии программы, чтобы разблокировать вторую.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />.  
  
- или - 
 Длина значения параметра<paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maximumCount" /> меньше 1.  
  
- или - 
 Значение параметра <paramref name="initialCount" /> меньше 0.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, доступ к нему безопасно регулируется, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор нельзя создать. Вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для создания именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Действие безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string * bool * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="maximumCount" Type="System.Int32" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialCount">Начальное количество запросов семафора, которое может быть удовлетворено одновременно.</param>
        <param name="maximumCount">Максимальное количество запросов семафора, которое может быть удовлетворено одновременно.</param>
        <param name="name">Имя объекта именованного системного семафора.</param>
        <param name="createdNew">При возврате этот метод содержит значение <see langword="true" />, если был создан локальный семафор (то есть если параметр <paramref name="name" /> имеет значение <see langword="null" /> или содержит пустую строку) или был создан заданный именованный системный семафор; значение <see langword="false" />, если указанный именованный семафор уже существовал. Этот параметр передается неинициализированным.</param>
        <param name="semaphoreSecurity">Объект <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />, представляющий безопасность управления доступом для применения к именованному системному семафору.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Threading.Semaphore" />, задающий начальное количество входов и максимальное количество одновременных входов, а также при необходимости задает имя объекта системного семафора, переменную, которая получает значение, указывающее, был ли создан новый системный семафор, и управление безопасным доступом для системного семафора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот конструктор для применения безопасности управления доступом к именованному системному семафору при его создании, предотвращая управление семафором другим кодом.  
  
 Этот конструктор инициализирует объект <xref:System.Threading.Semaphore>, представляющий именованный системный семафор. Можно создать несколько <xref:System.Threading.Semaphore> объектов, представляющих один и тот же именованный системный семафор.  
  
 Если именованный системный семафор не существует, он создается с указанной защитой управления доступом. Если существует именованный семафор, заданная безопасность контроля доступа игнорируется.  
  
> [!NOTE]
>  Вызывающий объект имеет полный контроль над вновь созданным <xref:System.Threading.Semaphore> объектом, даже если `semaphoreSecurity` запрещает или не может предоставить некоторые права доступа для текущего пользователя. Однако если текущий пользователь пытается получить другой объект <xref:System.Threading.Semaphore> для представления того же именованного семафора с помощью конструктора или метода <xref:System.Threading.Semaphore.OpenExisting%2A>, применяется безопасность управления доступом Windows.  
  
 Если именованный системный семафор не существует, он создается с начальным числом и максимальным числом, заданным в `initialCount` и `maximumCount`. Если именованный системный семафор уже существует, `initialCount` и `maximumCount` не используются, хотя недопустимые значения по-прежнему вызывают исключения. Используйте параметр `createdNew`, чтобы определить, был ли системный семафор создан этим конструктором.  
  
 Если `initialCount` меньше `maximumCount`, а `createdNew` `true`, то результат будет таким же, как если бы текущий поток вызывал <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` минус `initialCount`) раз.  
  
 Если для `name`указан `null` или пустая строка, создается локальный семафор, как если бы вы вызывали перегрузку конструктора <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>. В этом случае `createdNew` всегда `true`.  
  
 Так как именованные семафоры видимы во всей операционной системе, их можно использовать для координации использования ресурсов в пределах границ процесса.  
  
   
  
## Examples  
 В следующем примере кода показано поведение перекрестной обработки именованного семафора с защитой управления доступом. В примере используется перегрузка метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> для проверки существования именованного семафора. Если семафор не существует, он создается с максимальным числом двух и с защитой управления доступом, которое запрещает текущему пользователю право использовать семафор, но предоставляет право на чтение и изменение семафора. Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>. Исключение перехвачено, и в примере используется перегрузка метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> для открытия семафора с правами, необходимыми для чтения и изменения разрешений.  
  
 После изменения разрешений семафор открывается с правами, необходимыми для ввода и выпуска. Если запустить скомпилированный пример из третьего командного окна, он будет запущен с использованием новых разрешений.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение <paramref name="initialCount" /> больше значения <paramref name="maximumCount" />.  
  
- или - 
 Длина значения параметра<paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maximumCount" /> меньше 1.  
  
- или - 
 Значение параметра<paramref name="initialCount" /> меньше 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, доступ к нему безопасно регулируется, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор нельзя создать. Вероятно, дескриптор ожидания другого типа имеет то же имя.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для создания именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Действие безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает настройки управления доступом для именованного системного семафора.</summary>
        <returns>Объект <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />, представляющий параметры безопасности управления доступом для именованного системного семафора.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Threading.Semaphore.GetAccessControl%2A> использует следующее сочетание флагов (в сочетании с побитовой операцией OR) для поиска разрешений: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>и <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 Пользователь должен иметь права <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> для вызова этого метода, а семафор должен быть открыт с правами <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType>.  
  
 В локальном семафоре безопасность управления доступом не имеет значения. Если объект <xref:System.Threading.Semaphore> не представляет именованный системный семафор, этот метод возвращает объект <xref:System.Security.AccessControl.SemaphoreSecurity>, который предоставляет все права любому пользователю.  
  
   
  
## Examples  
 В следующем примере кода показано поведение перекрестной обработки именованного семафора с защитой управления доступом. В примере используется перегрузка метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> для проверки существования именованного семафора.  
  
 Если семафор не существует, он создается с максимальным числом двух и с защитой управления доступом, которое запрещает текущему пользователю право использовать семафор, но предоставляет право на чтение и изменение семафора.  
  
 Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>. Исключение перехвачено, и в примере используется перегрузка метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> для открытия семафора с правами, необходимыми для чтения и изменения разрешений. Безопасность управления доступом для системного семафора достигается с помощью метода <xref:System.Threading.Semaphore.GetAccessControl%2A>.  
  
 После изменения разрешений семафор открывается с правами, необходимыми для ввода и выпуска. Если запустить скомпилированный пример из третьего командного окна, он будет запущен с использованием новых разрешений.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Текущий объект <see cref="T:System.Threading.Semaphore" /> представляет именованный системный семафор, а пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.  
  
- или - 
Текущий объект <see cref="T:System.Threading.Semaphore" /> представляет именованный системный семафор и не был открыт с использованием прав <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Не поддерживается для Windows 98 или Windows Millennium Edition.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает указанный именованный семафор, если он уже существует.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного семафора для открытия.</param>
        <summary>Открывает указанный именованный семафор, если он уже существует.</summary>
        <returns>Объект, представляющий именованный системный семафор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Threading.Semaphore.OpenExisting%2A> пытается открыть указанный именованный семафор. Если системный семафор не существует, этот метод создает исключение вместо создания системного семафора. Чтобы создать системный семафор, если он еще не существует, используйте один из <xref:System.Threading.Semaphore.%23ctor%2A> конструкторов с параметром `name`.  
  
 Несколько вызовов этого метода, которые используют одно и то же значение для `name`, не обязательно возвращают один и тот же объект <xref:System.Threading.Semaphore>, даже если возвращаемые объекты представляют один и тот же именованный системный семафор.  
  
 Перегрузка этого метода эквивалентна вызову перегрузки метода <xref:System.Threading.Semaphore.OpenExisting%2A> и указанию прав <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> в сочетании с помощью побитовой операции или.  
  
 Задание флага <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> позволяет потоку входить в семафор, а указание флага <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> позволяет потоку вызывать метод <xref:System.Threading.Semaphore.Release%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано поведение перекрестной обработки именованного семафора с защитой управления доступом. В примере используется перегрузка метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> для проверки существования именованного семафора.  
  
 Если семафор не существует, он создается с максимальным числом двух и с защитой управления доступом, которое запрещает текущему пользователю право использовать семафор, но предоставляет право на чтение и изменение семафора.  
  
 Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове перегрузки метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>. Исключение перехвачено, и в примере используется перегрузка метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> для открытия семафора с правами, необходимыми для чтения и изменения разрешений.  
  
 После изменения разрешений семафор открывается с правами, необходимыми для ввода и освобождения. Если запустить скомпилированный пример из третьего командного окна, он будет запущен с использованием новых разрешений.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
- или - 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор не существует.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для открытия именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Действие безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного семафора для открытия.</param>
        <param name="rights">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</param>
        <summary>Открывает указанный именованный семафор, если он уже существует, с требуемыми правами доступа.</summary>
        <returns>Объект, представляющий именованный системный семафор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр `rights` должен включать флаг <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>, чтобы разрешить потокам входить в семафор, а флаг <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> разрешает потокам вызывать метод <xref:System.Threading.Semaphore.Release%2A>.  
  
 Метод <xref:System.Threading.Semaphore.OpenExisting%2A> пытается открыть существующий именованный семафор. Если системный семафор не существует, этот метод создает исключение вместо создания системного семафора. Чтобы создать системный семафор, если он еще не существует, используйте один из <xref:System.Threading.Semaphore.%23ctor%2A> конструкторов с параметром `name`.  
  
 Несколько вызовов этого метода, которые используют одно и то же значение для `name`, не обязательно возвращают один и тот же объект <xref:System.Threading.Semaphore>, даже если возвращаемые объекты представляют один и тот же именованный системный семафор.  
  
   
  
## Examples  
 В следующем примере кода показано поведение перекрестной обработки именованного семафора с защитой управления доступом. В примере используется перегрузка метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> для проверки существования именованного семафора.  
  
 Если семафор не существует, он создается с максимальным числом двух и с защитой управления доступом, которое запрещает текущему пользователю право использовать семафор, но предоставляет право на чтение и изменение семафора.  
  
 Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>. Исключение перехвачено, и в примере используется перегрузка метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> для открытия семафора с правами, необходимыми для чтения и изменения разрешений.  
  
 После изменения разрешений семафор открывается с правами, необходимыми для ввода и освобождения. Если запустить скомпилированный пример из третьего командного окна, он будет запущен с использованием новых разрешений.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
- или - 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Именованный семафор не существует.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, но у пользователя нет требуемых прав доступа.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода для создания именованного системного семафора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Действие безопасности: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет выход из семафора.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выходит из семафора и возвращает последнее значение счетчика.</summary>
        <returns>Счетчик семафора перед вызовом метода <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Потоки обычно используют метод <xref:System.Threading.WaitHandle.WaitOne%2A> для входа в семафор и обычно используют перегрузку метода для выхода.  
  
 Если метод <xref:System.Threading.Semaphore.Release%2A> вызывает <xref:System.Threading.SemaphoreFullException>, он не обязательно указывает на проблему в вызывающем потоке. Ошибка программирования в другом потоке могла привести к тому, что поток выполнит выход из семафора больше времени, чем он был введен.  
  
 Если текущий объект <xref:System.Threading.Semaphore> представляет именованный системный семафор, пользователь должен иметь права <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>, а семафор должен быть открыт с правами <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода создается семафор с максимальным числом трех и начальным счетчиком, равным нулю. В примере запускается пять потоков, которые блокируют ожидание семафора. Основной поток использует перегрузку метода <xref:System.Threading.Semaphore.Release%28System.Int32%29> для увеличения числа семафоров до максимального значения, позволяя трем потокам входить в семафор. Каждый поток использует метод <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> для ожидания одной секунды, для имитации работы, а затем вызывает перегрузку метода <xref:System.Threading.Semaphore.Release> для освобождения семафора.  
  
 При каждом освобождении семафора отображается предыдущее число семафоров. Сообщения консоли записывают использование семафора. Рабочий интервал смоделированной работы немного увеличивается для каждого потока, чтобы упростить чтение выходных данных.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">Счетчик семафора уже имеет максимальное значение.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32, связанная с именованным семафором.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Текущий семафор представляет именованный системный семафор, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
- или - 
Текущий семафор представляет именованный системный семафор, но он не был открыт с правами доступа <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Количество требуемых выходов из семафора.</param>
        <summary>Выходит из семафора указанное число раз и возвращает последнее значение счетчика.</summary>
        <returns>Счетчик семафора перед вызовом метода <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если поток вошел в семафор несколько раз, этот перегруженный метод позволяет восстановить все число семафоров с помощью одного вызова.  
  
 Если метод <xref:System.Threading.Semaphore.Release%2A> вызывает <xref:System.Threading.SemaphoreFullException>, он не обязательно указывает на проблему в вызывающем потоке. Ошибка программирования в другом потоке могла привести к тому, что поток выполнит выход из семафора больше времени, чем он был введен.  
  
 Если текущий объект <xref:System.Threading.Semaphore> представляет именованный системный семафор, пользователь должен иметь права <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>, а семафор должен быть открыт с правами <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода создается семафор с максимальным числом трех и начальным счетчиком, равным нулю. В примере запускается пять потоков, которые блокируют ожидание семафора. Основной поток использует перегрузку метода <xref:System.Threading.Semaphore.Release%28System.Int32%29> для увеличения числа семафоров до максимального значения, позволяя трем потокам входить в семафор. Каждый поток использует метод <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> для ожидания одной секунды, для имитации работы, а затем вызывает перегрузку метода <xref:System.Threading.Semaphore.Release> для освобождения семафора.  
  
 При каждом освобождении семафора отображается предыдущее число семафоров. Сообщения консоли записывают использование семафора. Рабочий интервал смоделированной работы немного увеличивается для каждого потока, чтобы упростить чтение выходных данных.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="releaseCount" /> меньше 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">Счетчик семафора уже имеет максимальное значение.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32, связанная с именованным семафором.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Текущий семафор представляет именованный системный семафор, но пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
- или - 
Текущий семафор представляет именованный системный семафор, но он не был открыт с правами <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">Объект <see cref="T:System.Security.AccessControl.SemaphoreSecurity" />, представляющий безопасность управления доступом для применения к именованному системному семафору.</param>
        <summary>Задает безопасность управления доступом для именованного системного семафора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Безопасность управления доступом можно задать только для объектов <xref:System.Threading.Semaphore>, представляющих именованные системные семафоры.  
  
 Пользователь должен иметь права <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> для вызова этого метода, а семафор должен быть открыт с правами <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода показано поведение перекрестной обработки именованного семафора с защитой управления доступом. В примере используется перегрузка метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> для проверки существования именованного семафора.  
  
 Если семафор не существует, он создается с максимальным числом двух и с защитой управления доступом, которое запрещает текущему пользователю право использовать семафор, но предоставляет право на чтение и изменение семафора.  
  
 Если запустить скомпилированный пример из двух окон командной строки, вторая копия выдаст исключение нарушения прав доступа при вызове метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>. Исключение перехвачено, и в примере используется перегрузка метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> для открытия семафора с правами, необходимыми для чтения и изменения разрешений.  
  
 После изменения разрешений с помощью метода <xref:System.Threading.Semaphore.SetAccessControl%2A> семафор открывается с правами, необходимыми для ввода и выпуска. Если запустить скомпилированный пример из третьего командного окна, он будет запущен с использованием новых разрешений.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="semaphoreSecurity" /> — <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Пользователь не имеет прав <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.  
  
- или - 
Семафор не был открыт с правами <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Текущий объект <see cref="T:System.Threading.Semaphore" /> не представляет именованный системный семафор.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Управляемая поточность</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Открывает заданный именованный семафор, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * Semaphore -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного семафора для открытия.</param>
        <param name="result">При возврате этот метод содержит объект <see cref="T:System.Threading.Semaphore" />, представляющий именованный семафор, если вызов завершился успешно, или значение <see langword="null" />, если вызов завершился неудачно. Этот параметр обрабатывается как неинициализированный.</param>
        <summary>Открывает указанный именованный семафор, если он уже существует, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
        <returns>Значение <see langword="true" />, если именованный семафор был успешно открыт; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный семафор не существует, этот метод не создает его. Чтобы создать системный семафор, если он еще не существует, используйте один из <xref:System.Threading.Semaphore.%23ctor%2A> конструкторов с параметром `name`.  
  
 Если вы не уверены, существует ли именованный семафор, используйте эту перегрузку метода вместо перегрузки метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%29>, которая вызывает исключение, если семафор не существует.  
  
 Перегрузка этого метода эквивалентна вызову перегрузки метода <xref:System.Threading.Semaphore.TryOpenExisting%2A> и указанию прав <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> и <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> в сочетании с помощью побитовой операции или. Задание флага <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> позволяет потоку входить в семафор, а указание флага <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> позволяет потоку вызывать метод <xref:System.Threading.Semaphore.Release%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
- или - 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights * Semaphore -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Имя системного семафора для открытия.</param>
        <param name="rights">Битовая комбинация значений перечисления, которые определяют желаемые права доступа.</param>
        <param name="result">При возврате этот метод содержит объект <see cref="T:System.Threading.Semaphore" /> , представляющий именованный семафор, если вызов завершился успешно, или значение <see langword="null" /> , если вызов завершился неудачно. Этот параметр обрабатывается как неинициализированный.</param>
        <summary>Открывает заданный именованный семафор, если он уже существует, с требуемыми правами доступа, и возвращает значение, указывающее, успешно ли выполнена операция.</summary>
        <returns>Значение <see langword="true" />, если именованный семафор был успешно открыт; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если именованный семафор не существует, этот метод не создает его. Чтобы создать системный семафор, если он еще не существует, используйте один из <xref:System.Threading.Semaphore.%23ctor%2A> конструкторов с параметром `name`.  
  
 Если вы не уверены, существует ли именованный семафор, используйте эту перегрузку метода вместо перегрузки метода <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>, которая вызывает исключение, если семафор не существует.  
  
 Параметр `rights` должен включать флаг <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>, чтобы разрешить потокам входить в семафор, а флаг <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> разрешает потокам вызывать метод <xref:System.Threading.Semaphore.Release%2A>.  
  
 Несколько вызовов этого метода, которые используют одно и то же значение для `name`, не обязательно возвращают один и тот же объект <xref:System.Threading.Semaphore>, даже если возвращаемые объекты представляют один и тот же именованный системный семафор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="name" /> равен пустой строке.  
  
- или - 
 Длина значения параметра <paramref name="name" /> превышает 260 символов.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Произошла ошибка Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Именованный семафор существует, но у пользователя нет прав доступа, необходимых для его использования.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
