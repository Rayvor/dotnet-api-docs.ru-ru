<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ad9f6d866494c9ca0078200940a3feafc462189e" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67243301" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет пул потоков, который можно использовать для выполнения задач, отправки рабочих элементов, обработки асинхронного ввода-вывода, ожидания от имени других потоков и обработки таймеров.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Многие приложения создают потоки, которые тратить много времени в состоянии, ожидая возникновения события. Другие потоки могут входить в бездействующее состояние только для периодически опрашивать для изменения или обновлять сведения о состоянии. Пул потоков позволяет более эффективно использовать потоки, предоставляя приложения с пулом рабочих потоков, управляемых системой. Следующие примеры операций, использующих потоки пула потоков.  
  
-   При создании <xref:System.Threading.Tasks.Task> или <xref:System.Threading.Tasks.Task%601> объект асинхронно, выполнить ряд задач по умолчанию, задача запланирована для выполнения в потоке пула потоков.  
  
-   Асинхронные таймеры используют пул потоков. Потоки из пула потоков исполнения ответных вызовов из <xref:System.Threading.Timer?displayProperty=nameWithType> класса и вызов событий из <xref:System.Timers.Timer?displayProperty=nameWithType> класса.  
  
-   При использовании дескрипторов ожидания, зарегистрированных в потоке операционной системы следит за состоянием дескрипторов ожидания. При завершении операции ожидания, рабочий поток из пула потоков выполняет соответствующую функцию обратного вызова.  
  
-   При вызове <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метод в очередь метод для выполнения в потоке пула потоков. Это можно сделать, передавая ему <xref:System.Threading.WaitCallback> делегировать.   Делегат имеет сигнатуру  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     где `state` — это объект, содержащий данные, используемые делегатом. Фактические данные могут передаваться делегата путем вызова <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> метод.  
  
> [!NOTE]
>  Потоки в пул управляемых потоков — это фоновые потоки. То есть их <xref:System.Threading.Thread.IsBackground%2A> свойства являются `true`. Это означает, что <xref:System.Threading.ThreadPool> поток не будет поддерживать работу после все основные потоки освободят приложения.  
  
> [!IMPORTANT]
>  Когда пул потоков повторно использует поток, он не очищает данные в локальном хранилище потока или в поля, помеченные атрибутом <xref:System.ThreadStaticAttribute> атрибута. Таким образом, когда метод проверяет локальное хранилище потока или полей, будут отмечены <xref:System.ThreadStaticAttribute> атрибут, значения, он находит может остаться после более ранних версий используйте потока из пула потоков.  
  
 Также можно поместить в очередь рабочие элементы, не относящиеся к операции ожидания в пул потоков. Чтобы запросить, что рабочий элемент должен обрабатываться потоком в пуле потоков, вызовите <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метод. Этот метод принимает в качестве параметра ссылку на метод или делегат, который будет вызываться в потоке из пула потоков. Нет способа отмены рабочего элемента, после его находится в очереди.  
  
 Таймеры очереди и зарегистрированные операции ожидания также используют пул потоков. Их функции обратного вызова помещаются в очередь в пул потоков.  
  
 Имеется один пул потоков каждого процесса. Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] размер по умолчанию пула потоков для процесса зависит от нескольких факторов, таких как размер виртуального адресного пространства. Процесс может вызвать метод <xref:System.Threading.ThreadPool.GetMaxThreads%2A> для определения количества потоков. Число потоков в пуле потоков может быть изменен с помощью <xref:System.Threading.ThreadPool.SetMaxThreads%2A> метод. Каждый поток использует размер стека по умолчанию и выполняется с приоритетом по умолчанию.  
  
> [!NOTE]
>  Неуправляемый код, на котором размещается платформа .NET Framework можно изменить размер пула потоков с помощью `CorSetMaxThreads` функции, определенной в файле mscoree.h.  
  
 Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не будет достигнуто минимальное значение для каждой категории. При достижении минимума пул потоков можно создавать дополнительные потоки в этой категории или дождитесь завершения выполнения некоторых задач. Начиная с [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] пул потоков создает и уничтожает рабочие потоки в целях оптимизации пропускной способности, которая определяется как количество задач, завершаемых за единицу времени. Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое их количество может усиливать конкуренцию за ресурсы.  
  
> [!NOTE]
>  Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.  
  
 Для получения этих минимальных значений можно использовать метод <xref:System.Threading.ThreadPool.GetMinThreads%2A>.  
  
> [!CAUTION]
>  Можно использовать <xref:System.Threading.ThreadPool.SetMinThreads%2A> метод, чтобы увеличить минимальное количество потоков. Однако необоснованное увеличение этих значений может привести к снижению производительности. Если одновременно запускается слишком много задач, все они могут выполняться слишком медленно. В большинстве случаев пул потоков работает наилучшим образом, если он использует собственный алгоритм выделения потоков.  
  
   
  
## Examples  
 В следующем примере основного потока приложения помещает метод с именем `ThreadProc` для выполнения в потоке пула потоков, бездействует одной секунде, а затем завершает работу. `ThreadProc` Метод просто отображает сообщение.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 Если закомментировать вызов <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод, основной поток завершает работу до выполнения метода в потоке пула потоков.  Пул потоков использует фоновые потоки, которые не смогут обеспечить работоспособность приложения при всех основных потоков завершены.  (Это простой пример гонки).  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">Потоки и работа с потоками</related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Пул управляемых потоков</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Связывает дескриптор операционной системы с объектом <see cref="T:System.Threading.ThreadPool" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="osHandle">Структура <see cref="T:System.IntPtr" />, хранящая дескриптор. Дескриптор должен быть открыт для перекрывающегося ввода-вывода в неуправляемой области.</param>
        <summary>Связывает дескриптор операционной системы с объектом <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns>Значение <see langword="true" />, если дескриптор является связанным; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle">Объект <see cref="T:System.Runtime.InteropServices.SafeHandle" />, содержащий дескриптор операционной системы. Дескриптор должен быть открыт для перекрывающегося ввода-вывода в неуправляемой области.</param>
        <summary>Связывает дескриптор операционной системы с объектом <see cref="T:System.Threading.ThreadPool" />.</summary>
        <returns>Значение <see langword="true" />, если дескриптор является связанным; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `osHandle` Параметр должен быть <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, который является производным от абстрактного <xref:System.Runtime.InteropServices.SafeHandle> класса.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="osHandle" /> — <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CompletedWorkItemCount">
      <MemberSignature Language="C#" Value="public static long CompletedWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 CompletedWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long CompletedWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedWorkItemCount : int64" Usage="System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Количество доступных рабочих потоков.</param>
        <param name="completionPortThreads">Количество доступных потоков асинхронного ввода-вывода.</param>
        <summary>Возвращает разницу между максимальным числом потоков пула, возвращаемых методом <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />, и числом активных в данный момент потоков.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> возвращает, переменная, указанная параметром `workerThreads` содержит число дополнительных рабочих потоков, которые могут быть запущены и переменная, указанная параметром `completionPortThreads` содержит число дополнительных потоков асинхронного ввода-вывода, которые могут быть к работе.  
  
 Если нет доступных потоков, запросы к пулу дополнительный поток остаются в очереди, пока не станут доступными из пула потоков.  
  
   
  
## Examples  
 Следующий пример отображает количество рабочих потоков и потоков ввода-вывода, доступных, когда запускается простое приложение.  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Максимальное количество рабочих потоков в пуле потоков.</param>
        <param name="completionPortThreads">Максимальное количество потоков асинхронного ввода-вывода в пуле потоков.</param>
        <summary>Возвращает количество запросов к пулу потоков, которые могут быть активными одновременно. Все запросы, превышающие это количество, остаются в очереди до тех пор, пока потоки пула не станут доступны.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Threading.ThreadPool.GetMaxThreads%2A> возвращает, переменная, указанная параметром `workerThreads` содержит максимальное число рабочих потоков, допустимых в пуле потоков, а переменная, указанная параметром `completionPortThreads` содержит максимальное количество потоков асинхронного ввода-вывода, разрешенных в пул потоков.  
  
 Можно использовать <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> метод, чтобы определить фактическое число потоков в пуле потоков в любой момент времени.  
  
 Можно использовать <xref:System.Threading.ThreadPool.SetMaxThreads%2A> задать максимальное число рабочих потоков и потоков асинхронного ввода-вывода в пуле потоков.  
  
 Можно поместить в очередь многие запросы к пулу потоков, сколько позволяет системной памяти. Если запросов больше, чем пула потоков, дополнительные запросы остаются в очереди, пока не станут доступными из пула потоков.  
  
   
  
## Examples  
 В следующем примере кода показано, как получить число доступных и максимальное число потоков в пуле потоков. Рабочий элемент помещается в очередь, использует `FileStream` для асинхронной записи в два файла. Перекрывать методы обратного вызова истекло время ожидания. Рабочий поток обрабатывает рабочий элемент, и в зависимости от скорости и количества процессоров на компьютере, одного или двух потоков портов завершения обработки операций записи.  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">При возвращении метода содержит минимальное количество рабочих потоков, которые создаются пулом потоков по требованию.</param>
        <param name="completionPortThreads">При возвращении метода содержит минимальное количество потоков асинхронного ввода-вывода, которые создаются пулом потоков по требованию.</param>
        <summary>Возвращает минимальное число потоков, создаваемых пулом потоков по требованию по мере поступления новых запросов перед переходом на алгоритм управления созданием и уничтожением потоков.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не будет достигнуто минимальное значение для каждой категории. Минимальное количество потоков по умолчанию присваивается количество процессоров в системе. При достижении минимума пул потоков может создавать дополнительные потоки в этой категории или дождитесь завершения выполнения некоторых задач. Начиная с версии [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], пул потоков, создание и удаление потоков для оптимизации пропускной способности, которая определяется как количество задач, завершаемых за единицу времени. Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое их количество может усиливать конкуренцию за ресурсы.  
  
> [!NOTE]
>  Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.  
  
   
  
## Examples  
 Следующий пример задает минимальное количество рабочих потоков до четырех и сохраняет исходное значение минимальное количество потоков асинхронного завершения ввода-вывода.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="PendingWorkItemCount">
      <MemberSignature Language="C#" Value="public static long PendingWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 PendingWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PendingWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long PendingWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PendingWorkItemCount : int64" Usage="System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Помещает метод в очередь на выполнение. Метод выполняется, когда становится доступен поток из пула потоков.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">Делегат <see cref="T:System.Threading.WaitCallback" />, представляющий метод, который требуется выполнить.</param>
        <summary>Помещает метод в очередь на выполнение. Метод выполняется, когда становится доступен поток из пула потоков.</summary>
        <returns>Значение <see langword="true" />, если метод успешно помещен в очередь. Если рабочий элемент не может быть помещен очередь, выдается исключение <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно поместить данные, необходимые в очереди в поля экземпляра класса, в котором определен метод, или можно использовать метод <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> перегрузку, которая принимает объект, содержащий необходимые данные.  
  
> [!NOTE]
>  Пользователи Visual Basic могут опускать <xref:System.Threading.WaitCallback> конструктора и просто использовать `AddressOf` оператор при передаче в метод обратного вызова, <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic автоматически вызывает соответствующий конструктор делегата.  
  
## <a name="version-information"></a>Сведения о версии  
 В .NET Framework версии 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метод. В более ранних версий информация об участнике не распространяются.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> перегрузку метода в очередь задачу, представленный `ThreadProc` метод для выполнения, когда поток станет доступным. Сведения о задачах предоставляется с помощью этой перегрузки. Поэтому сведения, позволяющие `ThreadProc` метод ограничен объект принадлежит метод.  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> — <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Среда CLR является размещенной, а основное приложение не поддерживает это действие.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Пул управляемых потоков</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">Делегат <see cref="T:System.Threading.WaitCallback" />, представляющий выполняемый метод.</param>
        <param name="state">Объект, содержащий данные, используемые методом.</param>
        <summary>Помещает метод в очередь на выполнение и указывает объект, содержащий данные для использования методом. Метод выполняется, когда становится доступен поток из пула потоков.</summary>
        <returns>Значение <see langword="true" />, если метод успешно помещен в очередь. Если рабочий элемент не может быть помещен очередь, выдается исключение <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если метод обратного вызова требуются сложные данные, можно определить класс, содержащий данные.  
  
> [!NOTE]
>  Пользователи Visual Basic могут опускать <xref:System.Threading.WaitCallback> конструктора и просто использовать `AddressOf` оператор при передаче в метод обратного вызова, <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>. Visual Basic автоматически вызывает соответствующий конструктор делегата.  
  
## <a name="version-information"></a>Сведения о версии  
 В .NET Framework версии 2.0 <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метод. В более ранних версий информация об участнике не распространяются.  
  
   
  
## Examples  
 В следующем примере пул потоков .NET для вычисления `Fibonacci` результат для пяти числа в диапазоне от 20 до 40. Каждый результат `Fibonacci` представлен классом `Fibonacci`, который предоставляет метод с именем `ThreadPoolCallback`, выполняющий вычисление. Создается объект, представляющий каждое значение `Fibonacci`, а затем метод `ThreadPoolCallback` передается в объект <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, который назначает для выполнения метода доступный в пуле поток.  
  
 Так как каждый `Fibonacci` объекту присваивается полупроизвольное значение для вычисления, и так как каждый поток будут конкурировать за ресурсы процессора, не знает заранее, сколько времени потребуется для всех пяти результатов необходимо вычислить. Именно поэтому во время конструирования каждому объекту `Fibonacci` передается экземпляр класса <xref:System.Threading.ManualResetEvent>. Каждый объект сигнализирует предоставленному объекту события когда его вычисление будет завершена, который позволяет основному потоку блокировать выполнение <xref:System.Threading.WaitHandle.WaitAll%2A> до всех пяти `Fibonacci` объектов вычисления результата. После этого метод `Main` отображает каждый результат `Fibonacci`.
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Среда CLR является размещенной, а основное приложение не поддерживает это действие.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> — <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Пул управляемых потоков</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState">Тип элементов <paramref name="state" />.</typeparam>
        <param name="callBack"><see cref="T:System.Action`1" /> для представления выполняемого метода.</param>
        <param name="state">Объект, содержащий данные, используемые методом.</param>
        <param name="preferLocal">В отличие от других методов QueueUserWorkItem ориентируется на выполнении не в глобальном, а локальном пуле потоков.</param>
        <summary>Помещает метод, определенный делегатом <see cref="T:System.Action`1" />, в очередь на выполнение и указывает данные для этого метода. Метод выполняется, когда становится доступен поток из пула потоков.</summary>
        <returns>Значение <see langword="true" />, если метод успешно помещен в очередь. Если рабочий элемент не может быть помещен очередь, выдается исключение <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует делегат, ожидающий объект <see cref="T:System.Threading.WaitHandle" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="millisecondsTimeOutInterval">Время ожидания в миллисекундах. Если параметр <paramref name="millisecondsTimeOutInterval" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <paramref name="millisecondsTimeOutInterval" /> равен -1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа со знаком.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, инкапсулирующий собственный дескриптор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`. Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод ставит в очередь указанный делегат в пул потоков. Рабочий поток выполняет делегат, когда происходит одно из следующих:  
  
-   Указанный объект находится в сигнальном состоянии.  
  
-   По истечении интервала времени ожидания.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод проверяет текущее состояние заданного объекта <xref:System.Threading.WaitHandle>. Если состояние объекта является сигналом, метод регистрирует операцию ожидания. Поток из пула потоков выполняет операцию ожидания. Делегат выполняется в рабочем потоке, когда переходит в сигнальное состояние объекта или по истечении интервала времени ожидания. Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или по истечении интервала времени ожидания.  
  
> [!IMPORTANT]
>  С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как основной API Windows использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков. Вместо <xref:System.Threading.Mutex>, использовать <xref:System.Threading.Semaphore> с максимальное число, равное 1.  
  
 Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод.  
  
 Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для наблюдения за зарегистрированные операции ожидания. Таким образом, если необходимо использовать же собственный дескриптор операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, следует повторно используя Win32 `DuplicateHandle` функции. Обратите внимание, что не следует посылать объект события, передаваемый <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.  
  
 Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации. Изменение происходит только для объекта условия ожидания вызвало которого сигнальное состояние. Например счетчик семафора уменьшается на единицу.  
  
## <a name="version-information"></a>Сведения о версии  
 Начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод. В более ранних версий информация об участнике не распространяются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Пул управляемых потоков</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="millisecondsTimeOutInterval">Время ожидания в миллисекундах. Если параметр <paramref name="millisecondsTimeOutInterval" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <paramref name="millisecondsTimeOutInterval" /> равен -1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 64-разрядного целого числа со знаком.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, инкапсулирующий собственный дескриптор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`. Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод ставит в очередь указанный делегат в пул потоков. Рабочий поток выполняет делегат, когда происходит одно из следующих:  
  
-   Указанный объект находится в сигнальном состоянии.  
  
-   По истечении интервала времени ожидания.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод проверяет текущее состояние заданного объекта <xref:System.Threading.WaitHandle>. Если состояние объекта является сигналом, метод регистрирует операцию ожидания. Поток из пула потоков выполняет операцию ожидания. Делегат выполняется в рабочем потоке, когда переходит в сигнальное состояние объекта или по истечении интервала времени ожидания. Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или по истечении интервала времени ожидания.  
  
> [!IMPORTANT]
>  С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как основной API Windows использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков. Вместо <xref:System.Threading.Mutex>, использовать <xref:System.Threading.Semaphore> с максимальное число, равное 1.  
  
 Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод.  
  
 Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для наблюдения за зарегистрированные операции ожидания. Таким образом, если необходимо использовать же собственный дескриптор операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, следует повторно используя Win32 `DuplicateHandle` функции. Обратите внимание, что не следует посылать объект события, передаваемый <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.  
  
 Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации. Изменение происходит только для объекта условия ожидания вызвало которого сигнальное состояние. Например счетчик семафора уменьшается на единицу.  
  
## <a name="version-information"></a>Сведения о версии  
 Начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод. В более ранних версий информация об участнике не распространяются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Пул управляемых потоков</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="timeout">Время ожидания, представленное объектом <see cref="T:System.TimeSpan" />. Если параметр <paramref name="timeout" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <paramref name="timeout" /> равен -1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая значение <see cref="T:System.TimeSpan" /> для времени ожидания.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, инкапсулирующий собственный дескриптор.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`. Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод ставит в очередь указанный делегат в пул потоков. Рабочий поток выполняет делегат, когда происходит одно из следующих:  
  
-   Указанный объект находится в сигнальном состоянии.  
  
-   По истечении интервала времени ожидания.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод проверяет текущее состояние заданного объекта <xref:System.Threading.WaitHandle>. Если состояние объекта является сигналом, метод регистрирует операцию ожидания. Поток из пула потоков выполняет операцию ожидания. Делегат выполняется в рабочем потоке, когда переходит в сигнальное состояние объекта или по истечении интервала времени ожидания. Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или по истечении интервала времени ожидания.  
  
> [!IMPORTANT]
>  С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как основной API Windows использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков. Вместо <xref:System.Threading.Mutex>, использовать <xref:System.Threading.Semaphore> с максимальное число, равное 1.  
  
 Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод.  
  
 Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для наблюдения за зарегистрированные операции ожидания. Таким образом, если необходимо использовать же собственный дескриптор операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, следует повторно используя Win32 `DuplicateHandle` функции. Обратите внимание, что не следует посылать объект события, передаваемый <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.  
  
 Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации. Изменение происходит только для объекта условия ожидания вызвало которого сигнальное состояние. Например счетчик семафора уменьшается на единицу.  
  
## <a name="version-information"></a>Сведения о версии  
 Начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод. В более ранних версий информация об участнике не распространяются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> меньше –1.</exception>
        <exception cref="T:System.NotSupportedException">Значение параметра <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Пул управляемых потоков</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат <see cref="T:System.Threading.WaitOrTimerCallback" />, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="millisecondsTimeOutInterval">Время ожидания в миллисекундах. Если параметр <paramref name="millisecondsTimeOutInterval" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <paramref name="millisecondsTimeOutInterval" /> равен -1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа без знака.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`. Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод ставит в очередь указанный делегат в пул потоков. Рабочий поток выполняет делегат, когда происходит одно из следующих:  
  
-   Указанный объект находится в сигнальном состоянии.  
  
-   По истечении интервала времени ожидания.  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> Метод проверяет текущее состояние заданного объекта <xref:System.Threading.WaitHandle>. Если состояние объекта является сигналом, метод регистрирует операцию ожидания. Поток из пула потоков выполняет операцию ожидания. Делегат выполняется в рабочем потоке, когда переходит в сигнальное состояние объекта или по истечении интервала времени ожидания. Если `timeOutInterval` параметра не равно 0 (ноль) и `executeOnlyOnce` параметр `false`, таймер сбрасывается каждый раз событие сигнализирует или по истечении интервала времени ожидания.  
  
> [!IMPORTANT]
>  С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как основной API Windows использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков. Вместо <xref:System.Threading.Mutex>, использовать <xref:System.Threading.Semaphore> с максимальное число, равное 1.  
  
 Чтобы отменить операцию ожидания, вызовите <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод.  
  
 Ожидающий поток использует Win32 `WaitForMultipleObjects` функции для наблюдения за зарегистрированные операции ожидания. Таким образом, если необходимо использовать же собственный дескриптор операционной системы в нескольких вызовах <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, следует повторно используя Win32 `DuplicateHandle` функции. Обратите внимание, что не следует посылать объект события, передаваемый <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, так как ожидающий поток может не обнаружить, что событие сигнализирует перед его изменением.  
  
 Перед возвратом, эта функция изменяет состояние некоторых типов объектов синхронизации. Изменение происходит только для объекта условия ожидания вызвало которого сигнальное состояние. Например счетчик семафора уменьшается на единицу.  
  
## <a name="version-information"></a>Сведения о версии  
 Начиная с .NET Framework версии 2.0, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> значение свойства распространяется на рабочих потоков в очереди с помощью <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод. В более ранних версий информация об участнике не распространяются.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> методом, выполняемым указанный метод обратного вызова, когда сигнал дескриптор ожидания. В этом примере метод обратного вызова — `WaitProc`, и дескриптора ожидания <xref:System.Threading.AutoResetEvent>.  
  
 В примере определяется `TaskInfo` класса для хранения сведений, который передается методу обратного вызова при его выполнении. В примере создается `TaskInfo` , которому присваивается некоторых строковых данных. <xref:System.Threading.RegisteredWaitHandle> , Возвращаемый <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метод назначается `Handle` поле `TaskInfo` таким образом, метод обратного вызова имеет доступ к <xref:System.Threading.RegisteredWaitHandle>.  
  
 Помимо указания `TaskInfo` как объект, передаваемый в метод обратного вызова, вызов <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> указывает метод <xref:System.Threading.AutoResetEvent> которого задачи будут ожидать, <xref:System.Threading.WaitOrTimerCallback> делегат, представляющий `WaitProc` метод обратного вызова интервал времени ожидания в одну секунду и несколько обратных вызовов.  
  
 Когда основной поток не сигнализирует о <xref:System.Threading.AutoResetEvent> путем вызова его <xref:System.Threading.EventWaitHandle.Set%2A> метода <xref:System.Threading.WaitOrTimerCallback> вызове делегата. `WaitProc` Тесты метод <xref:System.Threading.RegisteredWaitHandle> для определения, истекло ли время ожидания. Если был вызван обратный вызов, так как получил сигнал дескриптор ожидания, `WaitProc` отменяет регистрацию метод <xref:System.Threading.RegisteredWaitHandle>, остановка дополнительные обратные вызовы. В случае времени ожидания она будет продолжать ожидать. `WaitProc` Метод завершает сообщение в окно консоли.  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Пул управляемых потоков</related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Максимальное количество рабочих потоков в пуле потоков.</param>
        <param name="completionPortThreads">Максимальное количество потоков асинхронного ввода-вывода в пуле потоков.</param>
        <summary>Задает количество запросов к пулу потоков, которые могут быть активными одновременно. Все запросы, превышающие это количество, остаются в очереди до тех пор, пока потоки пула не станут доступны.</summary>
        <returns>Значение <see langword="true" />, если изменение выполнено успешно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Максимальное число рабочих потоков или потоков завершения ввода-вывода в число не может задать меньше, чем количество процессоров на компьютере. Чтобы определить, сколько процессоров присутствуют, получения значения <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> свойство. Кроме того невозможно задать максимальное число рабочих потоков или потоков завершения ввода-вывода в число меньше, чем соответствующий минимальное количество рабочих потоков или потоков завершения ввода-вывода. Чтобы определить размер пула потоков, минимальное, вызовите <xref:System.Threading.ThreadPool.GetMinThreads%2A> метод.  
  
 Если среда CLR размещается, например с помощью Internet Information Services (IIS) или SQL Server, узел может ограничить или запретить изменение размера пула потоков.  
  
 Соблюдайте осторожность при изменении максимальное количество потоков в пуле потоков. Во время вашего кода изменения могут возникнуть неблагоприятное воздействие на используемые библиотеки кода.  
  
 Задание слишком большой размер пула потоков может вызвать проблемы с производительностью. Если слишком много потоков выполняются одновременно, переключение задач издержки становится существенной.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности управления потоками. Значение разрешения: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">Минимальное количество рабочих потоков, которые создаются пулом потоков по требованию.</param>
        <param name="completionPortThreads">Минимальное количество потоков асинхронного ввода-вывода, которые создаются пулом потоков по требованию.</param>
        <summary>Задает минимальное число потоков, создаваемых пулом потоков по требованию по мере поступления новых запросов перед переходом на алгоритм управления созданием и уничтожением потоков.</summary>
        <returns>Значение <see langword="true" />, если изменение выполнено успешно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пул потоков предоставляет новые рабочие потоки или потоки завершения ввода-вывода по запросу, пока не будет достигнуто минимальное значение для каждой категории. При достижении минимума пул потоков может создавать дополнительные потоки в этой категории или дождитесь завершения выполнения некоторых задач. Начиная с версии [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], пул потоков, создание и удаление потоков для оптимизации пропускной способности, которая определяется как количество задач, завершаемых за единицу времени. Слишком малое количество потоков может препятствовать оптимальному использованию доступных ресурсов, тогда как слишком большое их количество может усиливать конкуренцию за ресурсы.  
  
 Если потребность низкая, фактическое количество потоков из пула потоков может быть ниже минимальных значений.  
  
 Если указать отрицательное число или число, большее, чем максимальное число активных потоков пула потоков (полученное с помощью <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> возвращает `false` и не меняется наименьших значений.  
  
> [!CAUTION]
>  Минимальное количество потоков по умолчанию присваивается количество процессоров в системе. Можно использовать <xref:System.Threading.ThreadPool.SetMinThreads%2A> метод, чтобы увеличить минимальное количество потоков. Однако необоснованное увеличение этих значений может привести к снижению производительности. Если одновременно запускается слишком много задач, все они могут выполняться слишком медленно. В большинстве случаев пул потоков работает наилучшим собственный алгоритм выделения потоков. Уменьшить минимальное меньшего, чем количество процессоров также может вызвать снижение производительности.  
  
   
  
## Examples  
 Следующий пример задает минимальное количество рабочих потоков до четырех и сохраняет исходное значение минимальное количество потоков асинхронного завершения ввода-вывода.  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности управления потоками. Значение разрешения: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="ThreadCount">
      <MemberSignature Language="C#" Value="public static int ThreadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ThreadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.ThreadCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ThreadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ThreadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadCount : int" Usage="System.Threading.ThreadPool.ThreadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="overlapped">Помещаемая в очередь структура <see cref="T:System.Threading.NativeOverlapped" />.</param>
        <summary>Помещает в очередь на выполнение операцию перекрывающегося ввода-вывода.</summary>
        <returns>Значение <see langword="true" />, если операция была успешна помещена в очередь порта завершения ввода-вывода; в противном случае значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сведения об использовании собственный доступ Win32 перекрывающегося ввода-вывода, см. в разделе <xref:System.Threading.Overlapped> класс, <xref:System.Threading.NativeOverlapped> структуры и `OVERLAPPED` структуры в пакете SDK для платформы Win32.  
  
> [!CAUTION]
>  С помощью <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> метод может непреднамеренно открыть брешь в системе безопасности. Управление доступом для кода выполняет его проверки разрешений всех вызывающих объектов разрешений на стеке. Когда работу в очереди для потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, стек потока из пула потоков не имеет контекста вызывающих. Вредоносный код, можно воспользоваться этим, чтобы избежать проверки разрешений.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="callBack">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callBack">Метод <see cref="T:System.Threading.WaitCallback" />, представляющий делегат, который вызывается, когда потоку в пуле потоков назначается рабочий элемент.</param>
        <param name="state">Объект, передаваемый делегату при вызове его из пула потоков.</param>
        <summary>Помещает указанный делегат в очередь пула потоков, но не распространяет вызывающий стек на рабочий поток.</summary>
        <returns>Значение <see langword="true" />, если метод завершается успешно. Если рабочий элемент не удалось поместить в очередь, создается исключение <see cref="T:System.OutOfMemoryException" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> метода <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> не распространяет вызывающий стек на рабочий поток. Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.  
  
> [!CAUTION]
>  С помощью <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> может непреднамеренно открыть брешь в системе безопасности. Управление доступом для кода выполняет его проверки разрешений всех вызывающих объектов разрешений на стеке. Когда работу в очереди для потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, стек потока из пула потоков не будет иметь контекст вызывающих. Вредоносный код, можно воспользоваться этим, чтобы избежать проверки разрешений.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <exception cref="T:System.ApplicationException">Возникла ситуация нехватки памяти.</exception>
        <exception cref="T:System.OutOfMemoryException">Не удается поместить в очередь рабочий элемент.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> — <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Пул управляемых потоков</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState">Тип элементов <paramref name="state" />.</typeparam>
        <param name="callBack">Делегат, представляющий выполняемый метод.</param>
        <param name="state">Объект, содержащий данные, используемые методом.</param>
        <param name="preferLocal">`true` для выполнения в локальном пуле потоков; `false` для выполнения в глобальном пуле потоков.</param>
        <summary>Помещает метод, определенный делегатом <see cref="T:System.Action`1" />, в очередь на выполнение и указывает объект, содержащий данные для этого метода. Метод выполняется, когда становится доступен поток из пула потоков.</summary>
        <returns>Значение <see langword="true" />, если метод успешно помещен в очередь. Если рабочий элемент не может быть помещен очередь, выдается исключение <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, но не распространяет вызывающий стек на рабочий поток.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="millisecondsTimeOutInterval">Время ожидания в миллисекундах. Если параметр <paramref name="millisecondsTimeOutInterval" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <paramref name="millisecondsTimeOutInterval" /> равен -1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа со знаком. Этот метод не распространяет вызывающий стек на рабочий поток.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метода <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек на рабочий поток. Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.  
  
> [!CAUTION]
>  С помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может непреднамеренно открыть брешь в системе безопасности. Управление доступом для кода выполняет его проверки разрешений всех вызывающих объектов разрешений на стеке. Когда работу в очереди для потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек потока из пула потоков не будет иметь контекст вызывающих. Вредоносный код, можно воспользоваться этим, чтобы избежать проверки разрешений.  
  
 С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как основной API Windows использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.  
  
 При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`. Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Пул управляемых потоков</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="millisecondsTimeOutInterval">Время ожидания в миллисекундах. Если параметр <paramref name="millisecondsTimeOutInterval" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <paramref name="millisecondsTimeOutInterval" /> равен -1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 64-разрядного целого числа со знаком. Этот метод не распространяет вызывающий стек на рабочий поток.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метода <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек на рабочий поток. Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.  
  
> [!CAUTION]
>  С помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может непреднамеренно открыть брешь в системе безопасности. Управление доступом для кода выполняет его проверки разрешений всех вызывающих объектов разрешений на стеке. Когда работу в очереди для потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек потока из пула потоков не будет иметь контекст вызывающих. Вредоносный код, можно воспользоваться этим, чтобы избежать проверки разрешений.  
  
 С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как основной API Windows использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.  
  
 При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`. Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="millisecondsTimeOutInterval" /> меньше –1.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Пул управляемых потоков</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="timeout">Время ожидания, представленное объектом <see cref="T:System.TimeSpan" />. Если параметр <paramref name="timeout" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <paramref name="timeout" /> равен -1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая значение <see cref="T:System.TimeSpan" /> для времени ожидания. Этот метод не распространяет вызывающий стек на рабочий поток.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метода <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек на рабочий поток. Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.  
  
> [!CAUTION]
>  С помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может непреднамеренно открыть брешь в системе безопасности. Управление доступом для кода выполняет его проверки разрешений всех вызывающих объектов разрешений на стеке. Когда работу в очереди для потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек потока из пула потоков не будет иметь контекст вызывающих. Вредоносный код, можно воспользоваться этим, чтобы избежать проверки разрешений.  
  
 С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как основной API Windows использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.  
  
 При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`. Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="timeout" /> меньше –1.</exception>
        <exception cref="T:System.NotSupportedException">Значение параметра <paramref name="timeout" /> больше значения <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Пул управляемых потоков</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">Регистрируемый объект <see cref="T:System.Threading.WaitHandle" />. Используйте объект <see cref="T:System.Threading.WaitHandle" />, отличный от <see cref="T:System.Threading.Mutex" />.</param>
        <param name="callBack">Делегат, который вызывается при получении сигнала объектом, указанным в параметре <paramref name="waitObject" />.</param>
        <param name="state">Передаваемый делегату объект.</param>
        <param name="millisecondsTimeOutInterval">Время ожидания в миллисекундах. Если параметр <paramref name="millisecondsTimeOutInterval" /> равен 0 (нулю), функция проверяет состояние объекта и немедленно возвращает значение. Если параметр <paramref name="millisecondsTimeOutInterval" /> равен -1, время ожидания функции никогда не истекает.</param>
        <param name="executeOnlyOnce">Значение <see langword="true" /> указывает, что после вызова делегата поток не будет ожидать параметр <paramref name="waitObject" />; значение <see langword="false" /> указывает, что таймер сбрасывается всякий раз по завершении операции ожидания до тех пор, пока регистрация ожидания не будет отменена.</param>
        <summary>Регистрирует делегат для ожидания объекта <see cref="T:System.Threading.WaitHandle" />, задавая время ожидания в миллисекундах в виде 32-разрядного целого числа без знака. Этот метод не распространяет вызывающий стек на рабочий поток.</summary>
        <returns>Объект <see cref="T:System.Threading.RegisteredWaitHandle" />, который можно использовать для отмены зарегистрированной операции ожидания.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> метода <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> не распространяет вызывающий стек на рабочий поток. Это позволяет коду терять стек вызовов и тем самым повысить свои привилегии безопасности.  
  
> [!CAUTION]
>  С помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> может непреднамеренно открыть брешь в системе безопасности. Управление доступом для кода выполняет его проверки разрешений всех вызывающих объектов разрешений на стеке. Когда работу в очереди для потока пула потоков с помощью <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, стек потока из пула потоков не будет иметь контекст вызывающих. Вредоносный код, можно воспользоваться этим, чтобы избежать проверки разрешений.  
  
 С помощью <xref:System.Threading.Mutex> для `waitObject` не предоставляют взаимоисключение для обратных вызовов, так как основной API Windows использует значение по умолчанию `WT_EXECUTEDEFAULT` флага, поэтому каждый обратный вызов отправляется в отдельном потоке пула потоков.  
  
 При завершении работы с помощью <xref:System.Threading.RegisteredWaitHandle> , возвращаемого этим методом, вызовите его <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод для освобождения ссылки на дескриптор ожидания. Рекомендуется всегда вызывать <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> метод, даже в том случае, если указать `true` для `executeOnlyOnce`. Сборка мусора работает более эффективно при вызове метода <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> вместо метода в зависимости от дескриптора ожидания зарегистрированного метода завершения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">Пул управляемых потоков</related>
      </Docs>
    </Member>
  </Members>
</Type>